##  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL CCSD_RHF_SV1_F12_fc
#
#-------------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index kiter    = 1, cc_iter   
      index jiter    = 1, cc_iter
      index   kptr1  = 1, 2
      index   kptr2  = 1, 2
      index   kone   = 1, 1
      index kkk = 1,2
      index iii = 1,2
      index   jfrag  = 1, 2 # Nfragments
#      index grd = 1,1000000

#
      aoindex mu     = 1, norb 
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex k = baocc, eaocc
      moaindex l = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex d = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt

      index grd = 1,1000000
# 
# Declare static arrays 
# --------------------- 
#
      distributed t1a_old(a,i) 
      distributed t1a_new(a,i) 
#
      distributed Fae_a(a,a1) 
      distributed Fme_a(i,a) 
      distributed Fmi_a(i,i1) 
#
# Arrays used in transformation for AO2 algorithm
# -----------------------------------------------
#
      temp Txixi(mu,i1,lambda,i)
      temp Txxii(mu,nu,i1,i)
      temp Tixxi(i1,nu,lambda,i)
      temp Txipi(mu,i,p,i1)
      temp Tpipi(p1,i,p,i1)
      temp T1pipi(p1,i,p,i1)
      temp Tixai(i,mu,a,i1)
      temp Txaii(mu,a,i,i1)
      temp Tiaai(i,a1,a,i1)
      temp Taaii(a,a1,i,i1)
      temp Txaai(mu,a1,a,i)
      temp Taaai(a2,a,a1,i)
      temp Txxai(mu,nu,a,i)
#
      served VSpipi(p1,i,p,i1)
      served Viaai(i,a1,a,i1) 
      served Vaaii(a,a1,i,i1)
      served Vaaai(a2,a,a1,i)
#
      temp Txjxj(mu,j1,lambda,j)
      temp Txxjj(mu,nu,j1,j)
      temp Tjjxx(j1,nu,lambda,j)
      temp Tjxxj(j1,nu,lambda,j)
      temp Txjqj(mu,j,q,j1)
      temp Tqjqj(q1,j,q,j1)
      temp T1qjqj(q1,j,q,j1)
      temp Tjxbj(j,mu,b,j1)
      temp Txbjj(mu,b,j,j1)
      temp Tjbbj(j,b1,b,j1)
      temp Tbbjj(b,b1,j,j1)
      temp Txbbj(mu,b1,b,j)
      temp Tbbbj(b2,b,b1,j)
      temp Txxbj(mu,nu,b,j)
#
      temp Txixj(mu,i,nu,j)
      temp Txiqj(mu,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp Tiixx(i,i1,mu,nu)
      temp Tiixb(i,i1,mu,b)
      temp Tiibb(i,i1,b1,b)
      temp Txajj(mu,a,j,j1)
      temp Taajj(a,a1,j,j1)
      temp Txabj(mu,a,b,j)
      temp Tixxj(i,mu,nu,j)
      temp Tixbj(i,mu,b,j)
      temp Tiabj(i,a,b,j)
      temp Taabj(a,a1,b,j)
#
      served Vpiqj(p,i,q,j)
#
      temp Txbii(mu,b,i,i1)
      temp Tbbii(b,b1,i,i1)
      temp Tjbii(j,b,i,i1)
      temp Txbai(mu,b,a,i)
      temp Tbbai(b,b1,a,i)
      temp twww1(a,i,d,k)
      temp t2test(a,i,b,j)
      temp t2test1(a,i,j,p)
#
# End Arrays used in transformation for AO2 algorithm
# --------------------------------------------------- 
#
# Declare temporary arrays 
# ------------------------ 
#
      temp Txxxi(mu,nu,lambda,i)
      temp Txxxj(mu,nu,lambda,j)
      temp T1xixi(mu,i,nu,i1)
      temp Txiix(mu,i,i1,nu)
      temp Txjjx(mu,j,j1,nu)
      temp Txijx(mu,i,j,nu)
      temp Txpii(mu,p,i,i1)
      temp Txqii(mu,q,i,i1)
      temp Tppii(p,p1,i,i1)
      temp Tqqii(q,q1,i,i1)
      temp Txpjj(mu,p,j,j1)
      temp Txqjj(mu,q,j,j1)
      temp Tppjj(p,p1,j,j1)
      temp Tqqjj(q,q1,j,j1)
      temp Tixpi(i,mu,p,i1)
      temp Tippi(i,p,p1,i1)
      temp Tjxqj(j,mu,q,j1)
      temp Tjqqj(j,q,q1,j1)
      temp Tixqj(i,mu,q,j)
      temp Tipqj(i,p,q,j)
#
      temp Vblock(i,i1,i2,i3)
      temp Taiai(p,i,p1,i1)
      temp T1aiai(p,i,p1,i1)
      temp T2aiai(p,i,p1,i1)
      temp T3aiai(p,i,p1,i1)
      temp Tbjbj(q,j,q1,j1)
      temp T1bjbj(q,j,q1,j1)
      temp T2bjbj(q,j,q1,j1)
      temp T3bjbj(q,j,q1,j1)
      temp Taibj(p,i,q,j)
      temp T1aibj(p,i,q,j)
      temp T2aibj(p,i,q,j)
      temp T3aibj(p,i,q,j)
      temp T4aibj(p,i,q,j)
      temp T5aibj(p,i,q,j)
#
      temp Txxxp(mu,nu,lambda,i)
      temp Txxxq(mu,nu,lambda,j)
      temp Txxpp(mu,nu,p1,i)
      temp Txxqq(mu,nu,q1,j)
      temp Txppp(mu,p2,p1,i)
      temp Txqpp(mu,q,p1,i)
      temp Txqqq(mu,q2,q1,j)
      temp Txpqq(mu,p,q1,j)
      temp Tpppp(p3,p2,p1,p)
      temp Tqqqq(q3,q2,q1,q)
      temp Tppqq(p1,p,q1,j)
      temp Tqqpp(q1,q,p1,i)
      temp Tixxx(i,mu,nu,sigma) 
      temp Tipxx(i,p,nu,sigma) 
      temp Tipqx(i,p,q,sigma) 
      temp Tipqq(i,p,q,q1) 
      temp Txiai(lambda,i,a1,i1) 
      temp Txjbj(lambda,j,b1,j1) 
      temp Txibj(lambda,i,b1,j1) 
#
      temp tmp1_aiai(a,i,a1,i1) 
      temp tmp2_aiai(a,i,a1,i1) 
      temp tmp3_aiai(a,i,a1,i1) 
      temp tmp1_bjbj(b,j,b1,j1) 
      temp tmp2_bjbj(b,j,b1,j1) 
      temp tmp3_bjbj(b,j,b1,j1) 
      temp tmp1_aibj(a,i,b,j) 
      temp tmp2_aibj(a,i,b,j) 
#
      temp Tai(a,i)
      temp t1_aux(a,i) 
      temp T1ai(a,i) 
      temp T2ai(a,i) 
      temp Tbj(b,j) 
      temp T1bj(b,j) 
      temp T2bj(b,j) 
#
      temp Taa(a,a1) 
      temp T1aa(a,a1) 
      temp Tbb(b,b1) 
      temp T1bb(b,b1) 
      temp Tae_a(a,a1) 
      temp Tae_b(b,b1) 
#
      temp Tia(i,a) 
      temp T1ia(i,a) 
      temp Tjb(j,b) 
      temp T1jb(j,b) 
      temp Tme_a(i,a) 
      temp Tme_b(j,b) 
#
      temp Tii(i,i1) 
      temp T1ii(i,i1) 
      temp Tjj(j,j1) 
      temp T1jj(j,j1) 
      temp Tmi_a(i,i1) 
      temp Tmi_b(j,j1) 
#
      temp T1pppp(p,p1,p2,p3) 
      temp T1qqqq(q,q1,q2,q3) 
      temp Taiii(a,i,i1,i2) 
      temp T1aiii(a,i,i1,i2) 
#
      temp  Tiiii(i,i1,i2,i3) 
      temp T1iiii(i,i1,i2,i3) 
#
      temp  Tjjjj(j,j1,j2,j3) 
      temp T1jjjj(j,j1,j2,j3) 
      temp  Tbjjj(b,j,j1,j2) 
      temp T1bjjj(b,j,j1,j2) 
#
      temp  Tiijj(i,i1,j2,j3) 
      temp T1iijj(i,i1,j2,j3) 
#
      temp  tmp_aa(a,a1) 
      temp tmp1_aa(a,a1) 
      temp  tmp_ii(i,i1) 
      temp tmp1_ii(i,i1) 
#
      temp  Tiiai(i,i1,a,i2) 
      temp T1iiai(i,i1,a,i2) 
#
      temp  tmp_bb(b,b1) 
      temp tmp1_bb(b,b1) 
      temp  tmp_jj(j,j1) 
      temp tmp1_jj(j,j1) 
#
      temp  Tjjbj(j,j1,b,j2) 
      temp T1jjbj(j,j1,b,j2) 
# 
      temp T1aaai(a,a1,a2,i)  
      temp T2aaai(a,a1,a2,i)  
      temp Taaaa(a,a1,a2,a3)  
      temp T1aaaa(a,a1,a2,a3)  
#
      temp T1bbbj(b,b1,b2,j)  
      temp T2bbbj(b,b1,b2,j)  
      temp Tbbbb(b,b1,b2,b3)  
      temp T1bbbb(b,b1,b2,b3)  
#
      temp Taabb(a,a1,b,b1)  
      temp T1aabb(a,a1,b,b1)  
#
      temp R1aiai(a,i,a1,i1) 
      temp R2aiai(a,i,a1,i1) 
      temp R3aiai(a,i,a1,i1) 
      temp R4aiai(a,i,a1,i1) 
      temp R1bjbj(b,j,b1,j1) 
      temp R2bjbj(b,j,b1,j1) 
      temp R3bjbj(b,j,b1,j1) 
      temp R4bjbj(b,j,b1,j1) 
      temp R1aibj(a,i,b,j) 
      temp R2aibj(a,i,b,j) 
      temp R3aibj(a,i,b,j) 
      temp R4aibj(a,i,b,j) 
#
      temp T1iaai(i,a,a1,i1) 
      temp T2iaai(i,a,a1,i1) 
      temp T1jbbj(j,b,b1,j1) 
      temp T2jbbj(j,b,b1,j1) 
      temp T1iabj(i,a,b,j) 
      temp T2iabj(i,a,b,j) 
      temp Tjjpp(j,j1,p,p1) 
      temp T1jjpp(j,j1,p,p1) 
      temp T2jjpp(j,j1,p,p1) 
      temp  Tiiqq(i,i1,q,q1) 
      temp T1iiqq(i,i1,q,q1) 
      temp T2iiqq(i,i1,q,q1) 
      temp  Tjjai(j,j1,a,i) 
      temp T1jjai(j,j1,a,i) 
      temp T2jjai(j,j1,a,i) 
      temp  Tiibj(i,i1,b,j) 
      temp T1iibj(i,i1,b,j) 
      temp T2iibj(i,i1,b,j) 
      temp  Tjbai(j,b,a,i)  
      temp T1jbai(j,b,a,i)  
      temp T2jbai(j,b,a,i)  
      temp  Taijj(a,i,j,j1) 
      temp T1aijj(a,i,j,j1) 
      temp Tqqip(a,i,b,b1)  
#
      temp tpx(p,mu) 
      temp t1px(p,mu) 
      temp tqx(q,mu) 
      temp t1qx(q,mu) 
      temp txi(mu,i) 
      temp t1xi(mu,i) 
      temp txj(mu,j) 
      temp t1xj(mu,j)
      temp tELAM(iii,kkk)

      temp tcpinterm(p,a)
      temp tmoval(p)
      temp tmoover(p,q)
      temp tmoval1(p)
      temp tmp3center(mu,nu)
      temp tmp3center_pi(p,q)
      temp tmp3center_imu(mu,q)
      temp tccc(i,j,k)
      temp tccc1(i,k,a)
#
# Declare distributed arrays 
# -------------------------- 
#
      served T2new_ab(a,i,b,j)
      served T2old_aa(a,i,a1,i1)
      served T2old_ab(a,i,b,j)
#
      served Tau_ab(a,i,b,j)
      served Taup_aa(a,i,a1,i1)
      served Taup_ab(a,i,b,j)
#
      served Wiibb(i1,i,b,b1)    
      served Wjjaa(j1,j,a,a1)     
      served cpinterm1(p,a)
      served cpinterm2(p,a)
      served cpinterm3(p,a)
      served cpinterm4(p,a) 
#
#
#------------T1 f12- intermediates---------------------------------------------------------
      served T1_1(i,a)
      served T1_2(i,j)
      served T1_3(a,p)
      served T1_4(a,i,a1,i1)
#------------T2 f12- intermediates---------------------------------------------------------
      served T2_1(a,i,b,j)
      served T2_2(i,k,j,a)
      served T2_3(i,k,j,l)
      served T2_4(i,j)
      served T2_5(a,i,b,j)
      served T2_6(a,i,q,j)
      served T2_7(q,i,a,j)
      served T2_8(a,i,p,j)
      served T2_9(a,p,i,j)
      served T2_10(i,a,d,b)
      served T2_11(d,a,j,b)

      served auxint1(a,i,p,j)
      served auxint2(a,i,p,j)
      served V0pipi(p,i,q,j)
      served V0aapi(a,b,p,i)
      served V0apai(a,p,b,i)
      served V2ppii(p,q,i,j)
      served V2piai(p,i,a,j)
#--------------Lambda f12-intermediates----------------------------------------------------
       served LAM_1(i,a)
       served LAM_2(i,a,k,b)
       served LAM_3(i,a,k,b)
       served LAM_4(i,a,k,b)
       served LAM_5(i,a,k,b)
       served ELAM(iii,kkk)

#------------------------------------------------------------------------------------------



# Declare served arrays 
# --------------------- 
#
      temp AOINT(mu,nu,lambda,sigma) 
      static pinf(kiter,kptr1)
      temp tpinf(kiter,kptr1)
      scalar ncount1
      scalar ncount2
      scalar one
      scalar two
      scalar five
      scalar six
      scalar seven
      scalar F12GAMMA
      scalar E_LAM
      scalar E_qcorr
      scalar E_dir
      scalar etmp
      scalar etmp1
      scalar etmp2
      scalar etmp3
#
# Arrays needed for AOLADDER contribution
# ---------------------------------------
#
     temp Zaa(lambda,i,a1,i1)
     temp Zbb(lambda,j,b,j1)
     temp Zab(lambda,i,b,j)
     temp ZZaa(lambda,i,sigma,i1)
     temp ZZ1aa(lambda,i,sigma,i1)
     temp ZZbb(lambda,j,sigma,j1)
     temp ZZ1bb(lambda,j,sigma,j1)
     temp ZZab(lambda,i,sigma,j)
#
     temp Yab(lambda,i,mu,j)
     temp Y1ab(lambda,i,mu,j)
#
     temp TXaiai(a,i,nu,i1)
     temp Taixi(a,i,nu,i1)   
     temp TYaiai(a,i,a1,i1)
     temp TY1aiai(a,i,a1,i1)
     temp TXbjbj(b,j,nu,j1)
     temp Tbjxj(b,j,nu,j1)
     temp TYbjbj(b,j,b1,j1)
     temp TY1bjbj(b,j,b1,j1)
     temp TXaibj(a,i,nu,j)
     temp TZaibj(a,i,nu,j)
     temp Taixj(a,i,nu,j)
     temp TYaibj(a,i,b,j)
     temp tccusp(i,j,k,l)
     temp t1ccusp(i,j,k,l)
     temp tCC3(i,j,k,l)
     temp tmoaux(p)
     temp tauxint(a,i,p,j)
     temp tauxint1(a,i,p,j) 
#
     served TAO_ab(lambda,i,sigma,j)
     served T2AO_ab(lambda,i,sigma,j)
     distributed t1a_ax(a,mu) 
     distributed t1a_xi(mu,i) 
     distributed t1b_xj(mu,j) 
     served TDaixj(a,i,nu,j)
     local LDaixj(a,i,nu,j) 
#
# local arrays used for data storage
# ---------------------------------- 
#
     local Liiai(i2,i,a,i1) 
     local L1iiai(i,i1,a2,i2) 
     local L2iiai(i2,i1,a2,i)  
     local L3iiai(i,i1,a,i2)  
     local L4iiai(i2,i1,a,i)  
     local Laiai(a,i,a2,i1) 
     local L1aiai(a,i,a1,i2) 
     local L2aiai(a1,i1,a2,i) 
     local L3aiai(a2,i1,a,i2) 
     local L4aiai(a1,i,a2,i1) 
     local Laaai(a,a2,a1,i) 
#
     local Ljjbj(j2,j,b,j1) 
     local Lbjbj(b,j,b2,j1) 
     local L1bjbj(b,j,b1,j2) 
     local L2bjbj(b1,j1,b2,j) 
     local L3bjbj(b2,j1,b,j2) 
     local L4bjbj(b1,j,b2,j1) 
     local Lbbbj(b,b2,b1,j) 
#
     local Laijj(a,i,j1,j) 
     local Laibj(a,i,b1,j) 
     local L1aibj(a1,i,b,j) 
     local L2aibj(a,i,b,j2) 
     local L3aibj(a,i1,b,j) 
     local L4aibj(a,i,b1,j) 
     local Liibj(i1,i,b,j) 
     local L1iibj(i,i1,b,j) 
     local Lbbai(b,b1,a,i) 
     local Laabj(a,a1,b,j) 
     local LLaiai(a,i,a1,i1) 
     local Lxiai(lambda,i,a1,i1) 
     local LLbjbj(b,j,b1,j1) 
     local Lxjbj(lambda,j,b1,j1) 
     local LLaibj(a,i,b,j) 
     local Lxibj(lambda,i,b,j) 
     local L1xixi(mu,i,nu,i1)  
     local L2xixi(nu,i1,mu,i)  
     local L1xjxj(mu,j,nu,j1)  
     local L2xjxj(nu,j1,mu,j)  
     local L1xixj(mu,i,nu,j)  
     local Laiii(a,i,i2,i1) 
     local L1aiii(a1,i2,i,i1) 
     local Lbjjj(b,j,j2,j1) 
     local L1bjjj(b1,j2,j,j1) 
     local Ljjai(a,i,j,j1) 
#
     local LWaaai(a2,a,a1,i1) 
     local LWbbbj(b2,b,b1,j1) 
     local LWbbai(b1,b,a,i) 
     local LWaabj(a1,a,b,j) 
     local LXbbai(b1,b,a1,i1) 
     local LXaabj(a1,a,b1,j1) 
     local LWaiai(a2,i,a,i1) 
     local LWbjbj(b2,j,b,j1) 
     local LWaibj(a,i,b,j) 
     local LWiaai(i1,a,a2,i)
     local LWjbai(j,b,a,i)
#--------------------------------
     local MOVAL(p) 
     local MOOVER(p,q)
     local l3center_imu(mu,q)
     local inv_r12_ip(p,q)
     local slater_ip(p,i)
     local CCC(i,i1,i2)
     local CCC1(i,i1,a)
     local CCC2(i,i1,a)
     local CCC3(i,i1,a)
     local CCC11(i,j,k)
     local ZV1(p,q)
     local ZVV1(p,q)
     local ZVV2(p,q)
     local ZVV3(p,q)
     local moaux(p)
     local ZV2(p,q)
     local ZV3(p,q) 
     local moaux2(p)
     local moaux3(p)
     local GV2(i,j)
     local lcp4(p,q) 
#
# Distributed two-particle arrays 
# ------------------------------- 
#
     distributed Wminj_aa(i2,i,i3,i1) 
     distributed Wminj_bb(j2,j,j3,j1) 
     distributed Wminj_ab(i2,i,j3,j1) 
#
# Declare scalars 
# --------------- 
#
      scalar etemp
      scalar esum
      scalar esuma
      scalar esumb
      scalar esumab
      scalar ecorraa
      scalar ecorrbb
      scalar ecorrab
      scalar ecorrT
      scalar enew 
      scalar eold 
      scalar ecrit 
      scalar ediff 
      scalar mp2_energy
      scalar restart
#
# Arrays/Scalars used exclusively in DIIS procedure. 
# -------------------------------------------------- 
#
       served D0aibj(a,i,b,j)  
       served D1aibj(a,i,b,j)  
       served D2aibj(a,i,b,j)  
       served D3aibj(a,i,b,j)  
       served D4aibj(a,i,b,j)  
       served D5aibj(a,i,b,j)  
#
       distributed D0ai(a,i)  
       distributed D1ai(a,i)  
       distributed D2ai(a,i)  
       distributed D3ai(a,i)  
       distributed D4ai(a,i)  
       distributed D5ai(a,i)  
#
       distributed e1ai(a,i)  
       distributed e2ai(a,i)  
       distributed e3ai(a,i)  
       distributed e4ai(a,i)  
       distributed e5ai(a,i)  
#
       served e1aibj(a,i,b,j)  
       served e2aibj(a,i,b,j)  
       served e3aibj(a,i,b,j)  
       served e4aibj(a,i,b,j)  
       served e5aibj(a,i,b,j)  
       served e6aibj(a,i,b,j)
#-----------------------------------
       served intaux3(a,i,b,j)
       served C_coef(i,i1,i2,i3)
       served CC1(i,j,k,l)
       served CC2(i,j,k,l)
       served CC3(i,j,k,l)

       served T2_aux1(a,i,b,j) 
#-----------------------------------
       served e5aiai(a,i,b,j) 
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510
#
       scalar b66
       scalar b67
       scalar b68
       scalar b69
       scalar b610
#
       scalar b77
       scalar b78
       scalar b79
       scalar b710
#
       scalar b88
       scalar b89
       scalar b810
#
       scalar b99
       scalar b910
#
       scalar b1010
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510
#
       scalar Tb66
       scalar Tb67
       scalar Tb68
       scalar Tb69
       scalar Tb610
#
       scalar Tb77
       scalar Tb78
       scalar Tb79
       scalar Tb710
#
       scalar Tb88
       scalar Tb89
       scalar Tb810
#
       scalar Tb99
       scalar Tb910
#
       scalar Tb1010
#
       scalar c1 
       scalar c2 
       scalar c3 
       scalar c4 
       scalar c5 
       scalar c6 
       scalar c7 
       scalar c8 
       scalar c9 
       scalar c10 
       scalar Ng
       scalar PTW
       scalar cnt
       scalar ind
       scalar int1_type
       scalar F12CALC

      scalar l1
      scalar l2
      scalar l3
      scalar l4
      scalar nfrags
      scalar icount
      scalar icount1
      scalar i_vstart
      scalar i_vend

      local wOccA_frag(i)

      temp xi(i)
      temp xi1(i)
      temp xi2(i)
      temp xi3(i)


#----Procedure which sets up fragments and segments--
      PROC SET_FRAG
#     -------------
      nfrags = 2.0
      allocate wOccA_frag(*)

      icount = 0.0

      DO jfrag

         icount   += 1.0

         i_vstart  = icount
         i_vend    = 6.0

         execute print_scalar i_vstart
         execute print_scalar i_vend


         execute frag_index_range i_vstart i_vend

         execute print_scalar i_vstart
         execute print_scalar i_vend


         DO i
            icount1 = 0.0
            do i1
               icount1 += 1.0
               if i == i1
                  exit
               endif
            enddo i1
            if icount1 >= i_vstart
            if icount1 <= i_vend
               wOccA_frag(i) = icount
            endif
            endif
         ENDDO i

      ENDDO jfrag



      ENDPROC SET_FRAG
#     ----------------



 
#
#    ------------------------------------------------------------------------ 
#
     PROC READ_2EL   
# 
#    ------------------------------------------------------------------------ 
#
      execute server_barrier
      execute list_to_blocks                VSpipi
      execute list_to_blocks                Vaaii
      execute list_to_blocks                Viaai
      execute list_to_blocks                Vaaai
      execute list_to_blocks                Vpiqj
#-----------Read intermediates from the disk----------------------------------------------
#
       IF F12CALC == 1.0
#------------- T1-intermediates----------------------------------------------------------
      execute list_to_blocks          T1_1
      execute list_to_blocks          T1_2
      execute list_to_blocks          T1_3
      execute list_to_blocks          T1_4
#------------ T2-intermediates----------------------------------------------------------
      execute list_to_blocks          T2_1
      execute list_to_blocks          T2_2
      execute list_to_blocks          T2_3
      execute list_to_blocks          T2_4
      execute list_to_blocks          T2_5
      execute list_to_blocks          T2_6
      execute list_to_blocks          T2_7
      execute list_to_blocks          T2_8
      execute list_to_blocks          T2_9
      execute list_to_blocks          T2_10
      execute list_to_blocks          T2_11
#------------ Lambda - intermediates---------------------------------------------------
      execute list_to_blocks          LAM_1
      execute list_to_blocks          LAM_2
      execute list_to_blocks          LAM_3
      execute list_to_blocks          LAM_4
      execute list_to_blocks          LAM_5
      execute list_to_blocks          ELAM
#------------ Additional integrals for T2 amplitudes ---------------------------------
      execute list_to_blocks          auxint1
      execute list_to_blocks          V2piai
      execute list_to_blocks          V0pipi
      execute list_to_blocks          V0apai
      execute list_to_blocks          V0aapi
#--------------------------------------------------------------------------------------
        ENDIF

      execute read_list_to_blocks
      execute server_barrier
#
#    ------------------------------------------------------------------------ 
#
     ENDPROC READ_2EL   
# 
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
     PROC WRITE_2EL   
# 
#    ------------------------------------------------------------------------ 
#
      execute server_barrier
      execute blocks_to_list                VSpipi(p,i,p1,i1) 
      execute blocks_to_list                Vaaii
      execute blocks_to_list                Viaai
      execute blocks_to_list                Vaaai
      execute blocks_to_list                Vpiqj(p,i,q,j) 
#
#    ------------------------------------------------------------------------ 
#
     ENDPROC WRITE_2EL   
# 
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
     PROC IGUESS_UHF  
# 
#    ------------------------------------------------------------------------ 
#
     PARDO a, b, i, j 

#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

           REQUEST                     Vpiqj(a,i,b,j) j  
           REQUEST                     Vpiqj(b,j,a,i) j  
           Taibj(a,i,b,j)            = Vpiqj(b,j,a,i)
           Taibj(a,i,b,j)           += Vpiqj(a,i,b,j)
           execute energy_denominator  Taibj 
           Taibj(a,i,b,j)           *= 0.5  
           PREPARE T2old_ab(a,i,b,j) = Taibj(a,i,b,j)  
           PREPARE D0aibj(a,i,b,j)   = Taibj(a,i,b,j)  


        endif
        endif
     ENDPARDO a, b, i, j 
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           tai(a,i) = 0.0
           PUT t1a_old(a,i) = tai(a,i)
           PUT D0ai(a,i) = tai(a,i)

       endif
     ENDPARDO a, i
#
#    ------------------------------------------------------------------------ 
# 
     ENDPROC IGUESS_UHF 
# 
#    ------------------------------------------------------------------------ 
#
      PROC TAUAA 
#     ----------
#
      PARDO a, i, a1, i1 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            REQUEST T2old_aa(a,i,a1,i1) i1  
            GET t1a_old(a1,i1) 
            GET t1a_old(a1,i) 
            GET t1a_old(a,i1) 
            GET t1a_old(a,i) 
# 
            tai(a1,i1)                 = t1a_old(a1,i1) 
            tmp1_aiai(a,i,a1,i1)       = t1a_old(a,i)^tai(a1,i1)  
            tai(a1,i)                  = t1a_old(a1,i) 
            tmp2_aiai(a,i,a1,i1)       = t1a_old(a,i1)^tai(a1,i)  
            tmp1_aiai(a,i,a1,i1)      -= tmp2_aiai(a,i,a1,i1)  
#
            tmp1_aiai(a,i,a1,i1)      *= 0.5  
            tmp1_aiai(a,i,a1,i1)      += T2old_aa(a,i,a1,i1) 
            PREPARE Taup_aa(a,i,a1,i1) = tmp1_aiai(a,i,a1,i1)  


         endif
         endif
      ENDPARDO a, i, a1, i1 

      ENDPROC TAUAA 
#     ------------- 
# 
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
      PROC TAUAB 
#     ----------
#
      PARDO a, i, b, j 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            REQUEST T2old_ab(a,i,b,j) j  
            GET t1a_old(a,i) 
            GET t1a_old(b,j) 
            tai(a,i) = t1a_old(a,i) 
#
            tmp1_aibj(a,i,b,j)       = tai(a,i)^t1a_old(b,j)  
            tmp2_aibj(a,i,b,j)       = tmp1_aibj(a,i,b,j)  
            tmp2_aibj(a,i,b,j)      *= 0.5  
#
            tmp1_aibj(a,i,b,j)      += T2old_ab(a,i,b,j) 
            tmp2_aibj(a,i,b,j)      += T2old_ab(a,i,b,j) 
            PREPARE Tau_ab(a,i,b,j)  = tmp1_aibj(a,i,b,j)  
            PREPARE Taup_ab(a,i,b,j) = tmp2_aibj(a,i,b,j)  

        endif
        endif 
      ENDPARDO a, i, b, j 
#
      ENDPROC TAUAB 
#     ------------- 
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
      PROC TAUPAA 
#     -----------
#
      PARDO a, i, a1, i1 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            REQUEST T2old_aa(a,i,a1,i1) i1  
            GET t1a_old(a1,i1) 
            GET t1a_old(a1,i) 
            GET t1a_old(a,i1) 
            GET t1a_old(a,i) 
#
            tai(a1,i1)                 = t1a_old(a1,i1) 
            tmp1_aiai(a,i,a1,i1)       = t1a_old(a,i)^tai(a1,i1)  
            tai(a1,i)                  = t1a_old(a1,i) 
            tmp2_aiai(a,i,a1,i1)       = t1a_old(a,i1)^tai(a1,i)  
            tmp1_aiai(a,i,a1,i1)      -= tmp2_aiai(a,i,a1,i1) 
            tmp1_aiai(a,i,a1,i1)      *= 0.5  
            tmp1_aiai(a,i,a1,i1)      += T2old_aa(a,i,a1,i1) 
            PREPARE Taup_aa(a,i,a1,i1) = tmp1_aiai(a,i,a1,i1)  
#
        endif
        endif
      ENDPARDO a, i, a1, i1 
#
      ENDPROC TAUPAA 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC TAUPAB 
#     -----------
#
      PARDO a, i, b, j 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------


            REQUEST T2old_ab(a,i,b,j) j  
            GET t1a_old(a,i) 
            GET t1a_old(b,j) 
            tai(a,i) = t1a_old(a,i) 
# 
            tmp1_aibj(a,i,b,j)       = tai(a,i)^t1a_old(b,j)  
            tmp1_aibj(a,i,b,j)      *= 0.5  
            tmp1_aibj(a,i,b,j)      += T2old_ab(a,i,b,j) 
            PREPARE Taup_ab(a,i,b,j) = tmp1_aibj(a,i,b,j)  


        endif 
        endif
      ENDPARDO a, i, b, j 
#
      ENDPROC TAUPAB 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC TAU 
#
           CALL TAUAA 
           CALL TAUAB 
#
      ENDPROC TAU 
#
      PROC TAUP
#
           CALL TAUPAA 
           CALL TAUPAB 
#
      ENDPROC TAUP
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
      PROC FAEA
#     ----------
#
      PARDO a, a2, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------


               allocate LWiaai(*,a,a2,i)
#     
               DO a1
#     
                  REQUEST            Vaaai(a1,a,a2,i) i
                  REQUEST            Vaaai(a2,a,a1,i) i
                  GET                t1a_old(a2,i)
#     
                  taaai(a1,a,a2,i) = Vaaai(a1,a,a2,i)
                  t1aaai(a1,a,a2,i)= Vaaai(a2,a,a1,i)
                  taaai(a1,a,a2,i)-= t1aaai(a1,a,a2,i)
#     
                  Taa(a,a1)        = taaai(a1,a,a2,i)*t1a_old(a2,i)
                  PUT Fae_a(a,a1) += Taa(a,a1)
#     
                  DO i1
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                     GET                  t1a_old(a1,i1)
                     tiaai(i1,a,a2,i)   = taaai(a1,a,a2,i)*t1a_old(a1,i1)
                     LWiaai(i1,a,a2,i) += tiaai(i1,a,a2,i)

                  endif
                  ENDDO i1
#
               ENDDO a1
#
               DO i1
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

                  Taiai(a2,i,a,i1)          = LWiaai(i1,a,a2,i)
                  PREPARE e5aiai(a2,i,a,i1) = Taiai(a2,i,a,i1)

               endif
               ENDDO i1
#
               deallocate LWiaai(*,a,a2,i)

          endif   
      ENDPARDO a, a2, i
#
      PARDO a, b, j
#-----------------------------
       xi(j)   = wOccA_frag(j)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

            allocate LWaibj(a,*,b,j)
#
            DO a1
#
               REQUEST            Vaaai(a1,a,b,j) j
               GET                t1a_old(b,j)
#
               DO i
#-----------------------------
       xi1(i)   = wOccA_frag(i)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                  GET                t1a_old(a1,i)
                  taibj(a,i,b,j)   = Vaaai(a1,a,b,j)*t1a_old(a1,i)
                  LWaibj(a,i,b,j) += taibj(a,i,b,j)

               endif
               ENDDO i
#
               Taa(a,a1)        = Vaaai(a1,a,b,j)*t1a_old(b,j)
               PUT Fae_a(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
            DO i
#-----------------------------
       xi1(i)   = wOccA_frag(i)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

               Taibj(a,i,b,j)          = LWaibj(a,i,b,j)
               T1aibj(b,j,a,i)         = LWaibj(a,i,b,j)
               PREPARE e6aibj(a,i,b,j) = Taibj(a,i,b,j)
               PREPARE e5aibj(b,j,a,i) = T1aibj(b,j,a,i) 

            endif
            ENDDO i
#
            deallocate LWaibj(a,*,b,j)

         endif
      ENDPARDO a, b, j
#
      PARDO a1, i, b, j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

           REQUEST Vpiqj(a1,i,b,j) j
#
           DO a
#
              REQUEST            Taup_ab(a,i,b,j) j
#
              Taa(a,a1)        = Taup_ab(a,i,b,j)*Vpiqj(a1,i,b,j)
              Taa(a,a1)       *= -1.0
#
              PUT Fae_a(a,a1) += Taa(a,a1)
#
           ENDDO a
           endif
           endif 
      ENDPARDO a1, i, b, j
#
      PARDO a1, i, a2, i1
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

           REQUEST VSpipi(a1,i1,a2,i) i
#
           DO a
#
               REQUEST Taup_aa(a,i,a2,i1) i
#
               Taa(a,a1)        = Taup_aa(a,i,a2,i1)*VSpipi(a1,i1,a2,i)
               Taa(a,a1)       *= 0.5
#
               PUT Fae_a(a,a1) += Taa(a,a1)
#
            ENDDO a

            endif
            endif
      ENDPARDO a1, i, a2, i1
#
      ENDPROC FAEA
#     -------------
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
      PROC FAEB
#     ----------
#
      PARDO a, i, b
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

            allocate LWjbai(*,b,a,i)
#              
            DO b1
#           
               REQUEST Vaaai(b1,b,a,i) i
               GET     t1a_old(a,i) 
#
               DO j  
#-----------------------------
       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                  GET                t1a_old(b1,j)
                  tjbai(j,b,a,i)   = Vaaai(b1,b,a,i)*t1a_old(b1,j)
                  LWjbai(j,b,a,i) += tjbai(j,b,a,i)

               endif 
               ENDDO j
#    
            ENDDO b1
#     
            DO j
#-----------------------------
       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
               Taibj(a,i,b,j)          = LWjbai(j,b,a,i)
               PREPARE e5aibj(a,i,b,j) = Taibj(a,i,b,j)
#     
            endif
            ENDDO j
#    
            deallocate LWjbai(*,b,a,i)
#
        endif    
      ENDPARDO a, i, b
#
      ENDPROC FAEB
#     -------------
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
      PROC FAE
#     --------
         CALL FAEA 
        #CALL FAEB 
      ENDPROC FAE
#     ----------- 
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
      PROC FMEA
#     ----------
#
      PARDO i, a 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

            Tme_a(i,a) = 0.0
# 
            DO i1
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            DO a1 
#
               REQUEST VSpipi(a,i,a1,i1) i1  
               GET     t1a_old(a1,i1) 
#
               Tia(i,a)    = VSpipi(a,i,a1,i1)*t1a_old(a1,i1) 
               Tme_a(i,a) += Tia(i,a) 
#
            ENDDO a1
            endif 
            ENDDO i1 
# 
            DO j
#----------------------------- 
       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            DO b 
#
               REQUEST Vpiqj(a,i,b,j) j  
               GET     t1a_old(b,j) 
#
               Tia(i,a)    = Vpiqj(a,i,b,j)*t1a_old(b,j) 
               Tme_a(i,a) += Tia(i,a) 
#
            ENDDO b 
            endif
            ENDDO j 
#
            PUT Fme_a(i,a) = Tme_a(i,a) 

       endif
      ENDPARDO i, a 
# 
      ENDPROC FMEA
#     -------------
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
      PROC FMIA
#     ----------
#
      PARDO i1, i, a, i2
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two

       xi2(i2)   = wOccA_frag(i2)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

            REQUEST VSpipi(a,i2,i,i1) i1  
            GET t1a_old(a,i2) 
#
            Tii(i1,i)        = VSpipi(a,i2,i,i1)*t1a_old(a,i2) 
            PUT Fmi_a(i1,i) += Tii(i1,i) 

        endif
        endif
        endif
      ENDPARDO i1, i, a, i2  
#
      PARDO a, a2, i2  
#-----------------------------
       xi3(i2)   = wOccA_frag(i2)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------

            allocate L3aiai(a2,*,a,i2) 
#
            DO i1 
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
               REQUEST VSpipi(a2,i1,a,i2) i2 
               L3aiai(a2,i1,a,i2) = VSpipi(a2,i1,a,i2) 

            endif 
            ENDDO i1 
#
            DO i   
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
               REQUEST Taup_aa(a2,i,a,i2) i2 
# 
               DO i1   
#----------------------------- 
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                  Tii(i1,i)        = L3aiai(a2,i1,a,i2)*Taup_aa(a2,i,a,i2) 
                  Tii(i1,i)       *= 0.5 
                  PUT Fmi_a(i1,i) += Tii(i1,i) 

               endif
               ENDDO i1  
            endif 
            ENDDO i   
#
            deallocate L3aiai(a2,*,a,i2) 

        endif 
      ENDPARDO a, a2, i2  
#
      PARDO i1, i, b, j  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two

       xi2(j)   = wOccA_frag(j)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
            REQUEST Vpiqj(i,i1,b,j) j  
            GET t1a_old(b,j) 
#
            Tii(i1,i)        = Vpiqj(i,i1,b,j)*t1a_old(b,j) 
            PUT Fmi_a(i1,i) += Tii(i1,i) 

        endif
        endif
        endif 
      ENDPARDO i1, i, b, j  
#
      PARDO i1, i, b, j  
#------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two

       xi2(j)   = wOccA_frag(j)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

            DO a 
#
               REQUEST Vpiqj(a,i1,b,j)  j  
               REQUEST Taup_ab(a,i,b,j) j 
 
               Tii(i1,i)        = Taup_ab(a,i,b,j)*Vpiqj(a,i1,b,j) 
               PUT Fmi_a(i1,i) += Tii(i1,i) 
#
            ENDDO a 


        endif
        endif
        endif
      ENDPARDO i1, i, b, j  
#
      ENDPROC FMIA
#     -------------
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
# In the procedure T1ANEW all contributions to the singles amplitude t1a 
# are computed. 
#
      PROC T1ANEW 
#     -----------
#
      PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
            tai(a,i) = 0.0
#
            DO i1
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

               GET t1a_old(a,i1)
               GET Fmi_a(i1,i)
#
               t1ai(a,i) = t1a_old(a,i1)*Fmi_a(i1,i)
               tai(a,i) -= t1ai(a,i)

            endif
            ENDDO i1
#
            DO b
            DO j
#-----------------------------
       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

               REQUEST T2old_ab(a,i,b,j) j
               REQUEST Viaai(i,a,b,j) j
               GET Fme_a(j,b)
               GET t1a_old(b,j)
#
               t1ai(a,i) = T2old_ab(a,i,b,j)*Fme_a(j,b)
               tai(a,i) += t1ai(a,i)
#
               t2ai(a,i)  = Viaai(i,a,b,j)*t1a_old(b,j)
               tai(a,i) += t2ai(a,i)

            endif
            ENDDO j
            ENDDO b
#
            DO a1
#
               GET t1a_old(a1,i)
               GET Fae_a(a,a1)
#
               t1ai(a,i) = t1a_old(a1,i)*Fae_a(a,a1)
               tai(a,i) += t1ai(a,i)
#
               DO i1
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                  REQUEST T2old_aa(a,i,a1,i1) i1
                  REQUEST Vaaii(a,a1,i1,i) i
                  REQUEST Viaai(i1,a1,a,i) i
                  GET Fme_a(i1,a1)
                  GET t1a_old(a1,i1)
#
                  t1ai(a,i) = T2old_aa(a,i,a1,i1)*Fme_a(i1,a1)
                  tai(a,i) += t1ai(a,i)
#
                  Tpppp(i1,a1,a,i)  = Vaaii(a,a1,i1,i)
                  Tpppp(i1,a1,a,i) -= Viaai(i1,a1,a,i)
#
                  t2ai(a,i) = Tpppp(i1,a1,a,i)*t1a_old(a1,i1)
                  tai(a,i) -= t2ai(a,i)

                endif
               ENDDO i1
#
            ENDDO a1
#
            PUT t1a_new(a,i) += tai(a,i)

        endif 
      ENDPARDO a, i
#
      PARDO a1, a2, i1
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            allocate L4aiai(a1,*,a2,i1)
#
            DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
               REQUEST T2old_aa(a1,i,a2,i1) i1
               L4aiai(a1,i,a2,i1) = T2old_aa(a1,i,a2,i1)

            endif
            ENDDO i
#
            DO a
#
               REQUEST Vaaai(a2,a,a1,i1)   i1
               REQUEST Vaaai(a1,a,a2,i1)   i1
               taaai(a2,a,a1,i1) = Vaaai(a2,a,a1,i1) 
               t1aaai(a2,a,a1,i1)= Vaaai(a1,a,a2,i1) 
               taaai(a2,a,a1,i1)-= t1aaai(a2,a,a1,i1) 
#
               DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
                  tai(a,i)  = taaai(a2,a,a1,i1)*L4aiai(a1,i,a2,i1)
                  tai(a,i) *= -0.5
#
                  PUT t1a_new(a,i) += tai(a,i)

               endif
               ENDDO i
#
            ENDDO a
#
            deallocate L4aiai(a1,*,a2,i1)

      endif 
      ENDPARDO a1, a2, i1
#
      PARDO a1, i1, i2
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two

       xi2(i2)   = wOccA_frag(i2)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

            allocate L1aiii(a1,i2,*,i1)
#
            DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
               REQUEST VSpipi(a1,i2,i,i1) i1
               L1aiii(a1,i2,i,i1) = VSpipi(a1,i2,i,i1)

            endif
            ENDDO i
#
            DO a
#
               REQUEST T2old_aa(a,i1,a1,i2) i1
#
               DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
                  tai(a,i)  = L1aiii(a1,i2,i,i1)*T2old_aa(a,i1,a1,i2)
                  tai(a,i) *= -0.5
#
                  PUT t1a_new(a,i) += tai(a,i)

               endif
               ENDDO i
#
            ENDDO a
#
            deallocate L1aiii(a1,i2,*,i1)

        endif
        endif 
      ENDPARDO a1, i1, i2
#
      PARDO a1, b, j
#-----------------------------
       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            allocate L1aibj(a1,*,b,j)
#
            DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

               REQUEST T2old_ab(a1,i,b,j) j
               L1aibj(a1,i,b,j) = T2old_ab(a1,i,b,j)

            endif
            ENDDO i
#
            DO a
#
               REQUEST Vaaai(a1,a,b,j) j
#
               DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

                  tai(a,i)  = Vaaai(a1,a,b,j)*L1aibj(a1,i,b,j)
#
                  PUT t1a_new(a,i) += tai(a,i)

               endif
               ENDDO i
#
            ENDDO a
#
            deallocate L1aibj(a1,*,b,j)

        endif 
      ENDPARDO a1, b, j
#
      PARDO b, j, i1
#-----------------------------
       xi1(i1)   = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two

       xi2(j)   = wOccA_frag(j)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

            allocate L1iibj(*,i1,b,j)
#
            DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

               REQUEST Vpiqj(i,i1,b,j) j
               L1iibj(i,i1,b,j) = Vpiqj(i,i1,b,j)

            endif
            ENDDO i
#
            DO a
#
               REQUEST T2old_ab(a,i1,b,j) j
#
               DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
                  tai(a,i)  = L1iibj(i,i1,b,j)*T2old_ab(a,i1,b,j)
                  tai(a,i) *= -1.0
#
                  PUT t1a_new(a,i) += tai(a,i)

               endif
               ENDDO i
#
            ENDDO a
#
            deallocate L1iibj(*,i1,b,j)

        endif
        endif 
      ENDPARDO b, j, i1
#
      ENDPROC T1ANEW 
#     --------------

#-----------------F12 contribution to T1 equation----------------------------      

      PROC T1_f12
#     -----------

      PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------


        tai(a,i) = 0.0
        
#---------V-ijka contribution------------------
        REQUEST T1_1(i,a) i
        t1_aux(a,i) = T1_1(i,a)         
        tai(a,i) += t1_aux(a,i)         

#------------Contribution of diagram 3.18------
        REQUEST T1_3(a,i) a
        t1_aux(a,i) = T1_3(a,i)
        tai(a,i) += t1_aux(a,i) 
        
#--------V-ijkl contribution-------------------
            DO j
#-----------------------------  
       xi2(j) = wOccA_frag(j)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
              GET t1a_old(a,j)
              REQUEST T1_2(i,j) i
              t1_aux(a,i) = t1a_old(a,j)*T1_2(i,j)
              tai(a,i) -= t1_aux(a,i) 
              endif 
            ENDDO j      
#---------------diagram d3.19------------------
            DO b
            REQUEST T1_3(a,b) a
            GET t1a_old(b,i) 
            t1_aux(a,i) = t1a_old(b,i)*T1_3(a,b)
            tai(a,i) += t1_aux(a,i)
            ENDDO b 

#---------------diagram d3.20-------------------

            DO j
#-----------------------------
       xi2(j) = wOccA_frag(j)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
            DO b
            REQUEST T1_4(a,i,b,j) a
            GET t1a_old(b,j)
            t1_aux(a,i) = T1_4(a,i,b,j)*t1a_old(b,j)
            tai(a,i) += t1_aux(a,i)
            ENDDO b
            endif
            ENDDO j

        PUT t1a_new(a,i) += tai(a,i)
        endif
      ENDPARDO a, i


      ENDPROC T1_f12
#     --------------

      PROC T2_f12
#     -----------

#------------------Diagram d4.1 from Noga JCP 1994---------------------
      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
       REQUEST T2_1(a,i,b,j) a
       T2aibj(a,i,b,j) = T2_1(a,i,b,j)     
       PREPARE T2new_ab(a,i,b,j) += T2aibj(a,i,b,j) 
       endif
       endif  
      ENDPARDO a,i,b,j

#------------------Diagram d4.2 from Noga JCP 1994---------------------
      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                T2aiai(a,i,b,j) = 0.0
         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
          REQUEST T2_2(j,k,i,a) j
          GET t1a_old(b,k)          
          T2aibj(a,i,b,j) = T2_2(j,k,i,a)*t1a_old(b,k)
          T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         endif
         ENDDO k

         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
          REQUEST T2_2(i,k,j,b) i
          GET t1a_old(a,k)
          T2aibj(a,i,b,j) = T2_2(i,k,j,b)*t1a_old(a,k)
          T2aiai(a,i,b,j) -= T2aibj(a,i,b,j) 
         endif
         ENDDO k 
      
       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
       endif
       endif
      ENDPARDO a,i,b,j

#------------------Diagram d4.3 and d4.4 from Noga JCP 1994------------

      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                T2aiai(a,i,b,j) = 0.0
         DO k
         DO l
#-----------------------------
       xi2(k)   = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two

       xi3(l) = wOccA_frag(l)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------
           REQUEST T2_3(i,k,j,l) i  
           REQUEST Tau_ab(a,k,b,l) a
           T2aibj(a,i,b,j) = T2_3(i,k,j,l)*Tau_ab(a,k,b,l)
           T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
         endif
         endif
         ENDDO l
         ENDDO k

       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
       endif
       endif
      ENDPARDO a,i,b,j

#------------------Diagram d4.5 from Noga JCP 1994---------------------

      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                T2aiai(a,i,b,j) = 0.0

         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
          REQUEST T2_4(i,k) i
          REQUEST T2old_ab(a,k,b,j) a
          T2aibj(a,i,b,j) = T2old_ab(a,k,b,j)*T2_4(i,k)         
          T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         endif
         ENDDO k

         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
          REQUEST T2_4(j,k) j
          REQUEST T2old_ab(a,i,b,k) a
          T2aibj(a,i,b,j) = T2old_ab(a,i,b,k)*T2_4(j,k)
          T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         endif
         ENDDO k

       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
       endif
       endif
      ENDPARDO a,i,b,j

#======================================================================
#-------------Terms with one doble-arrow line (i.e beyond RI)---------- 
#----------------------------------------------------------------------

#--------Intermediate for diagram d4.6 of Noga's JCP 1994----------------

      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
       REQUEST T2_5(a,i,b,j) a
       T2aibj(a,i,b,j) = T2_5(a,i,b,j)
       PREPARE T2new_ab(a,i,b,j) += T2aibj(a,i,b,j)
      endif
      endif 
      ENDPARDO a,i,b,j


#----------First term of Diagram d4.12 from Noga JCP 1994--------------

      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            T2aiai(a,i,b,j) = 0.0

         DO d
         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
           REQUEST T2old_ab(d,k,b,j) d
           REQUEST T1_4(a,i,d,k) a
           T2aibj(a,i,b,j) = T1_4(a,i,d,k)*T2old_ab(d,k,b,j)
           T2aiai(a,i,b,j) += T2aibj(a,i,b,j) 
         endif
         ENDDO k
         ENDDO d
         
         DO d
         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
           REQUEST T2old_ab(d,k,a,i) d
           REQUEST T1_4(b,j,d,k) b
           T2aibj(a,i,b,j) = T1_4(b,j,d,k)*T2old_ab(d,k,a,i)
           T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
         endif
         ENDDO k
         ENDDO d


       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
       endif
       endif
      ENDPARDO a,i,b,j

#------------------------diagram d4.8----------------------------------------

      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            T2aiai(a,i,b,j) = 0.0

#--------------------------------------------
        REQUEST T2_6(a,i,b,j) a
         T2aibj(a,i,b,j) = T2_6(a,i,b,j)       
         T2aiai(a,i,b,j) += T2aibj(a,i,b,j)

        REQUEST T2_7(a,i,b,j) a
         T2aibj(a,i,b,j) = T2_7(a,i,b,j)
         T2aiai(a,i,b,j) += T2aibj(a,i,b,j)

        REQUEST T2_6(b,j,a,i) b
         T2aibj(a,i,b,j) = T2_6(b,j,a,i)
         T2aiai(a,i,b,j) += T2aibj(a,i,b,j)

        REQUEST T2_7(b,j,a,i) a
         T2aibj(a,i,b,j) = T2_7(b,j,a,i)
         T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
#--------------------------------------------

       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
       endif
       endif
      ENDPARDO a,i,b,j

#------------------------diagram d4.9----------------------------------------
      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            T2aiai(a,i,b,j) = 0.0

      DO d
        REQUEST T2_10(i,a,d,b) i 
        REQUEST T2_10(j,b,d,a) j
        REQUEST T2_11(d,a,j,b) d
        REQUEST T2_11(d,b,i,a) d
        GET t1a_old(d,j)
        GET t1a_old(d,i)
        T2aibj(a,i,b,j) = T2_10(i,a,d,b)*t1a_old(d,j)
        T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
        T2aibj(a,i,b,j) = T2_10(j,b,d,a)*t1a_old(d,i)
        T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
        T2aibj(a,i,b,j) = T2_11(d,a,j,b)*t1a_old(d,i)
        T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
        T2aibj(a,i,b,j) = T2_11(d,b,i,a)*t1a_old(d,j)
        T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
      ENDDO d

       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
       endif
       endif
      ENDPARDO a,i,b,j


#------------------------diagram d4.10---------------------------------------

      PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            T2aiai(a,i,b,j) = 0.0

         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
           REQUEST T2_6(a,i,k,j) a
           REQUEST T2_7(k,j,a,i) k
           GET t1a_old(b,k)
           T2aibj(a,i,b,j) = T2_6(a,i,k,j)*t1a_old(b,k)
           T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
           T2aibj(a,i,b,j) = T2_7(k,j,a,i)*t1a_old(b,k)
           T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         endif 
         ENDDO k

         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
           REQUEST T2_6(b,j,k,i) b
           REQUEST T2_7(k,i,b,j) k
           GET t1a_old(a,k)
           T2aibj(a,i,b,j) = T2_6(b,j,k,i)*t1a_old(a,k)
           T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
           T2aibj(a,i,b,j) = T2_7(k,i,b,j)*t1a_old(a,k)
           T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         endif 
         ENDDO k

       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
       endif
       endif
      ENDPARDO a,i,b,j

#---------------and diagram d4.16----------------------------------------------

      PARDO a,i,b,j
#-------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            T2aiai(a,i,b,j) = 0.0

         DO d
         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
         REQUEST Tau_ab(b,k,d,j) b
         REQUEST T2_8(a,i,d,k) a
         REQUEST Tau_ab(b,k,d,i) b
         REQUEST T2_9(a,d,k,j) a
         T2aibj(a,i,b,j) = T2_8(a,i,d,k)*Tau_ab(b,k,d,j)
         T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         T2aibj(a,i,b,j) = T2_9(a,d,k,j)*Tau_ab(b,k,d,i)
         T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         endif
         ENDDO k
         ENDDO d

#---------------------------------

         DO d
         DO k
#-----------------------------
       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
         REQUEST Tau_ab(a,k,d,i) a  
         REQUEST T2_8(b,j,d,k) b
         REQUEST Tau_ab(a,k,d,j) a
         REQUEST T2_9(b,d,k,i) b
         twww1(a,i,d,k) = Tau_ab(a,k,d,i)
         T2aibj(a,i,b,j) = twww1(a,i,d,k)*T2_8(b,j,d,k)
         T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         T2aibj(a,i,b,j) = Tau_ab(a,k,d,j)*T2_9(b,d,k,i)
         T2aiai(a,i,b,j) -= T2aibj(a,i,b,j)
         endif
         ENDDO k
         ENDDO d


    
       PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)

       endif 
       endif
      ENDPARDO a,i,b,j


      execute server_barrier 

      ENDPROC T2_f12
#     --------------

      PROC LAMBDA_f12 
#     ---------------


#============================================================================
#----------Read precalculated Lambda - terms --------------------------------
                DO iii
                 DO kkk

                   IF iii == 1
                    IF kkk == 1
                    REQUEST ELAM(iii,kkk) iii
                    tELAM(iii,kkk) = ELAM(iii,kkk)
                    execute return_sval tELAM E_dir
                    ENDIF
                   ENDIF

                   IF iii == 1
                    IF kkk == 2
                    REQUEST ELAM(iii,kkk) iii
                    tELAM(iii,kkk) = ELAM(iii,kkk)
                    execute return_sval tELAM E_LAM
                    ENDIF
                   ENDIF

                   IF iii == 2
                    IF kkk == 1
                    REQUEST ELAM(iii,kkk) iii
                    tELAM(iii,kkk) = ELAM(iii,kkk)
                    execute return_sval tELAM E_qcorr
                    ENDIF
                   ENDIF

                 ENDDO kkk
                ENDDO iii
#----------------------------------------------------------------------------
#============================================================================

              PARDO i,j,k,l
              tccusp(i,j,k,l) = 0.0
              execute f12_c_coef tccusp F12GAMMA
              PREPARE C_coef(i,j,k,l) = tccusp(i,j,k,l)
              ENDPARDO i,j,k,l

              execute server_barrier

               PARDO i,j,k,l
                REQUEST C_coef(i,j,k,l) i
                REQUEST C_coef(i,l,k,j) i
                tccusp(i,j,k,l) = C_coef(i,j,k,l)
                tccusp(i,j,k,l) *= -2.0
                t1ccusp(i,j,k,l) = C_coef(i,l,k,j)
                tccusp(i,j,k,l)  += t1ccusp(i,j,k,l)
                PREPARE CC1(i,j,k,l) += tccusp(i,j,k,l)
               ENDPARDO i,j,k,l

               execute server_barrier

               PARDO i,j,k,l
                REQUEST C_coef(i,j,k,l) i
                REQUEST C_coef(i,l,k,j) i
                tccusp(i,j,k,l) = C_coef(i,j,k,l)
                tccusp(i,j,k,l) *= 2.0
                t1ccusp(i,j,k,l) = C_coef(i,l,k,j)
                t1ccusp(i,j,k,l) *= -1.0
                tccusp(i,j,k,l) += t1ccusp(i,j,k,l)
                PREPARE CC2(i,j,k,l) += tccusp(i,j,k,l)
               ENDPARDO i,j,k,l

               execute server_barrier


#---------------diagram 6.7 and 6.8 from Noga's JCP 1994-----------------|

        etmp = 0.0

        PARDO i,j,a,b
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
           REQUEST Tau_ab(a,i,b,j) a
           REQUEST T2_1(a,i,b,j) a
           REQUEST T2_1(a,j,b,i) a
           etmp1 = Tau_ab(a,i,b,j)*T2_1(a,i,b,j)
           etmp1 *= 2.0
           etmp2 = Tau_ab(a,i,b,j)*T2_1(a,j,b,i)
           etmp2 *= -1.0
           etmp3 += etmp1
           etmp3 += etmp2
        endif
        endif
        ENDPARDO i,j,a,b

        execute server_barrier


            collective etmp += etmp3

            E_LAM += etmp

#-----------------------diagram d6.9--------------------------------------
      etmp = 0.0
      etmp3 = 0.0

      PARDO i, a
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
        REQUEST T1_1(i,a) i
        GET t1a_old(a,i) 
        etmp1 = T1_1(i,a)*t1a_old(a,i)
        etmp1 *= 2.0
        etmp3 += etmp1
      endif
      ENDPARDO i,a
 
      execute server_barrier 

             collective etmp += etmp3

            E_LAM += etmp

#-----------------------diagram d6.22---------------------------------------      

      etmp = 0.0
      etmp3 = 0.0

        PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
          REQUEST T2_5(a,i,b,j) a 
          REQUEST T2old_ab(a,i,b,j) a
          REQUEST T2old_ab(a,j,b,i) a
           etmp1 = T2old_ab(a,i,b,j)*T2_5(a,i,b,j)
           etmp1 *= 2.0
           etmp2 = T2old_ab(a,j,b,i)*T2_5(a,i,b,j)
           etmp2 *= -1.0
           etmp3 += etmp1
           etmp3 += etmp2
        endif
        endif
        ENDPARDO a,i,b,j
      execute server_barrier

             collective etmp += etmp3

            E_LAM += etmp

#-----------------------diagram d6.24---------------------------------------
  
      etmp = 0.0
      etmp3 = 0.0

      PARDO i, a
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
        REQUEST LAM_1(i,a) i
        GET t1a_old(a,i)
        etmp1 = LAM_1(i,a)*t1a_old(a,i)
        etmp3 += etmp1
      endif 
      ENDPARDO i,a

      execute server_barrier

             collective etmp += etmp3

            E_LAM += etmp

     
#-------------------------- diagram d6.23 --------------------------------
#-------------------------- parts 1 and 2 --------------------------------


#-------------------------------------------------------------------------
#-----------------First term----------------------------------------------
#-------------------------------------------------------------------------

      etmp = 0.0
      etmp3 = 0.0

       PARDO i,a,k,b
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(k) = wOccA_frag(k)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
       REQUEST LAM_2(i,a,k,b) i
       REQUEST Tau_ab(a,i,b,k) a
       etmp1 = LAM_2(i,a,k,b)*Tau_ab(a,i,b,k)
       etmp3 += etmp1
       endif
       endif
       ENDPARDO i,a,k,b

       execute server_barrier

             collective etmp += etmp3

            E_LAM += etmp

#-------------------------------------------------------------------------
#-----------------Second term----------------------------------------------
#-------------------------------------------------------------------------

      etmp = 0.0
      etmp3 = 0.0

       PARDO i,a,k,b
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(k) = wOccA_frag(k)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
       REQUEST LAM_3(i,a,k,b) i
       REQUEST Tau_ab(a,i,b,k) a
       etmp1 = LAM_3(i,a,k,b)*Tau_ab(a,i,b,k)
       etmp3 += etmp1
       endif
       endif
       ENDPARDO i,a,k,b

       execute server_barrier

             collective etmp += etmp3

            E_LAM += etmp
#-------------------------------------------------------------------------
#-----------------Third term----------------------------------------------
#-------------------------------------------------------------------------


      etmp = 0.0
      etmp3 = 0.0

       PARDO i,a,k,b
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(k) = wOccA_frag(k)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

       REQUEST LAM_4(i,a,k,b) i
       REQUEST Tau_ab(a,i,b,k) a
       etmp1 = LAM_4(i,a,k,b)*Tau_ab(a,i,b,k)
       etmp3 += etmp1
       endif
       endif 
       ENDPARDO i,a,k,b

       execute server_barrier

             collective etmp += etmp3

            E_LAM += etmp
#-------------------------------------------------------------------------
#-----------------Forth term----------------------------------------------
#-------------------------------------------------------------------------

      etmp = 0.0
      etmp3 = 0.0

       PARDO i,a,k,b
#----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(k) = wOccA_frag(k)
       execute return_sval xi1 l2
       if l2 == two
#----------------------------
       REQUEST LAM_5(i,b,k,a) i
       REQUEST Tau_ab(a,i,b,k) a
       etmp1 = LAM_5(i,b,k,a)*Tau_ab(a,i,b,k)
       etmp3 += etmp1
       endif
       endif
       ENDPARDO i,a,k,b

       execute server_barrier

             collective etmp += etmp3

            E_LAM += etmp

#------------------------------------------------------------------------|
      E_LAM += E_qcorr 

      ENDPROC LAMBDA_F12
#     ---------------


      PROC T2_f12_extra_cp
#     --------------------

        execute server_barrier 

              PARDO i,j,k,l
              tccusp(i,j,k,l) = 0.0
              execute f12_c_coef tccusp F12GAMMA
              PREPARE C_coef(i,j,k,l) = tccusp(i,j,k,l)
              ENDPARDO i,j,k,l

              execute server_barrier
 
        PARDO a,i,p,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
         tauxint(a,i,p,j) = 0.0
         

        DO k
        DO l
#------------------------------
       xi2(k)   = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two

       xi3(l) = wOccA_frag(l)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------        
           REQUEST C_coef(i,l,j,k) i
           REQUEST V2piai(p,k,a,l) p
           tauxint1(a,i,p,j) = C_coef(i,l,j,k)*V2piai(p,k,a,l)
           tauxint(a,i,p,j) +=tauxint1(a,i,p,j)
        endif
        endif
        ENDDO l
        ENDDO k

         PREPARE auxint2(a,i,p,j) = tauxint(a,i,p,j)
        endif
        endif
        ENDPARDO a,i,p,j

        execute server_barrier



#-----------------------------------------------------------------------------
#---------Diagram 4.11 -------------------------------------------------------
        PARDO p,a
        tcpinterm(p,a) = 0.0 
        PREPARE cpinterm1(p,a) = tcpinterm(p,a) 
        PREPARE cpinterm2(p,a) = tcpinterm(p,a)
        ENDPARDO p,a
        execute server_barrier


        PARDO a,p,b,i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           REQUEST V0apai(a,p,b,i) a
           GET t1a_old(b,i)
           tcpinterm(p,a) = V0apai(a,p,b,i)*t1a_old(b,i)
           tcpinterm(p,a) *= -2.0
           PREPARE cpinterm1(p,a) += tcpinterm(p,a)     
        endif      
        ENDPARDO a,p,b,i

        execute server_barrier

        PARDO a,b,p,i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           REQUEST V0aapi(a,b,p,i) a
           GET t1a_old(b,i)
           tcpinterm(p,a) = V0aapi(a,b,p,i)*t1a_old(b,i)
           PREPARE cpinterm2(p,a) += tcpinterm(p,a)
        endif
        ENDPARDO a,b,p,i

        execute server_barrier

#---------Contribution to T2 amplitude -----------------------|

        PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
         T2aiai(a,i,b,j) = 0.0

          DO p 
       
            REQUEST auxint2(a,i,p,j) a
            REQUEST cpinterm1(p,b) p
            T2aibj(a,i,b,j) = auxint2(a,i,p,j)*cpinterm1(p,b)
            T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
         
            REQUEST auxint2(a,i,p,j) a
            REQUEST cpinterm2(p,b) p
            T2aibj(a,i,b,j) = auxint2(a,i,p,j)*cpinterm2(p,b)
            T2aiai(a,i,b,j) += T2aibj(a,i,b,j)

          ENDDO p

            T1aibj(b,j,a,i) = T2aiai(a,i,b,j)

         PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
         PREPARE T2new_ab(b,j,a,i) += T1aibj(b,j,a,i)
        endif
        endif
        ENDPARDO a,i,b,j


        execute server_barrier

#----------------------------------------------------------------------------
#----------------------------------------------------------------------------




#---------Diagram 4.14  and 4.17 ---------------------------------------------

        PARDO p,a
        tcpinterm(p,a) = 0.0
        PREPARE cpinterm1(p,a) = tcpinterm(p,a)
        PREPARE cpinterm4(p,a) = tcpinterm(p,a)
        ENDPARDO p,a
        execute server_barrier
#-------------------------------------------------|

        PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
          REQUEST Tau_ab(a,i,b,j) a
            DO p
          REQUEST Vpiqj(p,i,b,j) p
          tcpinterm(p,a) = 0.0
          tcpinterm(p,a) = Tau_ab(a,i,b,j)*Vpiqj(p,i,b,j)
          tcpinterm(p,a) *= 2.0
          PREPARE cpinterm1(p,a) += tcpinterm(p,a)
            ENDDO p
        endif
        endif
        ENDPARDO a,i,b,j
        
        execute server_barrier


        PARDO a,i,b,j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
          REQUEST Tau_ab(a,i,b,j) a
          DO p
          REQUEST Vpiqj(p,j,b,i) p
          tcpinterm(p,a) = 0.0
          tcpinterm(p,a) = Tau_ab(a,i,b,j)*Vpiqj(p,j,b,i)
          tcpinterm(p,a) *= -1.0
          PREPARE cpinterm4(p,a) += tcpinterm(p,a)
          ENDDO p
        endif
        endif
        ENDPARDO a,i,b,j


 
         execute server_barrier

#---------Contribution to T2 amplitude -----------------------|

        PARDO a,i,b,j

#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

         T2aiai(a,i,b,j) = 0.0
         t2test(a,i,b,j) = 0.0
 
          DO p

            REQUEST auxint2(a,i,p,j) a
            REQUEST cpinterm1(p,b) p
            T2aibj(a,i,b,j) = 0.0
            T2aibj(a,i,b,j) = auxint2(a,i,p,j)*cpinterm1(p,b)
            T2aiai(a,i,b,j) += T2aibj(a,i,b,j)

            REQUEST auxint2(a,i,p,j) a
            REQUEST cpinterm4(p,b) p
            T2aibj(a,i,b,j) = auxint2(a,i,p,j)*cpinterm4(p,b)
            T2aiai(a,i,b,j) += T2aibj(a,i,b,j)
            t2test(a,i,b,j) += T2aibj(a,i,b,j)
          ENDDO p

#            execute dump_amp t2test(a,i,b,j)

          REQUEST T2_aux1(a,i,b,j) a
          T2aiai(a,i,b,j) += T2_aux1(a,i,b,j)

          T1aibj(b,j,a,i) = T2aiai(a,i,b,j)


         
         PREPARE T2new_ab(a,i,b,j) += T2aiai(a,i,b,j)
         PREPARE T2new_ab(b,j,a,i) += T1aibj(b,j,a,i)

        endif
        endif
        ENDPARDO a,i,b,j

         execute server_barrier

     ENDPROC T2_f12_extra_cp
#   ------------------------


#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------


     PROC T2_f12_extra_3e
#    --------------------

#---------------Preparation of C-coefficients---------------------------------
              PARDO i,j,k,l
              tccusp(i,j,k,l) = 0.0
              execute f12_c_coef tccusp F12GAMMA
              PREPARE C_coef(i,j,k,l) = tccusp(i,j,k,l)
              ENDPARDO i,j,k,l

              execute server_barrier

               PARDO i,j,k,l
                REQUEST C_coef(i,j,k,l) i
                REQUEST C_coef(i,l,k,j) i
                tccusp(i,j,k,l) = C_coef(i,j,k,l)
                tccusp(i,j,k,l) *= 2.0
                t1ccusp(i,j,k,l) = C_coef(i,l,k,j)
                t1ccusp(i,j,k,l) *= -1.0
                tccusp(i,j,k,l) += t1ccusp(i,j,k,l)
                PREPARE CC2(i,j,k,l) = tccusp(i,j,k,l)
               ENDPARDO i,j,k,l

               execute server_barrier

               PARDO a,i,b,j
               t2test(a,i,b,j) = 0.0
               PREPARE T2_aux1(a,i,b,j) = t2test(a,i,b,j)  
               ENDPARDO a,i,b,j


#-----------Step 1 - definition of the number of grid points--------------------------
            Ng = 0.0
            cnt = 0.0
            execute get_grid_size Ng
#---------Loop over the grid points---------------------------------------------------
            DO grd
            cnt += 1.0
            
#--------Check if g is exceeded the number of grid points------
            IF cnt > Ng
            EXIT
            ENDIF
#----------Define to which worker belongs current point g--------------------------------
            execute grid_point_range cnt ind
#-----If g belongs to current worker - then do calculation-------------------------------           
                            IF ind == 1.0
#----------Get the weight of current point g---------------------------------------------
            execute grid_point_weight cnt PTW
#========================================================================================
#========================================================================================
#----Generation of values of molecular orbitals on the grid------------------------------

                              allocate MOVAL(*)

                               DO p
#-----------------------------Molecular orbitals---------------------------------------   
                                MOVAL(p) = 0.0
                                tmoval(p) = 0.0
                                execute F12_2center_moobj tmoval cnt
                                MOVAL(p) = tmoval(p)
                               ENDDO p
#=======================================================================================
#=======================================================================================
                              allocate MOOVER(*,*)

                               DO p
                                DO q
                                 tmoval(p) = MOVAL(p)
                                 tmoval1(q) =  MOVAL(q)
                                 tmoover(p,q) = tmoval(p)^tmoval1(q)
                                 tmoover(p,q) *= PTW
                                 MOOVER(p,q) = tmoover(p,q)
                                ENDDO q
                               ENDDO p
#=====================================================================================
#=====================================================================================
#     Generation of 3-center objects, which are necessary for the calculation        |
#                            of three-electron integrals                             |
#=====================================================================================

#-----------Allocate arrays for 3-center objects--------------------------------------
                               allocate inv_r12_ip(*,*)
                               allocate slater_ip(*,*)
#---------------Calculation of 1/r_{1g} integrals----------------------------------------
                       int1_type = 1.0
                       execute int1_setup cnt int1_type

                               DO mu
                                 allocate l3center_imu(mu,*)
                                DO nu
                                          tmp3center(mu,nu) = 0.0
                                          execute f12_1el_gen tmp3center(mu,nu)
                                   DO q
                                   tmp3center_imu(mu,q) = tmp3center(mu,nu)*ca(nu,q)
                                   l3center_imu(mu,q) += tmp3center_imu(mu,q)
                                   ENDDO q

                                ENDDO nu

                                   DO q
                                   DO p
                                   tmp3center_pi(p,q) = l3center_imu(mu,q)*ca(mu,p)
                                   inv_r12_ip(p,q) += tmp3center_pi(p,q)
                                   ENDDO p
                                   ENDDO q

                                   deallocate l3center_imu(mu,*)
                               ENDDO mu

#---------------Calculation of f_{1g} integrals-------------------------------------------
                       int1_type = 2.0
                       execute int1_setup cnt int1_type


                               DO mu
                                 allocate l3center_imu(mu,*)
                                DO nu
                                          tmp3center(mu,nu) = 0.0
                                          execute f12_1el_gen tmp3center(mu,nu)
                                   DO i
                                   tmp3center_imu(mu,i) = tmp3center(mu,nu)*ca(nu,i)
                                   l3center_imu(mu,i) += tmp3center_imu(mu,i)
                                   ENDDO i

                                ENDDO nu

                                   DO i
                                   DO p
                                   tmp3center_pi(p,i) = l3center_imu(mu,i)*ca(mu,p)
                                   slater_ip(p,i) += tmp3center_pi(p,i)
                                   ENDDO p
                                   ENDDO i

                                   deallocate l3center_imu(mu,*)
                               ENDDO mu
#========================================================================================

#----------------------Diagram d4.11-----------------------------------------------------
                      allocate CCC1(*,*,*)
                      allocate CCC2(*,*,*)
                      allocate CCC3(*,*,*)
                      allocate CCC(*,*,*)
                      allocate ZV1(*,*)
                      allocate ZV2(*,*)
                      allocate ZV3(*,*)
                      allocate moaux(*)
                      allocate moaux2(*)
                      allocate moaux3(*)
                      allocate GV2(*,*)
                      allocate ZVV1(*,*)
                      allocate ZVV2(*,*)
                      allocate ZVV3(*,*)
#-------------First set of intermediates--------------------------|
              DO i
               DO j
                DO k
                 DO l
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two

       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two

       xi3(l) = wOccA_frag(l)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------


                 REQUEST C_coef(i,j,k,l) i
                 tccc(i,j,k) = C_coef(i,j,k,l)*MOVAL(l)
                 tccc(i,j,k) *= PTW
                 CCC(i,j,k) += tccc(i,j,k)

                 REQUEST CC2(i,j,k,l) i
                 tmoover(i,j) = CC2(i,j,k,l)*MOOVER(k,l)
                 GV2(i,j) += tmoover(i,j)

                 endif
                 endif
                 endif
                 endif

                 ENDDO l
                ENDDO k
               ENDDO j
              ENDDO i


#------------Second set of intermediates--------------------------|
             DO i
              DO j
#------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
               DO a
                  tmoover(i,a) = GV2(i,j)*slater_ip(a,j)
                  ZVV1(i,a) += tmoover(i,a)
               ENDDO a
              endif
              endif 
              ENDDO j
             ENDDO i


              DO i
               DO k
                DO j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two

       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
                 DO a
                 tccc(i,k,j) = CCC(i,j,k)
                 tmoover(j,a) = slater_ip(a,j)
                 tccc1(i,k,a) = tccc(i,k,j)*tmoover(j,a)
                 CCC1(i,k,a) += tccc1(i,k,a)
                 ENDDO a

                endif
                endif
                endif
                ENDDO j
               ENDDO k
              ENDDO i
#-----------------------------------------------------|
             etmp = 0.0
              DO a
              DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------              
              GET t1a_old(a,i)
              etmp1 = t1a_old(a,i)*inv_r12_ip(i,a)
              etmp += etmp1
              endif
              ENDDO i
              ENDDO a
              
              DO a
              DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
              DO b
              GET t1a_old(b,i)
              tmoover(i,a) = t1a_old(b,i)*inv_r12_ip(b,a)
              ZV1(i,a) += tmoover(i,a)
              ENDDO b
              endif
              ENDDO i
              ENDDO a

              DO j
              DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
              DO b
              GET t1a_old(b,i)
              tmoover(j,i) = t1a_old(b,i)*inv_r12_ip(b,j)
              ZVV2(j,i) += tmoover(j,i)
              ENDDO b

              endif
              endif
              ENDDO i
              ENDDO j

              DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
              DO a
              tmoover(a,i) = ZV1(i,a)
              tmoaux(a) = tmoover(a,i)*MOVAL(i)
              moaux(a) += tmoaux(a)
              ENDDO a
              endif
              ENDDO i


#-------------Diagrams d4.14 and d4.17--------------------------------------------------|
              DO a
              DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
              DO b
              DO j
#-----------------------------
       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
                REQUEST Tau_ab(a,i,b,j) a
                tmoover(i,a) = Tau_ab(a,i,b,j)*inv_r12_ip(b,j)
                ZV2(i,a) += tmoover(i,a)
                tmoover(j,a) = Tau_ab(a,i,b,j)*inv_r12_ip(b,i)
                ZV3(j,a) += tmoover(j,a)   
              endif        
              ENDDO j
              ENDDO b
              endif
              ENDDO i
              ENDDO a
#-------------------------------------------------------|
              DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
              DO a
              tmoover(a,i) = ZV2(i,a)
              tmoaux(a) = tmoover(a,i)*MOVAL(i)
              moaux2(a) += tmoaux(a)
              ENDDO a
              endif
              ENDDO i

              DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
              DO a
              tmoover(a,i) = ZV3(i,a)
              tmoaux(a) = tmoover(a,i)*MOVAL(i)
              moaux3(a) += tmoaux(a)
              ENDDO a 
              endif
              ENDDO i

              DO i
              DO j
              DO k
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two

       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two

#-----------------------------
              DO a
              tccc1(i,j,a) = CCC1(i,k,a)*ZVV2(k,j)
              CCC2(i,j,a) += tccc1(i,j,a)
              ENDDO a

              endif
              endif
              endif
              ENDDO k
              ENDDO j
              ENDDO i

              DO i
              DO j
              DO k
#-----------------------------

       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two

       xi2(k) = wOccA_frag(k)
       execute return_sval xi2 l3
       if l3 == two

#-----------------------------
              DO a
              tccc1(i,j,a) = CCC1(k,j,a)*ZVV2(k,i)
              CCC3(i,j,a) += tccc1(i,j,a)
              ENDDO a

              endif
              endif
              endif
              ENDDO k
              ENDDO j
              ENDDO i

 
#---------------Diagrams contribution-----------------------------|
              DO a
              DO i
              DO b
              DO j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

              Tbjbj(a,i,b,j) = 0.0
              T1aibj(b,j,a,i) = 0.0 

#--------------Diagram d4.9------------------------------|
              T2aiai(a,i,b,j) = ZVV1(i,a)^ZV1(j,b)
              Tbjbj(a,i,b,j) += T2aiai(a,i,b,j)

              T2aiai(a,i,b,j) = CCC2(i,j,a)^MOVAL(b)
              T2aiai(a,i,b,j) *= -1.0
              Tbjbj(a,i,b,j) += T2aiai(a,i,b,j)

              T2aiai(a,i,b,j) = CCC3(i,j,a)^MOVAL(b)
              T2aiai(a,i,b,j) *= -1.0
              Tbjbj(a,i,b,j) += T2aiai(a,i,b,j)
#-------------Diagram d4.11-------------------------------|

              T2aiai(a,i,b,j) = CCC1(i,j,a)^MOVAL(b)
              T2aiai(a,i,b,j) *= etmp
              T2aiai(a,i,b,j) *= 2.0
              Tbjbj(a,i,b,j) += T2aiai(a,i,b,j)

              T2aiai(a,i,b,j) = CCC1(i,j,a)^moaux(b)
              T2aiai(a,i,b,j) *= -1.0
              Tbjbj(a,i,b,j) += T2aiai(a,i,b,j)
#-------------Diagrams d4.14 and d4.17--------------------|

              T2aiai(a,i,b,j) = CCC1(i,j,a)^moaux2(b)
              T2aiai(a,i,b,j) *= -2.0
              Tbjbj(a,i,b,j) += T2aiai(a,i,b,j)

              T2aiai(a,i,b,j) = CCC1(i,j,a)^moaux3(b)
              Tbjbj(a,i,b,j) += T2aiai(a,i,b,j)
                            
#--------------------------------------------------------|
              T1aibj(b,j,a,i) = Tbjbj(a,i,b,j)


              PREPARE T2_aux1(a,i,b,j) += Tbjbj(a,i,b,j)

              endif
              endif
              ENDDO j
              ENDDO b
              ENDDO i
              ENDDO a
#-------------------------------------------------------|


#----------------------------------------------------------------------------------------
                      deallocate ZVV3(*,*)
                      deallocate ZVV2(*,*) 
                      deallocate ZVV1(*,*) 
                      deallocate GV2(*,*)
                      deallocate moaux3(*)
                      deallocate moaux2(*) 
                      deallocate moaux(*)
                      deallocate ZV3(*,*)
                      deallocate ZV2(*,*)
                      deallocate ZV1(*,*)
                      deallocate CCC3(*,*,*) 
                      deallocate CCC2(*,*,*)
                      deallocate CCC1(*,*,*)
                      deallocate CCC(*,*,*)

#========================================================================================
                              deallocate inv_r12_ip(*,*)
                              deallocate slater_ip(*,*)
                              deallocate MOOVER(*,*)
                              deallocate MOVAL(*)
#----------------------------------------------------------------------------------------
                            ENDIF
            ENDDO grd



     ENDPROC T2_f12_extra_3e
#    -----------------------

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------





# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
      PROC WminjAB
#     ------------
#
      create Wminj_ab
      execute sip_barrier
      PARDO i, i1, j, j1
#---------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two

       xi2(j1) = wOccA_frag(j1)
       execute return_sval xi2 l3
       if l3 == two

       xi3(j) = wOccA_frag(j)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------


            REQUEST                    Vpiqj(i1,i,j1,j) j
            Tiijj(i1,i,j1,j)         = Vpiqj(i1,i,j1,j)
            PUT Wminj_ab(i1,i,j1,j) += Tiijj(i1,i,j1,j)
#
      endif
      endif
      endif
      endif   
      ENDPARDO i, i1, j, j1
#
      PARDO i,i1,b,j1
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two

       xi2(j1) = wOccA_frag(j1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------


         REQUEST Vpiqj(i,i1,b,j1) j1

         DO j
#-----------------------------
       xi3(j) = wOccA_frag(j)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------


            GET                        t1a_old(b,j)
            Tiijj(i1,i,j1,j)         = Vpiqj(i,i1,b,j1)*t1a_old(b,j)
            T1iijj(j1,j,i1,i)        = Tiijj(i1,i,j1,j)  
            PUT Wminj_ab(i1,i,j1,j) += Tiijj(i1,i,j1,j)
            PUT Wminj_ab(j1,j,i1,i) += T1iijj(j1,j,i1,i)
#
         endif
         ENDDO j

      endif 
      endif
      endif
      ENDPARDO i,i1,b,j1
#
      PARDO i1, j1, a, b
#-----------------------------
       xi(i1)   = wOccA_frag(i1)
       execute return_sval xi l1
       if l1 == two

       xi1(j1) = wOccA_frag(j1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

         REQUEST Vpiqj(a,i1,b,j1) j1
#
         DO j
         DO i
#-----------------------------
       xi2(i)   = wOccA_frag(i)
       execute return_sval xi2 l3
       if l3 == two

       xi3(j) = wOccA_frag(j)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------


            REQUEST                    Tau_ab(a,i,b,j)  j
            Tiijj(i1,i,j1,j)         = Tau_ab(a,i,b,j)*Vpiqj(a,i1,b,j1)
            Tiijj(i1,i,j1,j)        *= 0.5
            PUT Wminj_ab(i1,i,j1,j) += Tiijj(i1,i,j1,j)

         endif 
         endif
         ENDDO i
         ENDDO j
#
        endif
        endif
      ENDPARDO i1, j1, a, b
      execute sip_barrier
#
      PARDO i1, j1, a, b
#-----------------------------
       xi(i1)   = wOccA_frag(i1)
       execute return_sval xi l1
       if l1 == two

       xi1(j1) = wOccA_frag(j1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
            REQUEST Tau_ab(a,i1,b,j1) j1
#
            DO i
            DO j
#-------------------------------
       xi2(i)   = wOccA_frag(i)
       execute return_sval xi2 l3
       if l3 == two

       xi3(j) = wOccA_frag(j)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------

               GET                          Wminj_ab(i1,i,j1,j)
               T1aibj(a,i,b,j)            = Tau_ab(a,i1,b,j1)*Wminj_ab(i1,i,j1,j)
               PREPARE T2new_ab(a,i,b,j) += T1aibj(a,i,b,j)

            endif
            endif 
            ENDDO j
            ENDDO i

        endif
        endif
      ENDPARDO i1, j1, a, b
      execute sip_barrier
      delete Wminj_ab
#
      ENDPROC WminjAB
#     --------------- 
# 
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMINJ 
#
           CALL WminjAB 
#
      ENDPROC WMINJ 
# 
# ----------------------------------------------------------------------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# In PROCEDURE T2NEWAB the new amplitudes T2new_ab are computed. Contributions 
# involving large two-particle intermediates are computed in the corresponding  
# procedures where these intermediates(temp) are computed. Thus the 
# intermediate Wminj is stored and its contribution computed here.  
#
# Contributions coming from P_(ij)P_(ab)t^e_i t^a_m <mb||ej> are computed 
# elsewhere. 
#
      PROC T2NEWAB    
#     ------------
#
      PARDO i, b, j 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------



            allocate Liibj(*,i,b,j) 
            allocate L1aibj(*,i,b,j)   
#
            DO i1 
#-----------------------------
       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

               REQUEST           Vpiqj(i1,i,b,j) j 
               Liibj(i1,i,b,j) = Vpiqj(i1,i,b,j) 

            endif
            ENDDO i1 
#
            DO a1 
#
               REQUEST            T2old_ab(a1,i,b,j) j 
               L1aibj(a1,i,b,j) = T2old_ab(a1,i,b,j) 
#
            ENDDO a1 
#
            DO a 
#
               REQUEST          Vpiqj(a,i,b,j) j 
               Taibj(a,i,b,j) = Vpiqj(a,i,b,j)   
               Taibj(a,i,b,j)*= 0.5  
#
               DO i1 
#-----------------------------
       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
                  GET t1a_old(a,i1) 
#
                  T1aibj(a,i,b,j) = Liibj(i1,i,b,j)*t1a_old(a,i1) 
                  Taibj(a,i,b,j) -= T1aibj(a,i,b,j) 

               endif
               ENDDO i1 
#
               DO a1 
#
                  GET Fae_a(a,a1) 
                  tmp_aa(a,a1) = Fae_a(a,a1)    
#
                  DO i1 
#-----------------------------
       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
                     GET t1a_old(a,i1) 
                     GET Fme_a(i1,a1) 
                     tmp1_aa(a,a1)  = t1a_old(a,i1)*Fme_a(i1,a1) 
                     tmp1_aa(a,a1) *= 0.5 
                     tmp_aa(a,a1)  -= tmp1_aa(a,a1)  

                  endif
                  ENDDO i1 
#
                  T1aibj(a,i,b,j) = L1aibj(a1,i,b,j)*tmp_aa(a,a1)  
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j) 
#
               ENDDO a1 
#
               T1aibj(b,j,a,i)            = Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(a,i,b,j) += Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(b,j,a,i) += T1aibj(b,j,a,i)  
#
            ENDDO a 
#
            deallocate Liibj(*,i,b,j) 
            deallocate L1aibj(*,i,b,j)   
#
        endif
        endif
      ENDPARDO i, b, j 
#
      PARDO a, b, j 
#-----------------------------
       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
            allocate L3aibj(a,*,b,j) 
            allocate Laabj(a,*,b,j) 
#
            DO i1 
#-----------------------------
       xi(i1)   = wOccA_frag(i1)
       execute return_sval xi l1
       if l1 == two
#-----------------------------


               REQUEST T2old_ab(a,i1,b,j) j 
               L3aibj(a,i1,b,j) = T2old_ab(a,i1,b,j) 

            endif 
            ENDDO i1 
#
            DO a1 
#
               REQUEST Vaaai(a,a1,b,j) j  
               Laabj(a,a1,b,j) = Vaaai(a,a1,b,j)  
#
            ENDDO a1 
#
            DO i 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
#

#
               Taibj(a,i,b,j) = 0.0  
#
               DO i1 
#-----------------------------
       xi2(i1)   = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

                  GET Fmi_a(i1,i) 
                  tmp_ii(i1,i) = Fmi_a(i1,i) 
#
                  DO a1 
#
                     GET t1a_old(a1,i) 
                     GET Fme_a(i1,a1) 
#
                     tmp1_ii(i1,i)  = t1a_old(a1,i)*Fme_a(i1,a1) 
                     tmp1_ii(i1,i) *= 0.5 
                     tmp_ii(i1,i)  += tmp1_ii(i1,i) 
#
                  ENDDO a1  
#
                  T1aibj(a,i,b,j) = L3aibj(a,i1,b,j)*tmp_ii(i1,i) 
                  Taibj(a,i,b,j) -= T1aibj(a,i,b,j) 

               endif
               ENDDO i1 
#
               DO a1 
#
                  GET t1a_old(a1,i) 
#
                  T1aibj(a,i,b,j) = Laabj(a,a1,b,j)*t1a_old(a1,i)  
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j) 
#
               ENDDO a1 
#
               T1aibj(b,j,a,i)            = Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(a,i,b,j) += Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(b,j,a,i) += T1aibj(b,j,a,i)  
          
            endif 
            ENDDO i 
#
            deallocate L3aibj(a,*,b,j) 
            deallocate Laabj(a,*,b,j) 
        
        endif
      ENDPARDO a, b, j 
#
      ENDPROC T2NEWAB    
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
#    ------------------------------------------------------------------------ 
#
     PROC AOLADDER  
#
#    ------------------------------------------------------------------------ 
#
#    First create and zero-out intermediate arrays
#    ---------------------------------------------
#
     PARDO mu, nu, i, j
           Txixj(mu,i,nu,j)           = 0.0
           PREPARE TAO_ab(mu,i,nu,j)  = Txixj(mu,i,nu,j)
           PREPARE T2AO_ab(mu,i,nu,j) = Txixj(mu,i,nu,j)
     ENDPARDO mu, nu, i, j
#
     execute server_barrier 
#
#    Form Half back transformed cluster arrays  
#    -----------------------------------------
#
#    AB spin combination
#     -------------------
#
     PARDO b, a, j, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
           REQUEST Tau_ab(a,i,b,j) a
#
           DO mu
#
              Taixj(a,i,mu,j) = Tau_ab(a,i,b,j)*ca(mu,b)
#
              DO nu
#
                 Txixj(nu,i,mu,j)           = Taixj(a,i,mu,j)*ca(nu,a)
                 PREPARE TAO_ab(nu,i,mu,j) += Txixj(nu,i,mu,j)
#
              ENDDO nu
#
           ENDDO mu
#
        endif
        endif 
      ENDPARDO b, a, j, i
#
     create t1a_ax 
     execute server_barrier   
#
#    Contract AOINT with half back transformed Amplitudes 
#    ----------------------------------------------------    
#
     PARDO mu, nu, lambda, sigma
        WHERE mu < nu 
#
           compute_integrals aoint(lambda,mu,sigma,nu)
#
           DO i
           DO j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(lambda,mu,sigma,nu)*TAO_ab(lambda,i,sigma,j)
              Y1ab(nu,j,mu,i)             = Yab(mu,i,nu,j)
#
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)
              PREPARE T2AO_ab(nu,j,mu,i) += Y1ab(nu,j,mu,i)

           endif
           endif
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     PARDO mu, nu, lambda, sigma
        WHERE mu == nu 
#
           compute_integrals aoint(mu,lambda,nu,sigma)
#
           DO i
           DO j
#------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(mu,lambda,nu,sigma)*TAO_ab(lambda,i,sigma,j)
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)


           endif
           endif 
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
#    Half transform the t1 arrays. 
#    ----------------------------- 
#
     PARDO a, mu
#
           tpx(a,mu) = 0.0 
#
           DO i  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
              GET          t1a_old(a,i) 
              t1px(a,mu) = t1a_old(a,i)*ca(mu,i) 
              tpx(a,mu) += t1px(a,mu) 

           endif
           ENDDO i  
#
           PUT t1a_ax(a,mu) = tpx(a,mu) 
#
     ENDPARDO a, mu
#
     execute server_barrier  
     execute sip_barrier  
#
#    Perform final transformation
#    ----------------------------
#
        PARDO nu, i, j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
              allocate LDaixj(*,i,nu,j)
#
              DO mu
#
                 REQUEST T2AO_ab(mu,i,nu,j) j
#
                 DO a
                    Taixj(a,i,nu,j)   = T2AO_ab(mu,i,nu,j)*ca(mu,a)
                    LDaixj(a,i,nu,j) += Taixj(a,i,nu,j)
                 ENDDO a
#
              ENDDO mu
#
              DO a
                 PREPARE TDaixj(a,i,nu,j) = LDaixj(a,i,nu,j)
              ENDDO a
#
              deallocate LDaixj(*,i,nu,j)
#
          endif
          endif
        ENDPARDO nu, i, j
        execute server_barrier
#
        PARDO a, i, j, nu
#----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
              REQUEST TDaixj(a,i,nu,j) a
#
              DO b
#
                 GET                          t1a_ax(b,nu)
#
                 Taibj(a,i,b,j)             = TDaixj(a,i,nu,j)*ca(nu,b)
                 T1aibj(a,i,b,j)            = TDaixj(a,i,nu,j)*t1a_ax(b,nu)
                 T1aibj(a,i,b,j)           *= -1.0
                 T2aibj(b,j,a,i)            = T1aibj(a,i,b,j)
#
                 PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
                 PREPARE T2new_ab(a,i,b,j) += T1aibj(a,i,b,j)
                 PREPARE T2new_ab(b,j,a,i) += T2aibj(b,j,a,i)
#
              ENDDO b

          endif
          endif
        ENDPARDO a, i, j, nu
#
        execute sip_barrier
#
     execute sip_barrier  
     delete t1a_ax 
#
#    ------------------------------------------------------------------------ 
#
     ENDPROC AOLADDER  
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
# --------------------------------------------------------------------------- 
#
      PROC WAEBFAB 
#     ------------ 
#
# --------------------------------------------------------------------- 
# Comute contribution coming from:  
# 1/2 tau^{ab}_{mn} * [ 1/4 tau^{ef}_{ij} * (V^{mn}_{ef} - V^{mn}_{fe}]  
# --------------------------------------------------------------------- 
#
      create Wminj_ab 
      execute sip_barrier 
      PARDO i, j, a, b  
#------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------



            REQUEST Tau_ab(a,i,b,j)  j  
#
            DO i1   
            DO j1  
#-----------------------------
       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two

       xi3(j1) = wOccA_frag(j1)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------
               REQUEST                    Vpiqj(a,i1,b,j1) j1  
               Tiijj(i1,i,j1,j)         = Vpiqj(a,i1,b,j1)*Tau_ab(a,i,b,j) 
               PUT Wminj_ab(i1,i,j1,j) += Tiijj(i1,i,j1,j) 
#
            endif
            endif
            ENDDO j1  
            ENDDO i1   
#
        endif
        endif
      ENDPARDO i, j, a, b 
      execute sip_barrier 
#
      PARDO a, b, i1, j1  
#-------------------------------
       xi(i1)   = wOccA_frag(i1)
       execute return_sval xi l1
       if l1 == two

       xi1(j1) = wOccA_frag(j1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
            REQUEST Tau_ab(a,i1,b,j1) j1  
#
            DO i   
            DO j 
#-----------------------------
       xi2(i) = wOccA_frag(i)
       execute return_sval xi2 l3
       if l3 == two

       xi3(j) = wOccA_frag(j)
       execute return_sval xi3 l4
       if l4 == two
#-----------------------------
 
#
               GET                          Wminj_ab(i1,i,j1,j) 
               Taibj(a,i,b,j)             = Tau_ab(a,i1,b,j1)*Wminj_ab(i1,i,j1,j) 
               Taibj(a,i,b,j)            *= 0.5  
               PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j) 
#
            endif
            endif
            ENDDO j  
            ENDDO i  
#
        endif
        endif   
      ENDPARDO a, b, i1, j1  
      execute sip_barrier 
      delete Wminj_ab 
#
      ENDPROC WAEBFAB 
#     --------------- 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
#
      PROC WAEBF 
# 
           CALL WAEBFAB 
#
      ENDPROC WAEBF 
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
# In the procedures WMEBJAA, WMEBJBB, WMEBJAB, and WMEBJBA these  
# intermediates are formed as temporary arrarys. The contribution to the 
# outout arrays is computed directly from these temporary arrays so 
# that the array is never stored.   
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMEBJAA 
#     ------------
#
      PARDO a, a1, i, i1  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
               REQUEST              Viaai(i1,a1,a,i) i  
               REQUEST              Vaaii(a,a1,i1,i) i  
               REQUEST              e5aiai(a1,i1,a,i) i 
#
               TYaiai(a1,i1,a,i) = 0.0 
#
               DO i2
#-----------------------------
       xi2(i2) = wOccA_frag(i2)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

                  REQUEST              VSpipi(a1,i1,i,i2) i2
                  GET                  t1a_old(a,i2)
#
                  T1aiai(a1,i1,a,i)  = VSpipi(a1,i1,i,i2)*t1a_old(a,i2)
                  TYaiai(a1,i1,a,i) -= T1aiai(a1,i1,a,i)
               
               endif
               ENDDO i2

               Taiai(a1,i1,a,i)           = Vaaii(a,a1,i1,i)
               TYaiai(a1,i1,a,i)         -= Taiai(a1,i1,a,i)
               Taiai(a1,i1,a,i)           = Viaai(i1,a1,a,i)
               TYaiai(a1,i1,a,i)         += Taiai(a1,i1,a,i)
               TYaiai(a1,i1,a,i)         += e5aiai(a1,i1,a,i)
               PREPARE TAUP_aa(a1,i1,a,i) = TYaiai(a1,i1,a,i) 
#
        endif
        endif 
      ENDPARDO a, a1, i, i1  
      execute server_barrier 
#
      PARDO a, i, a2, i2
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i2) = wOccA_frag(i2)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
         REQUEST              T2old_aa(a2,i,a,i2) i2  
         GET                  t1a_old(a2,i) 
         GET                  t1a_old(a,i2) 
 
         tai(a,i2)          = t1a_old(a,i2) 
         T1aiai(a2,i2,a,i)  = t1a_old(a2,i)^tai(a,i2) 
         T2aiai(a2,i2,a,i)  = t2old_aa(a2,i,a,i2) 
         T2aiai(a2,i2,a,i) *= 0.5 
         T2aiai(a2,i2,a,i) += T1aiai(a2,i2,a,i) 

         DO i1
#-----------------------------
       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
         DO a1 
#
            REQUEST                       VSpipi(a1,i1,a2,i2) i2  
            T3aiai(a1,i1,a,i)           = VSpipi(a1,i1,a2,i2)*T2aiai(a2,i2,a,i) 
            T3aiai(a1,i1,a,i)          *= -1.0  
            PREPARE TAUP_aa(a1,i1,a,i) += T3aiai(a1,i1,a,i)
#
         ENDDO a1
         endif  
         ENDDO i1
#
        endif
        endif 
      ENDPARDO a, i, a2, i2 

      PARDO a, i, b, j 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
         REQUEST T2old_ab(a,i,b,j) j 
#
         DO i1
#-----------------------------
       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

         DO a1 
#
            REQUEST                       Vpiqj(a1,i1,b,j) j 
            T1aiai(a1,i1,a,i)           = Vpiqj(a1,i1,b,j)*T2old_ab(a,i,b,j)
            T1aiai(a1,i1,a,i)          *= 0.5
            PREPARE TAUP_aa(a1,i1,a,i) += T1aiai(a1,i1,a,i)
#
         ENDDO a1
         endif
         ENDDO i1
#
        endif
        endif
      ENDPARDO a, i, b, j
      execute server_barrier
#
# Contributions to T2new_ab 
# ------------------------- 
#
      PARDO a, i, a1, i1 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            REQUEST TAUP_aa(a1,i1,a,i)  i 
#
            DO j 
#-----------------------------
       xi2(j) = wOccA_frag(j)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
 
            DO b
#
               REQUEST                      T2old_ab(a1,i1,b,j) j  
               R1aibj(a,i,b,j)            = TAUP_aa(a1,i1,a,i)*T2old_ab(a1,i1,b,j) 
               Taibj(b,j,a,i)             = R1aibj(a,i,b,j) 
               PREPARE T2new_ab(a,i,b,j) += R1aibj(a,i,b,j)
               PREPARE T2new_ab(b,j,a,i) += Taibj(b,j,a,i)
#
            ENDDO b  
            endif
            ENDDO j  
#
        endif
        endif 
      ENDPARDO a, i, a1, i1 
#
      ENDPROC WMEBJAA 
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMEBJAB 
#     ------------
#
      PARDO j, b, i, a
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------



#
               REQUEST           Viaai(i,a,b,j) j  
               REQUEST           e5aibj(a,i,b,j) a 
#
               Taibj(a,i,b,j) = 0.
#
               DO j1
#-----------------------------
       xi2(j1) = wOccA_frag(j1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------

#
                  REQUEST           Vpiqj(a,i,j,j1) j1  
                  GET               t1a_old(b,j1) 
                  T1aibj(a,i,b,j) = Vpiqj(a,i,j,j1)*t1a_old(b,j1) 
                  Taibj(a,i,b,j) -= T1aibj(a,i,b,j) 
#
               endif 
               ENDDO j1

               T1aibj(a,i,b,j)          = Viaai(i,a,b,j) 
               Taibj(a,i,b,j)          += T1aibj(a,i,b,j)
               Taibj(a,i,b,j)          += e5aibj(a,i,b,j) 
               PREPARE TAUP_ab(a,i,b,j) = Taibj(a,i,b,j) 
#
        endif
        endif
      ENDPARDO j, b, i, a
      execute server_barrier

      PARDO j, b, j1, b1
#------------------------------
       xi(j)   = wOccA_frag(j)
       execute return_sval xi l1
       if l1 == two

       xi1(j1) = wOccA_frag(j1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
               REQUEST              T2old_aa(b1,j,b,j1) j1 
               GET                  t1a_old(b1,j) 
               GET                  t1a_old(b,j1) 
# 
               tbj(b,j1)          = t1a_old(b,j1) 
               T2bjbj(b1,j,b,j1)  = t1a_old(b1,j)^tbj(b,j1) 
               T1bjbj(b1,j,b,j1)  = 0.5*T2old_aa(b1,j,b,j1) 
               T1bjbj(b1,j,b,j1) += T2bjbj(b1,j,b,j1) 
#
               DO i 
#-----------------------------
       xi2(i) = wOccA_frag(i)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
 
               DO a 
#
                  REQUEST                     Vpiqj(a,i,b1,j1) j1  
                  Taibj(a,i,b,j)            = T1bjbj(b1,j,b,j1)*Vpiqj(a,i,b1,j1) 
                  Taibj(a,i,b,j)           *= -1.0  
                  PREPARE TAUP_ab(a,i,b,j) += Taibj(a,i,b,j)
#   
               ENDDO a 
               endif
               ENDDO i  
#
        endif
        endif 
      ENDPARDO j, b, j1, b1
#
      PARDO b, j, a1, i1
#-----------------------------
       xi(j)   = wOccA_frag(j)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
            REQUEST T2old_ab(a1,i1,b,j) j      
#
            DO a
            DO i
#-----------------------------
       xi2(i) = wOccA_frag(i)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
#
               REQUEST                     VSpipi(a1,i1,a,i) i
               T1aibj(a,i,b,j)           = T2old_ab(a1,i1,b,j)*VSpipi(a1,i1,a,i)
               T1aibj(a,i,b,j)          *= 0.5
               PREPARE TAUP_ab(a,i,b,j) += T1aibj(a,i,b,j)

            endif
            ENDDO i
            ENDDO a
#
        endif
        endif
      ENDPARDO b, j, a1, i1

      execute server_barrier 
#
# Contribution to T2new_ab 
# ------------------------ 
#
      PARDO i1, a1, a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
            REQUEST T2old_aa(a1,i1,a,i) i 
#
            DO j 
#-----------------------------
       xi2(j) = wOccA_frag(j)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
            DO b 
#
               REQUEST                        TAUP_ab(a,i,b,j) j  
               R1aibj(a1,i1,b,j)            = T2old_aa(a1,i1,a,i)*TAUP_ab(a,i,b,j)  
               Taibj(b,j,a1,i1)             = R1aibj(a1,i1,b,j) 
               PREPARE T2new_ab(a1,i1,b,j) += R1aibj(a1,i1,b,j) 
               PREPARE T2new_ab(b,j,a1,i1) += Taibj(b,j,a1,i1) 
#
            ENDDO b 
            endif
            ENDDO j 
#
        endif
        endif
      ENDPARDO i1, a1, a, i
      execute server_barrier 
#
      ENDPROC WMEBJAB 
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# -------------------------------------------------------------------------------  
#
      PROC T2ABS2 
#     ----------- 
#
      PARDO i, j, i1, b  

#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two

       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------


#
           Tiibj(i1,i,b,j) = 0.0 
#
           DO a1 
# 
              REQUEST            Viaai(i1,a1,b,j) j  
              GET                t1a_old(a1,i) 
#
              T1iibj(i1,i,b,j) = Viaai(i1,a1,b,j)*t1a_old(a1,i) 
              Tiibj(i1,i,b,j) += T1iibj(i1,i,b,j) 
#
           ENDDO a1  
#
           DO b1 
#
              REQUEST            Vaaii(b,b1,i1,i) i  
              GET                t1a_old(b1,j) 
#
              T1iibj(i1,i,b,j) = Vaaii(b,b1,i1,i)*t1a_old(b1,j)  
              Tiibj(i1,i,b,j) += T1iibj(i1,i,b,j) 
#
          ENDDO b1  
#
          DO a 
#
             GET                          t1a_old(a,i1) 
             Taibj(a,i,b,j)             = Tiibj(i1,i,b,j)*t1a_old(a,i1) 
             Taibj(a,i,b,j)            *= -1.0 
             PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j) 
#
          ENDDO a 
#

        endif
        endif
        endif  
      ENDPARDO i, j, i1, b  
#
      PARDO i, j, j1, a 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two

       xi2(j1) = wOccA_frag(j1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
#
            Tjjai(j1,j,a,i) = 0.0 
#
            DO a1 
#
               REQUEST            Vaaii(a,a1,j1,j) j  
               GET                t1a_old(a1,i) 
#
               T1jjai(j1,j,a,i) = Vaaii(a,a1,j1,j)*t1a_old(a1,i) 
               Tjjai(j1,j,a,i) += T1jjai(j1,j,a,i)
#
            ENDDO a1 
#
            DO b1 
# 
               REQUEST            Viaai(i,a,b1,j1) j1  
               GET                t1a_old(b1,j) 
#
               T1jjai(j1,j,a,i) = Viaai(i,a,b1,j1)*t1a_old(b1,j) 
               Tjjai(j1,j,a,i) += T1jjai(j1,j,a,i) 
#
            ENDDO b1  
#
            DO b 
#
               GET                          t1a_old(b,j1) 
               Taibj(a,i,b,j)             = Tjjai(j1,j,a,i)*t1a_old(b,j1) 
               Taibj(a,i,b,j)            *= -1.0 
               PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j) 
#
            ENDDO b 
#
        endif
        endif
        endif
      ENDPARDO i, j, j1, a  
#
      ENDPROC T2ABS2 
#     -------------- 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# Compute contributions from 'Wmjbe'. 
#
      PROC WMJBEab
#     -------------
#
      PARDO b, i, b1, i1
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            REQUEST            Vaaii(b,b1,i1,i) i
            Tiiqq(i1,i,b,b1) = Vaaii(b,b1,i1,i)
#
            DO j1
#-----------------------------
       xi2(j1) = wOccA_frag(j1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------


               REQUEST             Vpiqj(i,i1,b1,j1) j1
               GET                 t1a_old(b,j1)
#
               tbj(b,j1)         = t1a_old(b,j1)
               T1iiqq(i1,i,b,b1) = Vpiqj(i,i1,b1,j1)*tbj(b,j1)
               Tiiqq(i1,i,b,b1) -= T1iiqq(i1,i,b,b1)
#
            endif 
            ENDDO j1
#
            PREPARE Wiibb(i1,i,b,b1) = Tiiqq(i1,i,b,b1)
#
        endif
        endif
      ENDPARDO b, i, b1, i1
      execute server_barrier

      PARDO a1, b, i1, b1
#-----------------------------
       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
         REQUEST Vaaai(b1,b,a1,i1) i1
#
         DO i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

#
            GET                          t1a_old(a1,i)
            T1iiqq(i1,i,b,b1)          = Vaaai(b1,b,a1,i1)*t1a_old(a1,i)
            PREPARE Wiibb(i1,i,b,b1)  += T1iiqq(i1,i,b,b1)
#
          endif
         ENDDO i
#
        endif 
      ENDPARDO a1, b, i1, b1

      PARDO i, b, a1, j1
#--------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j1) = wOccA_frag(j1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
         REQUEST     T2old_ab(a1,i,b,j1) j1
         GET         t1a_old(a1,i)
         GET         t1a_old(b,j1)
         tai(a1,i) = t1a_old(a1,i) 

         Taibj(a1,i,b,j1)   = tai(a1,i)^t1a_old(b,j1)
         T1aibj(a1,i,b,j1)  = 0.5*T2old_ab(a1,i,b,j1)
         T1aibj(a1,i,b,j1) += Taibj(a1,i,b,j1)
#
         DO i1
#-----------------------------
       xi2(i1) = wOccA_frag(i1)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
         DO b1
#
            REQUEST                     Vpiqj(a1,i1,b1,j1) j1
            Tiiqq(i1,i,b,b1)          = T1aibj(a1,i,b,j1)*Vpiqj(a1,i1,b1,j1)
            Tiiqq(i1,i,b,b1)         *= -1.0  
            PREPARE Wiibb(i1,i,b,b1) += Tiiqq(i1,i,b,b1)
#
         ENDDO b1
         endif   
         ENDDO i1
#
        endif
        endif   
      ENDPARDO i, b, a1, j1
      execute server_barrier

#  Calculate contribution to the amplitudes
#  ----------------------------------------
#
      PARDO a, j, i1, b1
#-----------------------------
       xi(j)   = wOccA_frag(j)
       execute return_sval xi l1
       if l1 == two

       xi1(i1) = wOccA_frag(i1)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------


            REQUEST T2old_ab(a,i1,b1,j) j
#
            DO i
#-----------------------------
       xi2(i) = wOccA_frag(i)
       execute return_sval xi2 l3
       if l3 == two
#-----------------------------
            DO b
#
               REQUEST                      Wiibb(i1,i,b,b1) i
#
               Taibj(a,i,b,j)             = T2old_ab(a,i1,b1,j)*Wiibb(i1,i,b,b1)
               Taibj(a,i,b,j)            *= -1.0  
#
               T2aibj(b,j,a,i)            = Taibj(a,i,b,j) 
               PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
               PREPARE T2new_ab(b,j,a,i) += T2aibj(b,j,a,i)
#
            ENDDO b
            endif
            ENDDO i
#
        endif
        endif
      ENDPARDO a, j, i1, b1
#
      ENDPROC WMJBEab
#     ---------------
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
      PROC WMEBJ 
# 
           CALL WMEBJAA
           CALL WMEBJAB
           CALL WMJBEab
           CALL T2ABS2
#
      ENDPROC WMEBJ 
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
#    ------------------------------------------------------------------------ 
#
     PROC ENERGY_NEW 
# 
#    ------------------------------------------------------------------------ 
#
     ecorrab = 0.0 
     esumab  = 0.0 
     execute sip_barrier 
     PARDO a, b, i, j 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
           REQUEST Vpiqj(a,i,b,j) j  
           REQUEST Vpiqj(a,j,b,i) j  
#
           REQUEST T2old_ab(a,i,b,j) j  
           GET     t1a_old(a,i) 
           GET     t1a_old(b,j) 
           tai(a,i) = t1a_old(a,i) 
#
           Taibj(a,i,b,j)  = tai(a,i)^t1a_old(b,j) 
           Taibj(a,i,b,j) += T2old_ab(a,i,b,j)  
#
           T1aibj(a,i,b,j) = Vpiqj(a,i,b,j)  
           T2aibj(a,i,b,j) = Vpiqj(a,j,b,i)  
           T1aibj(a,i,b,j)*= 2.0  
           T1aibj(a,i,b,j)-= T2aibj(a,i,b,j)  
#
           etemp = Taibj(a,i,b,j)*T1aibj(a,i,b,j) 
           esumab += etemp 
#
       endif
       endif 
     ENDPARDO a, b, i, j 

     execute sip_barrier 
#
     collective ecorrab += esumab
    #execute print_scalar ecorrab 
#
    #ecorrT  = ecorraa + ecorrbb
     ecorrT = ecorrab 
#    execute print_scalar ecorrT  

     if kiter > 0
            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == one
               tpinf(kiter,kptr1) = ecorrab
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == two
               etemp = ecorrab
               etemp+= scfeneg
               tpinf(kiter,kptr1) = etemp
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

         execute print_rel_info five pinf
      endif

# 
#    ------------------------------------------------------------------------ 
# 
     ENDPROC ENERGY_NEW 
# 
#    ------------------------------------------------------------------------ 
# 
     PROC T2NEW_ZERO
#    --------------- 
#
#     Zero out new 1-particle amplitude arrays 
#     ---------------------------------------- 
#
          PARDO a, i
#----------------------------- 
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
                tai(a,i) = 0.0 
                PUT t1a_new(a,i) = tai(a,i) 
            endif
          ENDPARDO a, i 
#
#     Zero out new 2-particle amplitude arrays 
#     ---------------------------------------- 
#
          PARDO a, b, i, j 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

                Taibj(a,i,b,j) = 0.0
                PREPARE T2new_ab(a,i,b,j) = Taibj(a,i,b,j) 
            endif
            endif
          ENDPARDO a, b, i, j 
# 
     ENDPROC T2NEW_ZERO
# 
#    ------------------------------------------------------------------------ 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC UPDATET2 
#     ------------- 
#
      PARDO b, a, j, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

            REQUEST                    T2old_ab(b,j,a,i) b 
            REQUEST                    T2new_ab(b,j,a,i) b 
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            T1aibj(a,i,b,j)          = T2old_ab(b,j,a,i)
#
            REQUEST                    T2old_ab(a,i,b,j) b 
            REQUEST                    T2new_ab(a,i,b,j) b 
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            T1aibj(a,i,b,j)         += T2old_ab(a,i,b,j)

            execute energy_denominator Taibj
            T1aibj(a,i,b,j) -= Taibj(a,i,b,j)
            T1aibj(a,i,b,j) *= -0.5
#
            if kiter == 1
               PREPARE e1aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 2
               PREPARE e2aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 3
               PREPARE e3aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 4
               PREPARE e4aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter >= 5
               PREPARE e5aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
        endif
        endif
      ENDPARDO b, a, j, i
      execute server_barrier 
#
      PARDO b, a, j, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
            REQUEST                    T2new_ab(a,i,b,j) a
            REQUEST                    T2new_ab(b,j,a,i) a
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            Taibj(a,i,b,j)          *= 0.5  
            execute energy_denominator Taibj
            PREPARE T2old_ab(a,i,b,j)    = Taibj(a,i,b,j)
#
        endif
        endif
      ENDPARDO b, a, j, i
#
      ENDPROC UPDATET2 
#     ----------------  
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC UPDATET1 
#     ------------- 
#
      PARDO a, i 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

#
            GET                t1a_new(a,i) 
            GET                t1a_old(a,i) 
            tai(a,i)         = t1a_new(a,i) 
            t1ai(a,i)        = t1a_old(a,i) 
            execute energy_denominator tai 
           #PUT t1a_old(a,i) = tai(a,i) 
            tai(a,i)        -= t1ai(a,i) 
#
            if kiter == 1 
               PUT e1ai(a,i) = Tai(a,i) 
            endif 
#
            if kiter == 2 
               PUT e2ai(a,i) = Tai(a,i) 
            endif 
#
            if kiter == 3 
               PUT e3ai(a,i) = Tai(a,i) 
            endif 
#
            if kiter == 4 
               PUT e4ai(a,i) = Tai(a,i) 
            endif 
#
            if kiter >= 5 
               PUT e5ai(a,i) = Tai(a,i) 
            endif 
#
        endif
      ENDPARDO a, i 
#
      execute sip_barrier 
#
      PARDO a, i 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
            GET                t1a_new(a,i) 
            tai(a,i)         = t1a_new(a,i) 
            execute energy_denominator tai 
            PUT t1a_old(a,i) = tai(a,i) 
#
        endif
      ENDPARDO a, i 
#
      execute sip_barrier 
#
#
      ENDPROC UPDATET1 
#     ----------------  
#
      PROC MOVET2
#     ------------
#
      PARDO b, a, j, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
            REQUEST                    T2old_ab(a,i,b,j) a 
            Taibj(a,i,b,j)           = T2old_ab(a,i,b,j)
#
            if kiter == 1
               PREPARE d1aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 2
               PREPARE d2aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 3
               PREPARE d3aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 4
               PREPARE d4aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter >= 5
               PREPARE d4aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
        endif 
        endif
      ENDPARDO b, a, j, i
#
      ENDPROC MOVET2
#     ----------------
#
      PROC MOVET1
#     ------------
#
      PARDO a, i 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
#
            GET        t1a_old(a,i)
            tai(a,i) = t1a_old(a,i)
#
            if kiter == 1
               PUT d1ai(a,i) = tai(a,i)
            endif
#
            if kiter == 2
               PUT d2ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 3
               PUT d3ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 4
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
            if kiter >= 5
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
        endif
      ENDPARDO a, i
#
      ENDPROC MOVET1
#     ----------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR  
#    ----------------- 
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS 
#    expansion are zero'd out. 
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR  
#    -------------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS   
#    --------------- 
#
#    Put the matrix elements of B into the sip 'B' matrix. 
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS   
#    ------------------ 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
#             b1x x=1,2
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp

       endif
       endif 
     ENDPARDO a, i, b, j
#
#    Compute contributions due to T1ai amplitudes. 
#    --------------------------------------------- 
#
     PARDO a, i  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 2 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET e1ai(a,i)    # kiter-1 amplitudes  
           GET e2ai(a,i)    # kiter-0 amplitudes  
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#             b1x x=1,2 
#             --------- 
#
              etemp = e1ai(a,i)*e1ai(a,i) 
              etemp *= 4.0
              b11  += etemp            
#
              etemp = e1ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b12  += etemp            
#
#             b1x x=2,2 
#             --------- 
#
              etemp = e2ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b22  += etemp            
#
       endif 
     ENDPARDO a, i 
#
     execute sip_barrier
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb22 += b22 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     execute server_barrier 
    #execute print_scalar c1 
    #execute print_scalar c2 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
       endif
       endif
     ENDPARDO a, i, b, j
#
#    Form tai_old. 
#    ------------- 
#
     PARDO a, i  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 2 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET D0ai(a,i)     # kiter-2 amplitudes  
           GET D1ai(a,i)     # kiter-1 amplitudes  
#
           GET e1ai(a,i)     # kiter-1 amplitudes  
           GET e2ai(a,i)     # kiter-0 amplitudes  
#
#          Compute contributions to updated amplitudes --> tai_old. 
#          --------------------------------------------------------  
# 
           t1ai(a,i)     = d0ai(a,i) 
           t1ai(a,i)    += e1ai(a,i) 
           t1ai(a,i)    *= c1  
           tai(a,i)      = t1ai(a,i) 
#
           t1ai(a,i)     = d1ai(a,i) 
           t1ai(a,i)    += e2ai(a,i) 
           t1ai(a,i)    *= c2  
           tai(a,i)     += t1ai(a,i) 
# 
           PUT t1a_old(a,i) = tai(a,i) 
#
       endif
     ENDPARDO a, i  
#
     execute sip_barrier 
     execute server_barrier 
#
     ENDPROC DIIS1  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
#             b1x x=1,3
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
       endif
       endif
     ENDPARDO a, i, b, j
#
#    Compute contributions due to T1ai amplitudes. 
#    --------------------------------------------- 
#
     PARDO a, i 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
 
#
#          REQUEST/GET amplitude data from all 4 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET e1ai(a,i)    # kiter-2 amplitudes  
           GET e2ai(a,i)    # kiter-1 amplitudes  
           GET e3ai(a,i)    # kiter-0 amplitudes  
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#             b1x x=1,3 
#             --------- 
#
              etemp = e1ai(a,i)*e1ai(a,i) 
              etemp *= 4.0
              b11  += etemp            
#
              etemp = e1ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b12  += etemp            
#
              etemp = e1ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b13  += etemp            
#
#             b1x x=2,3 
#             --------- 
#
              etemp = e2ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b22  += etemp            
#
              etemp = e2ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b23  += etemp            
#
#             b1x x=3,3 
#             --------- 
#
              etemp = e3ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b33  += etemp            
#
       endif
     ENDPARDO a, i 
#
     execute sip_barrier
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb33 += b33 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     execute server_barrier 
    #execute print_scalar c1 
    #execute print_scalar c2 
    #execute print_scalar c3 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
       endif
       endif
     ENDPARDO a, i, b, j
#
#    Form tai_old. 
#    ------------- 
#
     PARDO a, i 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
#
#
#          REQUEST/GET amplitude data from all 3 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET D0ai(a,i)     # kiter-3 amplitudes  
           GET D1ai(a,i)     # kiter-2 amplitudes  
           GET D2ai(a,i)     # kiter-1 amplitudes  
#
           GET e1ai(a,i)     # kiter-2 amplitudes  
           GET e2ai(a,i)     # kiter-1 amplitudes  
           GET e3ai(a,i)     # kiter-0 amplitudes  
#
#          Compute contributions to updated amplitudes --> tai_old. 
#          --------------------------------------------------------  
# 
           t1ai(a,i)     = d0ai(a,i) 
           t1ai(a,i)    += e1ai(a,i) 
           t1ai(a,i)    *= c1  
           tai(a,i)      = t1ai(a,i) 
#
           t1ai(a,i)     = d1ai(a,i) 
           t1ai(a,i)    += e2ai(a,i) 
           t1ai(a,i)    *= c2  
           tai(a,i)     += t1ai(a,i) 
#
           t1ai(a,i)     = d2ai(a,i) 
           t1ai(a,i)    += e3ai(a,i) 
           t1ai(a,i)    *= c3  
           tai(a,i)     += t1ai(a,i) 
# 
           PUT t1a_old(a,i) = tai(a,i) 
#
       endif
     ENDPARDO a, i  
#
     execute sip_barrier 
     execute server_barrier 
#
     ENDPROC DIIS2  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-3 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e4aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e4aibj(a,j,b,i) 
           t4aibj(a,i,b,j) = e4aibj(a,i,b,j) 
           t4aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
              etemp = e1aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
              etemp = e2aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
              etemp = e3aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b44  += etemp
#
#             b1x x=1,4
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
              etemp = t1aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
              etemp = t2aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
              etemp = t3aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = t4aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b44  += etemp
#
       endif
       endif
     ENDPARDO a, i, b, j
#
#    Compute contributions due to T1ai amplitudes. 
#    --------------------------------------------- 
#
     PARDO a, i  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 4 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET e1ai(a,i)    # kiter-3 amplitudes  
           GET e2ai(a,i)    # kiter-2 amplitudes  
           GET e3ai(a,i)    # kiter-1 amplitudes  
           GET e4ai(a,i)    # kiter-0 amplitudes  
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#             b1x x=1,4 
#             --------- 
#
              etemp = e1ai(a,i)*e1ai(a,i) 
              etemp *= 4.0
              b11  += etemp            
#
              etemp = e1ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b12  += etemp            
#
              etemp = e1ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b13  += etemp            
#
              etemp = e1ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b14  += etemp            
#
#             b1x x=2,4 
#             --------- 
#
              etemp = e2ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b22  += etemp            
#
              etemp = e2ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b23  += etemp            
#
              etemp = e2ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b24  += etemp            
#
#             b1x x=3,4 
#             --------- 
#
              etemp = e3ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b33  += etemp            
#
              etemp = e3ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b34  += etemp            
#
#             b1x x=4,4 
#             --------- 
#
              etemp = e4ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b44  += etemp            
#
       endif
     ENDPARDO a, i 
#
     execute sip_barrier
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb14 += b14 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb24 += b24 
     collective Tb33 += b33 
     collective Tb34 += b34 
     collective Tb44 += b44 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     c4 = Tb44 
    #execute print_scalar c1 
    #execute print_scalar c2 
    #execute print_scalar c3 
    #execute print_scalar c4 
     execute server_barrier 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D3aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c4
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
       endif
       endif  
     ENDPARDO a, i, b, j
#
#    Form tai_old. 
#    ------------- 
#
     PARDO a, i  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

#
#          REQUEST/GET amplitude data from all 4 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET D0ai(a,i)     # kiter-4 amplitudes  
           GET D1ai(a,i)     # kiter-3 amplitudes  
           GET D2ai(a,i)     # kiter-2 amplitudes  
           GET D3ai(a,i)     # kiter-1 amplitudes  
#
           GET e1ai(a,i)     # kiter-3 amplitudes  
           GET e2ai(a,i)     # kiter-2 amplitudes  
           GET e3ai(a,i)     # kiter-1 amplitudes  
           GET e4ai(a,i)     # kiter-0 amplitudes  
#
#          Compute contributions to updated amplitudes --> tai_old. 
#          --------------------------------------------------------  
# 
           t1ai(a,i)     = d0ai(a,i) 
           t1ai(a,i)    += e1ai(a,i) 
           t1ai(a,i)    *= c1  
           tai(a,i)      = t1ai(a,i) 
#
           t1ai(a,i)     = d1ai(a,i) 
           t1ai(a,i)    += e2ai(a,i) 
           t1ai(a,i)    *= c2  
           tai(a,i)     += t1ai(a,i) 
#
           t1ai(a,i)     = d2ai(a,i) 
           t1ai(a,i)    += e3ai(a,i) 
           t1ai(a,i)    *= c3  
           tai(a,i)     += t1ai(a,i) 
#
           t1ai(a,i)     = d3ai(a,i) 
           t1ai(a,i)    += e4ai(a,i) 
           t1ai(a,i)    *= c4  
           tai(a,i)     += t1ai(a,i) 
# 
           PUT t1a_old(a,i) = tai(a,i) 
#
       endif 
     ENDPARDO a, i  
#
     execute sip_barrier 
     execute server_barrier 
#
     ENDPROC DIIS3  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j

#------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------


#
#          REQUEST/GET amplitude data from all 5 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e5aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-4 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-3 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e4aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e5aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e4aibj(a,j,b,i) 
           t4aibj(a,i,b,j) = e4aibj(a,i,b,j) 
           t4aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e5aibj(a,j,b,i) 
           t5aibj(a,i,b,j) = e5aibj(a,i,b,j) 
           t5aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
              etemp = e1aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b14  += etemp
#
              etemp = e1aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
              etemp = e2aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b24  += etemp
#
              etemp = e2aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
              etemp = e3aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b34  += etemp
#
              etemp = e3aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b44  += etemp
#
              etemp = e4aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b55  += etemp
#
#
#             b1x x=1,5
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
              etemp = t1aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b14  += etemp
#
              etemp = t1aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
              etemp = t2aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b24  += etemp
#
              etemp = t2aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
              etemp = t3aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b34  += etemp
#
              etemp = t3aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = t4aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b44  += etemp
#
              etemp = t4aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = t5aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b55  += etemp
#
       endif
       endif 
     ENDPARDO a, i, b, j
#
#    Compute contributions due to T1ai amplitudes. 
#    --------------------------------------------- 
#
     PARDO a, i 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
 
#
#          REQUEST/GET amplitude data from all 5 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET e1ai(a,i)    # kiter-4 amplitudes  
           GET e2ai(a,i)    # kiter-3 amplitudes  
           GET e3ai(a,i)    # kiter-2 amplitudes  
           GET e4ai(a,i)    # kiter-1 amplitudes  
           GET e5ai(a,i)    # kiter-0 amplitudes  
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#             b1x x=1,5 
#             --------- 
#
              etemp = e1ai(a,i)*e1ai(a,i) 
              etemp *= 4.0
              b11  += etemp            
#
              etemp = e1ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b12  += etemp            
#
              etemp = e1ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b13  += etemp            
#
              etemp = e1ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b14  += etemp            
#
              etemp = e1ai(a,i)*e5ai(a,i) 
              etemp *= 4.0
              b15  += etemp            
#
#             b1x x=2,5 
#             --------- 
#
              etemp = e2ai(a,i)*e2ai(a,i) 
              etemp *= 4.0
              b22  += etemp            
#
              etemp = e2ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b23  += etemp            
#
              etemp = e2ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b24  += etemp            
#
              etemp = e2ai(a,i)*e5ai(a,i) 
              etemp *= 4.0
              b25  += etemp            
#
#             b1x x=3,5 
#             --------- 
#
              etemp = e3ai(a,i)*e3ai(a,i) 
              etemp *= 4.0
              b33  += etemp            
#
              etemp = e3ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b34  += etemp            
#
              etemp = e3ai(a,i)*e5ai(a,i) 
              etemp *= 4.0
              b35  += etemp            
#
#             b1x x=4,5 
#             --------- 
#
              etemp = e4ai(a,i)*e4ai(a,i) 
              etemp *= 4.0
              b44  += etemp            
#
              etemp = e4ai(a,i)*e5ai(a,i) 
              etemp *= 4.0
              b45  += etemp            
#
#             b1x x=5,5 
#             --------- 
#
              etemp = e5ai(a,i)*e5ai(a,i) 
              etemp *= 4.0
              b55  += etemp            
#
       endif
     ENDPARDO a, i 
#
     execute sip_barrier
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb14 += b14 
     collective Tb15 += b15 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb24 += b24 
     collective Tb25 += b25 
     collective Tb33 += b33 
     collective Tb34 += b34 
     collective Tb35 += b35 
     collective Tb44 += b44 
     collective Tb45 += b45 
     collective Tb55 += b55 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     c4 = Tb44 
     c5 = Tb55 
    #execute print_scalar c1 
    #execute print_scalar c2 
    #execute print_scalar c3 
    #execute print_scalar c4 
    #execute print_scalar c5 
     execute server_barrier 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#------------------------------

#
#          REQUEST/GET amplitude data from all 5 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-5 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D4aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e5aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c4
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e5aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c5
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
       endif
       endif
     ENDPARDO a, i, b, j
#
#    Form tai_old. 
#    ------------- 
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------

  
#
#          REQUEST/GET amplitude data from all 5 previous iterations. 
#          ---------------------------------------------------------- 
#
           GET D0ai(a,i)     # kiter-5 amplitudes  
           GET D1ai(a,i)     # kiter-4 amplitudes  
           GET D2ai(a,i)     # kiter-3 amplitudes  
           GET D3ai(a,i)     # kiter-2 amplitudes  
           GET D4ai(a,i)     # kiter-1 amplitudes  
#
           GET e1ai(a,i)     # kiter-4 amplitudes  
           GET e2ai(a,i)     # kiter-3 amplitudes  
           GET e3ai(a,i)     # kiter-2 amplitudes  
           GET e4ai(a,i)     # kiter-1 amplitudes  
           GET e5ai(a,i)     # kiter-0 amplitudes  
#
#          Compute contributions to updated amplitudes --> tai_old. 
#          --------------------------------------------------------  
# 
           t1ai(a,i)     = d0ai(a,i) 
           t1ai(a,i)    += e1ai(a,i) 
           t1ai(a,i)    *= c1  
           tai(a,i)      = t1ai(a,i) 
#
           t1ai(a,i)     = d1ai(a,i) 
           t1ai(a,i)    += e2ai(a,i) 
           t1ai(a,i)    *= c2  
           tai(a,i)     += t1ai(a,i) 
#
           t1ai(a,i)     = d2ai(a,i) 
           t1ai(a,i)    += e3ai(a,i) 
           t1ai(a,i)    *= c3  
           tai(a,i)     += t1ai(a,i) 
#
           t1ai(a,i)     = d3ai(a,i) 
           t1ai(a,i)    += e4ai(a,i) 
           t1ai(a,i)    *= c4  
           tai(a,i)     += t1ai(a,i) 
#
           t1ai(a,i)     = d4ai(a,i) 
           t1ai(a,i)    += e5ai(a,i) 
           t1ai(a,i)    *= c5  
           tai(a,i)     += t1ai(a,i) 
# 
           PUT t1a_old(a,i) = tai(a,i) 
       endif
     ENDPARDO a, i  
#
     execute sip_barrier 
     execute server_barrier 
#
     ENDPROC DIIS4  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
     execute server_barrier
     execute sip_barrier
#
#    0 --> 1
#    ---------------------------------------------------
#
     execute array_copy d1aibj d0aibj
     execute server_barrier
#
#    2 --> 1
#    ---------------------------------------------------
#
     execute array_copy e2aibj e1aibj
     execute array_copy d2aibj d1aibj
     execute server_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     execute array_copy e3aibj e2aibj
     execute array_copy d3aibj d2aibj
     execute server_barrier
#
#
#    4 --> 3
#    ---------------------------------------------------
#
     execute array_copy e4aibj e3aibj
     execute array_copy d4aibj d3aibj
     execute server_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     execute array_copy e5aibj e4aibj
#
     execute sip_barrier
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET d1ai(a,i)
           PUT d0ai(a,i) = d1ai(a,i)
       endif
     ENDPARDO a, i
#
     execute sip_barrier
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET e2ai(a,i)
           PUT e1ai(a,i) = e2ai(a,i)
       endif
     ENDPARDO a, i
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET d2ai(a,i)
           PUT d1ai(a,i) = d2ai(a,i)
       endif 
     ENDPARDO a, i
#
     execute sip_barrier
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET e3ai(a,i)
           PUT e2ai(a,i) = e3ai(a,i)
       endif
     ENDPARDO a, i
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET d3ai(a,i)
           PUT d2ai(a,i) = d3ai(a,i)
       endif 
     ENDPARDO a, i
#
     execute sip_barrier
#
     PARDO a, i
#-------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET e4ai(a,i)
           PUT e3ai(a,i) = e4ai(a,i)
       endif
     ENDPARDO a, i
#
     PARDO a, i
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET d4ai(a,i)
           PUT d3ai(a,i) = d4ai(a,i)
        endif 
     ENDPARDO a, i
#
     execute sip_barrier
#
     PARDO a, i
#----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-----------------------------
           GET e5ai(a,i)
           PUT e4ai(a,i) = e5ai(a,i)
        endif   
     ENDPARDO a, i
#
     execute sip_barrier
     execute server_barrier
#
     ENDPROC MOVE4
#    -------------
#
#    proc do_checkpoint

#    execute checkpoint t2old_aa
#    execute checkpoint t2old_ab
#    execute checkpoint t1a_old
#    execute checkpoint E1aibj
#    execute checkpoint E2aibj
#    execute checkpoint E3aibj
#    execute checkpoint E4aibj
#    execute checkpoint E5aibj
#    execute checkpoint E1ai
#    execute checkpoint E2ai
#    execute checkpoint E3ai
#    execute checkpoint E4ai
#    execute checkpoint E5ai
#    execute checkpoint D0aibj
#    execute checkpoint D1aibj
#    execute checkpoint D2aibj
#    execute checkpoint D3aibj
#    execute checkpoint D4aibj
#    execute checkpoint D0ai
#    execute checkpoint D1ai
#    execute checkpoint D2ai
#    execute checkpoint D3ai
#    execute checkpoint D4ai
#    execute commit_checkpoint

#    execute get_restart_status restart
#    if restart == 1.0
#       CALL READ_2EL   # Restore data saved as BLOCKDATA 
#    endif

#    endproc do_checkpoint

# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
# 
# BEGIN MAIN PROGRAM 
# ------------------ 

      F12CALC = 0.0   

      execute f12info F12CALC
      execute print_scalar F12CALC

      ecrit = cc_conv  
      one = 1.0
      two = 2.0
      five  = 5.0
      six   = 6.0
      seven = 7.0

#------Set up fragments----------------

      CALL SET_FRAG

#
# Read transformed integrals from lists 
# ------------------------------------- 
#
      CALL READ_2EL 

      CREATE t1a_old 
      CREATE t1a_new 
#
      CREATE D0ai
      CREATE D1ai
      CREATE D2ai
      CREATE D3ai
      CREATE D4ai
      CREATE D5ai
#
      CREATE e1ai
      CREATE e2ai
      CREATE e3ai
      CREATE e4ai
      CREATE e5ai
#
      EXECUTE SIP_BARRIER  
#
# Get initial second-order guess 
# ------------------------------ 
      CALL IGUESS_UHF
      EXECUTE SIP_BARRIER  
      EXECUTE SERVER_BARRIER  
#
      PARDO a, i, b, j
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------
 
            REQUEST                     T2old_ab(a,i,b,j) a 
            REQUEST                     T2old_ab(a,j,b,i) a 
            taiai(a,i,b,j)            = T2old_ab(a,i,b,j) 
            t1aiai(a,i,b,j)           = T2old_ab(a,j,b,i) 
            taiai(a,i,b,j)           -= t1aiai(a,i,b,j) 
            PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j)
            endif
            endif 
      ENDPARDO a, i, b, j 
#
      EXECUTE SERVER_BARRIER  
#
# Calculate the second-order energy 
# --------------------------------- 
      CALL ENERGY_NEW 

      do kiter
      do kptr1
         etemp = 0.0
         pinf(kiter,kptr1)  = etemp
      enddo kptr1
      enddo kiter

        do jiter
           ncount2 = 0.0
         DO kptr1
            ncount2 += 1.0
            if ncount2 == two
               etemp              = ecorrab
               etemp             += scfeneg
               tpinf(jiter,kptr1) = etemp
               pinf(jiter,kptr1)  = tpinf(jiter,kptr1)
            endif
         ENDDO kptr1
        enddo jiter

        do jiter
           ncount2 = 0.0
         DO kptr1
            ncount2 += 1.0
            if ncount2 == one
               tpinf(jiter,kptr1) = ecorrab
               pinf(jiter,kptr1)  = tpinf(jiter,kptr1)
            endif
         ENDDO kptr1
        enddo jiter

        execute print_rel_info six pinf

      do kiter
      do kptr1
         etemp = 0.0
         pinf(kiter,kptr1)  = etemp
      enddo kptr1
      enddo kiter
#
# Start iterations
# ---------------- 
      DO KITER 

      EXECUTE SERVER_BARRIER  
#
      PARDO a, i, b, j

#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------

 
            REQUEST                     T2old_ab(a,i,b,j) a 
            REQUEST                     T2old_ab(a,j,b,i) a 
            taiai(a,i,b,j)            = T2old_ab(a,i,b,j) 
            t1aiai(a,i,b,j)           = T2old_ab(a,j,b,i) 
            taiai(a,i,b,j)           -= t1aiai(a,i,b,j) 
            PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j) 
            endif
            endif
      ENDPARDO a, i, b, j 
#
      EXECUTE SERVER_BARRIER  
#
#        Form Tau and Taup 
#        ----------------- 
         CALL TAU  
#
#        Zero-out the new two-particle amplitude arrays
#        ---------------------------------------------- 
#
         CALL T2NEW_ZERO
#
#        Form one-particle intermediates 
#        ------------------------------- 
         CREATE Fae_a 
         CREATE Fme_a
         CREATE Fmi_a 
         EXECUTE SIP_BARRIER  
         EXECUTE SERVER_BARRIER  
# 
         CALL FAE 
         CALL FMIA 
         CALL FMEA
         EXECUTE SIP_BARRIER 
         EXECUTE SERVER_BARRIER  
#
#        Calculate new one-particle amplitudes 
#        ------------------------------------- 
#
         CALL T1ANEW
#-----------------------------------------------------------------|
#  Here we do F12 correction to the T1 - equations                |
#-----------------------------------------------------------------|

         IF F12CALC == 1.0

         CALL T1_f12
 
         ENDIF
#
#        Calculate new two-particle amplitudes 
#        ------------------------------------- 

         CALL T2NEWAB  
#
         CALL WMINJ 
         CALL AOLADDER 
         CALL WAEBF  
         CALL WMEBJ

         IF F12CALC == 1.0

#-----------------------------------------------------------------|
#  Here we do F12 correction to the T2 - equations                |
#-----------------------------------------------------------------|
         CALL T2_f12
#-----------------------------------------------------------------|
#     3-electron integral terms of extra T2-F12 diagrams          |
#-----------------------------------------------------------------|
         CALL T2_f12_extra_3e
#-----------------------------------------------------------------|
#     Conuterparts of extra T2-F12 diagrams                       |
#-----------------------------------------------------------------|
         CALL T2_f12_extra_cp

         ENDIF

#
#        Wait for all to finish 
#        ---------------------- 
         EXECUTE SIP_BARRIER   
         EXECUTE SERVER_BARRIER   
#
         DELETE Fae_a 
         DELETE Fme_a
         DELETE Fmi_a 
         CALL UPDATET1 
         CALL UPDATET2 
#
         EXECUTE SIP_BARRIER   
         EXECUTE SERVER_BARRIER   
         CALL ENERGY_NEW 
         EXECUTE SIP_BARRIER  
         EXECUTE SERVER_BARRIER   
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
         EXECUTE SERVER_BARRIER  
#
         CALL MOVET1
         CALL MOVET2
#
         EXECUTE SERVER_BARRIER  
         PARDO a, i, b, j 
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#------------------------------
               REQUEST                     T2old_ab(a,i,b,j) a 
               REQUEST                     T2old_ab(a,j,b,i) a 
               taiai(a,i,b,j)            = T2old_ab(a,i,b,j) 
               t1aiai(a,i,b,j)           = T2old_ab(a,j,b,i) 
               taiai(a,i,b,j)           -= t1aiai(a,i,b,j) 
               PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j) 

               endif
               endif
         ENDPARDO a, i, b, j 
         EXECUTE SERVER_BARRIER  
#
#        Check on convergence 
#        -------------------- 
#
         IF ecorrT < eold 
            ediff = eold - ecorrT 
            IF ediff < ecrit 
               exit # kiter 
            ENDIF
         ENDIF   
#
         IF ecorrT > eold 
            ediff = ecorrT - eold  
            IF ediff < ecrit 
               exit # kiter 
            ENDIF
         ENDIF   
#
#        Reset eold --> enew 
#        ------------------- 
#
         eold = ecorrT 

         #if kiter >= 5 
         #   call do_checkpoint
         #endif
#
      ENDDO KITER 

      IF F12CALC == 1.0

      CALL LAMBDA_f12

      execute print_scalar E_dir
      execute print_scalar E_LAM

      ecorrT += E_LAM
      ecorrT += E_dir

      ENDIF
#------------------------------------------------------------------

            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == one
               tpinf(kiter,kptr1) = ecorrT
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == two
               etemp = ecorrT
               etemp+= scfeneg
               tpinf(kiter,kptr1) = etemp
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1



#------------------------------------------------------------------
      execute sip_barrier 
      totenerg  = ecorrT  
      totenerg += scfeneg  
     #execute print_scalar totenerg  
     


      execute print_rel_info seven pinf

 
#
# Write amplitudes to file
# ------------------------

      etemp = 21.0
      execute print_rel_info etemp pinf  
      DO a 
      DO b 
      DO i  
      DO j  
#-----------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two

       xi1(j) = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == two
#-----------------------------


         REQUEST T2old_ab(a,i,b,j) a 
         execute maxamp_print T2old_ab

        endif
        endif  
      ENDDO j  
      ENDDO i  
      ENDDO b  
      ENDDO a  

      etemp = 22.0
      execute print_rel_info etemp pinf  
      DO a 
      DO i
#-------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == two
#-------------------------------
  
         GET t1a_old(a,i) 
         execute maxamp_print t1a_old 

       endif 
      ENDDO i  
      ENDDO a  
      execute server_barrier

#---------Zero - out amplitudes with frozen orbitals---------------------------
      PARDO i,a
#-------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == one
#-------------------------------
      Tai(a,i) = 0.0      
      PUT t1a_old(a,i) = Tai(a,i) 
      endif 
      ENDPARDO i,a

      execute sip_barrier      

      PARDO i,a,j,b
#------frozen-frozen part-------
#-------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == one

       xi1(j)   = wOccA_frag(j)
       execute return_sval xi1 l2
       if l2 == one
#-------------------------------
       taiai(a,i,b,j) = 0.0 
       PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j) 
       PREPARE T2old_ab(a,i,b,j) = taiai(a,i,b,j)
       endif
       endif
      ENDPARDO i,a,j,b

      PARDO i,a,j,b
#------non-frozen frozen part---
#-------------------------------
       xi(i)   = wOccA_frag(i)
       execute return_sval xi l1
       if l1 == one
#-------------------------------
       taiai(a,i,b,j) = 0.0
       PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j)
       PREPARE T2old_ab(a,i,b,j) = taiai(a,i,b,j)
       endif
      ENDPARDO i,a,j,b

      PARDO i,a,j,b
#------frozen-non-frozen part---
#-------------------------------
       xi(j)   = wOccA_frag(j)
       execute return_sval xi l1
       if l1 == one
#-------------------------------

       taiai(a,i,b,j) = 0.0
       PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j)
       PREPARE T2old_ab(a,i,b,j) = taiai(a,i,b,j)
       endif
      ENDPARDO i,a,j,b



      execute server_barrier

#      CALL WRITE_2EL   

      execute sip_barrier
      execute blocks_to_list                t1a_old
      execute blocks_to_list                T2old_aa
      execute blocks_to_list                T2old_ab
#--------------F12 contributions to the Hbar for EOM-CC calculations-----------
       IF F12CALC == 1.0
      execute blocks_to_list                T1_2(i,j)
      execute blocks_to_list                T1_3(a,p)
      execute blocks_to_list                T2_2(j,k,i,a)
      execute blocks_to_list                T2_3(i,k,j,l)
      execute blocks_to_list                T2_6(a,i,q,j)
      execute blocks_to_list                T2_7(q,i,a,j)
      execute blocks_to_list                T2_9(a,p,i,j)
      execute blocks_to_list                T2_8(a,i,p,j)
#      execute blocks_to_list                auxint2(a,i,p,j)
       ENDIF 
#-----------Write amplitudes and intermediates to disk-------------------------
      execute write_blocks_to_list
      execute sip_barrier
#                            

      deallocate wOccA_frag(*)


                           ENDSIAL CCSD_RHF_SV1_F12_fc    
#
# EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE 
#
#
