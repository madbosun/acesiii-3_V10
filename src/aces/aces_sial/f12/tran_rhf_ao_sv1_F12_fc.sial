#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL TRAN_RHF_SV1_fc    
#
# ---------------------------------------------------------------------------
#
# Final set of of fully transformed integrals excluding the 4-virtual ones. 
#
# ---------------------------------------------------------------------------
#
#                          Integral     Type  
#                         -------------------  
#                         VSpipi       Served 
#                         Vaaii        Served 
#                         Viaai        Served 
#                         Vaaai       Served 
#                         VSqjqj       Served 
#                         Vbbjj        Served 
#                         Vjbbj        Served 
#                         VSbbbj       Served 
#                         Vbbii        Served 
#                         Vjbii        Served 
#                         Vpiqj        Served 
#                         Vaajj        Served 
#                         Viabj        Served 
#
# ---------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index qq =1,1
      aoindex mu     = 1, norb
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb

      index kkk = 1,2
      index iii = 1,2

#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex d = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex l = baocc, eaocc
      moaindex k = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
# 
# Declare served arrays 
# ---------------------
#
      served Vxxxi(mu,nu,lambda,i)
      served Vxixi(mu,i1,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
      served Vxipi(mu,i,p,i1)
      served VSpipi(p1,i,p,i1)
      served Vixai(i,mu,a,i1)
      served Vxaii(mu,a,i,i1)
      served Viaai(i,a1,a,i1)
      served Vaaii(a,a1,i,i1)
      served Vxaai(mu,a1,a,i)
      served Vxxai(mu,nu,a,i)
      served VSaaai(a2,a,a1,i)
#
      served Vxxxj(mu,nu,lambda,j)
      served Vxjxj(mu,j1,lambda,j)
      served Vxxjj(mu,nu,j1,j)
      served Vjxxj(j1,nu,lambda,j)
      served Vxjqj(mu,j,q,j1)
      served VSqjqj(q1,j,q,j1)
      served Vjxbj(j,mu,b,j1)
      served Vxbjj(mu,b,j,j1)
      served Vjbbj(j,b1,b,j1)
      served Vbbjj(b,b1,j,j1)
      served Vxbbj(mu,b1,b,j)
      served Vxxbj(mu,nu,b,j) 
      served VSbbbj(b2,b,b1,j)
#
      served Vxbii(mu,b,i,i1)
      served Vbbii(b,b1,i,i1)
      served Vjbii(j,b,i,i1)
      served Vxbai(mu,b,a,i)
#
      served Vxixj(mu,i,nu,j)
      served Vxiqj(mu,i,q,j)
      served Vpiqj(p,i,q,j)
      served Vxajj(mu,a,j,j1)
      served Vaajj(a,a1,j,j1)
      served Vxabj(mu,a,b,j)
      served Vxxij(mu,nu,i,j)
      served Vixxj(i,mu,nu,j)
      served Vixbj(i,mu,b,j)
      served Viabj(i,a,b,j)


#------------------ F12 - intermediates -------------------------------------------


#------------T1 f12- intermediates---------------------------------------------------------
       served T1_1(i,a)
       served T1_2(i,j)
       served T1_3(a,p)
       served T1_4(a,i,a1,i1)
#------------T2 f12- intermediates---------------------------------------------------------
       served T2_1(a,i,b,j)
       served T2_2(i,k,j,a)
       served T2_3(i,k,j,l)
       served T2_4(i,j)
       served T2_5(a,i,b,j)
       served T2_6(a,i,q,j)
       served T2_7(q,i,a,j)
       served T2_8(a,i,p,j)
       served T2_9(a,p,i,j)
       served T2_10(i,a,d,b)
       served T2_11(d,a,j,b)
#------------------------------------------------------------------------------------------
       served LAM_1(i,a)
       served LAM_2(i,a,k,b)
       served LAM_3(i,a,k,b)
       served LAM_4(i,a,k,b)
       served LAM_5(i,a,k,b)
       served ELAM(iii,kkk)

      served auxint1(a,i,p,j) 
      served V0pipi(p,i,q,j)
      served V0aapi(a,b,p,i)
      served V0apai(a,p,b,i)
      served V2ppii(p,q,i,j)
      served V2piai(p,i,a,j)
#----------------------------------------------------------------------------------

#
# Declare temporary arrays 
# ------------------------ 
#
      temp Txjxj(mu,j1,lambda,j)
      temp T1xjxj(mu,j1,lambda,j)
      temp Txxjj(mu,nu,j1,j)
      temp T1xxjj(mu,nu,j1,j)
      temp Tjjxx(j1,nu,lambda,j)
      temp Tjxxj(j1,nu,lambda,j)
      temp T1jxxj(j1,nu,lambda,j)
      temp Txjqj(mu,j,q,j1)
      temp T1xjqj(mu,j,q,j1)
      temp Tqjqj(q1,j,q,j1)
      temp T1qjqj(q1,j,q,j1)
      temp Tjxbj(j,mu,b,j1)
      temp T1jxbj(j,mu,b,j1)
      temp Txbjj(mu,b,j,j1)
      temp T1xbjj(mu,b,j,j1)
      temp Tjbbj(j,b1,b,j1)
      temp T1jbbj(j,b1,b,j1)
      temp Tbbjj(b,b1,j,j1)
      temp T1bbjj(b,b1,j,j1)
      temp Txbbj(mu,b1,b,j)
      temp T1xbbj(mu,b1,b,j)
      temp Tbbbj(b2,b,b1,j)
      temp T1bbbj(b2,b,b1,j)
      temp Txxbj(mu,nu,b,j)
#
      temp Txixj(mu,i,nu,j)
      temp T1xixj(mu,i,nu,j)
      temp Txiqj(mu,i,q,j)
      temp T1xiqj(mu,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp T1piqj(p,i,q,j)
      temp Tiixx(i,i1,mu,nu)
      temp Tiixb(i,i1,mu,b)
      temp Tiibb(i,i1,b1,b)
      temp Txajj(mu,a,j,j1)
      temp T1xajj(mu,a,j,j1)
      temp Taajj(a,a1,j,j1)
      temp T1aajj(a,a1,j,j1)
      temp Txabj(mu,a,b,j)
      temp T1xabj(mu,a,b,j)
      temp Tixxj(i,mu,nu,j)
      temp Tixbj(i,mu,b,j)
      temp T1ixbj(i,mu,b,j)
      temp Tiabj(i,a,b,j)
      temp T1iabj(i,a,b,j)
      temp Taabj(a,a1,b,j)
      temp T1aabj(a,a1,b,j)
#
      temp Txbii(mu,b,i,i1)
      temp T1xbii(mu,b,i,i1)
      temp Tbbii(b,b1,i,i1)
      temp T1bbii(b,b1,i,i1)
      temp Tjbii(j,b,i,i1)
      temp T1jbii(j,b,i,i1)
      temp Txbai(mu,b,a,i)
      temp T1xbai(mu,b,a,i)
      temp Tbbai(b,b1,a,i)
      temp T1bbai(b,b1,a,i)
#
      temp Taaai(a,a1,a2,i) 
      local Laaai(a2,a,a1,i) 
      temp T1aaai(a,a1,a2,i) 
      temp Txxai(mu,nu,a,i) 
      temp Txaai(mu,a,a1,i) 
      local Lxaai(mu,a1,a,i) 
      temp T1xaai(mu,a,a1,i) 
      temp Txaii(mu,a,i,i1) 
      temp T1xaii(mu,a,i,i1) 
      temp Tiaai(i,a,a1,i1) 
      temp T1iaai(i,a,a1,i1) 
      temp Taaii(a,a1,i,i1) 
      temp T1aaii(a,a1,i,i1) 
      temp T1xxai(mu,nu,a,i) 
      temp Tixai(i,mu,a,i1) 
      temp T1ixai(i,mu,a,i1) 
      temp Txipi(mu,i,p1,i1) 
      temp T1xipi(mu,i,p1,i1) 
      temp Tpipi(p,i,p1,i1) 
      temp T1pipi(p,i,p1,i1) 
#
      temp T1xxbj(mu,nu,b,j) 
#
      temp Txxij(mu,nu,i,j) 
      temp T1xxij(mu,nu,i,j) 
      temp T1ixxj(i,mu,nu,j) 
      local Txxxi(mu,nu,lambda,i)
      temp T1xxxi(mu,nu,lambda,i)
      local Txxxj(mu,nu,lambda,j)
      temp T1xxxj(mu,nu,lambda,j)
      temp Txixi(mu,i,nu,i1)
      temp T1xixi(mu,i,nu,i1)
      temp Txxii(mu,nu,i1,i) 
      temp T1xxii(mu,nu,i1,i) 
      temp Tixxi(i1,mu,nu,i) 
      temp T1ixxi(i1,mu,nu,i) 
      temp Txxpi(mu,nu,p,i) 
      temp Txiai(mu,i1,a,i) 
      temp Taiai(a1,i1,a,i) 
      temp T1aiai(a1,i1,a,i) 
      temp Taxai(a1,nu,a,i) 
      temp Tpxpi(p1,nu,p,i) 
#
# Declare integral arrays 
# ------------------------  
#
      temp AOINT(mu,nu,lambda,sigma) 
#     served SAOINT(mu,nu,lambda,sigma) 
      local TAOINT(mu,nu,lambda,sigma) 
      local L1xxxi(mu,nu,lambda,i) 
      local L2xxxi(mu,lambda,nu,i) 
      local L3xxxi(lambda,mu,nu,i) 
      local L1xxxj(mu,nu,lambda,j) 
      local L2xxxj(mu,lambda,nu,j) 
      local L3xxxj(lambda,mu,nu,j) 
      local Lxixi(mu,i,nu,i1) 
      local Lxxii(mu,nu,i,i1) 
      local Lixxi(i,mu,nu,i1) 
      local Lxjxj(mu,j,nu,j1) 
      local Lxxjj(mu,nu,j,j1) 
      local Ljxxj(j,mu,nu,j1) 
      local Lxxai(mu,nu,a,i) 
      local Lxxbj(mu,nu,b,j) 
      local Lxixj(mu,i,nu,j) 
      local Lixxj(i,mu,nu,j) 
      local Lxipi(mu,i,p,i1) 
      local Lxaii(mu,a,i,i1) 
      local Lixai(i,mu,a,i1) 
      local L1xaai(mu,a,a1,i)  
      local L2xaai(mu,a,a2,i)  
      local Lxjqj(mu,j,q,j1)  
      local Lxbjj(mu,b,j,j1) 
      local Ljxbj(j,mu,b,j1) 
      local Lxbbj(mu,b,b1,j) 
      local Lxbii(mu,b,i,i1) 
      local Lxbai(mu,b,a,i) 
      local Lxiqj(mu,i,q,j) 
      local Lxajj(mu,a,j,j1) 
      local Lixbj(i,mu,b,j) 
      local Lxabj(mu,a,b,j) 
      local L1xbbj(mu,b,b1,j) 
#
# Declare distributed arrays 
# --------------------------- 
#
      distributed Vxxpi(mu,nu,p,i)
      distributed VDxxxi(mu,nu,lambda,i)
#
# Define scalars 
# -------------- 
#
      scalar e1 
      scalar e2 
      scalar e3 
      scalar esum 


      PROC READF12INT

#-----------Read intermediates from the disk----------------------------------------------
#
#------------- T1-intermediates----------------------------------------------------------
      execute list_to_blocks          T1_1
      execute list_to_blocks          T1_2
      execute list_to_blocks          T1_3
      execute list_to_blocks          T1_4
#------------ T2-intermediates----------------------------------------------------------
      execute list_to_blocks          T2_1
      execute list_to_blocks          T2_2
      execute list_to_blocks          T2_3
      execute list_to_blocks          T2_4
      execute list_to_blocks          T2_5
      execute list_to_blocks          T2_6
      execute list_to_blocks          T2_7
      execute list_to_blocks          T2_8
      execute list_to_blocks          T2_9
      execute list_to_blocks          T2_10
      execute list_to_blocks          T2_11
#----------- Lambda - intermediates ---------------------------------------------------
      execute list_to_blocks          LAM_1
      execute list_to_blocks          LAM_2
      execute list_to_blocks          LAM_3
      execute list_to_blocks          LAM_4
      execute list_to_blocks          LAM_5
      execute list_to_blocks          ELAM
#----------- Additional integrals for T2 - amplitudes----------------------------------
      execute list_to_blocks          auxint1
      execute list_to_blocks          V2piai
      execute list_to_blocks          V0pipi
      execute list_to_blocks          V0apai
      execute list_to_blocks          V0aapi
#---Here we read arrays of integrals from the disk---|
      execute read_list_to_blocks
#----------------------------------------------------|

      ENDPROC READF12INT 
#
#    ------------------------------------------------------------------------
#
#    DEFINE PROCEDURES  
#
#    ------------------------------------------------------------------------
#
#    Compute the integrals and store in the served array saoint. 
#
     PROC COMP_INTEGRALS 
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda, sigma
#
              compute_integrals                    AOINT(mu,nu,lambda,sigma)
#             prepare saoint(mu,nu,lambda,sigma) = AOINT(mu,nu,lambda,sigma) 
#
     ENDPARDO mu, nu, lambda, sigma
     execute server_barrier 
#
#    ------------------------------------------------------------------------
#
     ENDPROC COMP_INTEGRALS 
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the first two stages of the transformation in two N5 steps. 
#
     PROC TRAN_TRAN2 
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
#
          allocate Txxxi(mu,nu,lambda,*)
#
          DO sigma
#
             compute_integrals            aoint(mu,nu,lambda,sigma)
#
             DO i   
#
                 T1xxxi(mu,nu,lambda,i)  = aoint(mu,nu,lambda,sigma)*ca(sigma,i)
                 Txxxi(mu,nu,lambda,i)  += T1xxxi(mu,nu,lambda,i)  
#
             ENDDO i   
#
          ENDDO sigma

          DO i
             T1xxxi(mu,nu,lambda,i)         = Txxxi(mu,nu,lambda,i) 
             PREPARE Vxxxi(mu,nu,lambda,i)  = T1xxxi(mu,nu,lambda,i)

           DO i1
#
              Txxii(mu,nu,i1,i)          = Txxxi(mu,nu,lambda,i)*ca(lambda,i1)
              PREPARE Vxxii(mu,nu,i1,i) += Txxii(mu,nu,i1,i)
              Txixi(mu,i1,lambda,i)      = Txxxi(mu,nu,lambda,i)*ca(nu,i1)
              PREPARE Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
              Tixxi(i1,nu,lambda,i)      = Txxxi(mu,nu,lambda,i)*ca(mu,i1)
              PREPARE Vixxi(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i)
#
           ENDDO i1
           ENDDO i
#
          deallocate Txxxi(mu,nu,lambda,*)
#
     ENDPARDO mu, nu, lambda 
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
        ALLOCATE Lxxai(mu,nu,*,i)
#
        DO lambda
           REQUEST Vxxxi(mu,nu,lambda,i) i

           DO a
              Txxai(mu,nu,a,i) = Vxxxi(mu,nu,lambda,i)*ca(lambda,a)
              Lxxai(mu,nu,a,i) += Txxai(mu,nu,a,i)
           ENDDO a 

        ENDDO lambda
#
        DO a
           PREPARE Vxxai(mu,nu,a,i) = Lxxai(mu,nu,a,i)
        ENDDO a

        DEALLOCATE Lxxai(mu,nu,*,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
     destroy Vxxxi
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2 
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.  
#
     PROC TRAN_TRAN3 
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxixi(mu,i,nu,i1) i1 
           REQUEST Vxxii(mu,nu,i,i1) i1 
           REQUEST Vixxi(i,mu,nu,i1) i1 
#
           DO p 
#
              Txipi(mu,i,p,i1)          = Vxixi(mu,i,nu,i1)*ca(nu,p)
              PREPARE Vxipi(mu,i,p,i1) += Txipi(mu,i,p,i1)
#
           ENDDO p 
#
           DO a
#
              Txaii(mu,a,i,i1)          = Vxxii(mu,nu,i,i1)*ca(nu,a)
              Tixai(i,mu,a,i1)          = Vixxi(i,mu,nu,i1)*ca(nu,a)
# 
              PREPARE Vxaii(mu,a,i,i1) += Txaii(mu,a,i,i1)
              PREPARE Vixai(i,mu,a,i1) += Tixai(i,mu,a,i1)
#
           ENDDO a
#
     ENDPARDO mu, nu, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, a, i
#
        ALLOCATE Lxaai(mu,*,a,i)

        DO nu
           REQUEST Vxxai(mu,nu,a,i) i 
#
           DO a1 
#
              T1xaai(mu,a1,a,i)          = Vxxai(mu,nu,a,i)*ca(nu,a1)
              Lxaai(mu,a1,a,i) += T1xaai(mu,a1,a,i)
#
           ENDDO a1 
        ENDDO nu
#
        DO a1
           PREPARE Vxaai(mu,a1,a,i) = Lxaai(mu,a1,a,i)
        ENDDO a1

        DEALLOCATE Lxaai(mu,*,a,i)
     ENDPARDO mu, a, i
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
     destroy Vxxai
#
     ENDPROC TRAN_TRAN3 
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4 
#
#    ------------------------------------------------------------------------
#
     PARDO mu, p, i, i1
#
           REQUEST             Vxipi(mu,i,p,i1) i1 
           REQUEST             Vxipi(mu,i1,p,i) i 
           Txipi(mu,i,p,i1)  = Vxipi(mu,i,p,i1) 
           T1xipi(mu,i,p,i1) = Vxipi(mu,i1,p,i) 
           Txipi(mu,i,p,i1) -= T1xipi(mu,i,p,i1) 
#
           DO p1 
#
              Tpipi(p1,i,p,i1)          = Vxipi(mu,i,p,i1)*ca(mu,p1)
              PREPARE Vpiqj(p1,i,p,i1) += Tpipi(p1,i,p,i1) 
#
           ENDDO p1 
#
           DO p1 
#
              Tpipi(p1,i,p,i1)           = Txipi(mu,i,p,i1)*ca(mu,p1)
              PREPARE VSpipi(p1,i,p,i1) += Tpipi(p1,i,p,i1) 
#
           ENDDO p1 
#
     ENDPARDO mu, p, i, i1
#
     PARDO mu, a, i, i1
#
           REQUEST Vxaii(mu,a,i,i1) i1 
           REQUEST Vixai(i,mu,a,i1) i1 
#
           DO a1 
#
              Taaii(a1,a,i,i1)          = Vxaii(mu,a,i,i1)*ca(mu,a1)
              PREPARE Vaaii(a1,a,i,i1) += Taaii(a1,a,i,i1)
#
           ENDDO a1 
#
           DO a1 
#
              Tiaai(i,a1,a,i1)          = Vixai(i,mu,a,i1)*ca(mu,a1)
              PREPARE Viaai(i,a1,a,i1) += Tiaai(i,a1,a,i1)
#
           ENDDO a1 
#
     ENDPARDO mu, a, i, i1
# 
     PARDO a, a1, i
#
        ALLOCATE Laaai(*,a,a1,i)

        DO mu
           REQUEST Vxaai(mu,a,a1,i) i 
#
           DO a2  
#
              T1aaai(a2,a,a1,i)          = Vxaai(mu,a,a1,i)*ca(mu,a2)
              Laaai(a2,a,a1,i)          += T1aaai(a2,a,a1,i)
#
           ENDDO a2  
        ENDDO mu
#
        DO a2
           T1aaai(a1,a,a2,i)          = Laaai(a2,a,a1,i)
           PREPARE VSaaai(a2,a,a1,i)  = Laaai(a2,a,a1,i)
          #T1aaai(a1,a,a2,i)         *= -1.0
          #PREPARE VSaaai(a1,a,a2,i) += T1aaai(a1,a,a2,i)
        ENDDO a2

        DEALLOCATE Laaai(*,a,a1,i) 

     ENDPARDO a, a1, i
# 
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN4 
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------ 
#
     PROC TRAN_UHF 
# 
#        CALL COMP_INTEGRALS # --> compute integrals and put into served array 
         CALL TRAN_TRAN2     # --> performs the first two stages of the 
                             #     two-electron integral transformation.  
         CALL TRAN_TRAN3     # --> performs the third stage   
                             #     two-electron integral transformation.  
         CALL TRAN_TRAN4     # --> performs the fourth stage of the  
                             #     two-electron integral transformation.  
#
     ENDPROC TRAN_UHF 
#
#    ------------------------------------------------------------------------ 
#
#    Main Program 
#
#    ------------------------------------------------------------------------ 
#
     execute server_barrier 
#-----------Read of F12 - intermediates--------------------------------------
     CALL READF12INT
     execute server_barrier
#----------------------------------------------------------------------------
     CALL TRAN_UHF 
     execute server_barrier 
     destroy Vxaai
#
# Write transformed two-electron integrals to list 
# ------------------------------------------------ 
# 
      execute server_barrier
#----------------------------------------------------------------------------
      execute blocks_to_list                VSpipi(p,i,p1,i1)   
      execute blocks_to_list                Vaaii   
      execute blocks_to_list                Viaai   
      execute blocks_to_list                VSaaai 
      execute blocks_to_list                Vpiqj(p,i,q,j)  

#---------------- F12 - intermediates----------------------------------------
#-----------Write intermediates to the disk----------------------------------------------

#------------- T1-intermediates----------------------------------------------------------
      execute blocks_to_list          T1_1
      execute blocks_to_list          T1_2
      execute blocks_to_list          T1_3
      execute blocks_to_list          T1_4
#------------ T2-intermediates----------------------------------------------------------
      execute blocks_to_list          T2_1
      execute blocks_to_list          T2_2
      execute blocks_to_list          T2_3
      execute blocks_to_list          T2_4
      execute blocks_to_list          T2_5
      execute blocks_to_list          T2_6
      execute blocks_to_list          T2_7
      execute blocks_to_list          T2_8
      execute blocks_to_list          T2_9
      execute blocks_to_list          T2_10
      execute blocks_to_list          T2_11
#----------- Lambda - intermediates ----------------------------------------------------
      execute blocks_to_list          LAM_1
      execute blocks_to_list          LAM_2
      execute blocks_to_list          LAM_3
      execute blocks_to_list          LAM_4
      execute blocks_to_list          LAM_5
      execute blocks_to_list          ELAM
#----------- Additional integrals for T2 - amplitudes-----------------------------------
      execute blocks_to_list          auxint1
      execute blocks_to_list          V2piai
      execute blocks_to_list          V0pipi
      execute blocks_to_list          V0apai
      execute blocks_to_list          V0aapi
#----------------------------------------------------------------------------
 
      execute write_blocks_to_list
      execute server_barrier
# 
# Done Write transformed two-electron integrals to list 
# ----------------------------------------------------- 
# 
#    ------------------------------------------------------------------------ 
# 
#
                           ENDSIAL TRAN_RHF_SV1_fc    
#
#    ------------------------------------------------------------------------ 
#
