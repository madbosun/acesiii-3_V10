#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                   SIAL RHF_HESS_SV1_OPT2  
#
# ---------------------------------------------------------------------------
#
#    PROCEDURE                 OPITIMIZATION 
#
# ---------------------------------------------------------------------------
#
#    PROC TRAN_TRAN2           DONE 
#    PROC TRAN_TRAN3           DONE 
#    PROC TRAN_TRAN4           DONE 
#    PROC CREATE_MOINTS        DONE 
#    PROC TRAN_UHF             DONE 
#    PROC UHF_ENERGY           DONE 
#    PROC T2AA_REFERANCE       DONE 
#    PROC T2BB_REFERANCE       DONE 
#    PROC T2AB_REFERANCE       DONE 
#    PROC PINTER               DONE 
#    PROC DENSIJ
#    PROC DENSAB
#    PROC DENSAI
#    PROC FORM_UYAI            DONE  
#    PROC FORM_UXAI            DONE  
#    PROC DINT_TRAN 
#    PROC TRAN_VX_XIXI         DONE  
#    PROC QYAI_H 
#    PROC QXAI_H 
#    PROC FINTY_TRAN 
#    PROC FINTX_TRAN 
#    PROC SINTY_TRAN 
#    PROC SINTX_TRAN 
#    PROC Uy_XX                DONE  
#    PROC Ux_XX                DONE  
#    PROC I_TRANS
#    PROC D_TRANS
#    PROC I_HF
#    PROC HFDENS
#    PROC I11
#    PROC SXY_CONT
#    PROC DXY_CONT
#    PROC GIJAB_CONT
#    PROC FSCF_HESS               DONE  
#    PROC FORMDDAB 
#    PROC FORMDDIJ 
#    PROC PART1                   DONE  
#    PROC PART2                   DONE  
#    PROC PART4                   DONE  
#    PROC PART5                   DONE  
#    PROC PART6                   DONE  
#    PROC DERIIJ                  DONE  
#    PROC DERIAB                  DONE  
#    PROC DERIAI                  DONE  
#    PROC PART3                   DONE  
#    PROC DERVYFULLAB             DONE  
#    PROC DERVYFULLAA             DONE 
#    PROC DERVYFULLBB             DONE  
#    PROC FORMDXAI                DONE 
#    PROC FORMDDAI                DONE 
#    PROC DT2AMP                  OBSOLETE  
#
# ---------------------------------------------------------------------------
#
# Final set of of fully transformed integrals INCLUDING the 4-virtual ones.
#
# ---------------------------------------------------------------------------
#
#                          Integral     Tyqe
#                         ------------------------
#                         VSpipi       SERVED  
#                         Vaaii        SERVED  
#                         Viaai        SERVED 
#                         VSaaai       SERVED  
#
#                         VSqjqj       SERVED  
#                         Vbbjj        SERVED  
#                         Vjbbj        SERVED  
#                         VSbbbj       SERVED  
#
#                         Vbbii        SERVED  
#                         Vjbii        SERVED  
#                         Vbbai        SERVED  
#                         Vpiqj        SERVED  
#                         Vaajj        SERVED  
#                         Viabj        SERVED  
#                         Vaabj        SERVED  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
# Declare indices. 
# ---------------- 
#
     index   kiter  = 1, 100 
     index   iatom  = 1, natoms  
     index   ix     = 1, 3 # 3  
     index   jatom  = 1, natoms  
     index   jx     = 1, 3 # 3  
#
     aoindex mu     = 1, norb
     aoindex nu     = 1, norb
     aoindex lambda = 1, norb
     aoindex sigma  = 1, norb
#
     moaindex i = baocc, eaocc
     moaindex i1= baocc, eaocc
     moaindex i2= baocc, eaocc
     moaindex i3= baocc, eaocc
     moaindex i4= baocc, eaocc
#
     moaindex a = bavirt, eavirt
     moaindex a1= bavirt, eavirt
     moaindex a2= bavirt, eavirt
     moaindex a3= bavirt, eavirt
     moaindex a4= bavirt, eavirt
#
     moaindex j = baocc, eaocc
     moaindex j1= baocc, eaocc
     moaindex j2= baocc, eaocc
     moaindex j3= baocc, eaocc
     moaindex j4= baocc, eaocc
#
     moaindex b = bavirt, eavirt
     moaindex b1= bavirt, eavirt
     moaindex b2= bavirt, eavirt
     moaindex b3= bavirt, eavirt
     moaindex b4= bavirt, eavirt
#
     moaindex p = baocc, eavirt
     moaindex p1= baocc, eavirt
     moaindex p2= baocc, eavirt
     moaindex p3= baocc, eavirt
#
     moaindex q = baocc, eavirt
     moaindex q1= baocc, eavirt
     moaindex q2= baocc, eavirt
     moaindex q3= baocc, eavirt
#
# Declare served arrays. 
# ----------------------
#
     temp saoint(mu,nu,lambda,sigma) 
     static dflags2(jatom,jx) 
     static dflags4(jatom,jx,iatom,ix) 
     distributed Lhess(jatom,jx,iatom,ix) 
     temp phess(jatom,jx,iatom,ix) 
     temp thess(jatom,jx,iatom,ix) 
     temp xhess(iatom,ix,jatom,jx) 
     distributed Dthess(jatom,jx,iatom,ix) 
     distributed Dxhess(jatom,jx,iatom,ix) 
     distributed CPHFa(p,p1,iatom,ix) 
     temp tqqss(q,q1,jatom,jx)       
     temp t1qqss(q,q1,jatom,jx)       
     temp tppss(p,p1,jatom,jx)       
     temp t1ppss(p,p1,jatom,jx)       
#
     distributed Tint(mu,nu,lambda,sigma)
     distributed DDxxxi(mu,nu,lambda,i)
#
# Declare served arrays which are used to hold the perturbed quantities 
# depending on the two-electrin derivative integrals. 
# --------------------------------------------------------------------- 
#
#    served VTpipi(a,i,a1,i1,iatom,ix)  
#    served VTqjqj(b,j,b1,j1,jatom,jx)  
     served VTpiqj(a,i,b,j,iatom,ix)   
     served HTa(p,p1,iatom,ix)
     served STa(p,p1,iatom,ix)
     served QTABxx(mu,nu,iatom,ix)
     served QTAxx(mu,nu,iatom,ix)
#
# Declare distributed arrays. 
# --------------------------- 
#
     served VXxixi(mu,i,nu,i1) 
     served VXxixj(mu,i,nu,j) 
     served VXxjxj(mu,j,nu,j1) 
     served VXxipi(mu,i,a1,i1) 
     served VXxiqj(mu,i,b,j) 
     served VXxjqj(mu,j,b1,j1) 
     served VYaiii(a,i,i1,i2) 
     served VYiiii(i,i1,i2,i3) 

     served VYaibj(a,i,b,j) 
     served VYaajj(a,a1,j,j1) 
     served VYiabj(i,a,b,j) 
     served VYaabj(a,a1,b,j) 
     served VYiibj(i,i1,b,j) 
#
#    served VXpiqj(a,i,b,j) 
#    served VXqjqj(b,j,b1,j1) 
#
     served Vxixi(mu,i,nu,i1) 
     served Vxixj(mu,i,nu,j) 
     served Vxjxj(mu,j,nu,j1) 
#
     served T1aiai_aa(a,i,a1,i1)#----|  
     served T1bjbj_bb(b,j,b1,j1)#    |  
     served T1aibj_ab(a,i,b,j)  #    |--> Unperturbed amplitudes   
     served DTpppi(p,p1,p2,i)#-------|  
     served DTqqqj(q,q1,q2,j)#       |--> Transformed 2-el derivative integrals 
     served DTppqj(p,p1,q,j)#        |  
     served DTqqpi(q,q1,p,i)#--------|  
#
     served T2yFullaa(a,i,a1,i1)#    |  
     served T2yFullab(a,i,b,j)#      |  
     served T2yFullbb(b,j,b1,j1)#    |  
#
     served DTxxpi(mu,nu,p,i) 
     served DTxxqj(mu,nu,q,j) 
     served DTxppi(mu,p1,p,i) 
     served DTxqqj(mu,q1,q,j) 
    #served DTxqpi(mu,q,p,i) 
     served DTxpqj(mu,p,q,j) 
#
     distributed Dij_a(i,i1)#-------------|  
     distributed Dij_b(j,j1)#             | 
     distributed Dab_a(a,a1)#             |  
     distributed Dab_b(b,b1)#             |--> Density   
     distributed Dai_a(a,i) #             |  
     distributed Dai_b(b,j)#--------------|  
     distributed Daiold_a(a,i) 
     distributed Daiold_b(b,j) 
     distributed Dainew_a(a,i) 
     distributed Dainew_b(b,j) 
     distributed Iij_a(i,i1) 
     distributed Iij_b(j,j1) 
     distributed Iai_a(a,i) 
     distributed Iai_b(b,j) 
     distributed Iab_a(a,a1) 
     distributed Iab_b(b,b1) 
     distributed Ipq_a(p,p1) 
     distributed Ipq_b(q,q1) 
     distributed Xai_a(a,i) 
     distributed Xai_b(b,j) 
     distributed Ixx_a(mu,nu) 
     distributed Ixx_b(mu,nu) 
     distributed Dxx_a(mu,nu) 
     distributed Dxx_b(mu,nu) 
     distributed Dpq_a(p,p1) 
     distributed Dpq_b(q,q1) 
     distributed Ihf(mu,nu) 
     distributed Ihfa(mu,nu) 
     distributed Ihfb(mu,nu) 
     distributed Dhfa(mu,nu) 
     distributed Dhfb(mu,nu) 
     distributed Dhfmo_a(p,p1) 
     distributed Dhfmo_b(q,q1) 
     distributed Stemp(mu,p) 
     local LDHFa(mu,nu)  
     local LDxx_a(mu,nu) 
     local La(p,mu) 
#
     distributed Uxaa(p,p1) 
     distributed Uyaa(p,p1) 
     local SUyaa(p,p1) 
     distributed Fxaa(p,p1) 
     distributed Fyaa(p,p1) 
     distributed Fybb(q,q1) 
     distributed Fxai(a,i) 
     distributed Fya(p,p1) 
     distributed Fyb(q,q1) 
     distributed Fxa(p,p1) 

     distributed Hxa(p,p1) 
     distributed Hxb(q,q1) 
     distributed Hya(p,p1) 
     distributed Hyb(q,q1) 
     distributed Hx_xp(mu,p) 
     distributed Hx_xq(mu,q) 
     distributed Hx_px(p,mu) 
     distributed Hx_qx(q,mu) 
     distributed Hx_pp(p,p1) 
     distributed Hx_qq(q,q1) 

     distributed Sya(p,p1) 
     distributed Sxa(p,p1) 
     distributed Sxb(q,q1) 
     distributed FA(p,p1) 
     distributed FB(q,q1) 
     distributed Qyai(a,i)  
     distributed Qxai(a,i)  
#
     distributed QAyy(mu,sigma) 
     distributed QByy(mu,sigma) 
     distributed QABxx(mu,sigma) 
     distributed QAxx(mu,sigma) 
     distributed QAB(mu,sigma) 
     distributed QA(mu,sigma) 
     distributed QB(mu,sigma) 
     distributed Uyai(a,i)   
     distributed Uybj(b,j)   
     distributed Uxai(a,i)   
     distributed Uxbj(b,j)   
     distributed Uyaiold(a,i)   
     distributed Uybjold(b,j)   
     distributed Uxaiold(a,i)   
     distributed Uxbjold(b,j)   
     distributed XAB(mu,nu) 
     distributed XA(mu,nu) 
     distributed XB(mu,nu) 
     distributed YAB(mu,nu) 
     distributed YA(mu,nu) 
     distributed YB(mu,nu) 
     distributed Ha(p,p1) 
     distributed Hb(q,q1) 
     distributed ID_a(p,p1)  
     distributed ID_b(q,q1)  
#
     distributed cya(mu,p) 
     distributed cyb(mu,q) 
     distributed cxa(mu,p) 
     distributed cxb(mu,q) 
     distributed dhfya(mu,nu) 
     distributed dhfyb(mu,nu) 
     distributed dhfxa(mu,nu) 
     distributed whfya(mu,nu) 
     distributed whfyb(mu,nu) 
     distributed whfa(mu,nu) 
     distributed whfb(mu,nu) 
#
     distributed pp1(p,p1) 
     distributed qq1(q,q1) 
     distributed pp5a(p,a) 
     distributed pp5b(a,i) 
     distributed pp5c(i,i1) 
     distributed pp5d(p,a) 
     distributed pp5e(p,i) 
     distributed qq5a(q,b) 
     distributed qq5b(b,j) 
     distributed qq5c(j,j1) 
     distributed qq5d(q,b) 
     distributed qq5e(q,j) 
#
# Declare arrays used in the transformation of the two-electron integrals. 
# ------------------------------------------------------------------------ 
#
      served Sxixi(mu,i,nu,i1) 
      served Sxixj(mu,i,nu,j) 
      served Sxjxj(mu,j,nu,j1) 
#
      served Vxxxi(mu,nu,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
      served Vxipi(mu,i,p,i1)
      served Vixai(i,mu,a,i1)
      served Vxaii(mu,a,i,i1)
      served Vxaai(mu,a1,a,i)
      served Vxxai(mu,nu,a,i)
      served Vxxxa(mu,nu,lambda,a) 
      served Vxxaa(mu,nu,a1,a) 
      served Vxaaa(mu,a2,a1,a) 
#
      served VSpipi(p1,i,p,i1)
      served Viaai(i,a1,a,i1)
      served Vaaii(a,a1,i,i1)
      served VSaaai(a2,a,a1,i)
#
      served Vxxxj(mu,nu,lambda,j)
      served Vxxjj(mu,nu,j1,j)
      served Vjxxj(j1,nu,lambda,j)
      served Vxjqj(mu,j,q,j1)
      served Vxbjj(mu,b,j,j1)
      served Vxbbj(mu,b1,b,j)
      served Vxxbj(mu,nu,b,j)
      served Vjxbj(j,mu,b,j1)
      served Vxxxb(mu,nu,lambda,b) 
      served Vxxbb(mu,nu,b1,b) 
      served Vxbbb(mu,b2,b1,b) 
      served VSqjqj(q1,j,q,j1)
      served Vjbbj(j,b1,b,j1)
      served Vbbjj(b,b1,j,j1)
      served VSbbbj(b2,b,b1,j)
#
      served Vxbii(mu,b,i,i1)
      served Vxbai(mu,b,a,i)
      served Vxabb(mu,a,b1,b) 
      served Vjbii(j,b,i,i1)
      served Vbbii(b,b1,i,i1)
      served Vbbai(b,b1,a,i)
#
      served Vxiqj(mu,i,q,j)
      served Vxajj(mu,a,j,j1)
      served Vxabj(mu,a,b,j)
      served Vxxij(mu,nu,i,j)
      served Vixxj(i,mu,nu,j)
      served Vixbj(i,mu,b,j)
      served Vpiqj(p,i,q,j)
      served Vaajj(a,a1,j,j1)
      served Viabj(i,a,b,j)
      served Vaabj(a,a1,b,j)
      temp Txjxj(mu,j1,lambda,j)
      temp T1xjxj(mu,j1,lambda,j)
      temp Txxjj(mu,nu,j1,j)
      temp T1xxjj(mu,nu,j1,j)
      temp Tjjxx(j1,nu,lambda,j)
      temp Tjxxj(j1,nu,lambda,j)
      temp T1jxxj(j1,nu,lambda,j)
      temp Txjqj(mu,j,q,j1)
      temp T1xjqj(mu,j,q,j1)
      temp Tqjqj(q1,j,q,j1)
      temp T1qjqj(q1,j,q,j1)
      temp Tjxbj(j,mu,b,j1)
      temp T1jxbj(j,mu,b,j1)
      temp Txbjj(mu,b,j,j1)
      temp T1xbjj(mu,b,j,j1)
      temp Tjbbj(j,b1,b,j1)
      temp T1jbbj(j,b1,b,j1)
      temp Tbbjj(b,b1,j,j1)
      temp T1bbjj(b,b1,j,j1)
      temp Txbbj(mu,b1,b,j)
      temp T1xbbj(mu,b1,b,j)
      temp Tbbbj(b2,b,b1,j)
      temp T1bbbj(b2,b,b1,j)
      temp Txxbj(mu,nu,b,j)
      temp Txixj(mu,i,nu,j)
      temp T1xixj(mu,i,nu,j)
      temp Txiqj(mu,i,q,j)
      temp T1xiqj(mu,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp T1piqj(p,i,q,j)
      temp Tiixx(i,i1,mu,nu)
      temp Tiixb(i,i1,mu,b)
      temp Tiibb(i,i1,b1,b)
      temp Txajj(mu,a,j,j1)
      temp T1xajj(mu,a,j,j1)
      temp Taajj(a,a1,j,j1)
      temp T1aajj(a,a1,j,j1)
      temp Txabj(mu,a,b,j)
      temp T1xabj(mu,a,b,j)
      temp Tixxj(i,mu,nu,j)
      temp Tixbj(i,mu,b,j)
      temp T1ixbj(i,mu,b,j)
      temp Tiabj(i,a,b,j)
      temp T1iabj(i,a,b,j)
      temp Taabj(a,a1,b,j)
      temp T1aabj(a,a1,b,j)
#
      temp Txbii(mu,b,i,i1)
      temp T1xbii(mu,b,i,i1)
      temp Tbbii(b,b1,i,i1)
      temp T1bbii(b,b1,i,i1)
      temp Tjbii(j,b,i,i1)
      temp T1jbii(j,b,i,i1)
      temp Txbai(mu,b,a,i)
      temp T1xbai(mu,b,a,i)
      temp Tbbai(b,b1,a,i)
      temp T1bbai(b,b1,a,i)
#
      temp Taaai(a,a1,a2,i)
      temp T1aaai(a,a1,a2,i)
      temp Txxai(mu,nu,a,i)
      temp Txaai(mu,a,a1,i)
      temp T1xaai(mu,a,a1,i)
      temp Txaii(mu,a,i,i1)
      temp T1xaii(mu,a,i,i1)
      temp Tiaai(i,a,a1,i1)
      temp T1iaai(i,a,a1,i1)
      temp Taaii(a,a1,i,i1)
      temp T1aaii(a,a1,i,i1)
      temp T1xxai(mu,nu,a,i)
      temp Tixai(i,mu,a,i1)
      temp T1ixai(i,mu,a,i1)
      temp Txipi(mu,i,p1,i1)
      temp T1xipi(mu,i,p1,i1)
      temp Tpipi(p,i,p1,i1)
      temp T1pipi(p,i,p1,i1)
      temp T1xxbj(mu,nu,b,j)
#
      temp Txxij(mu,nu,i,j)
      temp T1xxij(mu,nu,i,j)
      temp T1ixxj(i,mu,nu,j)
      temp Txxxi(mu,nu,lambda,i)
      temp T1xxxi(mu,nu,lambda,i)
      temp Txxxj(mu,nu,lambda,j)
      temp T1xxxj(mu,nu,lambda,j)
      temp Txixi(mu,i,nu,i1)
      temp T1xixi(mu,i,nu,i1)
      temp Txxii(mu,nu,i1,i)
      temp T1xxii(mu,nu,i1,i)
      temp Tixxi(i1,mu,nu,i)
      temp T1ixxi(i1,mu,nu,i)
      temp V0xxxi(mu,nu,lambda,i) 
      temp V2xxxi(mu,nu,sigma,i)  
      temp V0xxxj(mu,nu,lambda,j) 
      temp V2xxxj(mu,nu,sigma,j)  
#
      temp Txxxa(mu,nu,lambda,a)
      temp T1xxxa(mu,nu,lambda,a)
      temp Txxaa(mu,nu,a1,a)
      temp T1xxaa(mu,nu,a1,a)
      temp Txaaa(mu,a2,a1,a)
      temp T1xaaa(mu,a2,a1,a)
      temp Taaaa(a3,a2,a1,a)
      temp T1aaaa(a3,a2,a1,a)
#
      temp Txxxb(mu,nu,lambda,b)
      temp T1xxxb(mu,nu,lambda,b)
      temp Txxbb(mu,nu,b1,b)
      temp T1xxbb(mu,nu,b1,b)
      temp Txbbb(mu,b2,b1,b)
      temp T1xbbb(mu,b2,b1,b)
      temp Tbbbb(b3,b2,b1,b)
      temp T1bbbb(b3,b2,b1,b)
#
      temp Txabb(mu,a2,b1,b)
      temp T1xabb(mu,a2,b1,b)
      temp Taabb(a3,a2,b1,b)
      temp T1aabb(a3,a2,b1,b)
#
      temp tiiaa(i,i1,a,a1) 
      temp t1iiaa(i,i1,a,a1) 
      temp taiia(a,i,i1,a1) 
      temp t1aiia(a,i,i1,a1) 
#
      temp tjjbb(j,j1,b,b1) 
      temp t1jjbb(j,j1,b,b1) 
      temp tbjjb(b,j,j1,b1) 
      temp t1bjjb(b,j,j1,b1) 
#
      temp TSxxxx(mu,nu,lambda,sigma)
      temp TCxxxx(mu,nu,lambda,sigma)
      temp T1xxxx(mu,nu,lambda,sigma)
      temp T2xxxx(mu,nu,lambda,sigma)
      temp T3xxxx(mu,nu,lambda,sigma)
      temp T4xxxx(mu,nu,lambda,sigma)
      temp T5xxxx(mu,nu,lambda,sigma)
      temp T6xxxx(mu,nu,lambda,sigma)
      temp T7xxxx(mu,nu,lambda,sigma)
      temp T8xxxx(mu,nu,lambda,sigma)
      temp T2xxxi(mu,nu,lambda,i)
      temp T3xxxi(mu,nu,lambda,i)
      temp T4xxxi(mu,nu,lambda,i)
      temp T2xxxj(mu,nu,lambda,j)
      temp T3xxxj(mu,nu,lambda,j)
      temp T4xxxj(mu,nu,lambda,j)
      temp TAxxxi(mu,lambda,nu,i1)
      temp TBxxxi(mu,lambda,sigma,i1)
      temp TAxxxj(mu,lambda,nu,j1)
      temp TBxxxj(mu,lambda,sigma,j1)
#
# Declare integral arrays
# ------------------------
#
      temp AOINT(mu,nu,lambda,sigma)
      local TAOINT(mu,nu,lambda,sigma)
      local L1xxxi(mu,nu,lambda,i)
      local L2xxxi(mu,lambda,nu,i)
      local L3xxxi(lambda,mu,nu,i)
      local L1xxxj(mu,nu,lambda,j)
      local L2xxxj(mu,lambda,nu,j)
      local L3xxxj(lambda,mu,nu,j)
      local Lxixi(mu,i,nu,i1)
      local Lxxii(mu,nu,i,i1)
      local Lixxi(i,mu,nu,i1)
      local Lxjxj(mu,j,nu,j1)
      local Lxxjj(mu,nu,j,j1)
      local Ljxxj(j,mu,nu,j1)
      local Lxxai(mu,nu,a,i)
      local Lxxbj(mu,nu,b,j)
      local Lxixj(mu,i,nu,j)
      local Lixxj(i,mu,nu,j)
      local Lxipi(mu,i,p,i1)
      local Lxaii(mu,a,i,i1)
      local Lixai(i,mu,a,i1)
      local L1xaai(mu,a,a1,i)
      local L2xaai(mu,a,a2,i)
      local Lxjqj(mu,j,q,j1)
      local Lxbjj(mu,b,j,j1)
      local Ljxbj(j,mu,b,j1)
      local Lxbbj(mu,b,b1,j)
      local Lxbii(mu,b,i,i1)
      local Lxbai(mu,b,a,i)
      local Lxiqj(mu,i,q,j)
      local Lxajj(mu,a,j,j1)
      local Lixbj(i,mu,b,j)
      local Lxabj(mu,a,b,j)
      local L1xbbj(mu,b,b1,j)
      local Lxxxa(mu,nu,lambda,a) 
      local Lxxxb(mu,nu,lambda,b) 
      local Lxxaa(mu,nu,a1,a) 
      local Lxxbb(mu,nu,b1,b) 
      local Lxaaa(mu,a,a1,a2) 
      local Lxbbb(mu,b,b1,b2) 
      local Lxabb(mu,a2,b1,b2) 
      local Laiai(a,i,a1,i1) 
      local Lbjbj(b,j,b1,j1) 
      local Laibj(a,i,b,j) 
#
      local LX1xixi(mu,i1,lambda,i) 
      local LX1xjxj(mu,j1,lambda,j) 
      local LX1xixj(mu,i,lambda,j) 
      local L2xixi(mu,i,nu,i1) 
      local L2xjxj(mu,j,nu,j1) 
      local L2xixj(mu,i,nu,j) 
      local L3xipi(mu,i,a,i1) 
      local L3xjqj(mu,j,b,j1) 
      local L3xiqj(mu,i,b,j) 
#
# Declare temporary arrays. 
# ------------------------- 
#
     temp Txxxp(mu,nu,lambda,p) 
     temp T1xxxp(mu,nu,lambda,p) 
     temp Txxpp(mu,nu,p1,p) 
     temp T1xxpp(mu,nu,p1,p) 
     temp Txppp(mu,p2,p1,p) 
     temp T1xppp(mu,p2,p1,p) 
     temp Tpppp(p3,p2,p1,p) 
     temp T1pppp(p3,p2,p1,p) 
     temp T2pppp(p3,p2,p1,p) 
     temp T3pppp(p3,p2,p1,p) 
#
     temp Txxxq(mu,nu,lambda,q) 
     temp T1xxxq(mu,nu,lambda,q) 
     temp Txxqq(mu,nu,q1,q) 
     temp T1xxqq(mu,nu,q1,q) 
     temp Txqqq(mu,q2,q1,q) 
     temp T1xqqq(mu,q2,q1,q) 
     temp Tqqqq(q3,q2,q1,q) 
     temp T1qqqq(q3,q2,q1,q) 
     temp T2qqqq(q3,q2,q1,q) 
     temp T3qqqq(q3,q2,q1,q) 
#
     temp Txpqq(mu,p,q1,q) 
     temp T1xpqq(mu,p,q1,q) 
     temp Tppqq(p1,p,q1,q) 
     temp T1ppqq(p1,p,q1,q) 
     temp T2ppqq(p1,p,q1,q) 
     temp Tqqpp(q,q1,p,p1) 
     temp T1qqpp(q,q1,p,p1) 
     temp T2qqpp(q,q1,p,p1) 
#
     temp Taiai(a,i,a1,i1) 
     temp T1aiai(a,i,a1,i1) 
     temp T2aiai(a,i,a1,i1) 
     temp T3aiai(a,i,a1,i1) 
     temp T4aiai(a,i,a1,i1) 
     temp Tbjbj(b,j,b1,j1) 
     temp T1bjbj(b,j,b1,j1) 
     temp T2bjbj(b,j,b1,j1) 
     temp T3bjbj(b,j,b1,j1) 
     temp T4bjbj(b,j,b1,j1) 
     temp Taibj(a,i,b,j) 
     temp T1aibj(a,i,b,j) 
     temp T2aibj(a,i,b,j) 
#
     temp Taiii(a,i,i1,i2)  
     temp T1aiii(a,i,i1,i2) 
     temp Taijj(a,i,j1,j) 
     temp T1aijj(a,i,j1,j) 
     temp Tbjjj(b,j,j2,j1)  
     temp T1bjjj(b,j,j2,j1) 
     temp Tiibj(i1,i,b,j)  
     temp T1iibj(i1,i,b,j) 
#
     temp Txiai(mu,i,a1,i1)
     temp T1xiai(mu,i,a1,i1)
     temp Txjbj(mu,j,b1,j1) 
     temp T1xjbj(mu,j,b1,j1) 
     temp Txibj(mu,i,b,j) 
     temp T1xibj(mu,i,b,j) 
     temp Txxxx(mu,lambda,nu,sigma) 
     temp Txxpi(mu,nu,p,i) 
     temp T1xxpi(mu,nu,p,i) 
     temp Txxqj(mu,nu,q,j) 
     temp T1xxqj(mu,nu,q,j) 
     temp Txppi(mu,p1,p,i) 
     temp Txqqj(mu,q1,q,j) 
     temp Txqpi(mu,q,p,i) 
     temp Txpqj(mu,p,q,j) 
     temp Tpppi(p,p1,p2,i) 
     temp Tqqqj(q,q1,q2,j) 
     temp Tppqj(p,p1,q,j) 
     temp Tqqpi(q,q1,p,i) 
#
     temp T1pppi(p,p1,p2,i) 
     temp T1qqqj(q,q1,q2,j) 
     temp T1ppqj(p,p1,q,j) 
     temp T1qqpi(q,q1,p,i) 
#
     temp Tii(i,i1) 
     temp T1ii(i,i1) 
     temp Tjj(j,j1) 
     temp T1jj(j,j1) 
     temp Taa(a,a1) 
     temp T1aa(a,a1) 
     temp Tbb(b,b1) 
     temp T1bb(b,b1) 
     temp Tai(a,i) 
     temp T1ai(a,i) 
     temp T2ai(a,i) 
     temp T3ai(a,i) 
     temp T4ai(a,i) 
     temp Tbj(b,j)
     temp T1bj(b,j)
     temp T2bj(b,j)
     temp T3bj(b,j)
     temp T4bj(b,j)
     temp Tia(i,a) 
     temp T1ia(i,a) 
     temp Tjb(j,b) 
     temp T1jb(j,b) 
     temp Txi(mu,i) 
     temp T1xi(mu,i) 
     temp Txj(mu,j) 
     temp T1xj(mu,j) 
     temp Txx(mu,nu) 
     temp Txa(mu,a) 
     temp Txb(mu,b) 
     temp tpp(p,p1) 
     temp t1pp(p,p1) 
     temp t2pp(p,p1) 
     temp t3pp(p,p1) 
     temp t4pp(p,p1) 
     temp tqq(q,q1) 
     temp t1qq(q,q1) 
     temp t2qq(q,q1) 
     temp t3qq(q,q1) 
     temp tpi(p,i) 
     temp t1pi(p,i) 
     temp tqj(q,j) 
     temp t1qj(q,j) 
#
     temp t1xx(mu,nu) 
     temp t2xx(mu,nu) 
     temp t3xx(mu,nu) 
     temp t4xx(mu,nu) 
     temp t5xx(mu,nu) 
     temp t6xx(mu,nu) 
     temp t7xx(mu,nu) 
     temp t8xx(mu,nu) 
     temp t9xx(mu,nu) 
     temp tpx(p,mu) 
     temp t1px(p,mu) 
     temp tqx(q,mu) 
     temp t1qx(q,mu) 
     temp txp(mu,p) 
     temp t1xp(mu,p) 
     temp txq(mu,q) 
     temp t1xq(mu,q) 
     temp tax(a,sigma) 
     temp t1ax(a,sigma) 
#
# Declare local arrays. 
# --------------------- 

     temp daoint(mu,nu,lambda,sigma)
     temp faoint(mu,nu,lambda,sigma)
     temp D2(mu,lambda,nu,sigma)  
     local L1xxxp(mu,nu,lambda,p) 
     local L1xxxq(mu,nu,lambda,q) 
     local Lxxpp(mu,nu,p1,p) 
     local Lxxqq(mu,nu,q1,q) 
     local Lxppp(mu,p2,p1,p) 
     local Lxqqq(mu,q2,q1,q) 
     local Lxpqq(mu,p,q1,q) 
#
     local L1aiai(a,i2,a1,i1) 
     local L1aibj(a,i2,b,j) 
     local L1bjai(b,j2,a,i) 
     local L1bjbj(b,j2,b1,j1) 
     local L2aiai(a2,i,a1,i1) 
     local L2aibj(a1,i,b,j) 
     local L2bjbj(b2,j,b1,j1) 
     local L2bjai(b1,j,a,i) 
     local Dxxxi(mu,lambda,nu,i) 
     local Dxxxj(mu,lambda,nu,j) 
     local Exxpi(mu,lambda,p,i) 
     local Exxqj(mu,lambda,q,j) 
     local Fxppi(mu,p1,p,i) 
     local Fxqpi(mu,q,p,i) 
     local Fxqqj(mu,q1,q,j) 
     local Fxpqj(mu,p,q,j) 
     local Fpppi(p2,p1,p,i) 
     local Fqqqj(q2,q1,q,j) 
     local Fqqpi(q1,q,p,i) 
     local Fppqj(p1,p,q,j) 
#
     distributed zeta_a(p,p1) 
     distributed zeta_b(q,q1) 
     distributed zeta(mu,nu)  
#
# One-particle arrays used in 'NEW' implimentation. 
# ------------------------------------------------- 
#
     distributed Dyaa(a,a1) 
     distributed Dyii(i,i1)  
     distributed Dyai(a,i)  
     distributed DIii(i,i1)  
     distributed DIaa(a,a1)  
     distributed DIai(a,i)  
     distributed DXai(a,i)  
#
     distributed VYiijj(i,i1,j,j1)
#
# Arrays and scalars  used in iterative computation of Dai
# --------------------------------------------------------
#
      distributed Doldai_a(a,i)
      distributed Dnewai_a(a,i)
      distributed Doldai_b(b,j)
      distributed Dnewai_b(b,j)
#
      distributed D0ai(a,i)
      distributed D1ai(a,i)
      distributed D2ai(a,i)
      distributed D3ai(a,i)
      distributed D4ai(a,i)
#
      distributed D0bj(b,j)
      distributed D1bj(b,j)
      distributed D2bj(b,j)
      distributed D3bj(b,j)
      distributed D4bj(b,j)
#
      distributed e1ai(a,i)
      distributed e2ai(a,i)
      distributed e3ai(a,i)
      distributed e4ai(a,i)
      distributed e5ai(a,i)
#
      distributed e1bj(b,j)
      distributed e2bj(b,j)
      distributed e3bj(b,j)
      distributed e4bj(b,j)
      distributed e5bj(b,j)
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510
#
       scalar b66
       scalar b67
       scalar b68
       scalar b69
       scalar b610
#
       scalar b77
       scalar b78
       scalar b79
       scalar b710
#
       scalar b88
       scalar b89
       scalar b810
#
       scalar b99
       scalar b910
#
       scalar b1010
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510
#
       scalar Tb66
       scalar Tb67
       scalar Tb68
       scalar Tb69
       scalar Tb610
#
       scalar Tb77
       scalar Tb78
       scalar Tb79
       scalar Tb710
#
       scalar Tb88
       scalar Tb89
       scalar Tb810
#
       scalar Tb99
       scalar Tb910
#
       scalar Tb1010
#
       scalar c1
       scalar c2
       scalar c3
       scalar c4
       scalar c5
       scalar c6
       scalar c7
       scalar c8
       scalar c9
       scalar c10
#
# Arrays used in 'direct' computation of Vabcd terms. 
# ---------------------------------------------------
#
     served TAO_aa(lambda,i,sigma,i1)
     served TAO_bb(lambda,j,sigma,j1)
     served TAO_ab(lambda,i,sigma,j)
     served T1AO_aa(lambda,i,a,i1)
     served T1AO_bb(lambda,j,b,j1)
     served T1AO_ab(lambda,i,b,j)
     served T2AO_aa(lambda,i,sigma,i1)
     served T2AO_bb(lambda,j,sigma,j1)
     served T2AO_ab(lambda,i,sigma,j)
     served VT_aa(a,i,a1,i1) 
     served VT_ab(a,i,b,j) 
     served VT_bb(b,j,b1,j1) 
     distributed VD_aa(mu,nu) 
     distributed VDX_aa(mu,nu) 
     distributed VD_bb(mu,nu) 
     distributed VDX_bb(mu,nu) 
     distributed D_aa(mu,nu) 
     distributed D_bb(mu,nu) 
     distributed VDD_aa(a,a1) 
     distributed VDD_bb(b,b1) 
     distributed VXX_aa(a,a1) 
     distributed VXX_bb(b,b1) 
     local LLaiai(a,i,a1,i1) 
     local LLbjbj(b,j,b1,j1) 
     local LLaibj(a,i,b,j) 
     local Lxiai(lambda,i,a1,i1) 
     local Lxjbj(lambda,j,b1,j1) 
     local Lxibj(lambda,i,b,j) 
     local L1xixi(mu,i,nu,i1) 
     local L1xixj(mu,i,nu,j) 
     local L1xjxj(mu,j,nu,j1) 
     temp  Taixi(a,i,nu,i1) 
     temp  T1aixi(a,i,nu,i1) 
     temp  Tbjxj(b,j,nu,j1) 
     temp  T1bjxj(b,j,nu,j1) 
     temp  Taixj(a,i,nu,j) 
     temp  T1aixj(a,i,nu,j) 
#
# Declare served arrays which are used to hold the perturbed quantities
# depending on the two-electrin derivative integrals.
# ---------------------------------------------------------------------
#
     distributed QTai(a,i,iatom,ix)
     distributed Cainew(a,i,iatom,ix)
     distributed Caiold(a,i,iatom,ix)
     temp taixx(a,i,iatom,ix)
     temp tbjxx(b,j,iatom,ix)
     distributed eT1ai(a,i,iatom,ix)
     distributed eT2ai(a,i,iatom,ix)
     distributed eT3ai(a,i,iatom,ix)
     distributed eT4ai(a,i,iatom,ix)
     distributed eT5ai(a,i,iatom,ix)
     distributed dT0ai(a,i,iatom,ix)
     distributed dT1ai(a,i,iatom,ix)
     distributed dT2ai(a,i,iatom,ix)
     distributed dT3ai(a,i,iatom,ix)
     distributed dT4ai(a,i,iatom,ix)
     distributed dT5ai(a,i,iatom,ix)
#
     served Xaiai(a,i,a1,i1)
     served Xaibj(a,i,b1,j1)
     served Xbjbj(b,j,b1,j1)
#
# Declare scalars. 
# ---------------- 
#
     scalar eold  
     scalar enew 
     scalar ecrit 
     scalar esum 
     scalar etemp 
     scalar ediff 
     scalar ecorra 
     scalar ecorrb 
     scalar ecorraa 
     scalar ecorrbb 
     scalar ecorrab 
     scalar ecorrT 
     scalar hessxy 
     scalar phessxy 
     scalar hessyx 
     scalar phessyx 
     scalar doit  
     scalar dcrit   
#
#    ------------------------------------------------------------------------
#
#    Perform the first two stages of the transformation in two N5 steps.
#
     PROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#     Zero out Vxxxi and Vxxxj
#     ------------------------
#
      PARDO mu, nu, lambda, i
            txxxi(mu,nu,lambda,i)         = 0.0
            PREPARE Vxxxi(mu,nu,lambda,i) = txxxi(mu,nu,lambda,i)
      ENDPARDO mu, nu, lambda, i
#
      execute server_barrier 
#
#     Compute integrals and perform first stage of the transformation.
#     ----------------------------------------------------------------
#
     PARDO mu, nu, lambda, sigma 
#
           compute_integrals              AOINT(mu,nu,lambda,sigma)
#
           DO i
#
              V0xxxi(mu,nu,lambda,i)     = aoint(mu,nu,lambda,sigma)*ca(sigma,i)
              Prepare Vxxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i)
#
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma 
#
      execute server_barrier
#
#    ------------------------------------------------------------------------
#
#    Perform the second stage of the transformation 
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
           allocate L1xxxi(mu,nu,*,i)
#
           DO lambda
#             
              REQUEST                  Vxxxi(mu,nu,lambda,i) i
              L1xxxi(mu,nu,lambda,i) = Vxxxi(mu,nu,lambda,i)
#          
           ENDDO lambda
#          
           DO i1
#             
              Txxii(mu,nu,i1,i) = 0.0
#             
              DO lambda
#                
                 T1xxii(mu,nu,i1,i) = L1xxxi(mu,nu,lambda,i)*ca(lambda,i1)
                 Txxii(mu,nu,i1,i) += T1xxii(mu,nu,i1,i)
#             
              ENDDO lambda
#             
              PREPARE Vxxii(mu,nu,i1,i) = Txxii(mu,nu,i1,i)
#          
           ENDDO i1
#          
           DO a
#             
              Txxai(mu,nu,a,i) = 0.0
#             
              DO lambda
#                
                 T1xxai(mu,nu,a,i) = L1xxxi(mu,nu,lambda,i)*ca(lambda,a)
                 Txxai(mu,nu,a,i) += T1xxai(mu,nu,a,i)
#             
              ENDDO lambda
#             
              PREPARE Vxxai(mu,nu,a,i) = Txxai(mu,nu,a,i)
#          
           ENDDO a
#          
           deallocate L1xxxi(mu,nu,*,i)
#    
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#    
     PARDO mu, nu, i
#          
           allocate L2xxxi(mu,*,nu,i)
#
           DO lambda
#
              REQUEST                  Vxxxi(mu,lambda,nu,i) i
              L2xxxi(mu,lambda,nu,i) = Vxxxi(mu,lambda,nu,i)
#
           ENDDO lambda
#
           DO i1
#
              Txixi(mu,i1,nu,i) = 0.0
#
              DO lambda
#
                 T1xixi(mu,i1,nu,i) = L2xxxi(mu,lambda,nu,i)*ca(lambda,i1)
                 Txixi(mu,i1,nu,i) += T1xixi(mu,i1,nu,i)
#
              ENDDO lambda
#
              PREPARE Sxixi(mu,i1,nu,i) = Txixi(mu,i1,nu,i)
#
           ENDDO i1
#
           deallocate L2xxxi(mu,*,nu,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
           allocate L3xxxi(*,mu,nu,i)
#
           DO lambda
#
              REQUEST                  Vxxxi(lambda,mu,nu,i) i
              L3xxxi(lambda,mu,nu,i) = Vxxxi(lambda,mu,nu,i)
#
           ENDDO lambda
#
           DO i1
#
              Tixxi(i1,mu,nu,i) = 0.0
#
              DO lambda
#
                 T1ixxi(i1,mu,nu,i) = L3xxxi(lambda,mu,nu,i)*ca(lambda,i1)
                 Tixxi(i1,mu,nu,i) += T1ixxi(i1,mu,nu,i)
#
              ENDDO lambda
#
              PREPARE Vixxi(i1,mu,nu,i) = Tixxi(i1,mu,nu,i)
#
           ENDDO i1
#
           deallocate L3xxxi(*,mu,nu,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, j
#
           allocate L1xxxj(mu,nu,*,j)
#
           DO lambda
#
              REQUEST                  Vxxxi(mu,nu,lambda,j) j
              L1xxxj(mu,nu,lambda,j) = Vxxxi(mu,nu,lambda,j)
#
           ENDDO lambda
#
           DO j1
#
              Txxjj(mu,nu,j1,j) = 0.0
#
              DO lambda
#
                 T1xxjj(mu,nu,j1,j) = L1xxxj(mu,nu,lambda,j)*ca(lambda,j1)
                 Txxjj(mu,nu,j1,j) += T1xxjj(mu,nu,j1,j)
#
              ENDDO lambda
#
              PREPARE Vxxjj(mu,nu,j1,j) = Txxjj(mu,nu,j1,j)
#
           ENDDO j1
#
           DO b
#
              Txxbj(mu,nu,b,j) = 0.0
#
              DO lambda
#
                 T1xxbj(mu,nu,b,j) = L1xxxj(mu,nu,lambda,j)*ca(lambda,b)
                 Txxbj(mu,nu,b,j) += T1xxbj(mu,nu,b,j)
#
              ENDDO lambda
#
              PREPARE Vxxbj(mu,nu,b,j) = Txxbj(mu,nu,b,j)
#
           ENDDO b
#
           DO i
#
              Txxij(mu,nu,i,j) = 0.0
#
              DO lambda
#
                 T1xxij(mu,nu,i,j) = L1xxxj(mu,nu,lambda,j)*ca(lambda,i)
                 Txxij(mu,nu,i,j) += T1xxij(mu,nu,i,j)
#
              ENDDO lambda
#
              PREPARE Vxxij(mu,nu,i,j) = Txxij(mu,nu,i,j)
#
           ENDDO i
#
           deallocate L1xxxj(mu,nu,*,j)
#
     ENDPARDO mu, nu, j
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, j
#
           allocate L2xxxj(mu,*,nu,j)
#
           DO lambda
#
              REQUEST                  Vxxxi(mu,lambda,nu,j) j
              L2xxxj(mu,lambda,nu,j) = Vxxxi(mu,lambda,nu,j)
#
           ENDDO lambda
#
           DO j1
#
              Txjxj(mu,j1,nu,j) = 0.0
#
              DO lambda
#
                 T1xjxj(mu,j1,nu,j) = L2xxxj(mu,lambda,nu,j)*ca(lambda,j1)
                 Txjxj(mu,j1,nu,j) += T1xjxj(mu,j1,nu,j)
#
              ENDDO lambda
#
              PREPARE Sxjxj(mu,j1,nu,j) = Txjxj(mu,j1,nu,j)
#
           ENDDO j1
#
           DO i
#
              Txixj(mu,i,nu,j) = 0.0
#
              DO lambda
#
                 T1xixj(mu,i,nu,j) = L2xxxj(mu,lambda,nu,j)*ca(lambda,i)
                 Txixj(mu,i,nu,j) += T1xixj(mu,i,nu,j)
#
              ENDDO lambda
#
              PREPARE Sxixj(mu,i,nu,j) = Txixj(mu,i,nu,j)
#
           ENDDO i
#
           deallocate L2xxxj(mu,*,nu,j)
#
     ENDPARDO mu, nu, j
#
#    ------------------------------------------------------------------------
#
    PARDO mu, nu, j
#
           allocate L3xxxj(*,mu,nu,j)
#
           DO lambda
#
              REQUEST                  Vxxxi(lambda,mu,nu,j) j
              L3xxxj(lambda,mu,nu,j) = Vxxxi(lambda,mu,nu,j)
#
           ENDDO lambda
#
           DO j1
#
              Tjxxj(j1,mu,nu,j) = 0.0
#
              DO lambda
#
                 T1jxxj(j1,mu,nu,j) = L3xxxj(lambda,mu,nu,j)*ca(lambda,j1)
                 Tjxxj(j1,mu,nu,j) += T1jxxj(j1,mu,nu,j)
#
              ENDDO lambda
#
              PREPARE Vjxxj(j1,mu,nu,j) = Tjxxj(j1,mu,nu,j)
#
           ENDDO j1
#
           DO i
#
              Tixxj(i,mu,nu,j) = 0.0
#
              DO lambda
#
                 T1ixxj(i,mu,nu,j) = L3xxxj(lambda,mu,nu,j)*ca(lambda,i)
                 Tixxj(i,mu,nu,j) += T1ixxj(i,mu,nu,j)
#
              ENDDO lambda
#
              PREPARE Vixxj(i,mu,nu,j) = Tixxj(i,mu,nu,j)
#
           ENDDO i
#
           deallocate L3xxxj(*,mu,nu,j)
#
     ENDPARDO mu, nu, j
#
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.
#
     PROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, i1
#
           allocate Lxixi(mu,i,*,i1)
#
           DO nu
#
              REQUEST             Sxixi(mu,i,nu,i1) i1
              Lxixi(mu,i,nu,i1) = Sxixi(mu,i,nu,i1)
#
           ENDDO nu
#
           DO p
#
              Txipi(mu,i,p,i1) = 0.0
#
              DO nu
#
                 T1xipi(mu,i,p,i1) = Lxixi(mu,i,nu,i1)*ca(nu,p)
                 Txipi(mu,i,p,i1) += T1xipi(mu,i,p,i1)
#
              ENDDO nu
#
              PREPARE Vxipi(mu,i,p,i1) = Txipi(mu,i,p,i1)
#
           ENDDO p
#
           deallocate Lxixi(mu,i,*,i1)
#
     ENDPARDO mu, i, i1
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, i1
#
           allocate Lxxii(mu,*,i,i1)
#
           DO nu
#
              REQUEST             Vxxii(mu,nu,i,i1) i1
              Lxxii(mu,nu,i,i1) = Vxxii(mu,nu,i,i1)
#
           ENDDO nu
#
           DO a
#
              Txaii(mu,a,i,i1) = 0.0
#
              DO nu
#
                 T1xaii(mu,a,i,i1) = Lxxii(mu,nu,i,i1)*ca(nu,a)
                 Txaii(mu,a,i,i1) += T1xaii(mu,a,i,i1)

              ENDDO nu
#
              PREPARE Vxaii(mu,a,i,i1) = Txaii(mu,a,i,i1)
#
           ENDDO a
#
           DO b
#
              Txbii(mu,b,i,i1) = 0.0
#
              DO nu
#
                 T1xbii(mu,b,i,i1) = Lxxii(mu,nu,i,i1)*ca(nu,b)
                 Txbii(mu,b,i,i1) += T1xbii(mu,b,i,i1)
#
              ENDDO nu
#
              PREPARE Vxbii(mu,b,i,i1) = Txbii(mu,b,i,i1)
#
           ENDDO b
#
           deallocate Lxxii(mu,*,i,i1)
#
     ENDPARDO mu, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, i1
#
           allocate Lixxi(i,mu,*,i1)
#
           DO nu
#
              REQUEST             Vixxi(i,mu,nu,i1) i1
              Lixxi(i,mu,nu,i1) = Vixxi(i,mu,nu,i1)
#
           ENDDO nu
#
           DO a
#
              Tixai(i,mu,a,i1) = 0.0
#
              DO nu
#
                 T1ixai(i,mu,a,i1) = Lixxi(i,mu,nu,i1)*ca(nu,a)
                 Tixai(i,mu,a,i1) += T1ixai(i,mu,a,i1)

              ENDDO nu
#
              PREPARE Vixai(i,mu,a,i1) = Tixai(i,mu,a,i1)
#
           ENDDO a
#
           deallocate Lixxi(i,mu,*,i1)
#
     ENDPARDO mu, i, i1
#
#    ------------------------------------
#
#    ------------------------------------------------------------------------
#
     PARDO mu, a, i
#
           allocate Lxxai(mu,*,a,i)
#
           DO nu
#
              REQUEST Vxxai(mu,nu,a,i) i
              Lxxai(mu,nu,a,i) = Vxxai(mu,nu,a,i)
#
           ENDDO nu
#
           DO a1
#
              Txaai(mu,a1,a,i) = 0.0
#
              DO nu
#
                 T1xaai(mu,a1,a,i) = Lxxai(mu,nu,a,i)*ca(nu,a1)
                 Txaai(mu,a1,a,i) += T1xaai(mu,a1,a,i)
#
              ENDDO nu
#
              PREPARE Vxaai(mu,a1,a,i) = Txaai(mu,a1,a,i)
#
           ENDDO a1
#
           DO b
#
              Txbai(mu,b,a,i) = 0.0
#
              DO nu
#
                 T1xbai(mu,b,a,i) = Lxxai(mu,nu,a,i)*ca(nu,b)
                 Txbai(mu,b,a,i) += T1xbai(mu,b,a,i)
#
              ENDDO nu
#
              PREPARE Vxbai(mu,b,a,i) = Txbai(mu,b,a,i)
#
           ENDDO b
#
           deallocate Lxxai(mu,*,a,i)
#
     ENDPARDO mu, a, i
#
#    ------------------------------------------------------------------------
#
     PARDO mu, j, j1
#
           allocate Lxjxj(mu,j,*,j1)
#
           DO nu
#
              REQUEST             Sxjxj(mu,j,nu,j1) j1
              Lxjxj(mu,j,nu,j1) = Sxjxj(mu,j,nu,j1)
#
           ENDDO nu
#
           DO q
#
              Txjqj(mu,j,q,j1) = 0.0
#
              DO nu
#
                 T1xjqj(mu,j,q,j1) = Lxjxj(mu,j,nu,j1)*ca(nu,q)
                 Txjqj(mu,j,q,j1) += T1xjqj(mu,j,q,j1)
#
              ENDDO nu
#
              PREPARE Vxjqj(mu,j,q,j1) = Txjqj(mu,j,q,j1)
#
           ENDDO q
#
           deallocate Lxjxj(mu,j,*,j1)
#
     ENDPARDO mu, j, j1
#
#    ------------------------------------------------------------------------
#
    PARDO mu, j, j1
#
           allocate Lxxjj(mu,*,j,j1)
#
           DO nu
#
              REQUEST             Vxxjj(mu,nu,j,j1) j1
              Lxxjj(mu,nu,j,j1) = Vxxjj(mu,nu,j,j1)
#
           ENDDO nu
#
           DO b
#
              Txbjj(mu,b,j,j1) = 0.0
#
              DO nu
#
                 T1xbjj(mu,b,j,j1) = Lxxjj(mu,nu,j,j1)*ca(nu,b)
                 Txbjj(mu,b,j,j1) += T1xbjj(mu,b,j,j1)
#
              ENDDO nu
#
              PREPARE Vxbjj(mu,b,j,j1) = Txbjj(mu,b,j,j1)
#
           ENDDO b
#
           DO a
#
              Txajj(mu,a,j,j1) = 0.0
#
              DO nu
#
                 T1xajj(mu,a,j,j1) = Lxxjj(mu,nu,j,j1)*ca(nu,a)
                 Txajj(mu,a,j,j1) += T1xajj(mu,a,j,j1)
#
              ENDDO nu
#
              PREPARE Vxajj(mu,a,j,j1) = Txajj(mu,a,j,j1)
#
           ENDDO a
#
           deallocate Lxxjj(mu,*,j,j1)
#
     ENDPARDO mu, j, j1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, j, j1
#
           allocate Ljxxj(j,mu,*,j1)
#
           DO nu
#
              REQUEST             Vjxxj(j,mu,nu,j1) j1
              Ljxxj(j,mu,nu,j1) = Vjxxj(j,mu,nu,j1)
#
           ENDDO nu
#
           DO b
#
              Tjxbj(j,mu,b,j1) = 0.0
#
              DO nu
#
                 T1jxbj(j,mu,b,j1) = Ljxxj(j,mu,nu,j1)*ca(nu,b)
                 Tjxbj(j,mu,b,j1) += T1jxbj(j,mu,b,j1)

              ENDDO nu
#
              PREPARE Vjxbj(j,mu,b,j1) = Tjxbj(j,mu,b,j1)
#
           ENDDO b
#
           deallocate Ljxxj(j,mu,*,j1)
#
     ENDPARDO mu, j, j1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, b, j
#
           allocate Lxxbj(mu,*,b,j)
#
           DO nu
#
              REQUEST Vxxbj(mu,nu,b,j) j
              Lxxbj(mu,nu,b,j) = Vxxbj(mu,nu,b,j)
#
           ENDDO nu
#
           DO b1
#
              Txbbj(mu,b1,b,j) = 0.0
#
              DO nu
#
                 T1xbbj(mu,b1,b,j) = Lxxbj(mu,nu,b,j)*ca(nu,b1)
                 Txbbj(mu,b1,b,j) += T1xbbj(mu,b1,b,j)
#
              ENDDO nu
#
              PREPARE Vxbbj(mu,b1,b,j) = Txbbj(mu,b1,b,j)
#
           ENDDO b1
#
           DO a
#
              Txabj(mu,a,b,j) = 0.0
#
              DO nu
#
                 T1xabj(mu,a,b,j) = Lxxbj(mu,nu,b,j)*ca(nu,a)
                 Txabj(mu,a,b,j) += T1xabj(mu,a,b,j)
#
              ENDDO nu
#
              PREPARE Vxabj(mu,a,b,j) = Txabj(mu,a,b,j)
#
           ENDDO a
#
           deallocate Lxxbj(mu,*,b,j)
#
     ENDPARDO mu, b, j
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, j
#
           allocate Lxixj(mu,i,*,j)
#
           DO nu
#
              REQUEST            Sxixj(mu,i,nu,j) j
              Lxixj(mu,i,nu,j) = Sxixj(mu,i,nu,j)
#
           ENDDO nu
#
           DO q
#
              Txiqj(mu,i,q,j) = 0.0
#
              DO nu
#
                 T1xiqj(mu,i,q,j) = Lxixj(mu,i,nu,j)*ca(nu,q)
                 Txiqj(mu,i,q,j) += T1xiqj(mu,i,q,j)
#
              ENDDO nu
#
              PREPARE Vxiqj(mu,i,q,j) = Txiqj(mu,i,q,j)
#
           ENDDO q
#
           deallocate Lxixj(mu,i,*,j)
#
     ENDPARDO mu, i, j
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, j
#
           allocate Lixxj(i,mu,*,j)
#
           DO nu
#
              REQUEST            Vixxj(i,mu,nu,j) j
              Lixxj(i,mu,nu,j) = Vixxj(i,mu,nu,j)
#
           ENDDO nu
#
           DO b
#
              Tixbj(i,mu,b,j) = 0.0
#
              DO nu
#
                 T1ixbj(i,mu,b,j) = Lixxj(i,mu,nu,j)*ca(nu,b)
                 Tixbj(i,mu,b,j) += T1ixbj(i,mu,b,j)
#
              ENDDO nu
#
              PREPARE Vixbj(i,mu,b,j) = Tixbj(i,mu,b,j)
#
           ENDDO b
#
           deallocate Lixxj(i,mu,*,j)
#
     ENDPARDO mu, i, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
#
     ENDPROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PARDO p, i, i1
#
           allocate Lxipi(*,i,p,i1) 
#
           DO mu 
#
              REQUEST Vxipi(mu,i,p,i1) i1 
              REQUEST Vxipi(mu,i1,p,i) i
              Lxipi(mu,i,p,i1)  = Vxipi(mu,i,p,i1)
              Txipi(mu,i,p,i1)  = Vxipi(mu,i1,p,i)
              Lxipi(mu,i,p,i1) -= Txipi(mu,i,p,i1)
#
           ENDDO mu
#
           DO p1
#
              Tpipi(p1,i,p,i1) = 0.0
#
              DO mu
#
                 T1pipi(p1,i,p,i1) = Lxipi(mu,i,p,i1)*ca(mu,p1)
                 Tpipi(p1,i,p,i1) += T1pipi(p1,i,p,i1)
#
              ENDDO mu
#
              PREPARE VSpipi(p1,i,p,i1) = Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
           deallocate Lxipi(*,i,p,i1)
#
     ENDPARDO p, i, i1
#
     PARDO a, i, i1
#
           allocate Lxaii(*,a,i,i1)
           allocate Lixai(i,*,a,i1)
#
           DO mu
#
              REQUEST Vxaii(mu,a,i,i1) i1
              REQUEST Vixai(i,mu,a,i1) i1
#
              Lxaii(mu,a,i,i1) = Vxaii(mu,a,i,i1)
              Lixai(i,mu,a,i1) = Vixai(i,mu,a,i1)
#
           ENDDO mu
#
           DO a1
#
              Taaii(a1,a,i,i1) = 0.0
#
              DO mu
#
                 T1aaii(a1,a,i,i1) = Lxaii(mu,a,i,i1)*ca(mu,a1)
                 Taaii(a1,a,i,i1) += T1aaii(a1,a,i,i1)
#
              ENDDO mu
#
              PREPARE Vaaii(a1,a,i,i1) = Taaii(a1,a,i,i1)
#
           ENDDO a1
#
           deallocate Lxaii(*,a,i,i1)
#
           DO a1
#
              Tiaai(i,a1,a,i1) = 0.0
#
              DO mu
#
                 T1iaai(i,a1,a,i1) = Lixai(i,mu,a,i1)*ca(mu,a1)
                 Tiaai(i,a1,a,i1) += T1iaai(i,a1,a,i1)
#
              ENDDO mu
#
              PREPARE Viaai(i,a1,a,i1) = Tiaai(i,a1,a,i1)
#
           ENDDO a1
#
           deallocate Lixai(i,*,a,i1)
#
     ENDPARDO a, i, i1
#
     PARDO a, a1, i
#
           allocate L1xaai(*,a,a1,i)
#
           DO mu
#
              REQUEST Vxaai(mu,a,a1,i) i
#
              L1xaai(mu,a,a1,i)  = Vxaai(mu,a,a1,i)
#
           ENDDO mu
#
           DO a2
#
              Taaai(a2,a,a1,i) = 0.0
#
              DO mu
#
                 T1aaai(a2,a,a1,i) = L1xaai(mu,a,a1,i)*ca(mu,a2)
                 Taaai(a2,a,a1,i) += T1aaai(a2,a,a1,i)
#
              ENDDO mu
#
              T1aaai(a1,a,a2,i)           = Taaai(a2,a,a1,i)
              T1aaai(a1,a,a2,i)          *= -1.0
              PREPARE VSaaai(a2,a,a1,i)  += Taaai(a2,a,a1,i)
              PREPARE VSaaai(a1,a,a2,i)  += T1aaai(a1,a,a2,i)
#
           ENDDO a2
#
           deallocate L1xaai(*,a,a1,i)
#
     ENDPARDO a, a1, i
#
     PARDO q, j, j1
#
           allocate Lxjqj(*,j,q,j1)
#
           DO mu
#
              REQUEST Vxjqj(mu,j,q,j1) j1
              REQUEST Vxjqj(mu,j1,q,j) j1
              Lxjqj(mu,j,q,j1)  = Vxjqj(mu,j,q,j1)
              Txjqj(mu,j,q,j1)  = Vxjqj(mu,j1,q,j)
              Lxjqj(mu,j,q,j1) -= Txjqj(mu,j,q,j1)
#
           ENDDO mu
#
           DO q1
#
              Tqjqj(q1,j,q,j1) = 0.0
#
              DO mu
#
                 T1qjqj(q1,j,q,j1)      = Lxjqj(mu,j,q,j1)*ca(mu,q1)
                 Tqjqj(q1,j,q,j1)      += T1qjqj(q1,j,q,j1)
#
              ENDDO mu
#
              PREPARE VSqjqj(q1,j,q,j1) = Tqjqj(q1,j,q,j1)
#
           ENDDO q1
#
           deallocate Lxjqj(*,j,q,j1)
#
     ENDPARDO q, j, j1
#
     PARDO b, j, j1
#
           allocate Lxbjj(*,b,j,j1)
           allocate Ljxbj(j,*,b,j1)
#
           DO mu
#
              REQUEST Vxbjj(mu,b,j,j1) j1
              REQUEST Vjxbj(j,mu,b,j1) j1
#
              Lxbjj(mu,b,j,j1) = Vxbjj(mu,b,j,j1)
              Ljxbj(j,mu,b,j1) = Vjxbj(j,mu,b,j1)
#
           ENDDO mu
#
           DO b1
#
              Tbbjj(b1,b,j,j1) = 0.0
#
              DO mu
#
                 T1bbjj(b1,b,j,j1) = Lxbjj(mu,b,j,j1)*ca(mu,b1)
                 Tbbjj(b1,b,j,j1) += T1bbjj(b1,b,j,j1)
#
              ENDDO mu
#
              PREPARE Vbbjj(b1,b,j,j1) = Tbbjj(b1,b,j,j1)
#
           ENDDO b1
#
           deallocate Lxbjj(*,b,j,j1)
#
           DO b1
#
              Tjbbj(j,b1,b,j1) = 0.0
#
              DO mu
#
                 T1jbbj(j,b1,b,j1) = Ljxbj(j,mu,b,j1)*ca(mu,b1)
                 Tjbbj(j,b1,b,j1) += T1jbbj(j,b1,b,j1)
#
              ENDDO mu
#
              PREPARE Vjbbj(j,b1,b,j1) = Tjbbj(j,b1,b,j1)
#
           ENDDO b1
#
           deallocate Ljxbj(j,*,b,j1)
#
     ENDPARDO b, j, j1
#
     PARDO b, b1, j
#
           allocate L1xbbj(*,b,b1,j)
#
           DO mu
#
              REQUEST Vxbbj(mu,b,b1,j) j
#
              L1xbbj(mu,b,b1,j)  = Vxbbj(mu,b,b1,j)
#
           ENDDO mu
#
           DO b2
#
              Tbbbj(b2,b,b1,j) = 0.0
#
              DO mu
#
                 T1bbbj(b2,b,b1,j) = L1xbbj(mu,b,b1,j)*ca(mu,b2)
                 Tbbbj(b2,b,b1,j) += T1bbbj(b2,b,b1,j)
#
              ENDDO mu
#
              T1bbbj(b1,b,b2,j)           = Tbbbj(b2,b,b1,j)
              T1bbbj(b1,b,b2,j)          *= -1.0
              PREPARE VSbbbj(b2,b,b1,j)  += Tbbbj(b2,b,b1,j)
              PREPARE VSbbbj(b1,b,b2,j)  += T1bbbj(b1,b,b2,j)
#
           ENDDO b2
#
           deallocate L1xbbj(*,b,b1,j)
#
     ENDPARDO b, b1, j
#
     PARDO b, i, i1
#
           allocate Lxbii(*,b,i,i1)
#
           DO mu
#
              REQUEST Vxbii(mu,b,i,i1) i1
              Lxbii(mu,b,i,i1) = Vxbii(mu,b,i,i1)
#
           ENDDO mu
#
           DO b1
#
              Tbbii(b1,b,i,i1) = 0.0
#
              DO mu
#
                 T1bbii(b1,b,i,i1) = Lxbii(mu,b,i,i1)*ca(mu,b1)
                 Tbbii(b1,b,i,i1) += T1bbii(b1,b,i,i1)
#
              ENDDO mu
#
              PREPARE Vbbii(b1,b,i,i1) = Tbbii(b1,b,i,i1)
#
           ENDDO b1
#
           deallocate Lxbii(*,b,i,i1)
#
     ENDPARDO b, i, i1
#
     PARDO b, i, i1
#
           allocate Lxbii(*,b,i,i1)
#
           DO mu
#
              REQUEST Vxbii(mu,b,i,i1) i1
              Lxbii(mu,b,i,i1) = Vxbii(mu,b,i,i1)
#
           ENDDO mu
#
           DO j
#
              Tjbii(j,b,i,i1) = 0.0
#
              DO mu
#
                 T1jbii(j,b,i,i1) = Lxbii(mu,b,i,i1)*ca(mu,j)
                 Tjbii(j,b,i,i1) += T1jbii(j,b,i,i1)
#
              ENDDO mu
#
              PREPARE Vjbii(j,b,i,i1) = Tjbii(j,b,i,i1)
#
           ENDDO j
#
           deallocate Lxbii(*,b,i,i1)
#
     ENDPARDO b, i, i1
#
     PARDO b, a, i
#
           allocate Lxbai(*,b,a,i)
#
           DO mu
#
              REQUEST Vxbai(mu,b,a,i) i
              Lxbai(mu,b,a,i) = Vxbai(mu,b,a,i)
#
           ENDDO mu
#
           DO b1
#
              Tbbai(b1,b,a,i) = 0.0
#
              DO mu
#
                 T1bbai(b1,b,a,i) = Lxbai(mu,b,a,i)*ca(mu,b1)
                 Tbbai(b1,b,a,i) += T1bbai(b1,b,a,i)
#
              ENDDO mu
#
              PREPARE Vbbai(b1,b,a,i) = Tbbai(b1,b,a,i)
#
           ENDDO b1
#
           deallocate Lxbai(*,b,a,i)
#
     ENDPARDO b, a, i
#
     PARDO q, i, j
#
           allocate Lxiqj(*,i,q,j)
#
           DO mu
#
              REQUEST Vxiqj(mu,i,q,j) j
              Lxiqj(mu,i,q,j) = Vxiqj(mu,i,q,j)
#
           ENDDO mu
#
           DO p
#
              Tpiqj(p,i,q,j) = 0.0
#
              DO mu
#
                 T1piqj(p,i,q,j) = Lxiqj(mu,i,q,j)*ca(mu,p)
                 Tpiqj(p,i,q,j) += T1piqj(p,i,q,j)
#
              ENDDO mu
#
              PREPARE Vpiqj(p,i,q,j) = Tpiqj(p,i,q,j)
#
           ENDDO p
#
           deallocate Lxiqj(*,i,q,j)
#
     ENDPARDO q, i, j
#
     PARDO a, j, j1
#
           allocate Lxajj(*,a,j,j1)
#
           DO mu
#
              REQUEST Vxajj(mu,a,j,j1) j1
              Lxajj(mu,a,j,j1) = Vxajj(mu,a,j,j1)
#
           ENDDO mu
#
           DO a1
#
              Taajj(a1,a,j,j1) = 0.0
#
              DO mu
#
                 T1aajj(a1,a,j,j1) = Lxajj(mu,a,j,j1)*ca(mu,a1)
                 Taajj(a1,a,j,j1) += T1aajj(a1,a,j,j1)
#
              ENDDO mu
#
              PREPARE Vaajj(a1,a,j,j1) = Taajj(a1,a,j,j1)
#
           ENDDO a1
#
           deallocate Lxajj(*,a,j,j1)
#
     ENDPARDO a, j, j1
#
     PARDO b, i, j
#
           allocate Lixbj(i,*,b,j)
#
           DO mu
#
              REQUEST Vixbj(i,mu,b,j) j
              Lixbj(i,mu,b,j) = Vixbj(i,mu,b,j)
#
           ENDDO mu
#
           DO a
#
              Tiabj(i,a,b,j) = 0.0
#
              DO mu
#
                 T1iabj(i,a,b,j) = Lixbj(i,mu,b,j)*ca(mu,a)
                 Tiabj(i,a,b,j) += T1iabj(i,a,b,j)
#
              ENDDO mu
#
              PREPARE Viabj(i,a,b,j) = Tiabj(i,a,b,j)
#
           ENDDO a
#
           deallocate Lixbj(i,*,b,j)
#
     ENDPARDO b, i, j
#
     PARDO a, b, j
#
           allocate Lxabj(*,a,b,j)
#
           DO mu
#
              REQUEST Vxabj(mu,a,b,j) j
              Lxabj(mu,a,b,j) = Vxabj(mu,a,b,j)
#
           ENDDO mu
#
           DO a1
#
              Taabj(a1,a,b,j) = 0.0
#
              DO mu
#
                 T1aabj(a1,a,b,j) = Lxabj(mu,a,b,j)*ca(mu,a1)
                 Taabj(a1,a,b,j) += T1aabj(a1,a,b,j)
#
              ENDDO mu
#
              PREPARE Vaabj(a1,a,b,j) = Taabj(a1,a,b,j)
#
           ENDDO a1
#
           deallocate Lxabj(*,a,b,j)
#
     ENDPARDO a, b, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier 
#
     ENDPROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Create the distributed two-particle transformed integral arrays.
#
     PROC CREATE_MOINTS
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     ENDPROC CREATE_MOINTS
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF
#
         CALL CREATE_MOINTS  # --> create the distributed two-particle
                             #     transformed integral arrays.
         CALL TRAN_TRAN2     # --> performs the first two stages of the
                             #     two-electron integral transformation.
         CALL TRAN_TRAN3     # --> performs the third stage
                             #     two-electron integral transformation.
         CALL TRAN_TRAN4     # --> performs the fourth stage of the
                             #     two-electron integral transformation.
#
     ENDPROC TRAN_UHF
#
#    ------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC UHF_ENERGY
#     --------------------
#
#     'HF' terms
#     ----------
#
      esum    = 0.0
      ecorraa = 0.0
      PARDO a, a1, i, i1
#
            REQUEST VSpipi(a,i,a1,i1)    a 
            REQUEST T1aiai_aa(a,i,a1,i1) a 
#
            etemp = VSpipi(a,i,a1,i1)*T1aiai_aa(a,i,a1,i1)
            etemp = 0.25*etemp
            esum += etemp
#
      ENDPARDO a, a1, i, i1
#
      execute server_barrier
      collective ecorraa += esum
      execute print_scalar ecorraa
#
      ecorrbb = 0.0
      esum    = 0.0
      PARDO b, b1, j, j1
#
            REQUEST VSqjqj(b,j,b1,j1)    b 
            REQUEST T1bjbj_bb(b,j,b1,j1) b 
#
            etemp = VSqjqj(b,j,b1,j1)*T1bjbj_bb(b,j,b1,j1)
            etemp = 0.25*etemp
            esum += etemp
#
      ENDPARDO b, b1, j, j1
      execute server_barrier
      collective ecorrbb += esum
      execute print_scalar ecorrbb
#
      ecorrab = 0.0
      esum    = 0.0
      PARDO a, b, i, j
#
            REQUEST     Vpiqj(a,i,b,j) a 
            REQUEST T1aibj_ab(a,i,b,j) a 
#
            etemp = T1aibj_ab(a,i,b,j)*Vpiqj(a,i,b,j)
            esum += etemp
#
      ENDPARDO a, b, i, j
      execute server_barrier
      collective ecorrab += esum
      execute print_scalar ecorrab
#
      ecorrT  = ecorraa
      ecorrT += ecorrbb
      ecorrT += ecorrab
      execute print_scalar ecorrT
#
      ENDPROC UHF_ENERGY
#     -----------------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC T2AA_REFERANCE
#     -------------------
#
#     Create distributed arrays used in the referance computation. 
#     ------------------------------------------------------------ 
#
#     First initialize the amplitudes.
#     --------------------------------
#
#     T2AA  
#     -----
#
      esum    = 0.0
      ecorraa = 0.0 
#
      PARDO a, a1, i, i1
#
            REQUEST                     VSpipi(a,i,a1,i1) a 
            taiai(a,i,a1,i1)          = VSpipi(a,i,a1,i1)
            execute energy_denominator  taiai(a,i,a1,i1)
            etemp                     = taiai(a,i,a1,i1)*VSpipi(a,i,a1,i1) 
            etemp                    *= 0.25 
            esum                     += etemp 
            PREPARE T1aiai_aa(a,i,a1,i1)  = taiai(a,i,a1,i1)
#
      ENDPARDO a, a1, i, i1
      execute server_barrier 
#
      collective ecorraa += esum
      execute print_scalar ecorraa 
#
      ENDPROC T2AA_REFERANCE
#     ----------------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC T2BB_REFERANCE
#     -------------------
#
#     Create distributed arrays used in the referance computation. 
#     ------------------------------------------------------------ 
#
#     First initialize the amplitudes.
#     --------------------------------
#
#     T2BB  
#     -----
#
      esum    = 0.0
      ecorrbb = 0.0 
      PARDO b, b1, j, j1
#
            REQUEST                     VSqjqj(b,j,b1,j1) b 
            tbjbj(b,j,b1,j1)          = VSqjqj(b,j,b1,j1)
            execute energy_denominator  tbjbj(b,j,b1,j1)
            etemp                     = tbjbj(b,j,b1,j1)*VSqjqj(b,j,b1,j1) 
            etemp                    *= 0.25 
            esum                     += etemp 
            PREPARE T1bjbj_bb(b,j,b1,j1)  = tbjbj(b,j,b1,j1)
#
      ENDPARDO b, b1, j, j1
      execute server_barrier 
      collective ecorrbb += esum
      execute print_scalar ecorrbb 
#
      ENDPROC T2BB_REFERANCE
#     ----------------------
#
# ---------------------------------------------------------------------------
#
      PROC T2AB_REFERANCE
#     -------------------
#
#     Create distributed arrays used in the referance computation. 
#     ------------------------------------------------------------ 
#
#     First initialize the amplitudes.
#     --------------------------------
#
#     T2AB  
#     -----
#
      esum    = 0.0
      ecorrab = 0.0 
#
      PARDO a, b, i, j
#
            REQUEST                     Vpiqj(a,i,b,j) a 
            taibj(a,i,b,j)            = Vpiqj(a,i,b,j)
            execute energy_denominator  taibj(a,i,b,j)
            etemp                     = taibj(a,i,b,j)*Vpiqj(a,i,b,j) 
            esum                     += etemp 
            PREPARE T1aibj_ab(a,i,b,j)    = taibj(a,i,b,j)
#
      ENDPARDO a, b, i, j
      execute server_barrier 
#
      collective ecorrab += esum
      execute  print_scalar ecorrab 
#
      ecorrT             = ecorraa
      ecorrT            += ecorrbb
      ecorrT            += ecorrab
      execute print_scalar ecorrT
#
      ENDPROC T2AB_REFERANCE
#     ----------------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
#     Computed quantity    Description of quantity
#     --------------------------------------------
#
#     1. Iij_a
#     2. Iij_b
#     3. Iai_a
#     4. Iai_b
#     5. Iab_a
#     6. Iab_b
#     7. Xai_a
#     8. Xai_b
#
      PROC PINTER
#     -----------
#
#     Create distributed arrays. 
#     -------------------------- 
#
      create Iij_a
      create Iij_b
      create Iai_a
      create Iai_b
      create Iab_a
      create Iab_b
      create Ipq_a
      create Ipq_b
      create Xai_a
      create Xai_b
      execute sip_barrier 
#
#     Start Iij_a
#     -----------
#
      PARDO i, i1 
#
            Tii(i,i1) = 0.0  
#
            DO i2 
#
               IF i2 == i 
#
                  GET          Dij_a(i1,i2)
                  T1ii(i,i1) = Dij_a(i1,i2)*Fock_a(i2,i)
                  Tii(i,i1) -= T1ii(i,i1) 
#
               ENDIF # i2 == i 
#
            ENDDO i2 
#
            PUT Iij_a(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1 
#
      PARDO a, a1, i1, i2
#
            REQUEST T1aiai_aa(a,i1,a1,i2) a 
#
            DO i
#
               REQUEST            VSpipi(a,i,a1,i2) a 
               Tii(i,i1)        = VSpipi(a,i,a1,i2)*T1aiai_aa(a,i1,a1,i2)
               Tii(i,i1)       *= -0.5
               PUT Iij_a(i,i1) += Tii(i,i1)
#
            ENDDO i
#
      ENDPARDO a, a1, i1, i2
#
      PARDO a, b, i1, j
#
            REQUEST T1aibj_ab(a,i1,b,j) a 
#
            DO i
#
               REQUEST            Vpiqj(a,i,b,j) a 
               Tii(i,i1)        = Vpiqj(a,i,b,j)*T1aibj_ab(a,i1,b,j)
               Tii(i,i1)       *= -1.0
               PUT Iij_a(i,i1) += Tii(i,i1)
#
            ENDDO i
#
      ENDPARDO a, b, i1, j
#
#     Finish Iij_a
#     ------------
#
#     Start Iij_b
#     -----------
#
      PARDO j, j1 
#
            Tjj(j,j1) = 0.0  
#
            DO j2 
#
               IF j2 == j 
#
                  GET          Dij_b(j1,j2)
                  T1jj(j,j1) = Dij_b(j1,j2)*Fock_a(j2,j)
                  Tjj(j,j1) -= T1jj(j,j1) 
#
               ENDIF # j2 == j 
#
            ENDDO j2 
#
            PUT Iij_b(j,j1) += Tjj(j,j1)
#
      ENDPARDO j, j1 
#
      PARDO b, b1, j1, j2
#
            REQUEST T1bjbj_bb(b,j1,b1,j2) b
#
            DO j
#
               REQUEST            VSqjqj(b,j,b1,j2) b
               Tjj(j,j1)        = VSqjqj(b,j,b1,j2)*T1bjbj_bb(b,j1,b1,j2)
               Tjj(j,j1)       *= -0.5
               PUT Iij_b(j,j1) += Tjj(j,j1)
#
            ENDDO j
#
      ENDPARDO b, b1, j1, j2
#
      PARDO b, a, j1, i
#
            REQUEST T1aibj_ab(a,i,b,j1) a
#
            DO j
#
               REQUEST            Vpiqj(a,i,b,j) a 
               Tjj(j,j1)        = Vpiqj(a,i,b,j)*T1aibj_ab(a,i,b,j1)
               Tjj(j,j1)       *= -1.0
               PUT Iij_b(j,j1) += Tjj(j,j1)
#
            ENDDO j
#
      ENDPARDO b, a, j1, i
#
#     Finish Iij_b
#     ------------
#
#     Start Iai_a
#     -----------
#
      PARDO a, a1, i1, i2
#
            REQUEST T1aiai_aa(a,i1,a1,i2) a 
#
            DO i
#
               REQUEST           VSpipi(a1,i2,i,i1) a1 
               Tai(a,i)        = T1aiai_aa(a,i1,a1,i2)*VSpipi(a1,i2,i,i1)
               Tai(a,i)       *= -0.5
               PUT Iai_a(a,i) += Tai(a,i)
#
               tia(i,a)        = tai(a,i) 
               PUT Ipq_a(i,a) += tia(i,a) 
#
            ENDDO i
#
      ENDPARDO a, a1, i1, i2
#
      PARDO a, b, i1, j
#
            REQUEST T1aibj_ab(a,i1,b,j) a
#
            DO i
#
               REQUEST           Vjbii(j,b,i1,i) b  # Vppqq(i,i1,b,j)
               Tai(a,i)        = T1aibj_ab(a,i1,b,j)*Vjbii(j,b,i1,i)
               Tai(a,i)       *= -1.0
               PUT Iai_a(a,i) += Tai(a,i)
#
               tia(i,a)        = tai(a,i) 
               PUT Ipq_a(i,a) += tia(i,a) 
#
            ENDDO i
#
      ENDPARDO a, b, i1, j
#
#     Finish Iai_a
#     ------------
#
#     Start Iai_b
#     -----------
#
      PARDO b, b1, j1, j2
#
            REQUEST T1bjbj_bb(b,j1,b1,j2) b
#
            DO j
#
               REQUEST           VSqjqj(b1,j2,j,j1) j 
               Tbj(b,j)        = T1bjbj_bb(b,j1,b1,j2)*VSqjqj(b1,j2,j,j1)
               Tbj(b,j)       *= -0.5
               PUT Iai_b(b,j) += Tbj(b,j)
#
               tjb(j,b)        = tbj(b,j) 
               PUT Ipq_b(j,b) += tjb(j,b) 
#
            ENDDO j
#
      ENDPARDO b, b1, j1, j2
#
      PARDO b, a, j1, i
#
            REQUEST T1aibj_ab(a,i,b,j1) a
#
            DO j
#
               REQUEST           Vpiqj(a,i,j,j1) a 
               Tbj(b,j)        = T1aibj_ab(a,i,b,j1)*Vpiqj(a,i,j,j1)
               Tbj(b,j)       *= -1.0
               PUT Iai_b(b,j) += Tbj(b,j)
#
               tjb(j,b)        = tbj(b,j) 
               PUT Ipq_b(j,b) += tjb(j,b) 
#
            ENDDO j
#
      ENDPARDO b, a, j1, i
#
#     Finish Iai_b
#     ------------
#
#     Start Iab_a
#     -----------

       PARDO a, a1, a2
#
             GET                Dab_a(a2,a1)
             Taa(a,a1)        = Dab_a(a2,a1)*Fock_a(a2,a)
             Taa(a,a1)       *= -1.0
             PUT Iab_a(a,a1) += Taa(a,a1)
#
       ENDPARDO a, a1, a2 
#
      PARDO a1, a2, i, i1
#
            REQUEST T1aiai_aa(a1,i,a2,i1) a1 
#
            DO a
#
               REQUEST            VSpipi(a,i,a2,i1) a 
               Taa(a,a1)        = VSpipi(a,i,a2,i1)*T1aiai_aa(a1,i,a2,i1)
               Taa(a,a1)       *= -0.5
               PUT Iab_a(a,a1) += Taa(a,a1)
#
            ENDDO a
#
      ENDPARDO a1, a2, i, i1
#
      PARDO a1, b, i, j
#
            REQUEST T1aibj_ab(a1,i,b,j) b 
#
            DO a
#
               REQUEST            Vpiqj(a,i,b,j) a 
               Taa(a,a1)        = Vpiqj(a,i,b,j)*T1aibj_ab(a1,i,b,j)
               Taa(a,a1)       *= -1.0  
               PUT Iab_a(a,a1) += Taa(a,a1)
#
            ENDDO a
#
      ENDPARDO a1, b, i, j
#
#     Finish Iab_a
#     ------------
#
#     Start Iab_b
#     -----------
#
       PARDO b, b1, b2
#
             GET                Dab_b(b2,b1)
             Tbb(b,b1)        = Dab_b(b2,b1)*Fock_a(b2,b)
             Tbb(b,b1)       *= -1.0
             PUT Iab_b(b,b1) += Tbb(b,b1)
#
       ENDPARDO b, b1, b2 
#
      PARDO b1, b2, j, j1
#
            REQUEST T1bjbj_bb(b1,j,b2,j1) j
#
            DO b
#
               REQUEST            VSqjqj(b,j,b2,j1) b
               Tbb(b,b1)        = VSqjqj(b,j,b2,j1)*T1bjbj_bb(b1,j,b2,j1)
               Tbb(b,b1)       *= -0.5
               PUT Iab_b(b,b1) += Tbb(b,b1)
#
            ENDDO b
#
      ENDPARDO b1, b2, j, j1
#
      PARDO b1, a, i, j
#
            REQUEST T1aibj_ab(a,i,b1,j) a
#
            DO b
#
               REQUEST            Vpiqj(a,i,b,j) a 
               Tbb(b,b1)        = Vpiqj(a,i,b,j)*T1aibj_ab(a,i,b1,j)
               Tbb(b,b1)       *= -1.0  
               PUT Iab_b(b,b1) += Tbb(b,b1)
#
            ENDDO b
#
      ENDPARDO b1, a, i, j
#
#     Finish Iab_b
#     ------------
#
      execute sip_barrier # --> Xai depends on Iai !
#
#     Start Xai_a
#     -----------
#
      PARDO a, i
#
            GET        Iai_a(a,i)
            Tai(a,i) = Iai_a(a,i)
#
            DO i1
            DO i2
#
               REQUEST             VSpipi(a,i,i2,i1) a 
               REQUEST             VSpipi(a,i,i1,i2) a 
               GET                 Dij_a(i2,i1)
#
               Taiii(a,i,i2,i1)  = VSpipi(a,i,i2,i1)
               T1aiii(a,i,i2,i1) = VSpipi(a,i,i1,i2)
               Taiii(a,i,i2,i1) += T1aiii(a,i,i2,i1)
               T1ai(a,i)         = Taiii(a,i,i2,i1)*Dij_a(i2,i1)
               T1ai(a,i)        *= 0.5
               Tai(a,i)         += T1ai(a,i)
#
            ENDDO i2
            ENDDO i1
#
            DO j
            DO j1
#
               REQUEST            Vpiqj(a,i,j1,j) a 
               REQUEST            Vpiqj(a,i,j,j1) a 
               GET                Dij_b(j1,j)
#
               Taijj(a,i,j1,j)  = Vpiqj(a,i,j1,j)
               T1aijj(a,i,j1,j) = Vpiqj(a,i,j,j1)
               Taijj(a,i,j1,j) += T1aijj(a,i,j1,j)
               T1ai(a,i)        = Taijj(a,i,j1,j)*Dij_b(j1,j)
               T1ai(a,i)       *= 0.5
               Tai(a,i)        += T1ai(a,i)
#
            ENDDO j1
            ENDDO j
#
            DO a1
            DO a2
#
               REQUEST             VSaaai(a2,a1,a,i) a 
               REQUEST             VSaaai(a1,a2,a,i) a 
               GET                 Dab_a(a2,a1)
#
               Taaai(a2,a1,a,i)  = VSaaai(a2,a1,a,i)
               T1aaai(a2,a1,a,i) = VSaaai(a1,a2,a,i)
               Taaai(a2,a1,a,i) += T1aaai(a2,a1,a,i)
               T1ai(a,i)         = Taaai(a2,a1,a,i)*Dab_a(a2,a1)
               T1ai(a,i)        *= 0.5
               Tai(a,i)         += T1ai(a,i)
#
               DO i1
#
                  REQUEST     T1aiai_aa(a1,i1,a2,i) i 
                  REQUEST     VSaaai(a2,a,a1,i1)    a 
#
                  T1ai(a,i) = VSaaai(a2,a,a1,i1)*T1aiai_aa(a1,i1,a2,i)
                  T1ai(a,i) *= 0.5
                  Tai(a,i) += T1ai(a,i)
#
               ENDDO i1
#
            ENDDO a2
            ENDDO a1
#
            DO b
            DO b1
#
               REQUEST            Vbbai(b1,b,a,i) a # Vppqq(a,i,b1,b)
               REQUEST            Vbbai(b,b1,a,i) a # Vppqq(a,i,b,b1)
               GET                Dab_b(b1,b)
#
               Tbbai(b1,b,a,i)  = Vbbai(b1,b,a,i)
               T1bbai(b1,b,a,i) = Vbbai(b,b1,a,i)
               Tbbai(b1,b,a,i) += T1bbai(b1,b,a,i)
               T1ai(a,i)        = Tbbai(b1,b,a,i)*Dab_b(b1,b)
               T1ai(a,i)       *= 0.5
               Tai(a,i)        += T1ai(a,i)
#
            ENDDO b1
            ENDDO b
#
            DO b
            DO a1
            DO j
#
               REQUEST      T1aibj_ab(a1,i,b,j) b 
               REQUEST      Vaabj(a1,a,b,j) a 
#
               T1ai(a,i)  = Vaabj(a1,a,b,j)*T1aibj_ab(a1,i,b,j)
               Tai(a,i)  += T1ai(a,i)
#
            ENDDO j
            ENDDO a1
            ENDDO b
#
            PUT Xai_a(a,i) = Tai(a,i)
#
      ENDPARDO a, i
#
#     Finish Xai_a
#     ------------
#
#     Start Xai_b
#     -----------
#
      PARDO b, j
#
            GET        Iai_b(b,j)
            Tbj(b,j) = Iai_b(b,j)
#
            DO j1
            DO j2
#
               REQUEST             VSqjqj(b,j,j2,j1) b 
               REQUEST             VSqjqj(b,j,j1,j2) b 
               GET                 Dij_b(j2,j1)
#
               Tbjjj(b,j,j2,j1)  = VSqjqj(b,j,j2,j1)
               T1bjjj(b,j,j2,j1) = VSqjqj(b,j,j1,j2)
               Tbjjj(b,j,j2,j1) += T1bjjj(b,j,j2,j1)
               T1bj(b,j)         = Tbjjj(b,j,j2,j1)*Dij_b(j2,j1)
               T1bj(b,j)        *= 0.5
               Tbj(b,j)         += T1bj(b,j)
#
            ENDDO j2
            ENDDO j1
#
            DO i
            DO i1
#
               REQUEST            Vpiqj(i1,i,b,j) b 
               REQUEST            Vpiqj(i,i1,b,j) b 
               GET                Dij_a(i1,i)
#
               Tiibj(i1,i,b,j)  = Vpiqj(i1,i,b,j)
               T1iibj(i1,i,b,j) = Vpiqj(i,i1,b,j)
               Tiibj(i1,i,b,j) += T1iibj(i1,i,b,j)
               T1bj(b,j)        = Tiibj(i1,i,b,j)*Dij_a(i1,i)
               T1bj(b,j)       *= 0.5
               Tbj(b,j)        += T1bj(b,j)
#
            ENDDO i1
            ENDDO i
#
            DO b1
            DO b2
#
               REQUEST             VSbbbj(b2,b1,b,j) b 
               REQUEST             VSbbbj(b1,b2,b,j) b 
               GET                 Dab_b(b2,b1)
#
               Tbbbj(b2,b1,b,j)  = VSbbbj(b2,b1,b,j)
               T1bbbj(b2,b1,b,j) = VSbbbj(b1,b2,b,j)
               Tbbbj(b2,b1,b,j) += T1bbbj(b2,b1,b,j)
               T1bj(b,j)         = Tbbbj(b2,b1,b,j)*Dab_b(b2,b1)
               T1bj(b,j)        *= 0.5
               Tbj(b,j)         += T1bj(b,j)
#
               DO j1
#
                  REQUEST     T1bjbj_bb(b1,j1,b2,j) j 
                  REQUEST     VSbbbj(b2,b,b1,j1)    b 
#   
                  T1bj(b,j) = VSbbbj(b2,b,b1,j1)*T1bjbj_bb(b1,j1,b2,j)
                  T1bj(b,j) *= 0.5
                  Tbj(b,j) += T1bj(b,j)
#
               ENDDO j1
#
            ENDDO b2
            ENDDO b1
#
            DO a
            DO a1
#
               REQUEST            Vaabj(a1,a,b,j) a
               REQUEST            Vaabj(a,a1,b,j) a 
               GET                Dab_a(a1,a)
#
               Taabj(a1,a,b,j)  = Vaabj(a1,a,b,j)
               T1aabj(a1,a,b,j) = Vaabj(a,a1,b,j)
               Taabj(a1,a,b,j) += T1aabj(a1,a,b,j)
               T1bj(b,j)        = Taabj(a1,a,b,j)*Dab_a(a1,a)
               T1bj(b,j)       *= 0.5
               Tbj(b,j)        += T1bj(b,j)
#
            ENDDO a1
            ENDDO a
#
            DO a
            DO b1
            DO i
#
               REQUEST      T1aibj_ab(a,i,b1,j) a 
               REQUEST      Vbbai(b1,b,a,i) a # Vppqq(a,i,b1,b)
#
               T1bj(b,j)  = Vbbai(b1,b,a,i)*T1aibj_ab(a,i,b1,j)
               Tbj(b,j)  += T1bj(b,j)
#
            ENDDO i
            ENDDO b1
            ENDDO a
#
            PUT Xai_b(b,j) = Tbj(b,j)
#
      ENDPARDO b, j
      execute sip_barrier
#
#     Finish Xai_b
#     ------------
#
      ENDPROC PINTER
#     --------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC DENSIJ
#     -----------
#
#     Create distributed denisty arrays. 
#     --------------------------------- 
#
      create Dij_a 
      create Dij_b 
      create Dpq_a 
      create Dpq_b 
#
      execute sip_barrier 
#
# ---------------------------------------------------------------------------
#
#     Start Dij_a
#     -----------
#
      PARDO a, a1, i1
#
            allocate L1aiai(a,*,a1,i1)
#
            DO i2
#
               REQUEST              T1aiai_aa(a,i2,a1,i1) a 
               L1aiai(a,i2,a1,i1) = T1aiai_aa(a,i2,a1,i1)
#
            ENDDO i2
#
            DO i
#
               REQUEST T1aiai_aa(a,i,a1,i1) a 
#
               DO i2
#
                  Tii(i,i2)        = T1aiai_aa(a,i,a1,i1)*L1aiai(a,i2,a1,i1)
                  Tii(i,i2)       *= -0.5
                  PUT Dij_a(i,i2) += Tii(i,i2)
                  PUT Dpq_a(i,i2) += Tii(i,i2)
#
               ENDDO i2
#
            ENDDO i
#
            deallocate L1aiai(a,*,a1,i1)
#
      ENDPARDO a, a1, i1
#
      PARDO a, b, j
#
            allocate L1aibj(a,*,b,j)
#
            DO i2
#
               REQUEST            T1aibj_ab(a,i2,b,j) a 
               L1aibj(a,i2,b,j) = T1aibj_ab(a,i2,b,j)
#
            ENDDO i2
#
            DO i
#
               REQUEST T1aibj_ab(a,i,b,j) a 
#
               DO i2
#
                  Tii(i,i2)        = T1aibj_ab(a,i,b,j)*L1aibj(a,i2,b,j)
                  Tii(i,i2)       *= -1.0
                  PUT Dij_a(i,i2) += Tii(i,i2)
                  PUT Dpq_a(i,i2) += Tii(i,i2)
#
               ENDDO i2
#
            ENDDO i
#
            deallocate L1aibj(a,*,b,j)
#
      ENDPARDO a, b, j
#
#     Finish Dij_a
#     ------------
#
#     Start Dij_b
#     -----------
#
      PARDO b, b1, j1
#
            allocate L1bjbj(b,*,b1,j1)
#
            DO j2
#
               REQUEST              T1bjbj_bb(b,j2,b1,j1) b 
               L1bjbj(b,j2,b1,j1) = T1bjbj_bb(b,j2,b1,j1)
#
            ENDDO j2
#
            DO j
#
               REQUEST T1bjbj_bb(b,j,b1,j1) b 
#
               DO j2
#
                  Tjj(j,j2)        = T1bjbj_bb(b,j,b1,j1)*L1bjbj(b,j2,b1,j1)
                  Tjj(j,j2)       *= -0.5
                  PUT Dij_b(j,j2) += Tjj(j,j2)
                  PUT Dpq_b(j,j2) += Tjj(j,j2)
#
               ENDDO j2
#
            ENDDO j
#
            deallocate L1bjbj(b,*,b1,j1)
#
      ENDPARDO b, b1, j1
#
      PARDO b, a, i
#
            allocate L1bjai(b,*,a,i)
#
            DO j2
#
               REQUEST            T1aibj_ab(a,i,b,j2) a
               L1bjai(b,j2,a,i) = T1aibj_ab(a,i,b,j2)
#
            ENDDO j2
#
            DO j
#
               REQUEST T1aibj_ab(a,i,b,j) a 
#
               DO j2
#
                  Tjj(j,j2)        = T1aibj_ab(a,i,b,j)*L1bjai(b,j2,a,i)
                  Tjj(j,j2)       *= -1.0
                  PUT Dij_b(j,j2) += Tjj(j,j2)
                  PUT Dpq_b(j,j2) += Tjj(j,j2)
#
               ENDDO j2
#
            ENDDO j
#
            deallocate L1bjai(b,*,a,i)
#
      ENDPARDO b, a, i
#
#     Finish Dij_b
#     ------------
#
# ---------------------------------------------------------------------------
#
      ENDPROC DENSIJ
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC DENSAB
#     -----------
#
# ---------------------------------------------------------------------------
#
#     Create distributed denisty arrays. 
#     --------------------------------- 
#
      create Dab_a 
      create Dab_b 
#
      execute sip_barrier 
#
#     Start Dab_a
#     -----------
#
      PARDO i, i1, a1
#
            allocate L2aiai(*,i,a1,i1)
#
            DO a2
#
               REQUEST              T1aiai_aa(a2,i,a1,i1) i
               L2aiai(a2,i,a1,i1) = T1aiai_aa(a2,i,a1,i1)
#
            ENDDO a2
#
            DO a
#
               REQUEST T1aiai_aa(a,i,a1,i1) a
#
               DO a2
#
                  Taa(a,a2)        = T1aiai_aa(a,i,a1,i1)*L2aiai(a2,i,a1,i1)
                  Taa(a,a2)       *= 0.5
                  PUT Dab_a(a,a2) += Taa(a,a2)
                  PUT Dpq_a(a,a2) += Taa(a,a2)
#
               ENDDO a2
#
            ENDDO a
#
            deallocate L2aiai(*,i,a1,i1)
#
      ENDPARDO i, i1, a1
#
      PARDO i, j, b
#
            allocate L2aibj(*,i,b,j)
#
            DO a1
#
               REQUEST            T1aibj_ab(a1,i,b,j) b 
               L2aibj(a1,i,b,j) = T1aibj_ab(a1,i,b,j)
#
            ENDDO a1
#
            DO a
#
               REQUEST T1aibj_ab(a,i,b,j) a 
#
               DO a1
#
                  Taa(a,a1)        = T1aibj_ab(a,i,b,j)*L2aibj(a1,i,b,j)
                  PUT Dab_a(a,a1) += Taa(a,a1)
                  PUT Dpq_a(a,a1) += Taa(a,a1)
#
               ENDDO a1
#
            ENDDO a
#
            deallocate L2aibj(*,i,b,j)
#
      ENDPARDO i, j, b
#
#     Finish Dab_a
#     ------------
#
#     Start Dab_b
#     -----------
#
      PARDO j, j1, b1
#
            allocate L2bjbj(*,j,b1,j1)
#
            DO b2
#
               REQUEST              T1bjbj_bb(b2,j,b1,j1) j 
               L2bjbj(b2,j,b1,j1) = T1bjbj_bb(b2,j,b1,j1)
#
            ENDDO b2
#
            DO b
#
               REQUEST T1bjbj_bb(b,j,b1,j1) b 
#
               DO b2
#
                  Tbb(b,b2)        = T1bjbj_bb(b,j,b1,j1)*L2bjbj(b2,j,b1,j1)
                  Tbb(b,b2)       *= 0.5
                  PUT Dab_b(b,b2) += Tbb(b,b2)
                  PUT Dpq_b(b,b2) += Tbb(b,b2)
#
               ENDDO b2
#
            ENDDO b
#
            deallocate L2bjbj(*,j,b1,j1)
#
      ENDPARDO j, j1, b1
#
      PARDO i, j, a
#
            allocate L2bjai(*,j,a,i)
#
            DO b1
#
               REQUEST            T1aibj_ab(a,i,b1,j) a 
               L2bjai(b1,j,a,i) = T1aibj_ab(a,i,b1,j)
#
            ENDDO b1
#
            DO b
#
               REQUEST T1aibj_ab(a,i,b,j) a 
#
               DO b1
#
                  Tbb(b,b1)        = T1aibj_ab(a,i,b,j)*L2bjai(b1,j,a,i)
                  PUT Dab_b(b,b1) += Tbb(b,b1)
                  PUT Dpq_b(b,b1) += Tbb(b,b1)
#
               ENDDO b1
#
            ENDDO b
#
            deallocate L2bjai(*,j,a,i)
#
      ENDPARDO i, j, a
#
#     Finish Dab_b
#     ------------
#
# ---------------------------------------------------------------------------
#
      ENDPROC DENSAB
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------  
#
# The two-electron integral deivative <mn|ls>^l is computed
# and transformed to the MO basis for use in constructing
# the Hessian. The transformation is performed in 4 steps as
# is usually done. Since there will always be one occupied index
# in the Hessian computation the 4-types of integrals are computed. 
#
# 1. DTpppi
# 2. DTqqqj
# 3. DTppqj  
# 4. DTqqpi   
#
# Note that the integrals are not antisymmetrized in the transformation. 
#
# --------------------------------------------------------------------------- 
#
      PROC DINT_TRAN 
#     --------------  
#
#     Zero out Vxxxi and Vxxxj 
#     ------------------------ 
#
      PARDO mu, nu, lambda, i 
            txxxi(mu,nu,lambda,i)         = 0.0 
            PREPARE Vxxxi(mu,nu,lambda,i) = txxxi(mu,nu,lambda,i) 
      ENDPARDO mu, nu, lambda, i 
#
      create Qyai 
      create QA 
      execute sip_barrier 
      execute server_barrier 
#
#     Compute integrals and perform first stage of the transformation. 
#     ---------------------------------------------------------------- 
#
     PARDO mu, nu, lambda, sigma 
#
           execute der2_comp              AOINT(mu,nu,lambda,sigma)
           DO i
#
               V0xxxi(mu,nu,lambda,i)     = aoint(mu,nu,lambda,sigma)*ca(sigma,i)
               Prepare Vxxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i)
#
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma 
#
      execute server_barrier 
#
#     Perform second stage of the transformation. 
#     ------------------------------------------- 
#
      PARDO mu, lambda, i 
            IF mu <  lambda 
               allocate Exxpi(mu,lambda,*,i) 
               DO nu 
                  REQUEST Vxxxi(mu,lambda,nu,i) i  
                  DO p 
                     txxpi(mu,lambda,p,i)  = Vxxxi(mu,lambda,nu,i)*ca(nu,p) 
                     Exxpi(mu,lambda,p,i) += txxpi(mu,lambda,p,i)  
                  ENDDO p 
               ENDDO nu  
               DO p 
                  txxpi(mu,lambda,p,i)          = Exxpi(mu,lambda,p,i) 
                  t1xxpi(lambda,mu,p,i)         = txxpi(mu,lambda,p,i) 
                  PREPARE DTxxpi(mu,lambda,p,i) = txxpi(mu,lambda,p,i) 
                  PREPARE DTxxpi(lambda,mu,p,i) = t1xxpi(lambda,mu,p,i) 
               ENDDO p 
               deallocate Exxpi(mu,lambda,*,i) 
            ENDIF 
      ENDPARDO mu, lambda, i 
#
      PARDO mu, lambda, i 
            IF mu == lambda 
               allocate Exxpi(mu,lambda,*,i) 
               DO nu 
                  REQUEST Vxxxi(mu,lambda,nu,i) i  
                  DO p 
                     txxpi(mu,lambda,p,i)  = Vxxxi(mu,lambda,nu,i)*ca(nu,p) 
                     Exxpi(mu,lambda,p,i) += txxpi(mu,lambda,p,i)  
                  ENDDO p 
               ENDDO nu  
               DO p 
                  txxpi(mu,lambda,p,i)          = Exxpi(mu,lambda,p,i) 
                  PREPARE DTxxpi(mu,lambda,p,i) = txxpi(mu,lambda,p,i) 
               ENDDO p 
               deallocate Exxpi(mu,lambda,*,i) 
            ENDIF 
      ENDPARDO mu, lambda, i 
#
      execute server_barrier 
#
#     Perform third stage of the transformation. 
#     ------------------------------------------ 
#
      PARDO mu, p, i 
#
            allocate Fxppi(mu,*,p,i) 
#
            DO nu 
               REQUEST DTxxpi(mu,nu,p,i) i 
               DO p1 
                  txppi(mu,p1,p,i)  = DTxxpi(mu,nu,p,i)*ca(nu,p1) 
                  Fxppi(mu,p1,p,i) += txppi(mu,p1,p,i)
               ENDDO p1 
            ENDDO nu 
#
            DO p1 
               txppi(mu,p1,p,i)          = Fxppi(mu,p1,p,i) 
               PREPARE DTxppi(mu,p1,p,i) = txppi(mu,p1,p,i)  
            ENDDO p1 
#
            deallocate Fxppi(mu,*,p,i) 
#
      ENDPARDO mu, p, i 
#
      execute server_barrier 
#
#     Perform fourth stage of the transformation. 
#     ------------------------------------------- 
#
      PARDO p, p1, i 
#
            allocate Fpppi(*,p1,p,i) 
#
            DO mu 
               REQUEST DTxppi(mu,p1,p,i) i 
               DO p2 
                  tpppi(p2,p1,p,i)  = DTxppi(mu,p1,p,i)*ca(mu,p2) 
                  Fpppi(p2,p1,p,i) += tpppi(p2,p1,p,i) 
               ENDDO p2 
            ENDDO mu 
#
            DO p2 
               tpppi(p2,p1,p,i)          = Fpppi(p2,p1,p,i) 
               PREPARE DTpppi(p2,p1,p,i) = tpppi(p2,p1,p,i) 
            ENDDO p2 
#
            deallocate Fpppi(*,p1,p,i) 
#
      ENDPARDO p, p1, i 
#
      PARDO mu, sigma
#
            REQUEST QTABxx(mu,sigma,jatom,jx) mu  
            REQUEST QTAxx(mu,sigma,jatom,jx) mu  
#
            txx(mu,sigma)   = QTABxx(mu,sigma,jatom,jx) 
            t1xx(mu,sigma)  = QTAxx(mu,sigma,jatom,jx) 
            txx(mu,sigma)  += t1xx(mu,sigma) 
#
            PUT QA(mu,sigma) = txx(mu,sigma) 
#
      ENDPARDO mu, sigma
#
      create Fya 
      create Fyb 
      execute sip_barrier 
      execute server_barrier 
#
#     Finish the contribution to Qyai and Fya  
#     ---------------------------------------- 
#
# VFL Modified Feb. 2, 2009 
#
      PARDO sigma, a   
#
            tax(a,sigma) = 0.0 
#
            DO mu 
               GET             QA(mu,sigma) 
               t1ax(a,sigma) = QA(mu,sigma)*ca(mu,a)  
               tax(a,sigma) += t1ax(a,sigma) 
            ENDDO mu 
#
            DO a1 
               tpp(a,a1)      = tax(a,sigma)*ca(sigma,a1)
               PUT Fya(a,a1) += tpp(a,a1)
            ENDDO a1 
#
            DO i 
               tai(a,i)       = tax(a,sigma)*ca(sigma,i) 
               PUT Qyai(a,i) += tai(a,i)  
            ENDDO i 
#
      ENDPARDO sigma, a   
#
      PARDO sigma, i   
#
            tpx(i,sigma) = 0.0 
#
            DO mu 
               GET             QA(mu,sigma) 
               t1px(i,sigma) = ca(mu,i)*QA(mu,sigma)
               tpx(i,sigma) += t1px(i,sigma) 
            ENDDO mu 
#
            DO i1 
               tpp(i,i1)      = tpx(i,sigma)*ca(sigma,i1)
               PUT Fya(i,i1) += tpp(i,i1)
            ENDDO i1 
#
      ENDPARDO sigma, i   
#
      execute sip_barrier 
      delete QA 
#
      ENDPROC DINT_TRAN 
#     -----------------  
#
# ---------------------------------------------------------------------- 
#
# ----------------------------------------------------------------------  
#
# The two-electron integral deivative <mn|ls>^l is computed
# and transformed to the MO basis for use in constructing
# the Hessian. The transformation is performed in 3 steps as
# as only the vovo integrals are needed. 
#
# 1. VXpipi  
# 1. VXqjqj  
# 1. VXpiqj  
#
# Note that the integrals are not antisymmetrized in the transformation. 
#
# ---------------------------------------------------------------------- 
#
      PROC TRAN_VX_XIXI  
#     ----------------- 
#
     #create Qxai 
     #create Fxa
     #create Hxa
     #create Hxb
     #create QAxx
     #create QABxx 
     #create Sxa 
     #create Sxb 
     #execute server_barrier 
     #execute sip_barrier 
#
      PARDO mu, nu
            REQUEST            QTABxx(mu,nu,iatom,ix) mu  
            REQUEST            QTAxx(mu,nu,iatom,ix)  mu  
            PUT QABxx(mu,nu) = QTABxx(mu,nu,iatom,ix)   
            PUT QAxx(mu,nu)  = QTAxx(mu,nu,iatom,ix)   
      ENDPARDO mu, nu 
#
      PARDO p, p1
            REQUEST         HTa(p,p1,iatom,ix) p
            PUT Hxa(p,p1) = HTa(p,p1,iatom,ix) 
      ENDPARDO p, p1
#
      PARDO a, a1
            REQUEST         HTa(a,a1,iatom,ix) a 
            PUT Fxa(a,a1) = HTa(a,a1,iatom,ix)  
      ENDPARDO a, a1
#
      PARDO a, i
            GET             QTai(a,i,iatom,ix) 
            PUT Qxai(a,i) = QTai(a,i,iatom,ix)  
      ENDPARDO a, i
#
      PARDO i, i1
            REQUEST         HTa(i,i1,iatom,ix) i  
            PUT Fxa(i,i1) = HTa(i,i1,iatom,ix) 
      ENDPARDO i, i1
#
      PARDO p, p1
            REQUEST         STa(p,p1,iatom,ix) p
            PUT Sxa(p,p1) = STa(p,p1,iatom,ix) 
      ENDPARDO p, p1
#
     #execute sip_barrier
#
      ENDPROC TRAN_VX_XIXI  
#     --------------------  
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC QYAI_H 
#     ----------- 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Qxai and Qxbj  
#           ------------------------------ 
#
            DO a 
#
               tpx(a,nu) = ca(mu,a)*txx(mu,nu)   
#
               DO i 
#
                  tpp(a,i)       = tpx(a,nu)*ca(nu,i) 
                  PUT Qyai(a,i) += tpp(a,i) 
#
               ENDDO i  
#
            ENDDO a 
#
      ENDPARDO mu, nu 
#
      ENDPROC QYAI_H 
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC QXAI_H 
#     ----------- 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Qxai and Qxbj  
#           ------------------------------ 
#
            DO a 
#
               tpx(a,nu) = txx(mu,nu)*ca(mu,a)  
#
               DO i 
#
                  tpp(a,i)       = tpx(a,nu)*ca(nu,i) 
                  PUT Qxai(a,i) += tpp(a,i) 
#
               ENDDO i  
#
            ENDDO a 
#
      ENDPARDO mu, nu 
#
      ENDPROC QXAI_H 
#     -------------- 
#
# ---------------------------------------------------------------------------
#
      PROC FINTY_TRAN 
#     --------------- 
#
#     The transformed first-derivative fock matrix is computed. The 
#     perturbation is defined by jatom, jx and jcenter and the 
#     final arrays are Fya and Fyb. 
#
      create Stemp 
      execute sip_barrier 
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
            DO p 
               txp(mu,p) = txx(mu,nu)*ca(nu,p)  
               PUT Stemp(mu,p) += txp(mu,p) 
            ENDDO p 
#
      ENDPARDO mu, nu 
      execute sip_barrier 
#
      PARDO mu, a  
#
            GET Stemp(mu,a) 
#
            DO a1 
#
               tpp(a1,a)       = Stemp(mu,a)*ca(mu,a1) 
               PUT Fya(a1,a)  += tpp(a1,a) 
#
            ENDDO a1  
#
      ENDPARDO mu, a 
#
      PARDO mu, i  
#
            GET Stemp(mu,i) 
#
            DO i1 
#
               tpp(i1,i)       = Stemp(mu,i)*ca(mu,i1) 
               PUT Fya(i1,i)  += tpp(i1,i) 
#
            ENDDO i1  
#
      ENDPARDO mu, i 
      execute sip_barrier 
      delete Stemp 
#
#     Add contributions from overlap derivatives and two-electron integrals  
#     --------------------------------------------------------------------- 
#
#     alpha-alpha virtual-virtual block 
#     --------------------------------- 
#
      PARDO a, a1 
#
            taa(a,a1) = 0.0 
#
            DO a2 
#
               if a2 == a1 
#
               GET           Sya(a,a2) 
               t1aa(a,a1)  = Sya(a,a2)*Fock_a(a1,a2) 
               t1aa(a,a1) *= -0.5  
               taa(a,a1)  += t1aa(a,a1) 
#
               endif 
#
            ENDDO a2 
#
            DO a2 
#
               if a2 == a 
#
               GET           Sya(a2,a1) 
               t1aa(a,a1)  = Sya(a2,a1)*Fock_a(a2,a) 
               t1aa(a,a1) *= -0.5  
               taa(a,a1)  += t1aa(a,a1) 
#
               endif 
#
            ENDDO a2 
#
            PUT Fya(a,a1) += taa(a,a1)  
#
      ENDPARDO a, a1 
#
      PARDO a, a1, i, i1  
#
               REQUEST             Vaaii(a,a1,i,i1) a
               REQUEST             Viaai(i,a1,a,i1) a
               GET                 Sya(i1,i) 
#
               tpppp(a,a1,i,i1)  = Vaaii(a,a1,i,i1) 
               t1pppp(a,a1,i,i1) = Viaai(i,a1,a,i1) 
               tpppp(a,a1,i,i1) -= t1pppp(a,a1,i,i1) 
#
               taa(a,a1)         = tpppp(a,a1,i,i1)*Sya(i1,i)  
               taa(a,a1)        *= -1.0  
#
               PUT Fya(a,a1)    += taa(a,a1)  
#
      ENDPARDO a, a1, i, i1  
#
      PARDO a, a1, j, j1  
#
               REQUEST          Vaajj(a,a1,j,j1) a
               GET              Sya(j1,j) 
#
               taa(a,a1)      = Vaajj(a,a1,j,j1)*Sya(j1,j)  
               taa(a,a1)     *= -1.0  
#
               PUT Fya(a,a1) += taa(a,a1)  
#
      ENDPARDO a, a1, j, j1  
#
      PARDO a, a1, a2, i  
#
               REQUEST             VSaaai(a1,a,a2,i) a
               REQUEST             VSaaai(a,a1,a2,i) a 
              #GET                 Uyaa(a2,i) 
#
               tpppp(a,a1,a2,i)  = VSaaai(a1,a,a2,i) 
               t1pppp(a,a1,a2,i) = VSaaai(a,a1,a2,i) 
               tpppp(a,a1,a2,i) += t1pppp(a,a1,a2,i) 
#
               taa(a,a1)         = tpppp(a,a1,a2,i)*SUyaa(a2,i) 
#
               PUT Fya(a,a1)    += taa(a,a1)  
#
      ENDPARDO a, a1, a2, i  
#
      PARDO a, a1, b, j  
#
               REQUEST            Vaabj(a1,a,b,j) b 
               REQUEST            Vaabj(a,a1,b,j) b 
              #GET                Uyaa(b,j) 
#
               tppqq(a,a1,b,j)  = Vaabj(a1,a,b,j) 
               t1ppqq(a,a1,b,j) = Vaabj(a,a1,b,j) 
               tppqq(a,a1,b,j) += t1ppqq(a,a1,b,j) 
#
               taa(a,a1)        = tppqq(a,a1,b,j)*SUyaa(b,j) 
#
               PUT Fya(a,a1)   += taa(a,a1)  
#
      ENDPARDO a, a1, b, j  
#
#     alpha-alpha occupied-occupied block 
#     ----------------------------------- 
#
      PARDO i, i1, i2  
#
               if i1 == i2 
#
               GET           Sya(i,i2) 
               t1ii(i,i1)  = Sya(i,i2)*Fock_a(i1,i2) 
               t1ii(i,i1) *= -0.5  
               PUT Fya(i,i1) += t1ii(i,i1)  
#
               endif 
#
               if i == i2 
#
               GET           Sya(i2,i1) 
               t1ii(i,i1)  = Sya(i2,i1)*Fock_a(i2,i) 
               t1ii(i,i1) *= -0.5  
               PUT Fya(i,i1) += t1ii(i,i1)  
#
               endif 
#
      ENDPARDO i, i1, i2  
#
      PARDO i, i1, i2, i3  
#
               REQUEST      VSpipi(i,i1,i2,i3) i
               GET          Sya(i3,i2) 
#
               tii(i,i1) = VSpipi(i,i1,i2,i3)*Sya(i3,i2)  
               tii(i,i1) *= -1.0  
#
               PUT Fya(i,i1) += tii(i,i1)  
#
      ENDPARDO i, i1, i2, i3  
#
      PARDO i, i1, j, j1  
#
               REQUEST      Vpiqj(i,i1,j,j1) i
               GET          Sya(j1,j) 
#
               tii(i,i1) = Vpiqj(i,i1,j,j1)*Sya(j1,j)  
               tii(i,i1) *= -1.0  
#
               PUT Fya(i,i1) += tii(i,i1)  
#
      ENDPARDO i, i1, j, j1  
#
      PARDO i, i1, i2, a2  
#
               REQUEST              VSpipi(i1,i,a2,i2) i 
               REQUEST              VSpipi(i,i1,a2,i2) i 
              #GET                  Uyaa(a2,i2) 
#
               tpppp(i,i1,a2,i2)  = VSpipi(i1,i,a2,i2) 
               t1pppp(i,i1,a2,i2) = VSpipi(i,i1,a2,i2) 
               tpppp(i,i1,a2,i2) += t1pppp(i,i1,a2,i2) 
#
               tii(i,i1)         = tpppp(i,i1,a2,i2)*SUyaa(a2,i2) 
#
               PUT Fya(i,i1) += tii(i,i1)  
#
      ENDPARDO i, i1, i2, a2  
#
      PARDO i, i1, j, b  
#
               REQUEST            Vpiqj(i1,i,b,j) i
               REQUEST            Vpiqj(i,i1,b,j) i
              #GET                Uyaa(b,j) 
#
               tppqq(i,i1,b,j)  = Vpiqj(i1,i,b,j) 
               t1ppqq(i,i1,b,j) = Vpiqj(i,i1,b,j) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j) 
#
               tii(i,i1)       = tppqq(i,i1,b,j)*SUyaa(b,j) 
#
               PUT Fya(i,i1) += tii(i,i1)  
#
      ENDPARDO i, i1, j, b  
#
      execute sip_barrier 
#
# ---------------------------------------------------------------------------
#
      ENDPROC FINTY_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC HINTX_TRAN 
#     --------------- 
#
#     The transformed first-derivative fock matrix is computed. The 
#     perturbation is defined by iatom, ix and icenter and the 
#     final arrays are Fxa and Fxb. 
#
      create Hx_xp 
#     create Hx_xq 
      execute sip_barrier 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
            DO p 
#
               txp(mu,p)        = txx(mu,nu)*ca(nu,p)  
               PUT Hx_xp(mu,p) += txp(mu,p) 
#
            ENDDO p 
#
#           DO q 
#
#              txq(mu,q)        = txx(mu,nu)*ca(nu,q)  
#              PUT Hx_xq(mu,q) += txq(mu,q) 
#
#           ENDDO q 
#
      ENDPARDO mu, nu 
#
      execute sip_barrier 
#
      PARDO mu, p, p1 
#
            GET              Hx_xp(mu,p) 
            tpp(p1,p)      = Hx_xp(mu,p)*ca(mu,p1) 
            PUT Hxa(p1,p) += tpp(p1,p) 
#
      ENDPARDO mu, p, p1 
#
#     PARDO mu, q, q1 
#
#           GET              Hx_xq(mu,q) 
#           tqq(q1,q)      = Hx_xq(mu,q)*ca(mu,q1) 
#           PUT Hxb(q1,q) += tqq(q1,q) 
#
#     ENDPARDO mu, q, q1 
#
      execute sip_barrier 
      delete Hx_xp 
#     delete Hx_xq 
#
      ENDPROC HINTX_TRAN 
#     ----------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC SINTY_TRAN 
#     --------------- 
#
#     The transformed first-derivative overlap matrix is computed. The 
#     perturbation is defined by jatom, jx and jcenter and the 
#     final arrays are Sya and Syb. 
#
      PARDO mu, nu 
            execute overlap_der txx(mu,nu) 
            DO p 
               tpx(p,nu) = txx(mu,nu)*ca(mu,p)  
               DO p1 
                  tpp(p,p1)       = tpx(p,nu)*ca(nu,p1) 
                  PUT Sya(p,p1)  += tpp(p,p1) 
               ENDDO p1  
            ENDDO p 
      ENDPARDO mu, nu 
#
#     create Stemp 
#     execute sip_barrier 
#     PARDO mu, nu 
#
#           execute overlap_der txx(mu,nu) 
#
#           DO p 
#              txp(mu,p) = txx(mu,nu)*ca(nu,p)  
#              PUT Stemp(mu,p) += txp(mu,p) 
#           ENDDO p 
#
#     ENDPARDO mu, nu 
#     execute sip_barrier 
#
#     PARDO mu, p  
#
#           GET Stemp(mu,p) 
#
#           DO p1 
#
#              tpp(p1,p)       = Stemp(mu,p)*ca(mu,p1) 
#              PUT Sya(p1,p)  += tpp(p1,p) 
#
#           ENDDO p1  
#
#     ENDPARDO mu, p 
#     execute sip_barrier 
#     delete Stemp 

      ENDPROC SINTY_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC SINTX_TRAN 
#     --------------- 
#
#     The transformed first-derivative overlap matrix is computed. The 
#     perturbation is defined by iatom, ix and icenter and the 
#     final arrays are Sxa and Sxb. 
#
      execute sip_barrier 
#
      PARDO mu, nu 
#
            GET            whfya(mu,nu) 
           #GET            whfyb(mu,nu) 
#
            execute overlap_der txx(mu,nu)
#
#           Compute contributions to HF hessian. 
#           ------------------------------------ 
            t1xx(mu,nu)  = whfya(mu,nu) 
           #t1xx(mu,nu) += whfyb(mu,nu) 
            etemp        = txx(mu,nu)*t1xx(mu,nu) 
           #etemp       *= 0.5 
            hessxy      += etemp 
            hessyx      += etemp 
#
      ENDPARDO mu, nu 
#
      PARDO mu, nu 
#
            GET            dhfya(mu,nu) 
           #GET            dhfyb(mu,nu) 
#
            GET            QABxx(mu,nu) 
            GET            QAxx(mu,nu) 
#
            execute fock_der txx(mu,nu) 
#
#           Compute contributions to the HF hessian. 
#           ---------------------------------------- 
#
            t1xx(mu,nu)  = txx(mu,nu) 
            t1xx(mu,nu) += QABxx(mu,nu) 
            t1xx(mu,nu) += QAxx(mu,nu) 

            etemp        = t1xx(mu,nu)*dhfya(mu,nu) 
           #etemp       *= 0.5 
            hessxy      += etemp 
            hessyx      += etemp 

           #t1xx(mu,nu)  = txx(mu,nu) 
           #t1xx(mu,nu) += QABxx(mu,nu) 
           #t1xx(mu,nu) += QBxx(mu,nu) 

           #etemp        = t1xx(mu,nu)*dhfyb(mu,nu) 
           #etemp       *= 0.5 
           #hessxy      += etemp 
           #hessyx      += etemp 
#
      ENDPARDO mu, nu 
#
      ENDPROC SINTX_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC Uy_XX  
#     ----------- 
#
      create Uyaa 
      execute sip_barrier 
#
      PARDO a, a1  
#
            REQUEST           STa(a1,a,jatom,jx) a 
            tpp(a1,a)       = STa(a1,a,jatom,jx) 
            tpp(a1,a)      *= -0.5  
            PUT Uyaa(a1,a) += tpp(a1,a) 
#
      ENDPARDO a, a1  
#
      PARDO i, i1  
#
            REQUEST           STa(i1,i,jatom,jx) i 
            tpp(i1,i)       = STa(i1,i,jatom,jx) 
            tpp(i1,i)      *= -0.5  
            PUT Uyaa(i1,i) += tpp(i1,i) 
#
      ENDPARDO i, i1  
#
#     PARDO b, b1  
#
#           REQUEST           STb(b1,b,jatom,jx) b 
#           tqq(b1,b)       = STb(b1,b,jatom,jx) 
#           tqq(b1,b)      *= -0.5  
#           PUT Uybb(b1,b) += tqq(b1,b) 
#
#     ENDPARDO b, b1  
#
#     PARDO j, j1  
#
#           REQUEST           STb(j1,j,jatom,jx) j 
#           tqq(j1,j)       = STb(j1,j,jatom,jx) 
#           tqq(j1,j)      *= -0.5  
#           PUT Uybb(j1,j) += tqq(j1,j) 
#
#     ENDPARDO j, j1  
#
      ENDPROC Uy_XX  
#     ------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC Ux_XX  
#     ----------- 
#
      PARDO a, a1  
#
            REQUEST           STa(a1,a,iatom,ix) a 
            tpp(a1,a)       = STa(a1,a,iatom,ix) 
            tpp(a1,a)      *= -0.5  
            PUT Uxaa(a1,a)  = tpp(a1,a) 
#
      ENDPARDO a, a1  
#
      PARDO i, i1  
#
            REQUEST           STa(i1,i,iatom,ix) i 
            tpp(i1,i)       = STa(i1,i,iatom,ix) 
            tpp(i1,i)      *= -0.5  
            PUT Uxaa(i1,i)  = tpp(i1,i) 
#
      ENDPARDO i, i1  
#
      ENDPROC Ux_XX  
#     ------------- 
#
      PROC Qx_XX 
#     ---------- 
#
#     Form the virtual-occupied block of the Q array --> Qxai, Qxbj
#     -------------------------------------------------------------
#
#     Qxai first
#     ----------
#
      PARDO a, i, i1 
#
            GET              Sxa(a,i1)
            tai(a,i)       = Sxa(a,i1)*Fock_a(i,i1)
            tai(a,i)      *= -1.0  
            PUT Qxai(a,i) += tai(a,i)
#
      ENDPARDO a, i, i1 
#
      PARDO a, i, i1, i2  
#
            REQUEST          VSpipi(a,i,i2,i1) i 
            GET              Sxa(i1,i2)
            tai(a,i)       = VSpipi(a,i,i2,i1)*Sxa(i1,i2)
            tai(a,i)      *= -1.0  
            PUT Qxai(a,i) += tai(a,i)
#
      ENDPARDO a, i, i1, i2 
#
      PARDO a, i, j, j1 
#
            REQUEST          Vpiqj(a,i,j1,j) a 
            GET              Sxa(j,j1)
            tai(a,i)       = Vpiqj(a,i,j1,j)*Sxa(j,j1)
            tai(a,i)      *= -1.0  
            PUT Qxai(a,i) += tai(a,i)
#
      ENDPARDO a, i, j, j1 
#
      execute sip_barrier 
#
      ENDPROC Qx_XX  
#     ------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC I_TRANS
#     ------------
#
      create Ixx_a 
      create Ixx_b 
      create Ihf 
      execute sip_barrier 
#
#     1. Iij_a
#     --------
#
      PARDO i, i1
#
            GET Ipq_a(i,i1)
#
            DO mu
#
               Txi(mu,i1) = ca(mu,i)*Ipq_a(i,i1)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i1)*ca(nu,i1)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO i, i1
#
#     2. Iij_b
#     --------
#
      PARDO j, j1
#
            GET Ipq_b(j,j1)
#
            DO mu
#
               Txj(mu,j1) = ca(mu,j)*Ipq_b(j,j1)
#
               DO nu
#
                  Txx(mu,nu)        = Txj(mu,j1)*ca(nu,j1)
                  PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO j, j1
#
#     3. Iab_a
#     --------
#
      PARDO a, a1
#
            GET Ipq_a(a,a1)
#
            DO mu
#
               Txa(mu,a1) = ca(mu,a)*Ipq_a(a,a1)
#
               DO nu
#
                  Txx(mu,nu)        = Txa(mu,a1)*ca(nu,a1)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, a1
#
#     4. Iab_b
#     --------
#
      PARDO b, b1
#
            GET Ipq_b(b,b1)
#
            DO mu
#
               Txb(mu,b1) = ca(mu,b)*Ipq_b(b,b1)
#
               DO nu
#
                  Txx(mu,nu)        = Txb(mu,b1)*ca(nu,b1)
                  PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO b, b1
#
#     5. Iai_a
#     --------
#
      PARDO a, i
#
#           GET Ipq_a(a,i)
            GET Ipq_a(i,a)
#
            DO mu
#
               Txi(mu,i)  = ca(mu,a)*Ipq_a(i,a)
#              T1xi(mu,i) = ca(mu,a)*Ipq_a(i,a)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i)*ca(nu,i)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
                  T1xx(nu,mu)       = Txx(mu,nu) 
                  PUT Ixx_a(nu,mu) += T1xx(nu,mu)
#
#                 Txx(mu,nu)        = T1xi(mu,i)*ca(nu,i)
#                 PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, i
#
#     6. Iai_b
#     --------
#
      PARDO b, j
#
#           GET Ipq_b(b,j)
            GET Ipq_b(j,b)
#
            DO mu
#
               Txj(mu,j)  = ca(mu,b)*Ipq_b(j,b)
#              T1xj(mu,j) = ca(mu,b)*Ipq_b(j,b)
#
               DO nu
#
                  Txx(mu,nu)        = Txj(mu,j)*ca(nu,j)
                  PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
                  T1xx(nu,mu)       = Txx(mu,nu) 
                  PUT Ixx_b(nu,mu) += T1xx(nu,mu)
#
#                 Txx(mu,nu)        = T1xj(mu,j)*ca(nu,j)
#                 PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO b, j
#
      ENDPROC I_TRANS
#     ---------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC D_TRANS
#     ------------
#
      create Dxx_a 
      create Dxx_b 
      execute sip_barrier 
#
#     1. Dij_a
#     --------
#
      PARDO i, i1
#
            GET Dij_a(i,i1)
#
            DO mu
#
               Txi(mu,i1) = ca(mu,i)*Dij_a(i,i1)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i1)*ca(nu,i1)
                  PUT Dxx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO i, i1
#
#     2. Dij_b
#     --------
#
      PARDO j, j1
#
            GET Dij_b(j,j1)
#
            DO mu
#
               Txj(mu,j1) = ca(mu,j)*Dij_b(j,j1)
#
               DO nu
#
                  Txx(mu,nu)        = Txj(mu,j1)*ca(nu,j1)
                  PUT Dxx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO j, j1
#
#     3. Dab_a
#     --------
#
      PARDO a, a1
#
            GET Dab_a(a,a1)
#
            DO mu
#
               Txa(mu,a1) = ca(mu,a)*Dab_a(a,a1)
#
               DO nu
#
                  Txx(mu,nu)        = Txa(mu,a1)*ca(nu,a1)
                  PUT Dxx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, a1
#
#     4. Dab_b
#     --------
#
      PARDO b, b1
#
            GET Dab_b(b,b1)
#
            DO mu
#
               Txb(mu,b1) = ca(mu,b)*Dab_b(b,b1)
#
               DO nu
#
                  Txx(mu,nu)        = Txb(mu,b1)*ca(nu,b1)
                  PUT Dxx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO b, b1
#
#     5. Dai_a
#     --------
#
      PARDO a, i
#
            GET Dai_a(a,i)
#
            DO mu
#
               Txi(mu,i) = ca(mu,a)*Dai_a(a,i)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i)*ca(nu,i)
                  PUT Dxx_a(mu,nu) += Txx(mu,nu)
#
                  T1xx(nu,mu)       = Txx(mu,nu)
                  PUT Dxx_a(nu,mu) += T1xx(nu,mu) 
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, i
#
#     6. Dai_b
#     --------
#
      PARDO b, j
#
            GET Dai_b(b,j)
#
            DO mu
#
               Txj(mu,j) = ca(mu,b)*Dai_b(b,j)
#
               DO nu
#
                  Txx(mu,nu)        = Txj(mu,j)*ca(nu,j)
                  T1xx(nu,mu)       = Txx(mu,nu)
#
                  PUT Dxx_b(mu,nu) += Txx(mu,nu)
                  PUT Dxx_b(nu,mu) += T1xx(nu,mu) 
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO b, j
#
      ENDPROC D_TRANS
#     ---------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC I_HF
#     --------
#
      create Ihfa 
      create Ihfb 
      execute sip_barrier 
#
      PARDO mu, nu, i
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               T1xi(nu,i) = ca(nu,i1)*fock_a(i,i1)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)      = ca(mu,i)*Txi(nu,i)
            PUT Ihf(mu,nu) += Txx(mu,nu)
            PUT Ihfa(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i
#
      PARDO mu, nu, j
#
            Txj(nu,j) = 0.0
#
            DO j1
#
               T1xj(nu,j) = ca(nu,j1)*fock_a(j,j1)
               Txj(nu,j) -= T1xj(nu,j)
#
            ENDDO j1
#
            Txx(mu,nu)      = ca(mu,j)*Txj(nu,j)
            PUT Ihf(mu,nu) += Txx(mu,nu)
            PUT Ihfb(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, j
#
      execute sip_barrier 
#
      ENDPROC I_HF
#     ------------
#
# ---------------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
      create Dhfa 
      execute sip_barrier 
#
      PARDO mu, nu, i
#
            Txi(nu,i)        = ca(nu,i)
            Txx(mu,nu)       = ca(mu,i)*Txi(nu,i)
            PUT Dhfa(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i
#
      ENDPROC HFDENS
#     --------------
#
# ---------------------------------------------------------------------------------- 
#
     PROC I11
#    --------
#
      PARDO a, i
#
            Tia(i,a) = 0.0
#
            DO i1
#
               IF i1 == i
#
                  GET         Dpq_a(a,i1)
                  T1ia(i,a) = Dpq_a(a,i1)*fock_a(i1,i)
                  Tia(i,a) -= T1ia(i,a)
#
               ENDIF # i1 == i
#
            ENDDO i1
#
            PUT Ipq_a(i,a) += Tia(i,a)
#
      ENDPARDO a, i 
#
      PARDO b, j
#
            Tjb(j,b) = 0.0
#
            DO j1
#
               IF j1 == j
#
                  GET         Dpq_b(b,j1)
                  T1jb(j,b) = Dpq_b(b,j1)*fock_a(j1,j)
                  Tjb(j,b) -= T1jb(j,b)
#
               ENDIF # j1 == j
#
            ENDDO j1
#
            PUT Ipq_b(j,b) += Tjb(j,b)
#
      ENDPARDO b, j
#
# Compute contribution to Iij_a
# -----------------------------
#
#     Dab contribution
#     ----------------
#
      PARDO a, a1, i, i1
#
            REQUEST             Vaaii(a,a1,i,i1) a
            REQUEST             Viaai(i,a1,a,i1) a
            REQUEST             Vaaii(a,a1,i1,i) a
            REQUEST             Viaai(i1,a1,a,i) a  
            GET                 Dab_a(a,a1)
#
            Tpppp(i,i1,a,a1)  = Vaaii(a,a1,i,i1)
            T1pppp(i,i1,a,a1) = Viaai(i,a1,a,i1)
            T2pppp(i,i1,a,a1) = Vaaii(a,a1,i1,i)
            T3pppp(i,i1,a,a1) = Viaai(i1,a1,a,i)
#
            Tpppp(i,i1,a,a1) -= T1pppp(i,i1,a,a1)
            Tpppp(i,i1,a,a1) += T2pppp(i,i1,a,a1)
            Tpppp(i,i1,a,a1) -= T3pppp(i,i1,a,a1)
#
            Tii(i,i1)         = Tpppp(i,i1,a,a1)*Dab_a(a,a1)
            Tii(i,i1)        *= -0.5
            PUT Iij_a(i,i1)  += Tii(i,i1)
#
      ENDPARDO a, a1, i, i1
#
      PARDO b, b1, i, i1
#
            REQUEST             Vbbii(b,b1,i,i1) b
            REQUEST             Vbbii(b,b1,i1,i) b 
            GET                 Dab_b(b,b1)
#
            Tppqq(i,i1,b,b1)  = Vbbii(b,b1,i,i1)
            T2ppqq(i,i1,b,b1) = Vbbii(b,b1,i1,i)
            Tppqq(i,i1,b,b1) += T2ppqq(i,i1,b,b1)
#
            Tii(i,i1)         = Tppqq(i,i1,b,b1)*Dab_b(b,b1)
            Tii(i,i1)        *= -0.5
            PUT Iij_a(i,i1)  += Tii(i,i1)
#
      ENDPARDO b, b1, i, i1
#
#     Dij contribution
#     ----------------
#
      PARDO i2, i3, i, i1
#
            REQUEST              VSpipi(i2,i3,i,i1) i
            REQUEST              VSpipi(i2,i3,i1,i) i 
            GET                  Dij_a(i2,i3)
#
            Tpppp(i,i1,i2,i3)  = VSpipi(i2,i3,i,i1)
            T2pppp(i,i1,i2,i3) = VSpipi(i2,i3,i1,i)
            Tpppp(i,i1,i2,i3) += T2pppp(i,i1,i2,i3)
#
            Tii(i,i1)          = Tpppp(i,i1,i2,i3)*Dij_a(i2,i3)
            Tii(i,i1)         *= -0.5
            PUT Iij_a(i,i1)   += Tii(i,i1)
#
      ENDPARDO i2, i3, i, i1
#
      PARDO j, j1, i, i1
#
            REQUEST             Vpiqj(i,i1,j,j1) i
            REQUEST             Vpiqj(i1,i,j,j1) i  
            GET                 Dij_b(j,j1)
#
            Tppqq(i,i1,j,j1)  = Vpiqj(i,i1,j,j1)
            T2ppqq(i,i1,j,j1) = Vpiqj(i1,i,j,j1)
            Tppqq(i,i1,j,j1) += T2ppqq(i,i1,j,j1)
#
            Tii(i,i1)         = Tppqq(i,i1,j,j1)*Dij_b(j,j1)
            Tii(i,i1)        *= -0.5
            PUT Iij_a(i,i1)  += Tii(i,i1)
#
      ENDPARDO j, j1, i, i1
#
# DONE Compute contribution to Iij_a
# -----------------------------------
#
# Compute contribution to Iij_b
# -----------------------------
#
#     Dab contribution
#     ----------------
#
      PARDO b, b1, j, j1
#
            REQUEST             Vbbjj(b,b1,j,j1) b
            REQUEST             Vjbbj(j,b1,b,j1) b
            REQUEST             Vbbjj(b,b1,j1,j) b
            REQUEST             Vjbbj(j1,b1,b,j) b
            GET                 Dab_b(b,b1)
#
            Tqqqq(j,j1,b,b1)  = Vbbjj(b,b1,j,j1)
            T1qqqq(j,j1,b,b1) = Vjbbj(j,b1,b,j1)
            T2qqqq(j,j1,b,b1) = Vbbjj(b,b1,j1,j)
            T3qqqq(j,j1,b,b1) = Vjbbj(j1,b1,b,j)
#
            Tqqqq(j,j1,b,b1) -= T1qqqq(j,j1,b,b1)
            Tqqqq(j,j1,b,b1) += T2qqqq(j,j1,b,b1)
            Tqqqq(j,j1,b,b1) -= T3qqqq(j,j1,b,b1)
#
            Tjj(j,j1)         = Tqqqq(j,j1,b,b1)*Dab_b(b,b1)
            Tjj(j,j1)        *= -0.5
            PUT Iij_b(j,j1)  += Tjj(j,j1)
#
      ENDPARDO b, b1, j, j1
#
      PARDO a, a1, j, j1
#
            REQUEST             Vaajj(a,a1,j,j1) a
            REQUEST             Vaajj(a,a1,j1,j) a 
            GET                 Dab_a(a,a1)
#
            Tqqpp(j,j1,a,a1)  = Vaajj(a,a1,j,j1)
            T2qqpp(j,j1,a,a1) = Vaajj(a,a1,j1,j)
            Tqqpp(j,j1,a,a1) += T2qqpp(j,j1,a,a1)
#
            Tjj(j,j1)         = Tqqpp(j,j1,a,a1)*Dab_a(a,a1)
            Tjj(j,j1)        *= -0.5
            PUT Iij_b(j,j1)  += Tjj(j,j1)
#
      ENDPARDO a, a1, j, j1
#
#     Dij contribution
#     ----------------
#
      PARDO j2, j3, j, j1
#
            REQUEST              VSqjqj(j2,j3,j,j1) j
            REQUEST              VSqjqj(j2,j3,j1,j) j
            GET                  Dij_b(j2,j3)
#
            Tqqqq(j,j1,j2,j3)  = VSqjqj(j2,j3,j,j1)
            T2qqqq(j,j1,j2,j3) = VSqjqj(j2,j3,j1,j)
            Tqqqq(j,j1,j2,j3) += T2qqqq(j,j1,j2,j3)
            Tjj(j,j1)          = Tqqqq(j,j1,j2,j3)*Dij_b(j2,j3)
            Tjj(j,j1)         *= -0.5
            PUT Iij_b(j,j1)   += Tjj(j,j1)
#
      ENDPARDO j2, j3, j, j1
#
      PARDO j, j1, i, i1
#
            REQUEST             Vpiqj(i,i1,j,j1) i
            REQUEST             Vpiqj(i,i1,j1,j) i
            GET                 Dij_a(i,i1)
#
            Tppqq(i,i1,j,j1)  = Vpiqj(i,i1,j,j1)
            T2ppqq(i,i1,j,j1) = Vpiqj(i,i1,j1,j)
            Tppqq(i,i1,j,j1) += T2ppqq(i,i1,j,j1)
#
            Tjj(j,j1)         = Tppqq(i,i1,j,j1)*Dij_a(i,i1)
            Tjj(j,j1)        *= -0.5
            PUT Iij_b(j,j1)  += Tjj(j,j1)
#
      ENDPARDO j, j1, i, i1
#
#      virtual-occupied contribution 
#      -----------------------------
#
       PARDO i, i1, a, i2
#
             REQUEST            VSpipi(i,i1,a,i2) a 
             GET                Dpq_a(a,i2)
#
             Tii(i,i1)        = VSpipi(i,i1,a,i2)*Dpq_a(a,i2)
             Tii(i,i1)       *= -1.0
             PUT Iij_a(i,i1) += Tii(i,i1)
             T1ii(i1,i)       = Tii(i,i1)
             PUT Iij_a(i1,i) += T1ii(i1,i)
#
       ENDPARDO i, i1, a, i2 
#
       PARDO i, i1, b, j
#
             REQUEST            Vpiqj(i,i1,b,j) b 
             GET                Dpq_b(b,j)
#
             Tii(i,i1)        = Vpiqj(i,i1,b,j)*Dpq_b(b,j)
             Tii(i,i1)       *= -1.0
             PUT Iij_a(i,i1) += Tii(i,i1)
             T1ii(i1,i)       = Tii(i,i1)
             PUT Iij_a(i1,i) += T1ii(i1,i)
#
       ENDPARDO i, i1, b, j
#
#      virtual-occupied contribution --> Needs checked VFL
#      -----------------------------
       PARDO j, j1, j2, b
#
             REQUEST            VSqjqj(j,j1,b,j2) b 
             GET                Dpq_b(b,j2)
#
             Tjj(j,j1)        = VSqjqj(j,j1,b,j2)*Dpq_b(b,j2)
             Tjj(j,j1)       *= -1.0
             PUT Iij_b(j,j1) += Tjj(j,j1)
             T1jj(j1,j)       = Tjj(j,j1)
             PUT Iij_b(j1,j) += T1jj(j1,j)
#
       ENDPARDO j, j1, j2, b
#
       PARDO j, j1, i, a
#
             REQUEST            Vpiqj(a,i,j,j1) a 
             GET                Dpq_a(a,i)
#
             Tjj(j,j1)        = Vpiqj(a,i,j,j1)*Dpq_a(a,i)
             Tjj(j,j1)       *= -1.0
             PUT Iij_b(j,j1) += Tjj(j,j1)
             T1jj(j1,j)       = Tjj(j,j1)
             PUT Iij_b(j1,j) += T1jj(j1,j)
#
       ENDPARDO j, j1, i, a
#
       execute sip_barrier 
#
#      Complete intermediate arrays to be used in construction of Hessian. 
#      ------------------------------------------------------------------- 
#
       PARDO i, i1
             GET               Iij_a(i,i1)
             PUT Ipq_a(i,i1) = Iij_a(i,i1)
       ENDPARDO i, i1
#
       PARDO a, a1
             GET               Iab_a(a,a1)
             PUT Ipq_a(a,a1) = Iab_a(a,a1)
       ENDPARDO a, a1
#
       PARDO j, j1
             GET               Iij_b(j,j1)
             PUT Ipq_b(j,j1) = Iij_b(j,j1)
       ENDPARDO j, j1
#
       PARDO b, b1
             GET               Iab_b(b,b1)
             PUT Ipq_b(b,b1) = Iab_b(b,b1)
       ENDPARDO b, b1
#
       PARDO a, i
             GET              Ipq_a(i,a)
             tai(a,i)       = Ipq_a(i,a)
             PUT Ipq_a(a,i) = tai(a,i)
       ENDPARDO a, i
#
       PARDO b, j
             GET              Ipq_b(j,b)
             tbj(b,j)       = Ipq_b(j,b)
             PUT Ipq_b(b,j) = tbj(b,j)
       ENDPARDO b, j
#
       execute sip_barrier 
#
     ENDPROC I11
#    -----------
#
# ---------------------------------------------------------------------------------
#
      PROC SXY_CONT
#     -------------
#
# Contract with the second derivative integrals
# --------------------------------------
#
      PARDO mu, nu
#
            GET             Ihf(mu,nu) 
            GET             Ixx_a(mu,nu)
            GET             Ixx_b(mu,nu)

            Txx(mu,nu)    = Ixx_a(mu,nu)
            Txx(mu,nu)   += Ixx_b(mu,nu)
            Txx(mu,nu)   += Ihf(mu,nu)

            EXECUTE SCONTXY Txx(mu,nu)
# 
      ENDPARDO mu, nu
#
      ENDPROC SXY_CONT
#     ----------------
#
# ---------------------------------------------------------------------------------
#
      PROC DXY_CONT
#     -------------
#
# Contract with the second derivative integrals
# --------------------------------------
#
      PARDO mu, nu
            GET             Dxx_a(mu,nu)
           #GET             Dxx_b(mu,nu)
            GET             Dhfa(mu,nu)
           #GET             Dhfb(mu,nu)
#
            Txx(mu,nu)    = Dxx_a(mu,nu)
           #Txx(mu,nu)   += Dxx_b(mu,nu)
            Txx(mu,nu)   += Dhfa(mu,nu)
           #Txx(mu,nu)   += Dhfb(mu,nu)
            Txx(mu,nu)  *= 2.0 
#
            EXECUTE HCONTXY Txx(mu,nu)
#
      ENDPARDO mu, nu
#
      ENDPROC DXY_CONT
#     ----------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC GIJAB_BT 
#     -------------
#
#     'backtransform' G^{ab}_{ij} to G^{mu nu}_{ij}.
#     ----------------------------------------------
#
#     alpha/alpha block.
#     ------------------
#
      PARDO a, a1, i, i1
#
            REQUEST T1aiai_aa(a,i,a1,i1) a
#
            DO mu  
#
               Txiai(mu,i,a1,i1) = T1aiai_aa(a,i,a1,i1)*ca(mu,a)
#
               DO nu   
#
                  Txixi(mu,i,nu,i1)          = Txiai(mu,i,a1,i1)*La(a1,nu) # ca(nu,a1)
                  PREPARE Vxixi(mu,i,nu,i1) += Txixi(mu,i,nu,i1)
#
               ENDDO nu  
#
            ENDDO mu  
#
      ENDPARDO a, a1, i, i1
#
#     alpha/beta block.
#     -----------------
#
      PARDO a, b, i, j
#
            REQUEST T1aibj_ab(a,i,b,j) a
#
            DO mu 
#
               Txibj(mu,i,b,j) = T1aibj_ab(a,i,b,j)*ca(mu,a)
#
               DO nu   
#
                  Txixj(mu,i,nu,j)          = Txibj(mu,i,b,j)*La(b,nu) # ca(nu,b)
                  PREPARE Vxixj(mu,i,nu,j) += Txixj(mu,i,nu,j)
#
               ENDDO nu  
#
            ENDDO mu 
#
      ENDPARDO a, b, i, j
#
      execute sip_barrier
      execute server_barrier
#
# ---------------------------------------------------------------------------------
#
      ENDPROC GIJAB_BT 
#     ----------------
#
# ---------------------------------------------------------------------------------
#
      PROC GIJAB_CONT
#     ---------------
#
#     Complete backtransformation and 'contract' with second derivative integral.
#     ---------------------------------------------------------------------------
#
        PARDO mu, nu 
#
           DO lambda   
           DO sigma   
#
              IF mu < lambda
              IF nu < sigma
#
#                Get 1-particle pieces
#                ---------------------
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = LDHFa(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDHFa(mu,lambda) 
                 t1xx(mu,lambda)           *= 2.0  
#
                 T5xx(mu,sigma)             = LDHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^LDHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = LDHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^LDHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = LDHFA(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDxx_a(mu,lambda)  
                 t1xx(nu,sigma)            *= 2.0  
#
                 T5xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,sigma)^LDHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,nu)^LDHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(nu,lambda)^LDHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(sigma,lambda)^LDHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 TCxxxx(mu,lambda,nu,sigma) *= 0.5  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)     = 0.0
                    TBxxxi(mu,lambda,sigma,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)        i
                       REQUEST Vxixi(lambda,i,nu,i1)    i
                       REQUEST Vxixi(mu,i,sigma,i1)     i
                       REQUEST Vxixi(lambda,i,sigma,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)    = Vxixi(mu,i,nu,i1)*La(i,lambda) # ca(lambda,i)
                       T2xxxi(mu,lambda,nu,i1)    = Vxixi(lambda,i,nu,i1)*ca(mu,i)
#
                       TAxxxi(mu,lambda,nu,i1)   += T1xxxi(mu,lambda,nu,i1)
                       TAxxxi(mu,lambda,nu,i1)   += T2xxxi(mu,lambda,nu,i1) # -
#
                       T3xxxi(mu,lambda,sigma,i1) = Vxixi(mu,i,sigma,i1)*La(i,lambda) # ca(lambda,i)
                       T4xxxi(mu,lambda,sigma,i1) = Vxixi(lambda,i,sigma,i1)*ca(mu,i)
#
                       TBxxxi(mu,lambda,sigma,i1)+= T4xxxi(mu,lambda,sigma,i1)
                       TBxxxi(mu,lambda,sigma,i1)+= T3xxxi(mu,lambda,sigma,i1) # -
#
                    ENDDO i
                    T1xxxx(mu,lambda,sigma,nu)  = TBxxxi(mu,lambda,sigma,i1)*La(i1,nu) # ca(nu,i1)
                    Txxxx(mu,lambda,nu,sigma)  = T1xxxx(mu,lambda,sigma,nu)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma)  = TAxxxi(mu,lambda,nu,i1)*La(i1,sigma) # ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)     = 0.0
                    TBxxxj(mu,lambda,sigma,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)        j
                       REQUEST Vxixj(lambda,i,nu,j)    j
                       REQUEST Vxixj(mu,i,sigma,j)     j
                       REQUEST Vxixj(lambda,i,sigma,j) j
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixj(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       T2xxxj(mu,lambda,nu,j)    = Vxixj(lambda,i,nu,j)*ca(mu,i)
#
                       TAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       TAxxxj(mu,lambda,nu,j)   += T2xxxj(mu,lambda,nu,j) # -
#
                       T3xxxj(mu,lambda,sigma,j) = Vxixj(mu,i,sigma,j)*La(i,lambda) # ca(lambda,i)
                       T4xxxj(mu,lambda,sigma,j) = Vxixj(lambda,i,sigma,j)*ca(mu,i)
#
                       TBxxxj(mu,lambda,sigma,j)+= T4xxxj(mu,lambda,sigma,j)
                       TBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # -
#
                    ENDDO i
                    T1xxxx(mu,lambda,sigma,nu)  = TBxxxj(mu,lambda,sigma,j)*La(j,nu) # ca(nu,j)
                    Txxxx(mu,lambda,nu,sigma)  = T1xxxx(mu,lambda,sigma,nu) 
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma)  = TAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 4.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
              ENDIF # nu < sigma
              ENDIF # mu < lambda
#
           ENDDO sigma   
           ENDDO lambda   
#
        ENDPARDO mu, nu 
#
        PARDO mu, nu 
#
           DO lambda   
           DO sigma   
#
              IF mu == lambda
              IF nu < sigma
#
#                Get 1-particle pieces
#                ---------------------
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = LDHFa(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDHFa(mu,lambda) 
                 t1xx(mu,lambda)           *= 2.0  
#
                 T5xx(mu,sigma)             = LDHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^LDHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = LDHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^LDHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = LDHFA(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDxx_a(mu,lambda)  
                 t1xx(mu,lambda)           *= 2.0  
#
                 T5xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,sigma)^LDHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,nu)^LDHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(nu,lambda)^LDHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(sigma,lambda)^LDHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 TCxxxx(mu,lambda,nu,sigma) *= 0.5  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)     = 0.0
                    TBxxxi(mu,lambda,sigma,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)    i
                       REQUEST Vxixi(mu,i,sigma,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)    = Vxixi(mu,i,nu,i1)*La(i,lambda) # ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1)   += T1xxxi(mu,lambda,nu,i1)
                       T3xxxi(mu,lambda,sigma,i1) = Vxixi(mu,i,sigma,i1)*La(i,lambda) # ca(lambda,i)
                       TBxxxi(mu,lambda,sigma,i1)+= T3xxxi(mu,lambda,sigma,i1) # -
#
                    ENDDO i
                    T1xxxx(mu,lambda,sigma,nu) = TBxxxi(mu,lambda,sigma,i1)*La(i1,nu) # ca(nu,i1)
                    Txxxx(mu,lambda,nu,sigma) = T1xxxx(mu,lambda,sigma,nu) 
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*La(i1,sigma) # ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)    = 0.0
                    TBxxxj(mu,lambda,sigma,j) = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)    j
                       REQUEST Vxixj(mu,i,sigma,j) j
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixj(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       T3xxxj(mu,lambda,sigma,j) = Vxixj(mu,i,sigma,j)*La(i,lambda) # ca(lambda,i)
                       TBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # -
#
                    ENDDO i
                    T1xxxx(mu,lambda,sigma,nu) = TBxxxj(mu,lambda,sigma,j)*La(j,nu) # ca(nu,j)
                    Txxxx(mu,lambda,nu,sigma) = T1xxxx(mu,lambda,sigma,nu) 
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
              ENDIF # nu < sigma
              ENDIF # mu == lambda
#
           ENDDO sigma   
           ENDDO lambda   
#
        ENDPARDO mu, nu 
#
        PARDO mu, nu 
#
           DO lambda   
           DO sigma   
#
              IF mu < lambda
              IF nu == sigma
#
#                Get 1-particle pieces
#                ---------------------
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = LDHFa(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDHFa(mu,lambda) 
                 t1xx(mu,lambda)           *= 2.0  
#
                 T5xx(mu,sigma)             = LDHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^LDHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = LDHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^LDHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = LDHFA(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDxx_a(mu,lambda)  
                 t1xx(mu,lambda)           *= 2.0  
#
                 T5xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,sigma)^LDHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,nu)^LDHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(nu,lambda)^LDHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(sigma,lambda)^LDHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 TCxxxx(mu,lambda,nu,sigma) *= 0.5  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)  = 0.0
                    TBxxxi(lambda,mu,nu,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)     i
                       REQUEST Vxixi(lambda,i,nu,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)  = Vxixi(mu,i,nu,i1)*La(i,lambda) # ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                       T2xxxi(lambda,mu,nu,i1)  = Vxixi(lambda,i,nu,i1)*La(i,mu) # ca(mu,i)
                       TBxxxi(lambda,mu,nu,i1) += T2xxxi(lambda,mu,nu,i1) # -
#
                    ENDDO i
                    T1xxxi(mu,lambda,nu,i1)   = TBxxxi(lambda,mu,nu,i1) 
                    T1xxxi(mu,lambda,nu,i1)  += TAxxxi(mu,lambda,nu,i1) 
                    Txxxx(mu,lambda,nu,sigma) = T1xxxi(mu,lambda,nu,i1)*La(i1,sigma) # ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                   #Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*La(i1,sigma) # ca(sigma,i1)
                   #D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)  = 0.0
                    TBxxxj(lambda,mu,nu,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)     j
                       REQUEST Vxixj(lambda,i,nu,j) j
#
                       T1xxxj(mu,lambda,nu,j)  = Vxixj(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j) += T1xxxj(mu,lambda,nu,j)
                       T2xxxj(lambda,mu,nu,j)  = Vxixj(lambda,i,nu,j)*La(i,mu) # ca(mu,i)
                       TBxxxj(lambda,mu,nu,j) += T2xxxj(lambda,mu,nu,j) # -
#
                    ENDDO i
                    T1xxxj(mu,lambda,nu,j)    = TBxxxj(lambda,mu,nu,j) 
                    T1xxxj(mu,lambda,nu,j)   += TAxxxj(mu,lambda,nu,j) 
                    T1xxxj(mu,lambda,nu,j)   *= 2.0  
                    Txxxx(mu,lambda,nu,sigma) = T1xxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                   #D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                   #Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                   #D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                   #D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
              ENDIF # nu == sigma
              ENDIF # mu < lambda
#
           ENDDO sigma   
           ENDDO lambda   
#
        ENDPARDO mu, nu 
#
        PARDO mu, nu 
#
           DO lambda   
           DO sigma   
#
              IF mu == lambda
              IF nu == sigma
#
#                Get 1-particle pieces
#                ---------------------
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = LDHFa(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDHFa(mu,lambda) 
                 t1xx(mu,lambda)           *= 2.0  
#
                 T5xx(mu,sigma)             = LDHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^LDHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = LDHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^LDHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = LDHFA(nu,sigma) 
                 t2xx(nu,sigma)            *= 2.0  
                 t1xx(mu,lambda)            = LDxx_a(mu,lambda)  
                 t1xx(mu,lambda)           *= 2.0  
#
                 T5xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,sigma)^LDHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = LDxx_a(mu,nu)^LDHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(nu,lambda)^LDHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = LDxx_a(sigma,lambda)^LDHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 TCxxxx(mu,lambda,nu,sigma) *= 0.5  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1) i
                       T1xxxi(mu,lambda,nu,i1)  = Vxixi(mu,i,nu,i1)*La(i,lambda) # ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*La(i1,sigma) # ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j) i
                       T1xxxj(mu,lambda,nu,j)  = Vxixj(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j) += T1xxxj(mu,lambda,nu,j)
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                    Txxxx(mu,lambda,nu,sigma)*= 2.0  
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)#
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
              ENDIF # nu == sigma
              ENDIF # mu == lambda
#
           ENDDO sigma   
           ENDDO lambda   
#
        ENDPARDO mu, nu 
#
      ENDPROC GIJAB_CONT
#     ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC GIJAB_CONT_NEW 
#     ---------------
#
#     Complete backtransformation and 'contract' with second derivative integral.
#     ---------------------------------------------------------------------------
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu < lambda
              WHERE nu < sigma
#
#                Get 1-particle pieces
#                ---------------------
#
                 GET DHFa(mu,lambda)
                 GET DHFa(mu,sigma)
                 GET DHFa(mu,nu)
                 GET DHFa(nu,sigma)
                 GET DHFa(nu,lambda)
                 GET DHFa(sigma,lambda)
#
                 GET Dxx_a(mu,lambda)
                 GET Dxx_a(mu,sigma)
                 GET Dxx_a(mu,nu)
                 GET Dxx_a(nu,lambda)
                 GET Dxx_a(nu,sigma)
                 GET Dxx_a(sigma,lambda)
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = DHFa(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = DHFa(mu,lambda) 
                 t1xx(mu,lambda)           += DHFa(mu,lambda) 
#
                 T5xx(mu,sigma)             = DHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T6xx(mu,sigma)             = DHFa(mu,sigma)
                 T5xxxx(mu,lambda,nu,sigma) = T6xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = DHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xx(mu,nu)                = DHFa(mu,nu)
                 T7xxxx(mu,lambda,nu,sigma) = T8xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T7xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = DHFA(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = Dxx_a(mu,lambda)  
                 t1xx(mu,lambda)           += Dxx_a(mu,lambda)  
#
                 T5xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFa(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFa(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFa(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFa(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) *= 0.25  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)     = 0.0
                    TBxxxi(mu,lambda,sigma,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)        i
                       REQUEST Vxixi(lambda,i,nu,i1)    i
                       REQUEST Vxixi(mu,i,sigma,i1)     i
                       REQUEST Vxixi(lambda,i,sigma,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)    = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       T2xxxi(mu,lambda,nu,i1)    = Vxixi(lambda,i,nu,i1)*ca(mu,i)
#
                       TAxxxi(mu,lambda,nu,i1)   += T1xxxi(mu,lambda,nu,i1)
                       TAxxxi(mu,lambda,nu,i1)   += T2xxxi(mu,lambda,nu,i1) # -
#
                       T3xxxi(mu,lambda,sigma,i1) = Vxixi(mu,i,sigma,i1)*ca(lambda,i)
                       T4xxxi(mu,lambda,sigma,i1) = Vxixi(lambda,i,sigma,i1)*ca(mu,i)
#
                       TBxxxi(mu,lambda,sigma,i1)+= T4xxxi(mu,lambda,sigma,i1)
                       TBxxxi(mu,lambda,sigma,i1)+= T3xxxi(mu,lambda,sigma,i1) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma)  = TBxxxi(mu,lambda,sigma,i1)*ca(nu,i1)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma)  = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0  
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)     = 0.0
                    TBxxxj(mu,lambda,sigma,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)        j
                       REQUEST Vxixj(lambda,i,nu,j)    j
                       REQUEST Vxixj(mu,i,sigma,j)     j
                       REQUEST Vxixj(lambda,i,sigma,j) j
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       T2xxxj(mu,lambda,nu,j)    = Vxixj(lambda,i,nu,j)*ca(mu,i)
#
                       TAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       TAxxxj(mu,lambda,nu,j)   += T2xxxj(mu,lambda,nu,j) # -
#
                       T3xxxj(mu,lambda,sigma,j) = Vxixj(mu,i,sigma,j)*ca(lambda,i)
                       T4xxxj(mu,lambda,sigma,j) = Vxixj(lambda,i,sigma,j)*ca(mu,i)
#
                       TBxxxj(mu,lambda,sigma,j)+= T4xxxj(mu,lambda,sigma,j)
                       TBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma)  = TBxxxj(mu,lambda,sigma,j)*ca(nu,j)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma)  = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 4.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
        ENDPARDO mu, nu, lambda, sigma   
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu == lambda
              WHERE nu < sigma
#
#                Get 1-particle pieces
#                ---------------------
#
                 GET DHFa(mu,lambda)
                 GET DHFa(mu,sigma)
                 GET DHFa(mu,nu)
                 GET DHFa(nu,sigma)
                 GET DHFa(nu,lambda)
                 GET DHFa(sigma,lambda)
#
                 GET Dxx_a(mu,lambda)
                 GET Dxx_a(mu,sigma)
                 GET Dxx_a(mu,nu)
                 GET Dxx_a(nu,lambda)
                 GET Dxx_a(nu,sigma)
                 GET Dxx_a(sigma,lambda)
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = DHFa(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = DHFa(mu,lambda) 
                 t1xx(mu,lambda)           += DHFa(mu,lambda) 
#
                 T5xx(mu,sigma)             = DHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T6xx(mu,sigma)             = DHFa(mu,sigma)
                 T5xxxx(mu,lambda,nu,sigma) = T6xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = DHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xx(mu,nu)                = DHFa(mu,nu)
                 T7xxxx(mu,lambda,nu,sigma) = T8xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T7xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = DHFA(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = Dxx_a(mu,lambda)  
                 t1xx(mu,lambda)           += Dxx_a(mu,lambda)  
#
                 T5xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFa(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFa(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFa(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFa(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) *= 0.25  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)     = 0.0
                    TBxxxi(mu,lambda,sigma,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)    i
                       REQUEST Vxixi(mu,i,sigma,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)    = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1)   += T1xxxi(mu,lambda,nu,i1)
                       T3xxxi(mu,lambda,sigma,i1) = Vxixi(mu,i,sigma,i1)*ca(lambda,i)
                       TBxxxi(mu,lambda,sigma,i1)+= T3xxxi(mu,lambda,sigma,i1) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxi(mu,lambda,sigma,i1)*ca(nu,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0  
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)    = 0.0
                    TBxxxj(mu,lambda,sigma,j) = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)    j
                       REQUEST Vxixj(mu,i,sigma,j) j
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       T3xxxj(mu,lambda,sigma,j) = Vxixj(mu,i,sigma,j)*ca(lambda,i)
                       TBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxj(mu,lambda,sigma,j)*ca(nu,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
        ENDPARDO mu, nu, lambda, sigma   
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu < lambda
              WHERE nu == sigma
#
#                Get 1-particle pieces
#                ---------------------
#
                 GET DHFa(mu,lambda)
                 GET DHFa(mu,sigma)
                 GET DHFa(mu,nu)
                 GET DHFa(nu,sigma)
                 GET DHFa(nu,lambda)
                 GET DHFa(sigma,lambda)
#
                 GET Dxx_a(mu,lambda)
                 GET Dxx_a(mu,sigma)
                 GET Dxx_a(mu,nu)
                 GET Dxx_a(nu,lambda)
                 GET Dxx_a(nu,sigma)
                 GET Dxx_a(sigma,lambda)
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = DHFa(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = DHFa(mu,lambda) 
                 t1xx(mu,lambda)           += DHFa(mu,lambda) 
#
                 T5xx(mu,sigma)             = DHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T6xx(mu,sigma)             = DHFa(mu,sigma)
                 T5xxxx(mu,lambda,nu,sigma) = T6xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = DHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xx(mu,nu)                = DHFa(mu,nu)
                 T7xxxx(mu,lambda,nu,sigma) = T8xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T7xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = DHFA(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = Dxx_a(mu,lambda)  
                 t1xx(mu,lambda)           += Dxx_a(mu,lambda)  
#
                 T5xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFa(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFa(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFa(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFa(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) *= 0.25  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)  = 0.0
                    TBxxxi(mu,lambda,nu,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)     i
                       REQUEST Vxixi(lambda,i,nu,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)  = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                       T2xxxi(mu,lambda,nu,i1)  = Vxixi(lambda,i,nu,i1)*ca(mu,i)
                       TBxxxi(mu,lambda,nu,i1) += T2xxxi(mu,lambda,nu,i1) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0  
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)  = 0.0
                    TBxxxj(mu,lambda,nu,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)     j
                       REQUEST Vxixj(lambda,i,nu,j) j
#
                       T1xxxj(mu,lambda,nu,j)  = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j) += T1xxxj(mu,lambda,nu,j)
                       T2xxxj(mu,lambda,nu,j)  = Vxixj(lambda,i,nu,j)*ca(mu,i)
                       TBxxxj(mu,lambda,nu,j) += T2xxxj(mu,lambda,nu,j) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
        ENDPARDO mu, nu, lambda, sigma   
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu == lambda
              WHERE nu == sigma
#
#                Get 1-particle pieces
#                ---------------------
#
                 GET DHFa(mu,lambda)
                 GET DHFa(mu,sigma)
                 GET DHFa(mu,nu)
                 GET DHFa(nu,sigma)
                 GET DHFa(nu,lambda)
                 GET DHFa(sigma,lambda)
#
                 GET Dxx_a(mu,lambda)
                 GET Dxx_a(mu,sigma)
                 GET Dxx_a(mu,nu)
                 GET Dxx_a(nu,lambda)
                 GET Dxx_a(nu,sigma)
                 GET Dxx_a(sigma,lambda)
#
#                HF only
#                -------
#
                 Txxxx(mu,lambda,nu,sigma)  = 0.0 
                 TCxxxx(mu,lambda,nu,sigma) = 0.0 
                 t2xx(nu,sigma)             = DHFa(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = DHFa(mu,lambda) 
                 t1xx(mu,lambda)           += DHFa(mu,lambda) 
#
                 T5xx(mu,sigma)             = DHFa(mu,sigma)
                 T4xxxx(mu,lambda,nu,sigma) = T5xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
                 T6xx(mu,sigma)             = DHFa(mu,sigma)
                 T5xxxx(mu,lambda,nu,sigma) = T6xx(mu,sigma)^DHFa(nu,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T7xx(mu,nu)                = DHFa(mu,nu)
                 T6xxxx(mu,lambda,nu,sigma) = T7xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T8xx(mu,nu)                = DHFa(mu,nu)
                 T7xxxx(mu,lambda,nu,sigma) = T8xx(mu,nu)^DHFa(sigma,lambda)
                 Txxxx(mu,lambda,nu,sigma) -= T7xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
                 T8xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T8xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Correlation
#                -----------
#
                 t2xx(nu,sigma)             = DHFA(nu,sigma) 
                 t2xx(nu,sigma)            += DHFa(nu,sigma) 
                 t1xx(mu,lambda)            = Dxx_a(mu,lambda)  
                 t1xx(mu,lambda)           += Dxx_a(mu,lambda)  
#
                 T5xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFA(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 T6xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFA(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFA(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFA(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFa(nu,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFa(sigma,lambda)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFa(mu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
                 T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFa(mu,nu)
                 TCxxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 TCxxxx(mu,lambda,nu,sigma) *= 0.25  
#
                 T1xxxx(mu,lambda,nu,sigma) = t1xx(mu,lambda)^t2xx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) += TCxxxx(mu,lambda,nu,sigma)
#
                 TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1) i
                       T1xxxi(mu,lambda,nu,i1)  = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0  
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j) i
                       T1xxxj(mu,lambda,nu,j)  = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j) += T1xxxj(mu,lambda,nu,j)
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    Txxxx(mu,lambda,nu,sigma)*= 2.0  
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)#
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
        ENDPARDO mu, nu, lambda, sigma   
#
      ENDPROC GIJAB_CONT_NEW 
#     ------------------
#
# ---------------------------------------------------------------------------------
#
#
# ---------------------------------------------------------------------------------
#
      PROC FSCF_HESS 
#     -------------- 
#
      create cya 
      create cyb 
      create dhfya 
      create dhfyb 
      create whfya 
      create whfyb 
      execute sip_barrier 
#
#     Compute derivatives of coefficients. 
#     ------------------------------------ 
#
      PARDO mu, i 
#
           txp(mu,i) = 0.0 
#
           DO p1 
#
             #GET          Uyaa(p1,i) 
              t1xp(mu,i) = ca(mu,p1)*SUyaa(p1,i) 
              txp(mu,i) += t1xp(mu,i) 
#
           ENDDO p1 
#
           PUT cya(mu,i) = txp(mu,i) 
#
      ENDPARDO mu, i 
#
#     PARDO mu, j 
#
#          txq(mu,j) = 0.0 
#
#          DO q1 
#
#             GET          Uybb(q1,j) 
#             t1xq(mu,j) = ca(mu,q1)*Uybb(q1,j) 
#             txq(mu,j) += t1xq(mu,j) 
#
#          ENDDO q1 
#
#          PUT cyb(mu,j) = txq(mu,j) 
#
#     ENDPARDO mu, j 
#
      execute sip_barrier 
#
#     Form derivatives of HF density. 
#     ------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component. 
#           ---------------- 
#
            txx(mu,nu) = 0.0 
#
            DO i 
#
               GET           cya(mu,i) 
               GET           cya(nu,i) 
#
               t1xx(mu,nu) = cya(mu,i)*ca(nu,i) 
               txx(mu,nu) += t1xx(mu,nu) 
#
               t1xx(mu,nu) = ca(mu,i)*cya(nu,i) 
               txx(mu,nu) += t1xx(mu,nu) 
#
            ENDDO i 
#
            PUT dhfya(mu,nu) = txx(mu,nu) 
#
#           beta component. 
#           --------------- 
#
#           txx(mu,nu) = 0.0 
#
#           DO j 
#
#              GET           cyb(mu,j) 
#              GET           cyb(nu,j) 
#
#              t1xx(mu,nu) = cyb(mu,j)*ca(nu,j) 
#              txx(mu,nu) += t1xx(mu,nu) 
#
#              t1xx(mu,nu) = ca(mu,j)*cyb(nu,j) 
#              txx(mu,nu) += t1xx(mu,nu) 
#
#           ENDDO j 
#
#           PUT dhfyb(mu,nu) = txx(mu,nu) 
#
      ENDPARDO mu, nu 
#
#     Compute derivatives of weighted HF density. 
#     ------------------------------------------- 
#
      PARDO mu, nu, i  
#
#           piece 1. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               GET          cya(nu,i1) 
               T1xi(nu,i) = cya(nu,i1)*fock_a(i1,i)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)        = ca(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      PARDO mu, nu, i  
#
#           piece 2. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               T1xi(nu,i) = ca(nu,i1)*fock_a(i1,i)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            get                 cya(mu,i) 
            Txx(mu,nu)        = cya(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      PARDO mu, nu, i  
#
#           piece 3. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               get          fya(i1,i) 
               T1xi(nu,i) = ca(nu,i1)*fya(i1,i) 
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)        = ca(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
#     PARDO mu, nu 
#
#           DO j 
#
#           piece 1. 
#           -------- 
#
#           Txj(nu,j) = 0.0
#
#           DO j1
#
#              GET          cyb(nu,j1) 
#              T1xj(nu,j) = cyb(nu,j1)*fock_a(j1,j)
#              Txj(nu,j) -= T1xj(nu,j)
#
#           ENDDO j1
#
#           Txx(mu,nu)        = ca(mu,j)*Txj(nu,j)
#           PUT whfyb(mu,nu) += Txx(mu,nu)
#
#           ENDDO j 
#
#           piece 2. 
#           -------- 
#
#           DO j 
#
#           Txj(nu,j) = 0.0
#
#           DO j1
#
#              T1xj(nu,j) = ca(nu,j1)*fock_a(j1,j)
#              Txj(nu,j) -= T1xj(nu,j)
#
#           ENDDO j1
#
#           GET                 cyb(mu,j) 
#           Txx(mu,nu)        = cyb(mu,j)*Txj(nu,j)
#           PUT whfyb(mu,nu) += Txx(mu,nu)
#
#           ENDDO j 
#
#           piece 3. 
#           -------- 
#
#           DO j 
#
#           Txj(nu,j) = 0.0
#
#           DO j1
#
#              get          fyb(j1,j) 
#              T1xj(nu,j) = ca(nu,j1)*fyb(j1,j) 
#              Txj(nu,j) -= T1xj(nu,j)
#
#           ENDDO j1
#
#           Txx(mu,nu)        = ca(mu,j)*Txj(nu,j)
#           PUT whfyb(mu,nu) += Txx(mu,nu)
#
#           ENDDO j 
#
#     ENDPARDO mu, nu 
#
      execute sip_barrier 
#
      delete cya 
      delete cyb 
#
      ENDPROC FSCF_HESS 
#     ----------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
# --------------------------------------------------------------------------- 
#
# The derivatives of the virtual-virtual block of the denstity matrix
# are formed.  
#
# --------------------------------------------------------------------------- 
#
      PROC FORMDDAB 
#     ------------- 
#
      PARDO a, a2, i, i1  
#
            REQUEST T1aiai_aa(a,i,a2,i1) a
#
            DO a1 
#
               REQUEST           T2yFullaa(a1,i,a2,i1) i  
               tpp(a,a1)       = T1aiai_aa(a,i,a2,i1)*T2yFullaa(a1,i,a2,i1)
               tpp(a,a1)      *= 0.5 
               t1pp(a1,a)      = tpp(a,a1) 
               PUT Dyaa(a,a1) += tpp(a,a1) 
               PUT Dyaa(a1,a) += t1pp(a1,a) 
#
            ENDDO a1 
#
      ENDPARDO a, a2, i, i1  
#
      PARDO a, i, b, j 
#
            REQUEST T1aibj_ab(a,i,b,j) a  
#
            DO a1  
#
               REQUEST           T2yFullab(a1,i,b,j) b  
               tpp(a,a1)       = T1aibj_ab(a,i,b,j)*T2yFullab(a1,i,b,j)
               t1pp(a1,a)      = tpp(a,a1) 
               PUT Dyaa(a,a1) += tpp(a,a1) 
               PUT Dyaa(a1,a) += t1pp(a1,a) 
#
            ENDDO a1  
#
      ENDPARDO a, i, b, j  
#
      ENDPROC FORMDDAB 
#     ---------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivatives of the occupied-occupied block of the denstity matrix
# are formed.  
#
# ---------------------------------------------------------------------- 
#
      PROC FORMDDIJ 
#     ------------- 
#
      PARDO i, i2, a, a1  
#
            REQUEST T1aiai_aa(a,i,a1,i2) a
#
            DO i1 
#
               REQUEST           T2yFullaa(a,i1,a1,i2) a  
               tpp(i,i1)       = T1aiai_aa(a,i,a1,i2)*T2yFullaa(a,i1,a1,i2)
               tpp(i,i1)      *= -0.5 
               t1pp(i1,i)      = tpp(i,i1) 
               PUT Dyii(i,i1) += tpp(i,i1) 
               PUT Dyii(i1,i) += t1pp(i1,i) 
#
            ENDDO i1 
#
      ENDPARDO i, i2, a, a1  
#
      PARDO i, a, j, b 
#
            REQUEST T1aibj_ab(a,i,b,j) a  
#
            DO i1 
#
               REQUEST           T2yFullab(a,i1,b,j) a  
               tpp(i,i1)       = T1aibj_ab(a,i,b,j)*T2yFullab(a,i1,b,j)
               tpp(i,i1)      *= -1.0 
               t1pp(i1,i)      = tpp(i,i1) 
               PUT Dyii(i,i1) += tpp(i,i1) 
               PUT Dyii(i1,i) += t1pp(i1,i) 
#
            ENDDO i1  
#
      ENDPARDO i, a, j, b 
#
      ENDPROC FORMDDIJ 
#     ---------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The contributions to the Hessian from 'part1' are computed. 
#
#     hess(x,y) = 1/2 ( f^x_{ij}*dD_{ij}/dy 
#                     + f^x_{ab}*dD_{ab}/dy 
#                     + f^x_{ai}*dD_{ai}/dy 
#                     + f^x_{ia}*dD_{ia}/dy) + x<-->y  
#
# ---------------------------------------------------------------------- 
#
      PROC PART1  
#     ---------- 
#
      PARDO i, i1 
            GET       Hxa(i,i1) 
            GET       Dyii(i,i1) 
            etemp   = Hxa(i,i1)*Dyii(i,i1) 
            etemp  *= 2.0 
            hessxy += etemp 
      ENDPARDO i, i1 
#
      PARDO a, a1 
            GET       Hxa(a,a1) 
            GET       Dyaa(a,a1) 
            etemp   = Hxa(a,a1)*Dyaa(a,a1) 
            etemp  *= 2.0 
            hessxy += etemp 
      ENDPARDO a, a1 
#
      PARDO a, i 
            GET       Hxa(a,i) 
            GET       Dyai(a,i) 
            etemp   = Hxa(a,i)*Dyai(a,i) 
            etemp  *= 4.0 
            hessxy += etemp 
      ENDPARDO a, i 
#
# ---------------------------------------------------------------------- 
#
      ENDPROC PART1  
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC FORM_P1 
#     ------------ 
      create pp1 
#     create qq1 
      execute sip_barrier 
#
#     Also included in Part1 should be the contribution from the derivative 
#     of the density(HF)-->Term 24 in CPL. 
#     ---------------------------------------------------------------------- 
#
#     Contributions from Uxpi.
#     -----------------------
#
#     alpha/alpha contribution.
#     -------------------------
#
      PARDO p, i, p1, p2  
#
              REQUEST             DTpppi(p2,p1,p,i)  p
              REQUEST             DTpppi(p,p1,p2,i)  p
              GET                 Dpq_a(p2,p1)
#
              tpppi(p2,p1,p,i)  = DTpppi(p2,p1,p,i)
              tpppi(p2,p1,p,i) *= 2.0  
              t1pppi(p2,p1,p,i) = DTpppi(p,p1,p2,i)
              tpppi(p2,p1,p,i) -= t1pppi(p2,p1,p,i)
#
              t1pi(p,i)         = tpppi(p2,p1,p,i)*Dpq_a(p2,p1)
              PUT pp1(p,i) += t1pi(p,i)  
#
      ENDPARDO p, i, p1, p2 
#
#     alpha/beta contribution.
#     ------------------------
#
#     PARDO p, i, q, q1 
#
#             REQUEST         DTqqpi(q,q1,p,i) p
#             GET             Dpq_b(q1,q)
#
#             t1pi(p,i)     = DTqqpi(q,q1,p,i)*Dpq_b(q1,q)
#             PUT pp1(p,i) += t1pi(p,i)  
#
#     ENDPARDO p, i, q, q1 
#
#     Contributions from Uxqj.
#     -----------------------
#
#     alpha/alpha contribution.
#     -------------------------
#
#     PARDO q, j, q1, q2 
#
#          REQUEST             DTqqqj(q2,q1,q,j) q
#          REQUEST             DTqqqj(q,q1,q2,j) q 
#          GET                 Dpq_b(q1,q2)
#
#          tqqqj(q2,q1,q,j)  = DTqqqj(q2,q1,q,j)
#          t1qqqj(q2,q1,q,j) = DTqqqj(q,q1,q2,j)
#          tqqqj(q2,q1,q,j) -= t1qqqj(q2,q1,q,j)
#
#          t1qj(q,j)         = tqqqj(q2,q1,q,j)*Dpq_b(q1,q2)
#          PUT qq1(q,j)     += t1qj(q,j)  
#
#     ENDPARDO q, j, q1, q2 
#
#     alpha/beta contribution.
#     ------------------------
#
#     PARDO q, j, p, p1 
#
#          REQUEST          DTppqj(p,p1,q,j) p
#          GET              Dpq_a(p1,p)
#
#          t1qj(q,j)      = DTppqj(p,p1,q,j)*Dpq_a(p1,p)
#          PUT qq1(q,j)     += t1qj(q,j)  
#
#     ENDPARDO q, j, p, p1 
#
      ENDPROC FORM_P1  
#     --------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC FINISH_P1  
#     -------------- 
#
      DO iatom 
         IF iatom >= ihess1 
         IF iatom <= ihess2 
      DO ix 
#
#           Zero out the hessian element. 
#           ----------------------------- 
#
            hessxy                   = 0.0 
            phessxy                  = 0.0 
            thess(jatom,jx,iatom,ix) = 1.0 
#
            hessyx                   = 0.0 
            phessyx                  = 0.0 
            xhess(iatom,ix,jatom,jx) = 1.0 
#
            execute sip_barrier 
#
#           Finish PART1 
#           ------------ 
#
            PARDO a, i   
              GET         CPHFa(a,i,iatom,ix) 
              GET         pp1(a,i) 
              tpp(a,i)  = CPHFa(a,i,iatom,ix)
              etemp     = tpp(a,i)*pp1(a,i)
              etemp    *= 4.0 
              hessyx   += etemp
            ENDPARDO a, i   
#
            PARDO i, i1  
              REQUEST      STa(i1,i,iatom,ix) i  
              GET          pp1(i1,i) 
              tpp(i1,i)  = STa(i1,i,iatom,ix) 
              etemp      = tpp(i1,i)*pp1(i1,i)
              etemp     *= 2.0 
              hessyx    -= etemp
            ENDPARDO i, i1  
#
#           PARDO b, j  
#             GET         CPHFb(b,j,iatom,ix)
#             GET         qq1(b,j)
#             tqq(b,j)  = CPHFb(b,j,iatom,ix) 
#             etemp     = tqq(b,j)*qq1(b,j)
#             etemp    *= 2.0 
#             hessyx   += etemp
#           ENDPARDO b, j  
#
#           PARDO j, j1 
#             REQUEST      STb(j1,j,iatom,ix) j 
#             GET          qq1(j1,j)
#             tqq(j1,j)  = STb(j1,j,iatom,ix)
#             etemp      = tqq(j1,j)*qq1(j1,j)
#            #etemp     *= 2.0 
#             hessyx    -= etemp
#           ENDPARDO j, j1 
#
#           DONE FINISH PART1 
#           ----------------- 
#
            execute sip_barrier 
            execute server_barrier 
#
            collective phessxy       += hessxy  
            thess(jatom,jx,iatom,ix) *= phessxy  
            execute                     read_hess thess(jatom,jx,iatom,ix) 
#
            collective phessyx       += hessyx  
            xhess(iatom,ix,jatom,jx) *= phessyx  
            execute                     read_hess xhess(iatom,ix,jatom,jx) 
#
      ENDDO ix 
         ENDIF 
         ENDIF 
      ENDDO iatom 
#
      execute sip_barrier 
      delete pp1 
#     delete qq1 
#
      ENDPROC FINISH_P1  
#     ----------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC FORM_P5 
#     ------------ 
#
      create pp5a 
      create pp5b 
      create pp5c 
      create pp5d 
      create pp5e 
#     create qq5a 
#     create qq5b 
#     create qq5c 
#     create qq5d 
#     create qq5e 
      execute sip_barrier 
#
#     Contribution from Taiai. 
#     ------------------------ 
#
      PARDO p, a1, i, i1 
#
            REQUEST             DTpppi(p,i,a1,i1)  p
            REQUEST             DTpppi(p,i1,a1,i)  p  
#
            t2pppp(p,i,a1,i1) = DTpppi(p,i,a1,i1) 
            t3pppp(p,i,a1,i1) = DTpppi(p,i1,a1,i) 
            t2pppp(p,i,a1,i1)-= t3pppp(p,i,a1,i1)  
# 
            DO a 
#
               REQUEST          T1aiai_aa(a,i,a1,i1) a  
               tpp(p,a)       = t2pppp(p,i,a1,i1)* T1aiai_aa(a,i,a1,i1) 
               PUT pp5a(p,a) += tpp(p,a) 
# 
            ENDDO a 
#
      ENDPARDO p, a1, i, i1 
#
      PARDO a2, a1, a, i1 
#
            REQUEST              DTpppi(a,a2,a1,i1)  a
            REQUEST              DTpppi(a1,a2,a,i1)  a  
#
            t2pppp(a,a2,a1,i1) = DTpppi(a,a2,a1,i1) 
            t3pppp(a,a2,a1,i1) = DTpppi(a1,a2,a,i1) 
            t2pppp(a,a2,a1,i1)-= t3pppp(a,a2,a1,i1) 
# 
            DO i 
#
               REQUEST           T1aiai_aa(a,i,a1,i1) a  
               tpp(a2,i)       = t2pppp(a,a2,a1,i1)*T1aiai_aa(a,i,a1,i1)   
               PUT pp5b(a2,i) += tpp(a2,i) 
# 
            ENDDO i 
#
      ENDPARDO a2, a1, a, i1 
#
      PARDO i2, a, a1, i1 
#
            REQUEST              DTpppi(a,i2,a1,i1)  a
            REQUEST              DTpppi(a,i1,a1,i2)  a 
#
            t2pppp(a,i2,a1,i1) = DTpppi(a,i2,a1,i1) 
            t3pppp(a,i2,a1,i1) = DTpppi(a,i1,a1,i2) 
            t2pppp(a,i2,a1,i1)-= t3pppp(a,i2,a1,i1) 
# 
            DO i 
#
               REQUEST           T1aiai_aa(a,i,a1,i1) a  
               tpp(i2,i)       = t2pppp(a,i2,a1,i1)*T1aiai_aa(a,i,a1,i1)   
               PUT pp5c(i2,i) += tpp(i2,i) 
# 
            ENDDO i 
# 
      ENDPARDO i2, a, a1, i1 
#
#     Contribution from Tbjbj. 
#     ------------------------ 
#
#     PARDO q, b1, j, j1 
#
#           REQUEST             DTqqqj(q,j,b1,j1)  q
#           REQUEST             DTqqqj(q,j1,b1,j)  q  
#
#           t2qqqq(q,j,b1,j1) = DTqqqj(q,j,b1,j1) 
#           t3qqqq(q,j,b1,j1) = DTqqqj(q,j1,b1,j) 
#           t2qqqq(q,j,b1,j1)-= t3qqqq(q,j,b1,j1)  
# 
#           DO b 
#
#              REQUEST          T1bjbj_bb(b,j,b1,j1) b  
#              tqq(q,b)       = t2qqqq(q,j,b1,j1)*T1bjbj_bb(b,j,b1,j1) 
#              PUT qq5a(q,b) += tqq(q,b) 
# 
#           ENDDO b 
#
#     ENDPARDO q, b1, j, j1 
#
#     PARDO b2, b1, b, j1 
#
#           REQUEST              DTqqqj(b,b2,b1,j1)  b
#           REQUEST              DTqqqj(b1,b2,b,j1)  b  
#
#           t2qqqq(b,b2,b1,j1) = DTqqqj(b,b2,b1,j1) 
#           t3qqqq(b,b2,b1,j1) = DTqqqj(b1,b2,b,j1) 
#           t2qqqq(b,b2,b1,j1)-= t3qqqq(b,b2,b1,j1) 
# 
#           DO j 
#
#              REQUEST           T1bjbj_bb(b,j,b1,j1) b  
#              tqq(b2,j)       = t2qqqq(b,b2,b1,j1)*T1bjbj_bb(b,j,b1,j1)   
#              PUT qq5b(b2,j) += tqq(b2,j) 
# 
#           ENDDO j 
#
#     ENDPARDO b2, b1, b, j1 
#
#     PARDO j2, b, b1, j1 
#
#           REQUEST              DTqqqj(b,j2,b1,j1)  b
#           REQUEST              DTqqqj(b,j1,b1,j2)  b 
#
#           t2qqqq(b,j2,b1,j1) = DTqqqj(b,j2,b1,j1) 
#           t3qqqq(b,j2,b1,j1) = DTqqqj(b,j1,b1,j2) 
#           t2qqqq(b,j2,b1,j1)-= t3qqqq(b,j2,b1,j1) 
# 
#           DO j 
#
#              REQUEST           T1bjbj_bb(b,j,b1,j1) b  
#              tqq(j2,j)       = t2qqqq(b,j2,b1,j1)*T1bjbj_bb(b,j,b1,j1)   
#              PUT qq5c(j2,j) += tqq(j2,j) 
# 
#           ENDDO j 
# 
#     ENDPARDO j2, b, b1, j1 
#
#     Contribution from Taibj. 
#     ------------------------ 
#
      PARDO p, b, i, j 
#
            REQUEST DTpppi(p,i,b,j) p  
#
            DO a 
#
               REQUEST          T1aibj_ab(a,i,b,j) a  
               tpp(p,a)       = DTpppi(p,i,b,j)*T1aibj_ab(a,i,b,j) 
               PUT pp5d(p,a) += tpp(p,a) 
#
            ENDDO a 
#
      ENDPARDO p, b, i, j 
#
      PARDO p, a, b, j 
#
            REQUEST DTpppi(a,p,b,j) p   
#
            DO i 
#
               REQUEST          T1aibj_ab(a,i,b,j) a  
               tpp(p,i)       = DTpppi(a,p,b,j)*T1aibj_ab(a,i,b,j) 
               PUT pp5e(p,i) += tpp(p,i)
#
            ENDDO i 
#
      ENDPARDO p, a, b, j 
# 
#     PARDO q, a, i, j 
#
#           REQUEST DTppqj(a,i,q,j) a  
#
#           DO b 
#
#              REQUEST          T1aibj_ab(a,i,b,j) a 
#              tqq(q,b)       = DTppqj(a,i,q,j)*T1aibj_ab(a,i,b,j) 
#              PUT qq5d(q,b) += tqq(q,b) 
#
#           ENDDO b 
#
#     ENDPARDO q, a, i, j 
# 
#     PARDO q, a, b, i  
#
#           REQUEST DTqqpi(b,q,a,i) a  
#
#           DO j 
#
#              REQUEST          T1aibj_ab(a,i,b,j) a 
#              tqq(q,j)       = DTqqpi(b,q,a,i)*T1aibj_ab(a,i,b,j) 
#              PUT qq5e(q,j) += tqq(q,j) 
#
#           ENDDO j 
#
#     ENDPARDO q, a, b, i  
#
      execute sip_barrier 
#
      DO iatom 
         IF iatom >= ihess1 
         IF iatom <= ihess2 
      DO ix 
#
#         Zero out the hessian element. 
#         ----------------------------- 
#
          hessyx                   = 0.0 
          phessyx                  = 0.0 
          xhess(iatom,ix,jatom,jx) = 1.0 
#
          execute sip_barrier 
#
#         alpha/alpha contributions 
#         ------------------------- 
#
          PARDO a, i
               GET             CPHFa(a,i,iatom,ix) 
               REQUEST         STa(a,i,iatom,ix) a 
               GET             pp5a(i,a) 
               tai(a,i)      = CPHFa(a,i,iatom,ix)
               t1ai(a,i)     = STa(a,i,iatom,ix) 
               tai(a,i)     += t1ai(a,i)
               tia(i,a)      = tai(a,i)
               tia(i,a)     *= -2.0
               etemp         = tia(i,a)*pp5a(i,a) 
               hessyx       += etemp 
          ENDPARDO a, i
#
          PARDO a, a1  
               REQUEST         STa(a,a1,iatom,ix) a 
               GET             pp5a(a,a1) 
               tpp(a,a1)     = STa(a,a1,iatom,ix) 
               etemp         = tpp(a,a1)*pp5a(a,a1) 
               etemp        *= -1.0 
               hessyx       += etemp 
          ENDPARDO a, a1  
#
          PARDO a, i 
               GET       CPHFa(a,i,iatom,ix)
               GET       pp5b(a,i) 
               tpp(a,i)= CPHFa(a,i,iatom,ix)
               etemp   = tpp(a,i)*pp5b(a,i)
               etemp  *= 2.0  
               hessyx += etemp 
          ENDPARDO a, i
#
          PARDO i1, i
               REQUEST     STa(i1,i,iatom,ix) i 
               GET         pp5c(i1,i) 
               tpp(i1,i) = STa(i1,i,iatom,ix) 
               etemp     = tpp(i1,i)*pp5c(i1,i) 
               etemp    *= -1.0 
               hessyx   += etemp 
          ENDPARDO i1, i
#
#         beta/beta contributions 
#         ----------------------- 
#
#         PARDO b, j
#              GET             CPHFb(b,j,iatom,ix) 
#              REQUEST         STb(b,j,iatom,ix) b 
#              GET             qq5a(j,b) 
#              tbj(b,j)      = CPHFb(b,j,iatom,ix)
#              t1bj(b,j)     = STb(b,j,iatom,ix) 
#              tbj(b,j)     += t1bj(b,j)
#              tjb(j,b)      = tbj(b,j)
#              tjb(j,b)     *= -1.0
#              etemp         = tjb(j,b)*qq5a(j,b) 
#              hessyx       += etemp 
#         ENDPARDO b, j
#
#         PARDO b, b1  
#              REQUEST         STb(b,b1,iatom,ix) b 
#              GET             qq5a(b,b1) 
#              tqq(b,b1)     = STb(b,b1,iatom,ix) 
#              etemp         = tqq(b,b1)*qq5a(b,b1) 
#              etemp        *= -0.5 
#              hessyx       += etemp 
#         ENDPARDO b, b1  
#
#         PARDO b, j 
#              GET       CPHFb(b,j,iatom,ix)
#              GET       qq5b(b,j) 
#              tqq(b,j)= CPHFb(b,j,iatom,ix)
#              etemp   = tqq(b,j)*qq5b(b,j)
#              hessyx += etemp 
#         ENDPARDO b, j
#
#         PARDO j1, j
#              REQUEST     STb(j1,j,iatom,ix) j 
#              GET         qq5c(j1,j) 
#              tqq(j1,j) = STb(j1,j,iatom,ix) 
#              etemp     = tqq(j1,j)*qq5c(j1,j) 
#              etemp    *= -0.5 
#              hessyx   += etemp 
#         ENDPARDO j1, j
#
#         alpha/beta contributions 
#         ------------------------ 
#
          PARDO p, a 
              GET        CPHFa(p,a,iatom,ix) 
              GET        pp5d(p,a) 
              tpp(p,a) = CPHFa(p,a,iatom,ix) 
              etemp    = tpp(p,a)*pp5d(p,a) 
              etemp   *= 4.0 
              hessyx  += etemp 
          ENDPARDO p, a 
#
          PARDO p, i 
              GET        CPHFa(p,i,iatom,ix) 
              GET        pp5e(p,i) 
              tpp(p,i) = CPHFa(p,i,iatom,ix) 
              etemp    = tpp(p,i)*pp5e(p,i) 
              etemp   *= 4.0 
              hessyx  += etemp 
          ENDPARDO p, i 
#
#         PARDO q, b 
#             GET        CPHFb(q,b,iatom,ix) 
#             GET        qq5d(q,b) 
#             tqq(q,b) = CPHFb(q,b,iatom,ix) 
#             etemp    = tqq(q,b)*qq5d(q,b) 
#             etemp   *= 2.0 
#             hessyx  += etemp 
#         ENDPARDO q, b 
#
#         PARDO q, j 
#             GET        CPHFb(q,j,iatom,ix) 
#             GET        qq5e(q,j) 
#             tqq(q,j) = CPHFb(q,j,iatom,ix) 
#             etemp    = tqq(q,j)*qq5e(q,j) 
#             etemp   *= 2.0 
#             hessyx  += etemp 
#         ENDPARDO q, j 
#
#         DONE FINISH PART5 
#         ----------------- 
#
          execute sip_barrier 
#
          collective phessyx       += hessyx  
          xhess(iatom,ix,jatom,jx) *= phessyx  
          execute                     read_hess xhess(iatom,ix,jatom,jx) 
#
      ENDDO ix 
         ENDIF # iatom >= ihess1 
         ENDIF # iatom <= ihess2 
      ENDDO iatom 
#
      execute sip_barrier 
      delete pp5a 
      delete pp5b 
      delete pp5c 
      delete pp5d 
      delete pp5e 
#     delete qq5a 
#     delete qq5b 
#     delete qq5c 
#     delete qq5d 
#     delete qq5e 
#
      ENDPROC FORM_P5 
#     --------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC PART2  
#     ---------- 
#
      PARDO p, p1 
#
            GET         Dpq_a(p,p1) 
            tpp(p,p1) = 0.0 
#
            DO p2 
#
               GET          Hxa(p2,p1) 
               GET          Uyaa(p2,p) 
               GET          Hxa(p,p2) 
               GET          Uyaa(p2,p1) 
#
               t1pp(p,p1) = Uyaa(p2,p)*Hxa(p2,p1)
               tpp(p,p1) += t1pp(p,p1) 
#
               t1pp(p,p1) = Uyaa(p2,p1)*Hxa(p,p2) 
               tpp(p,p1) += t1pp(p,p1) 
#
            ENDDO p2 
#
            etemp   = tpp(p,p1)*Dpq_a(p,p1) 
            etemp  *= 2.0  
            hessxy += etemp 
#
      ENDPARDO p, p1 
#
      ENDPROC PART2  
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC PART4 
#     ---------- 
#
      PARDO p, p1 
#
            GET         Ipq_a(p,p1) 
            tpp(p,p1) = 0.0 
#
            DO p2 
#
               GET          Uyaa(p2,p) 
               GET          Sxa(p2,p1) 
               GET          Uyaa(p2,p1) 
               GET          Sxa(p,p2) 
#
               t1pp(p,p1) = Uyaa(p2,p)*Sxa(p2,p1)
               tpp(p,p1) += t1pp(p,p1) 
#
               t1pp(p,p1) = Uyaa(p2,p1)*Sxa(p,p2) 
               tpp(p,p1) += t1pp(p,p1) 
#
            ENDDO p2 
#
            etemp   = tpp(p,p1)*Ipq_a(p,p1) 
            etemp  *= 2.0  
            hessxy += etemp 
#
      ENDPARDO p, p1 
#
      ENDPROC PART4 
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# Part6 corresponds to Term6 in the CPL BUT the derivative of V 
# does not contain U derivatives. It only contains derivatives of
# the integrals transformed to the unperturbed MO basis. 
#
# ---------------------------------------------------------------------- 
#
      PROC PART6 
#     ---------- 
#
#     PARDO a, i, a1, i1 
#
#           REQUEST T2yFullaa(a,i,a1,i1) a 
#
#           DO iatom 
#              IF iatom >= ihess1 
#              IF iatom <= ihess2 
#           DO ix 
#
#              REQUEST             VTpipi(a,i,a1,i1,iatom,ix) a
#              tpppp(a,i,a1,i1)  = VTpipi(a,i,a1,i1,iatom,ix) 
#
#              etemp             = T2yFullaa(a,i,a1,i1)*tpppp(a,i,a1,i1)
#              etemp            *= 0.5 
#              phess(jatom,jx,iatom,ix) = etemp 
#              PUT Lhess(jatom,jx,iatom,ix) += phess(jatom,jx,iatom,ix)  
#
#           ENDDO ix 
#              ENDIF # iatom >= ihess1 
#              ENDIF # iatom <= ihess2 
#           ENDDO iatom 
#
#     ENDPARDO a, i, a1, i1 
#
#     PARDO b, j, b1, j1 
#
#           REQUEST T2yFullbb(b,j,b1,j1) b 
#
#           DO iatom 
#              IF iatom >= ihess1 
#              IF iatom <= ihess2 
#           DO ix 
#
#              REQUEST             VTqjqj(b,j,b1,j1,iatom,ix) b
#              tqqqq(b,j,b1,j1)  = VTqjqj(b,j,b1,j1,iatom,ix) 
#
#              etemp             = T2yFullbb(b,j,b1,j1)*tqqqq(b,j,b1,j1)
#              etemp            *= 0.5 
#              phess(jatom,jx,iatom,ix) = etemp 
#              PUT Lhess(jatom,jx,iatom,ix) += phess(jatom,jx,iatom,ix)  
#
#           ENDDO ix 
#              ENDIF # iatom >= ihess1 
#              ENDIF # iatom <= ihess2 
#           ENDDO iatom 
#
#     ENDPARDO b, j, b1, j1 
#
      PARDO a, i, b, j 
#
            REQUEST T2yFullab(a,i,b,j) a 
            REQUEST T2yFullab(a,j,b,i) a 
            t1aibj(a,i,b,j) = T2yFullab(a,j,b,i) 
            t1aibj(a,i,b,j) *= -2.0  
            t2aibj(a,i,b,j)  = T2yFullab(a,i,b,j)  
            t2aibj(a,i,b,j) *= 4.0  
            t2aibj(a,i,b,j) += t1aibj(a,i,b,j)  
#
            DO iatom 
               IF iatom >= ihess1 
               IF iatom <= ihess2 
            DO ix 
#
               REQUEST          VTpiqj(a,i,b,j,iatom,ix) a
               taibj(a,i,b,j) = VTpiqj(a,i,b,j,iatom,ix) 
#
              #etemp           = T2yFullab(a,i,b,j)*taibj(a,i,b,j)
              #etemp          *= 2.0 
               etemp           = t2aibj(a,i,b,j)*taibj(a,i,b,j)
               phess(jatom,jx,iatom,ix) = etemp 
               PUT Lhess(jatom,jx,iatom,ix) += phess(jatom,jx,iatom,ix)  
#
            ENDDO ix 
               ENDIF # iatom >= ihess1 
               ENDIF # iatom <= ihess2 
            ENDDO iatom 
#
      ENDPARDO a, i, b, j 
#
      ENDPROC PART6 
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivative of the occupied-occupied block of the intermediate 
# Ipq is determined. This is the most complicated procedure in this 
# program!  
#
# ---------------------------------------------------------------------- 
#
      PROC DERIIJ 
#     ----------- 
#
#     alpha/alpha block 
#     ----------------- 
#
      PARDO i, i1 
#
            tpp(i,i1)  = 0.0 
            t3pp(i1,i) = 0.0 
#
            DO i2 
#
               GET Dpq_a(i,i2) 
               GET Fya(i2,i1) 
#
               IF i2 == i1 
                  GET          Dyii(i,i2) 
                  t1pp(i,i1) = Dyii(i,i2)*Fock_a(i2,i1)  
                  tpp(i,i1) -= t1pp(i,i1) 
               ENDIF 
#
               t1pp(i,i1) = Dpq_a(i,i2)*Fya(i2,i1) 
               tpp(i,i1) -= t1pp(i,i1) 
#
               DO a 
               DO a1 
#
                  REQUEST             VSpipi(a,i,a1,i2)     a  
                  REQUEST             T2yFullaa(a,i1,a1,i2) a  
#
                  t1pp(i,i1)        = VSpipi(a,i,a1,i2)*T2yFullaa(a,i1,a1,i2) 
                  t1pp(i,i1)       *= 0.5 
                  tpp(i,i1)        -= t1pp(i,i1) 
#
               ENDDO a1 
               ENDDO a 
#
               DO i3 
#
                  REQUEST      VSpipi(i,i1,i2,i3) i
                  GET          Dyii(i2,i3) 
#
                  t1pp(i,i1) = VSpipi(i,i1,i2,i3)*Dyii(i2,i3)
                  tpp(i,i1) -= t1pp(i,i1) 
#
               ENDDO i3 
#
               DO a 
#
                  REQUEST       VSpipi(i,i1,a,i2) a
                  GET           Dyai(a,i2) 
#
                  t1pp(i,i1)  = VSpipi(i,i1,a,i2)*Dyai(a,i2)
                  tpp(i,i1)  -= t1pp(i,i1)
#
                  t2pp(i1,i)  = t1pp(i,i1) 
                  t3pp(i1,i) -= t2pp(i1,i) 
#
               ENDDO a
#
            ENDDO i2 
#
            DO a 
#
               DO b 
               DO j 
#
                  REQUEST      Vpiqj(a,i,b,j)      a  
                  REQUEST      T2yFullab(a,i1,b,j) a  
#
                  t1pp(i,i1) = Vpiqj(a,i,b,j)*T2yFullab(a,i1,b,j) 
                  tpp(i,i1) -= t1pp(i,i1) 
#
               ENDDO j 
               ENDDO b 
#
               DO a1 
#
                  REQUEST             Vaaii(a,a1,i,i1) a  
                  REQUEST             Viaai(i,a1,a,i1) a  
                  GET                 Dyaa(a,a1) 
#
                  tpppp(a,a1,i,i1)  = Vaaii(a,a1,i,i1)  
                  t1pppp(a,a1,i,i1) = Viaai(i,a1,a,i1)
                  tpppp(a,a1,i,i1) -= t1pppp(a,a1,i,i1)  
#
                  t1pp(i,i1)        = tpppp(a,a1,i,i1)*Dyaa(a,a1) 
                  tpp(i,i1)        -= t1pp(i,i1) 
#
               ENDDO a1 
#
            ENDDO a 
#
            DO b 
#
               DO b1 
#
                  REQUEST      Vbbii(b1,b,i,i1) b  
                  GET          Dyaa(b1,b) 
#
                  t1pp(i,i1) = Vbbii(b1,b,i,i1)*Dyaa(b1,b) 
                  tpp(i,i1) -= t1pp(i,i1) 
#
               ENDDO b1 
#
               DO j2 
#
                  REQUEST       Vpiqj(i,i1,b,j2) i
                  GET           Dyai(b,j2) 
#
                  t1pp(i,i1)  = Vpiqj(i,i1,b,j2)*Dyai(b,j2)
                  tpp(i,i1)  -= t1pp(i,i1)
#
                  t2pp(i1,i)  = t1pp(i,i1) 
                  t3pp(i1,i) -= t2pp(i1,i) 
#
               ENDDO j2
#
            ENDDO b
#
            DO j2 
            DO j3 
#
               REQUEST      Vpiqj(i,i1,j2,j3) i
               GET          Dyii(j2,j3) 
#
               t1pp(i,i1) = Vpiqj(i,i1,j2,j3)*Dyii(j2,j3)
               tpp(i,i1) -= t1pp(i,i1) 
#
            ENDDO j3 
            ENDDO j2 
#
            PUT DIii(i,i1) += tpp(i,i1) 
            PUT DIii(i1,i) += t3pp(i1,i) 
#
      ENDPARDO i, i1 
#
#     Done alpha/alpha block 
#     ---------------------- 
#
      ENDPROC DERIIJ 
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivative of the virtual-virtual block of the intermediate 
# Ipq is determined. 
#
# ---------------------------------------------------------------------- 
#
      PROC DERIAB  
#     ----------- 
#
#     alpha/alpha block 
#     ----------------- 
#
      PARDO a, a1 
#
            tpp(a,a1) = 0.0 
#
            DO a2 
#
               GET Dpq_a(a,a2) 
               GET Fya(a2,a1) 
#
               IF a2 == a1 
                  GET          Dyaa(a,a2) 
                  t1pp(a,a1) = Dyaa(a,a2)*Fock_a(a2,a1)  
                  tpp(a,a1) -= t1pp(a,a1) 
               ENDIF 
#
               t1pp(a,a1) = Dpq_a(a,a2)*Fya(a2,a1) 
               tpp(a,a1) -= t1pp(a,a1) 
#
               DO i 
               DO i1 
#
                  REQUEST       VSpipi(a,i,a2,i1)     a  
                  REQUEST       T2yFullaa(a1,i,a2,i1) i  
#
                  t1pp(a,a1)  = VSpipi(a,i,a2,i1)*T2yFullaa(a1,i,a2,i1) 
                  t1pp(a,a1) *= 0.5 
                  tpp(a,a1)  -= t1pp(a,a1) 
#
               ENDDO i1 
               ENDDO i 
#
            ENDDO a2 
#
            DO i 
            DO j1 
            DO b2 
#
               REQUEST       Vpiqj(a,i,b2,j1)      a  
               REQUEST       T2yFullab(a1,i,b2,j1) i  
#
               t1pp(a,a1)  = Vpiqj(a,i,b2,j1)*T2yFullab(a1,i,b2,j1) 
               tpp(a,a1)  -= t1pp(a,a1) 
#
            ENDDO b2 
            ENDDO j1 
            ENDDO i 
#
            tpp(a,a1)      *= 0.5 
            t1pp(a1,a)      = tpp(a,a1) 
            PUT DIaa(a,a1) += tpp(a,a1) 
            PUT DIaa(a1,a) += t1pp(a1,a) 
#
      ENDPARDO a, a1 
#
#     End alpha/alpha block 
#     --------------------- 
#
      ENDPROC DERIAB  
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivative of the virtual-occipied block of the intermediate 
# Ipq is determined. 
#
# ---------------------------------------------------------------------- 
#
      PROC DERIAI  
#     ----------- 
#
#     alpha/alpha block 
#     ----------------- 
#
      PARDO a, i 
#
            tpp(a,i)  = 0.0 
#
            DO i2 
#
               GET Dpq_a(a,i2) 
               GET Fya(i2,i) 
#
               IF i2 == i 
                  GET         Dyai(a,i2) 
                  t1pp(a,i) = Dyai(a,i2)*Fock_a(i2,i)  
                  tpp(a,i) -= t1pp(a,i) 
               ENDIF 
#
               t1pp(a,i) = Dpq_a(a,i2)*Fya(i2,i) 
               tpp(a,i) -= t1pp(a,i) 
#
               DO a1 
               DO i1 
#
                  REQUEST      VSpipi(a1,i2,i,i1)    i 
                  REQUEST      T2yFullaa(a,i1,a1,i2) a  
#
                  t1pp(a,i)  = T2yFullaa(a,i1,a1,i2)*VSpipi(a1,i2,i,i1) 
                  t1pp(a,i) *= 0.5  
                  tpp(a,i)  -= t1pp(a,i) 
#
               ENDDO i1 
               ENDDO a1 
#
               DO b1 
               DO j2 
#
                  REQUEST     Vpiqj(i,i2,b1,j2)     i 
                  REQUEST     T2yFullab(a,i2,b1,j2) a  
#
                  t1pp(a,i) = T2yFullab(a,i2,b1,j2)*Vpiqj(i,i2,b1,j2) 
                  tpp(a,i) -= t1pp(a,i) 
#
               ENDDO j2 
               ENDDO b1 
#
            ENDDO i2 
#
            PUT DIai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i 
#
#     Done alpha/alpha block 
#     ---------------------- 
#
      ENDPROC DERIAI  
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC PART3 
#     ---------- 
#
      PARDO i, i1 
#
            GET       Sxa(i,i1) 
            GET       DIii(i,i1) 
#
            etemp   = Sxa(i,i1)*DIii(i,i1)
            etemp  *= 2.0 
            hessxy += etemp 
#
      ENDPARDO i, i1 
#
      PARDO a, a1 
#
            GET       Sxa(a,a1) 
            GET       DIaa(a,a1) 
#
            etemp   = Sxa(a,a1)*DIaa(a,a1)
            etemp  *= 2.0 
            hessxy += etemp 
#
      ENDPARDO a, a1 
#
      PARDO a, i1 
#
            GET       Sxa(a,i1) 
            GET       DIai(a,i1) 
#
            etemp   = Sxa(a,i1)*DIai(a,i1)
            etemp  *= 4.0 
            hessxy += etemp 
#
      ENDPARDO a, i1 
#
      ENDPROC PART3 
#     ------------- 
#
# --------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------
#
      PROC DERVYFULLAB  
#     ----------------  
#
      create VYiijj 
      execute sip_barrier 
#
#     Initialize the 'Full' derivatives to the bare transformed integrals 
#     ------------------------------------------------------------------- 
#
      PARDO a, b, i, j 
#
            REQUEST                   DTpppi(a,i,b,j) a  
            tppqq(a,i,b,j)          = DTpppi(a,i,b,j) 
            PREPARE VYaibj(a,i,b,j) = tppqq(a,i,b,j) 
#
      ENDPARDO a, b, i, j 
#
      PARDO a, a1, j1, j 
#
            REQUEST                     DTpppi(a,a1,j1,j) a  
            tppqq(a,a1,j1,j)          = DTpppi(a,a1,j1,j) 
            PREPARE VYaajj(a,a1,j1,j) = tppqq(a,a1,j1,j) 
#
      ENDPARDO a, a1, j1, j 
#
      PARDO a, b, i, j 
#
            REQUEST                   DTpppi(i,a,b,j) a  
            tppqq(i,a,b,j)          = DTpppi(i,a,b,j) 
            PREPARE VYiabj(i,a,b,j) = tppqq(i,a,b,j)  
#
      ENDPARDO a, b, i, j 
#
      PARDO b, j, a, a1 
#
            REQUEST                    DTpppi(a1,a,b,j) a  
            tppqq(a1,a,b,j)          = DTpppi(a1,a,b,j) 
            PREPARE VYaabj(a1,a,b,j) = tppqq(a1,a,b,j) 
#
      ENDPARDO b, j, a, a1 
#
      PARDO i, i1, j, j1 
#
            REQUEST                 DTpppi(i,i1,j,j1) i  
            tppqq(i,i1,j,j1)      = DTpppi(i,i1,j,j1)
            PUT VYiijj(i,i1,j,j1) = tppqq(i,i1,j,j1) 
#
      ENDPARDO i, i1, j, j1 
#
      PARDO i, i1, b, j 
#
            REQUEST                    DTpppi(i,i1,b,j) b  
            tppqq(i,i1,b,j)          = DTpppi(i,i1,b,j) 
            PREPARE VYiibj(i,i1,b,j) = tppqq(i,i1,b,j) 
#
      ENDPARDO i, i1, b, j 
#
#     Done initialization 
#     ------------------- 
#
      execute server_barrier 
#
#     Contributions from Vaabj 
#     ------------------------ 
#
      PARDO j, b, a, a1  
#
            REQUEST Vaabj(a,a1,b,j) b  
#
            DO i 
#
              #GET                        Uyaa(a1,i) 
               tppqq(a,i,b,j)           = Vaabj(a,a1,b,j)*SUyaa(a1,i) 
               PREPARE VYaibj(a,i,b,j) += tppqq(a,i,b,j) 
#
            ENDDO i 
#
            DO i 
#
              #GET                         Uyaa(a,i) 
               tppqq(i,a1,b,j)           = Vaabj(a,a1,b,j)*SUyaa(a,i) 
               PREPARE VYiabj(i,a1,b,j) += tppqq(i,a1,b,j)  
#
            ENDDO i 
#
            DO j1 
#
              #GET                          Uyaa(j,j1) 
               tppqq(a,a1,b,j1)           = Vaabj(a,a1,b,j)*SUyaa(j,j1) 
               PREPARE VYaabj(a,a1,b,j1) += tppqq(a,a1,b,j1) 
#
            ENDDO j1 
#
            DO j1  
#
              #GET                          Uyaa(b,j1) 
               tppqq(a,a1,j1,j)           = Vaabj(a,a1,b,j)*SUyaa(b,j1) 
               PREPARE VYaajj(a,a1,j1,j) += tppqq(a,a1,j1,j) 
#
               t1ppqq(a,a1,j,j1)          = tppqq(a,a1,j1,j) 
               PREPARE VYaajj(a,a1,j,j1) += t1ppqq(a,a1,j,j1) 
#
            ENDDO j1  
#
            DO b1 
#
              #GET                          Uyaa(b,b1) 
               tppqq(a,a1,b1,j)           = Vaabj(a,a1,b,j)*SUyaa(b,b1) 
               PREPARE VYaabj(a,a1,b1,j) += tppqq(a,a1,b1,j) 
#
            ENDDO b1 
#
            DO a2 
#
              #GET                          Uyaa(a,a2) 
               tppqq(a2,a1,b,j)           = Vaabj(a,a1,b,j)*SUyaa(a,a2) 
               PREPARE VYaabj(a2,a1,b,j) += tppqq(a2,a1,b,j) 
#
            ENDDO a2 
#
            DO a2 
#
              #GET                         Uyaa(a1,a2) 
               tppqq(a,a2,b,j)           = Vaabj(a,a1,b,j)*SUyaa(a1,a2) 
               PREPARE VYaabj(a,a2,b,j) += tppqq(a,a2,b,j) 
#
            ENDDO a2 
#
      ENDPARDO j, b, a, a1  
#
#     Done Contributions from Vaabj 
#     ----------------------------- 
#
#     Contributions from Vbbai  
#     ------------------------ 
#
      PARDO i, a, b, b1  
#
            REQUEST            Vbbai(b,b1,a,i) a  
#
            t1ppqq(a,i,b,b1) = Vbbai(b,b1,a,i) 
#
            DO j 
#
              #GET                        Uyaa(b1,j) 
               tppqq(a,i,b,j)           = t1ppqq(a,i,b,b1)*SUyaa(b1,j) 
               PREPARE VYaibj(a,i,b,j) += tppqq(a,i,b,j) 
#
            ENDDO j 
#
            t1ppqq(i,a,b1,b) = Vbbai(b,b1,a,i) 
#
            DO j 
#
              #GET                         Uyaa(b,j) 
               tppqq(i,a,b1,j)           = t1ppqq(i,a,b1,b)*SUyaa(b,j) 
               PREPARE VYiabj(i,a,b1,j) += tppqq(i,a,b1,j)  
#
            ENDDO j 
#
      ENDPARDO i, a, b, b1  
#
#     Done contributions from Vbbai 
#     ----------------------------- 
#
#     Contributions from Vaibj 
#     ------------------------ 
#
      PARDO j, b, i, a  
#
            REQUEST Vpiqj(a,i,b,j) b  
#
            DO a1 
#
              #GET                         Uyaa(a,a1) 
               tppqq(a1,i,b,j)           = Vpiqj(a,i,b,j)*SUyaa(a,a1) 
               PREPARE VYaibj(a1,i,b,j) += tppqq(a1,i,b,j) 
#
            ENDDO a1 
#
            DO a1 
#
              #GET                         Uyaa(i,a1) 
               tppqq(a,a1,b,j)           = Vpiqj(a,i,b,j)*SUyaa(i,a1) 
               PREPARE VYaabj(a,a1,b,j) += tppqq(a,a1,b,j) 
#
            ENDDO a1 
#
            DO i1 
#
              #GET                         Uyaa(i,i1) 
               tppqq(a,i1,b,j)           = Vpiqj(a,i,b,j)*SUyaa(i,i1) 
               PREPARE VYaibj(a,i1,b,j) += tppqq(a,i1,b,j) 
#
            ENDDO i1 
#
            DO i1 
#
              #GET                         Uyaa(a,i1) 
               tppqq(i1,i,b,j)           = Vpiqj(a,i,b,j)*SUyaa(a,i1) 
               PREPARE VYiibj(i1,i,b,j) += tppqq(i1,i,b,j) 
#
            ENDDO i1 
#
            DO b1 
#
              #GET                         Uyaa(b,b1) 
               tppqq(a,i,b1,j)           = Vpiqj(a,i,b,j)*SUyaa(b,b1) 
               PREPARE VYaibj(a,i,b1,j) += tppqq(a,i,b1,j) 
#
            ENDDO b1 
#
            t1qqpp(b,j,a,i) = Vpiqj(a,i,b,j) 
#
            DO j1 
#
              #GET                         Uyaa(j,j1) 
               tppqq(a,i,b,j1)           = Vpiqj(a,i,b,j)*SUyaa(j,j1) 
               PREPARE VYaibj(a,i,b,j1) += tppqq(a,i,b,j1) 
#
            ENDDO j1 
#
      ENDPARDO j, b, i, a  
#
#     Done Contributions from Vaibj 
#     ----------------------------- 
#
#     Contributions from Vaajj 
#     ------------------------ 
#
      PARDO j, j1, a, a1  
#
            REQUEST Vaajj(a,a1,j,j1) j  
#
            DO a2 
#
              #GET                           Uyaa(a,a2) 
               tppqq(a2,a1,j,j1)           = Vaajj(a,a1,j,j1)*SUyaa(a,a2) 
               PREPARE VYaajj(a2,a1,j,j1) += tppqq(a2,a1,j,j1) 
#
               t1ppqq(a1,a2,j,j1)          = tppqq(a2,a1,j,j1) 
               PREPARE VYaajj(a1,a2,j,j1) += t1ppqq(a1,a2,j,j1) 
#
            ENDDO a2 
#
            DO j2 
#
              #GET                          Uyaa(j,j2) 
               tppqq(a,a1,j2,j1)          = Vaajj(a,a1,j,j1)*SUyaa(j,j2) 
               PREPARE VYaajj(a,a1,j2,j1) += tppqq(a,a1,j2,j1) 
#
               t1ppqq(a,a1,j1,j2)          = tppqq(a,a1,j2,j1)
               PREPARE VYaajj(a,a1,j1,j2) += t1ppqq(a,a1,j1,j2) 
#
            ENDDO j2 
#
            DO b 
#
              #GET                          Uyaa(j,b)
               tppqq(a,a1,b,j1)           = Vaajj(a,a1,j,j1)*SUyaa(j,b) 
               PREPARE VYaabj(a,a1,b,j1) += tppqq(a,a1,b,j1) 
#
            ENDDO b 
#
      ENDPARDO j, j1, a, a1  
#
#     Done Contributions from Vaajj 
#     ----------------------------- 
#
#     Contributions from Vbbii 
#     ------------------------ 
#
      PARDO i, i1, b, b1  
#
            REQUEST Vbbii(b,b1,i,i1) i  
            t1ppqq(i,i1,b,b1) = Vbbii(b,b1,i,i1) 
#
            DO j 
#
              #GET                         Uyaa(b1,j) 
               tppqq(i,i1,b,j)           = t1ppqq(i,i1,b,b1)*SUyaa(b1,j) 
               PREPARE VYiibj(i,i1,b,j) += tppqq(i,i1,b,j) 
#
            ENDDO j 
#
      ENDPARDO i, i1, b, b1 
#
#     Done Contributions from Vbbii 
#     ----------------------------- 
#
#     All other contributions 
#     ----------------------- 
#
      PARDO j, b, i, i1  
#
            REQUEST Vpiqj(i1,i,b,j) b  
#
            DO a 
#
              #GET                        Uyaa(i1,a) 
               tppqq(a,i,b,j)           = Vpiqj(i1,i,b,j)*SUyaa(i1,a) 
               PREPARE VYaibj(a,i,b,j) += tppqq(a,i,b,j) 
#
            ENDDO a 
#
      ENDPARDO j, b, i, i1  
#
      PARDO a, i, j, j1  
#
            REQUEST Vpiqj(a,i,j1,j) a  
#
            DO b 
#
              #GET                        Uyaa(j1,b) 
               tppqq(a,i,b,j)           = Vpiqj(a,i,j1,j)*SUyaa(j1,b) 
               PREPARE VYaibj(a,i,b,j) += tppqq(a,i,b,j) 
#
            ENDDO b 
#
      ENDPARDO a, i, j, j1  
#
      PARDO j, j1, a, i2  
#
            REQUEST Vpiqj(a,i2,j1,j) j  
#
            DO a1  
#
              #GET                          Uyaa(i2,a1) 
               tppqq(a,a1,j1,j)           = Vpiqj(a,i2,j1,j)*SUyaa(i2,a1) 
               PREPARE VYaajj(a,a1,j1,j) += tppqq(a,a1,j1,j) 
#
               t1ppqq(a1,a,j,j1)          = tppqq(a,a1,j1,j) 
               PREPARE VYaajj(a1,a,j,j1) += t1ppqq(a1,a,j,j1) 
#
            ENDDO a1  
#
      ENDPARDO j, j1, a, i2  
#
      PARDO j, b, i, a1  
#
            REQUEST Viabj(i,a1,b,j) i  
#
            DO a 
#
              #GET                        Uyaa(a1,a) 
               tppqq(i,a,b,j)           = Viabj(i,a1,b,j)*SUyaa(a1,a) 
               PREPARE VYiabj(i,a,b,j) += tppqq(i,a,b,j)  
#
            ENDDO a 
#
      ENDPARDO j, b, i, a1  
#
      PARDO b, j, a, i1  
#
            REQUEST Viabj(i1,a,b,j) b  
#
            DO i 
#
              #GET                        Uyaa(i1,i) 
               tppqq(i,a,b,j)           = Viabj(i1,a,b,j)*SUyaa(i1,i) 
               PREPARE VYiabj(i,a,b,j) += tppqq(i,a,b,j)  
#
            ENDDO i 
#
      ENDPARDO b, j, a, i1 
#
      PARDO j, b, i, i1  
#
            REQUEST Vpiqj(i,i1,b,j) b  
#
            DO a 
#
              #GET                        Uyaa(i1,a) 
               tppqq(i,a,b,j)           = Vpiqj(i,i1,b,j)*SUyaa(i1,a) 
               PREPARE VYiabj(i,a,b,j) += tppqq(i,a,b,j)  
#
            ENDDO a 
#
      ENDPARDO j, b, i, i1 
#
      PARDO i, a, j, b1  
#
            REQUEST Viabj(i,a,b1,j) a  
#
            DO b 
#
              #GET                        Uyaa(b1,b) 
               tppqq(i,a,b,j)           = Viabj(i,a,b1,j)*SUyaa(b1,b) 
               PREPARE VYiabj(i,a,b,j) += tppqq(i,a,b,j)  
#
            ENDDO b 
#
      ENDPARDO i, a, j, b1  
#
      PARDO a, i, j, j1 
#
            REQUEST            Vpiqj(a,i,j,j1) a
            t1ppqq(i,a,j1,j) = Vpiqj(a,i,j,j1) 
#
            DO b 
#
              #GET                        Uyaa(j1,b) 
               tppqq(i,a,b,j)           = t1ppqq(i,a,j1,j)*SUyaa(j1,b) 
               PREPARE VYiabj(i,a,b,j) += tppqq(i,a,b,j)  
#
            ENDDO b 
#
      ENDPARDO a, i, j, j1 
#
      PARDO a, i, b, j1 
#
            REQUEST Viabj(i,a,b,j1) a  
#
            DO j 
#
              #GET                        Uyaa(j1,j) 
               tppqq(i,a,b,j)           = Viabj(i,a,b,j1)*SUyaa(j1,j) 
               PREPARE VYiabj(i,a,b,j) += tppqq(i,a,b,j)  
#
            ENDDO j 
#
      ENDPARDO a, i, b, j1
#
      PARDO b, j, a, i2  
#
            REQUEST Viabj(i2,a,b,j) b 
#
            DO a1  
#
              #GET                         Uyaa(i2,a1) 
               tppqq(a1,a,b,j)           = Viabj(i2,a,b,j)*SUyaa(i2,a1) 
               PREPARE VYaabj(a1,a,b,j) += tppqq(a1,a,b,j) 
#
            ENDDO a1  
#
      ENDPARDO b, j, a, i2 
#
      PARDO b, j, i, a2  
#
            REQUEST Viabj(i,a2,b,j) b  
#
            DO i1 
#
              #GET                         Uyaa(a2,i1) 
               tppqq(i,i1,b,j)           = Viabj(i,a2,b,j)*SUyaa(a2,i1) 
               PREPARE VYiibj(i,i1,b,j) += tppqq(i,i1,b,j) 
#
            ENDDO i1 
#
      ENDPARDO b, j, i, a2  
#
      PARDO b, j, i1, i2  
#
            REQUEST Vpiqj(i2,i1,b,j) b  
#
            DO i 
#
              #GET                         Uyaa(i2,i) 
               tppqq(i,i1,b,j)           = Vpiqj(i2,i1,b,j)*SUyaa(i2,i) 
               PREPARE VYiibj(i,i1,b,j) += tppqq(i,i1,b,j) 
#
            ENDDO i 
#
      ENDPARDO b, j, i1, i2  
#
      PARDO b, j, i, i2  
#
            REQUEST Vpiqj(i,i2,b,j) b  
#
            DO i1 
#
              #GET                         Uyaa(i2,i1) 
               tppqq(i,i1,b,j)           = Vpiqj(i,i2,b,j)*SUyaa(i2,i1) 
               PREPARE VYiibj(i,i1,b,j) += tppqq(i,i1,b,j) 
#
            ENDDO i1 
#
      ENDPARDO b, j, i, i2  
#
      PARDO i, i1, j, b2  
#
            REQUEST Vpiqj(i,i1,b2,j) i  
#
            DO b 
#
              #GET                         Uyaa(b2,b) 
               tppqq(i,i1,b,j)           = Vpiqj(i,i1,b2,j)*SUyaa(b2,b) 
               PREPARE VYiibj(i,i1,b,j) += tppqq(i,i1,b,j) 
#
            ENDDO b 
#
      ENDPARDO i, i1, j, b2 
#
      PARDO i, i1, j, j2  
#
            REQUEST Vpiqj(i,i1,j2,j) i  
#
            DO b 
#
              #GET                         Uyaa(j2,b) 
               tppqq(i,i1,b,j)           = Vpiqj(i,i1,j2,j)*SUyaa(j2,b) 
               PREPARE VYiibj(i,i1,b,j) += tppqq(i,i1,b,j) 
#
            ENDDO b 
#
      ENDPARDO i, i1, j, j2  
#
      PARDO i, i1, b, j2 
#
            REQUEST Vpiqj(i,i1,b,j2) i  
#
            DO j 
#
              #GET                         Uyaa(j2,j) 
               tppqq(i,i1,b,j)           = Vpiqj(i,i1,b,j2)*SUyaa(j2,j) 
               PREPARE VYiibj(i,i1,b,j) += tppqq(i,i1,b,j) 
#
            ENDDO j 
#
      ENDPARDO i, i1, b, j2 
#
      PARDO j, j1, i1, a  
#
            REQUEST Vpiqj(a,i1,j,j1) a  
#
            DO i 
#
              #GET                      Uyaa(a,i) 
               tppqq(i,i1,j,j1)       = Vpiqj(a,i1,j,j1)*SUyaa(a,i) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO i 
#
      ENDPARDO j, j1, i1, a  
#
      PARDO j, j1, i, a  
#
            REQUEST            Vpiqj(a,i,j1,j) a 
            t1ppqq(i,a,j,j1) = Vpiqj(a,i,j1,j) 
#
            DO i1  
#
              #GET                      Uyaa(a,i1) 
               tppqq(i,i1,j,j1)       = t1ppqq(i,a,j,j1)*SUyaa(a,i1) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO i1  
#
      ENDPARDO j, j1, i, a  
#
      PARDO j, j1, i1, i2  
#
            REQUEST Vpiqj(i2,i1,j,j1) j  
#
            DO i 
#
              #GET                      Uyaa(i2,i) 
               tppqq(i,i1,j,j1)       = Vpiqj(i2,i1,j,j1)*SUyaa(i2,i) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO i 
#
      ENDPARDO j, j1, i1, i2  
#
      PARDO j, j1, i, i2  
#
            REQUEST Vpiqj(i,i2,j,j1) j  
#
            DO i1 
#
              #GET                      Uyaa(i2,i1) 
               tppqq(i,i1,j,j1)       = Vpiqj(i,i2,j,j1)*SUyaa(i2,i1) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO i1 
#
      ENDPARDO j, j1, i, i2  
#
      PARDO i, i1, j1, b  
#
            REQUEST Vpiqj(i,i1,b,j1) b  
#
            DO j 
#
              #GET                      Uyaa(b,j) 
               tppqq(i,i1,j,j1)       = Vpiqj(i,i1,b,j1)*SUyaa(b,j) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO j 
#
      ENDPARDO i, i1, j1, b 
#
      PARDO i, i1, j, b 
#
            REQUEST            Vpiqj(i1,i,b,j) b  
            t1ppqq(i,i1,j,b) = Vpiqj(i1,i,b,j) 
#
            DO j1 
#
              #GET                      Uyaa(b,j1) 
               tppqq(i,i1,j,j1)       = t1ppqq(i,i1,j,b)*SUyaa(b,j1) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO j1  
#
      ENDPARDO i, i1, j, b 
#
      PARDO i, i1, j1, j2 
#
            REQUEST Vpiqj(i,i1,j2,j1) i  
#
            DO j 
#
              #GET                      Uyaa(j2,j) 
               tppqq(i,i1,j,j1)       = Vpiqj(i,i1,j2,j1)*SUyaa(j2,j) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO j 
#
      ENDPARDO i, i1, j1, j2 
#
      PARDO i, i1, j, j2 
#
            REQUEST Vpiqj(i,i1,j,j2) i  
#
            DO j1 
#
              #GET                      Uyaa(j2,j1) 
               tppqq(i,i1,j,j1)       = Vpiqj(i,i1,j,j2)*SUyaa(j2,j1) 
               PUT VYiijj(i,i1,j,j1) += tppqq(i,i1,j,j1) 
#
            ENDDO j1 
#
      ENDPARDO i, i1, j, j2 
#
#     Done all other contributions VFL 
#     -------------------------------- 
#
      execute sip_barrier 
      execute server_barrier 
#
      PARDO a, i, b, j 
#
            REQUEST          VYaibj(a,i,b,j) a 
            tppqq(a,i,b,j) = VYaibj(a,i,b,j) 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           Compute contribution to Dyaa. 
#           ----------------------------- 
#
            DO a2 
#
               REQUEST           T1aibj_ab(a2,i,b,j) b  
               tpp(a,a2)       = tppqq(a,i,b,j)*T1aibj_ab(a2,i,b,j) 
               tpp(a,a2)      *= -0.5 
               t1pp(a2,a)      = tpp(a,a2) 
               PUT DIaa(a,a2) += tpp(a,a2) 
               PUT DIaa(a2,a) += t1pp(a2,a) 
#
            ENDDO a2 
#
#           Compute contribution to DIii. 
#           ----------------------------- 
#
            DO i1  
#
               REQUEST           T1aibj_ab(a,i1,b,j) a  
               tpp(i,i1)       = tppqq(a,i,b,j)*T1aibj_ab(a,i1,b,j) 
               tpp(i,i1)      *= -1.0 
               PUT DIii(i,i1) += tpp(i,i1)  
#
            ENDDO i1  
#
#           Compute contribution to DXai. 
#           ----------------------------- 
#
            GET              Dpq_b(b,j) 
            tpp(a,i)       = tppqq(a,i,b,j)*Dpq_b(b,j)
            PUT DXai(a,i) += tpp(a,i) 
#
#           Form complete amplitude derivative. 
#           ---------------------------------- 
#
            DO i1 
#
               REQUEST           T1aibj_ab(a,i1,b,j) a  
               GET               Fya(i1,i) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a,i1,b,j)*Fya(i1,i)  
               tppqq(a,i,b,j) -= t1ppqq(a,i,b,j) 
#
            ENDDO i1 
#
            DO j1 
#
               REQUEST           T1aibj_ab(a,i,b,j1) a  
               GET               Fya(j1,j) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a,i,b,j1)*Fya(j1,j)  
               tppqq(a,i,b,j) -= t1ppqq(a,i,b,j) 
#
            ENDDO j1 
#
            DO a1 
#
               REQUEST           T1aibj_ab(a1,i,b,j) b  
               GET               Fya(a,a1) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a1,i,b,j)*Fya(a,a1) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO a1 
#
            DO b1 
#
               REQUEST           T1aibj_ab(a,i,b1,j) a  
               GET               Fya(b,b1) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a,i,b1,j)*Fya(b,b1) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO b1 
#
            execute                      energy_denominator tppqq(a,i,b,j) 
            PREPARE T2yFullab(a,i,b,j) = tppqq(a,i,b,j)
#
      ENDPARDO a, i, b, j 
#
      PARDO b, b1, i1, i 
#
            REQUEST            VYaajj(b,b1,i1,i) b 
            tqqpp(b,b1,i1,i) = VYaajj(b,b1,i1,i) 
#
#           Compute contributions to intermediates. 
#           --------------------------------------- 
#
            GET               Dpq_b(b,b1)  
            tpp(i1,i)       = tqqpp(b,b1,i1,i)*Dpq_b(b,b1) 
            tpp(i1,i)      *= -1.0  
            PUT DIii(i1,i) += tpp(i1,i) 
#
      ENDPARDO b, b1, i1, i 
#
      PARDO a, b, i, j 
#
            REQUEST          VYiabj(i,a,b,j) a 
            tppqq(i,a,b,j) = VYiabj(i,a,b,j)  
#
#           Compute contribution to DXai. 
#           ---------------------------- 
#
            GET              Dpq_b(b,j) 
            tpp(a,i)       = tppqq(i,a,b,j)*Dpq_b(b,j)
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO a, b, i, j 
#
      PARDO a, i, b, b1 
#
            REQUEST           VYaabj(b1,b,a,i) a 
            tqqpp(b1,b,a,i) = VYaabj(b1,b,a,i) 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            GET                        Dpq_b(b1,b)  
            tpp(a,i)                 = tqqpp(b1,b,a,i)*Dpq_b(b1,b) 
            PUT DXai(a,i)           += tpp(a,i) 
#
      ENDPARDO a, i, b, b1 
#
#     Add contributions to DXai from 'direct' intermediates. 
#     ------------------------------------------------------ 
#
      PARDO a, a1 
#
           GET VXX_aa(a,a1)
#
           DO i 
#
              GET              Uyaa(a1,i) 
              tpp(a,i)       = VXX_aa(a,a1)*Uyaa(a1,i) 
              PUT DXai(a,i) += tpp(a,i)  
#
           ENDDO i 
#
      ENDPARDO a, a1 
#
      PARDO b, j, a, a1 
#
            REQUEST           VYaabj(a1,a,b,j) a 
            tppqq(a1,a,b,j) = VYaabj(a1,a,b,j) 
#
#           Contributions to DXai. 
#           ---------------------- 
#
            DO i 
#
               REQUEST          T1aibj_ab(a1,i,b,j) b  
               tpp(a,i)       = tppqq(a1,a,b,j)*T1aibj_ab(a1,i,b,j)  
               PUT DXai(a,i) += tpp(a,i) 
# 
            ENDDO i 
#
      ENDPARDO b, j, a, a1 
#
#     Add contributions to DXai from 'direct' intermediates. 
#     ------------------------------------------------------ 
#
      PARDO a, i, b, j 
#
           REQUEST          VT_ab(a,i,b,j) a 
           GET              Uyaa(b,j) 
#
           tpp(a,i)       = VT_ab(a,i,b,j)*Uyaa(b,j) 
           PUT DXai(a,i) += tpp(a,i)  
#
      ENDPARDO a, i, b, j 
#
      PARDO i, i1, j, j1 
#
            GET                VYiijj(i,i1,j,j1)  
            tppqq(i,i1,j,j1) = VYiijj(i,i1,j,j1) 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           DIii contribution. 
#           ------------------ 
#
            GET               Dpq_b(j,j1) 
            tpp(i,i1)       = tppqq(i,i1,j,j1)*Dpq_b(j,j1)
            tpp(i,i1)      *= -1.0  
            PUT DIii(i,i1) += tpp(i,i1) 
#
      ENDPARDO i, i1, j, j1 
# 
      PARDO i, i1, b, j 
#
            REQUEST           VYiibj(i,i1,b,j) b 
            tppqq(i,i1,b,j) = VYiibj(i,i1,b,j) 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
            DO a 
#
               REQUEST          T1aibj_ab(a,i1,b,j) a 
               tpp(a,i )      = T1aibj_ab(a,i1,b,j)*tppqq(i,i1,b,j)
               tpp(a,i)      *= -1.0  
               PUT DIai(a,i) += tpp(a,i) 
#
            ENDDO a 
#
#          DIii. 
#          ----- 
#
           GET               Dpq_b(b,j) 
           tpp(i,i1)       = tppqq(i,i1,b,j)*Dpq_b(b,j)
           tpp(i,i1)      *= -1.0  
           t2pp(i1,i)      = tpp(i,i1) 
           PUT DIii(i,i1) += tpp(i,i1) 
           PUT DIii(i1,i) += t2pp(i1,i) 
#
#          Compute contributions to DXai. 
#          ----------------------------- 
#
           DO a 
#
               REQUEST          T1aibj_ab(a,i1,b,j) a  
               tpp(a,i)       = T1aibj_ab(a,i1,b,j)*tppqq(i,i1,b,j)
               tpp(a,i)      *= -1.0 
               PUT DXai(a,i) += tpp(a,i)  
#
           ENDDO a 
#
      ENDPARDO i, i1, b, j 
#
#     Compute contributions to density derivatives. 
#     --------------------------------------------- 
#
      PARDO j, j1, a, i 
#
            REQUEST           VYiibj(j,j1,a,i) a 
            tqqpp(j,j1,a,i) = VYiibj(j,j1,a,i) 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
# 
            GET              Dpq_b(j,j1) 
            tpp(a,i)       = tqqpp(j,j1,a,i)*Dpq_b(j,j1)
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO j, j1, a, i 
#
      execute sip_barrier 
      delete VYiijj 
#
      ENDPROC DERVYFULLAB  
#     -------------------  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC DERVYFULLAA  
#     ----------------  
#
#     Initialize the 'Full' derivatives 
#     --------------------------------- 
#
      PARDO a, a1, i, i1 
#
            t2pppp(a,i,a1,i1)            = 0.0 
            PREPARE T2yFullaa(a,i,a1,i1) = t2pppp(a,i,a1,i1)
#
      ENDPARDO a, a1, i, i1 
#
      PARDO i, i1, a, i2 
#
            REQUEST             DTpppi(a,i2,i,i1) a  
            REQUEST             DTpppi(a,i1,i,i2) a  
            tpppp(a,i2,i,i1)  = DTpppi(a,i2,i,i1) # + 
            t1pppp(a,i2,i,i1) = DTpppi(a,i1,i,i2) # - 
            tpppp(a,i2,i,i1) -= t1pppp(a,i2,i,i1)
            PREPARE VYaiii(a,i2,i,i1) = tpppp(a,i2,i,i1)
#
      ENDPARDO i, i1, a, i2 
#
      PARDO i, i1, i2, i3 
#
            REQUEST              DTpppi(i,i2,i1,i3) i
            REQUEST              DTpppi(i1,i2,i,i3) i  
            tpppp(i,i2,i1,i3)  = DTpppi(i,i2,i1,i3) # + 
            t1pppp(i,i2,i1,i3) = DTpppi(i1,i2,i,i3) # - 
            tpppp(i,i2,i1,i3) -= t1pppp(i,i2,i1,i3) 
            PREPARE VYiiii(i,i2,i1,i3) = tpppp(i,i2,i1,i3) 
#
      ENDPARDO i, i1, i2, i3 
#
#     Done Initialize the 'Full' derivatives 
#     -------------------------------------- 
#
      execute server_barrier 
      execute sip_barrier 
#
#     Contributions from Vaiai 
#     ------------------------ 
# 
      PARDO i, i1, a, a1  
#
            REQUEST VSpipi(a,i,a1,i1) i 
#
            DO i4  
#
              #GET                          Uyaa(a1,i4) 
               tpppp(a,i,i4,i1)           = VSpipi(a,i,a1,i1)*SUyaa(a1,i4) 
               PREPARE VYaiii(a,i,i4,i1) += tpppp(a,i,i4,i1)
#
            ENDDO i4 
#
      ENDPARDO i, i1, a, a1  
#
#     Done Contributions from Vaiai 
#     ----------------------------- 
#
#     Contributions from Vaaii 
#     ------------------------ 
#
      PARDO i, a, i1, a1   
#
            REQUEST               Vaaii(a,a1,i,i1)  i
            REQUEST               Viaai(i,a1,a,i1)  i
#
            t2pppp(a,a1,i,i1)  = Vaaii(a,a1,i,i1) 
            t1pppp(a,a1,i,i1)  = Viaai(i,a1,a,i1) 
            t2pppp(a,a1,i,i1) -= t1pppp(a,a1,i,i1)  
#
            DO i2  
#
              #GET                          Uyaa(a1,i2) 
               tpppp(a,i2,i,i1)           = t2pppp(a,a1,i,i1)*SUyaa(a1,i2) 
               PREPARE VYaiii(a,i2,i,i1) += tpppp(a,i2,i,i1)
#
            ENDDO i2 
#
            t2pppp(a,i1,i,a1)  = Viaai(i,a1,a,i1) 
            t1pppp(a,i1,i,a1)  = Vaaii(a,a1,i,i1)  
            t2pppp(a,i1,i,a1) -= t1pppp(a,i1,i,a1) 
#
            DO i3  
#
              #GET                          Uyaa(a1,i3) 
               tpppp(a,i1,i,i3)           = t2pppp(a,i1,i,a1)*SUyaa(a1,i3) 
               PREPARE VYaiii(a,i1,i,i3) += tpppp(a,i1,i,i3)
#
            ENDDO i3  
#
      ENDPARDO i, a, i1, a1   
#
#     Done Contributions from Vaaii 
#     ----------------------------- 
#
#     All other contributions 
#     ----------------------- 
#
      PARDO i1, i2, i3, i4  
#
            REQUEST VSpipi(i4,i2,i1,i3) i1  
#
            DO i 
#
              #GET                           Uyaa(i4,i) 
               tpppp(i,i2,i1,i3)           = VSpipi(i4,i2,i1,i3)*SUyaa(i4,i) 
               PREPARE VYiiii(i,i2,i1,i3) += tpppp(i,i2,i1,i3) 
#
            ENDDO i 
#
            DO i 
#
              #GET                           Uyaa(i2,i) 
               tpppp(i4,i,i1,i3)           = VSpipi(i4,i2,i1,i3)*SUyaa(i2,i) 
               PREPARE VYiiii(i4,i,i1,i3) += tpppp(i4,i,i1,i3) 
#
            ENDDO i 
#
            DO i 
#
              #GET                           Uyaa(i1,i) 
               tpppp(i4,i2,i,i3)           = VSpipi(i4,i2,i1,i3)*SUyaa(i1,i) 
               PREPARE VYiiii(i4,i2,i,i3) += tpppp(i4,i2,i,i3) 
#
            ENDDO i 
#
            DO i 
#
              #GET                           Uyaa(i3,i) 
               tpppp(i4,i2,i1,i)           = VSpipi(i4,i2,i1,i3)*SUyaa(i3,i) 
               PREPARE VYiiii(i4,i2,i1,i) += tpppp(i4,i2,i1,i) 
#
            ENDDO i 
#
      ENDPARDO i1, i2, i3, i4  
#
      PARDO i1, i2, i3, a4  
#
            REQUEST VSpipi(a4,i2,i1,i3) i1  
#
            DO i 
#
              #GET                           Uyaa(a4,i) 
               tpppp(i,i2,i1,i3)           = VSpipi(a4,i2,i1,i3)*SUyaa(a4,i) 
               PREPARE VYiiii(i,i2,i1,i3) += tpppp(i,i2,i1,i3) 
#
               t1pppp(i2,i,i3,i1)          = tpppp(i,i2,i1,i3) 
               PREPARE VYiiii(i2,i,i3,i1) += t1pppp(i2,i,i3,i1) 
#
               t2pppp(i1,i3,i,i2)          = tpppp(i,i2,i1,i3) 
               PREPARE VYiiii(i1,i3,i,i2) += t2pppp(i1,i3,i,i2) 
#
               t3pppp(i3,i1,i2,i)          = tpppp(i,i2,i1,i3) 
               PREPARE VYiiii(i3,i1,i2,i) += t3pppp(i3,i1,i2,i) 
#
            ENDDO i 
#
      ENDPARDO i1, i2, i3, a4  
#
      PARDO i1, a, i2, i3  
#
           #REQUEST VSpipi(i3,i1,a,i2) a  
            REQUEST VSpipi(a,i2,i3,i1) a  
#
            DO i 
#
              #GET                          Uyaa(i3,i) 
               tpppp(a,i2,i,i1)           = VSpipi(a,i2,i3,i1)*SUyaa(i3,i) 
               PREPARE VYaiii(a,i2,i,i1) += tpppp(a,i2,i,i1)
#
            ENDDO i 
#
      ENDPARDO i1, a, i2, i3  
#
      PARDO i, a, i2, i3  
#
           #REQUEST VSpipi(i,i3,a,i2) a  
            REQUEST VSpipi(a,i2,i,i3) a  
#
            DO i1 
#
              #GET                          Uyaa(i3,i1) 
               tpppp(a,i2,i,i1)           = VSpipi(a,i2,i,i3)*SUyaa(i3,i1) 
               PREPARE VYaiii(a,i2,i,i1) += tpppp(a,i2,i,i1)
#
            ENDDO i1 
#
      ENDPARDO i, a, i2, i3  
#
      PARDO i, i1, a, i3 
#
           #REQUEST VSpipi(i,i1,a,i3) a  
            REQUEST VSpipi(a,i3,i,i1) a  
#
            DO i2 
#
              #GET                          Uyaa(i3,i2) 
               tpppp(a,i2,i,i1)           = VSpipi(a,i3,i,i1)*SUyaa(i3,i2) 
               PREPARE VYaiii(a,i2,i,i1) += tpppp(a,i2,i,i1)
#
            ENDDO i2 
#
      ENDPARDO i, i1, a, i3 
#
      PARDO i, i1, i2, i3  
#
           #REQUEST VSpipi(i,i1,i3,i2) i  
            REQUEST VSpipi(i3,i2,i,i1) i  
#
            DO a 
#
              #GET                          Uyaa(i3,a) 
               tpppp(a,i2,i,i1)           = VSpipi(i3,i2,i,i1)*SUyaa(i3,a) 
               PREPARE VYaiii(a,i2,i,i1) += tpppp(a,i2,i,i1)
#
            ENDDO a 
#
      ENDPARDO i, i1, i2, i3  
#
      PARDO i, i1, i2, a3  
#
            REQUEST VSpipi(i,i1,a3,i2) i  
#
            DO a 
#
              #GET                          Uyaa(a3,a) 
               tpppp(a,i2,i,i1)           = VSpipi(i,i1,a3,i2)*SUyaa(a3,a) 
               PREPARE VYaiii(a,i2,i,i1) += tpppp(a,i2,i,i1)
#
            ENDDO a 
#
      ENDPARDO i, i1, i2, a3  
#
#     End All other contributions 
#     --------------------------- 
#
      execute server_barrier 
      execute sip_barrier 
#
      PARDO a, i, a1, i1 
#
           #REQUEST            VYpipi(a,i,a1,i1) a 
            REQUEST            VYaibj(a,i,a1,i1) a 
            REQUEST            VYaibj(a,i1,a1,i) a 
            GET                Dpq_a(a1,i1) 
           #tpppp(a,i,a1,i1) = VYpipi(a,i,a1,i1) 
            tpppp(a,i,a1,i1) = VYaibj(a,i1,a1,i) 
            tpppp(a,i,a1,i1)-= VYaibj(a,i,a1,i1) 
            tpppp(a,i,a1,i1)*= -1.0  
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           Compute contribution to Dyaa. 
#           ----------------------------- 
#
            DO a2 
#
               REQUEST           T1aiai_aa(a2,i,a1,i1) i  
               tpp(a,a2)       = tpppp(a,i,a1,i1)*T1aiai_aa(a2,i,a1,i1) 
               tpp(a,a2)      *= -0.25 
               t1pp(a2,a)      = tpp(a,a2) 
               PUT DIaa(a,a2) += tpp(a,a2) 
               PUT DIaa(a2,a) += t1pp(a2,a) 
#
            ENDDO a2 
#
#           Compute contribution to Dyii. 
#           ----------------------------- 
#
            DO i2 
#
               REQUEST            T1aiai_aa(a,i2,a1,i1) a 
               tpp(i,i2)        = tpppp(a,i,a1,i1)*T1aiai_aa(a,i2,a1,i1) 
               tpp(i,i2)       *= -0.5 
               PUT DIii(i,i2)  += tpp(i,i2) 
#
            ENDDO i2 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            tpp(a,i)       = tpppp(a,i,a1,i1)*Dpq_a(a1,i1)
            PUT Dxai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i, a1, i1 
#
      PARDO a, i, a1, i1 
#
           #REQUEST            VYpipi(a,i,a1,i1) a 
           #tpppp(a,i,a1,i1) = VYpipi(a,i,a1,i1)   
            REQUEST            VYaibj(a,i,a1,i1) a 
            REQUEST            VYaibj(a,i1,a1,i) a 
            tpppp(a,i,a1,i1) = VYaibj(a,i1,a1,i) 
            tpppp(a,i,a1,i1)-= VYaibj(a,i,a1,i1) 
            tpppp(a,i,a1,i1)*=-0.5 # 0.5   
#
#           Compute complete amplitude derivative. 
#           -------------------------------------- 
#
            DO i2 
#
               REQUEST             T1aiai_aa(a,i2,a1,i1) a  
              #REQUEST             T1aiai_aa(a,i,a1,i2)  a  
               GET                 Fya(i2,i) 
              #GET                 Fya(i2,i1) 
#
               t1pppp(a,i,a1,i1) = T1aiai_aa(a,i2,a1,i1)*Fya(i2,i) 
               tpppp(a,i,a1,i1) -= t1pppp(a,i,a1,i1) 
#
              #t1pppp(a,i,a1,i1) = T1aiai_aa(a,i,a1,i2)*Fya(i2,i1) 
              #tpppp(a,i,a1,i1) -= t1pppp(a,i,a1,i1) 
#
            ENDDO i2 
#
            DO a2 
#
               REQUEST             T1aiai_aa(a2,i,a1,i1) i  
              #REQUEST             T1aiai_aa(a,i,a2,i1)  i  
               GET                 Fya(a2,a) 
              #GET                 Fya(a2,a1) 
#
               t1pppp(a,i,a1,i1) = T1aiai_aa(a2,i,a1,i1)*Fya(a2,a) 
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1) 
#
              #t1pppp(a,i,a1,i1) = T1aiai_aa(a,i,a2,i1)*Fya(a2,a1) 
              #tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1) 
#
            ENDDO a2 
#
            execute                        energy_denominator tpppp(a,i,a1,i1) 
            t2pppp(a1,i1,a,i)            = tpppp(a,i,a1,i1) 
            PREPARE T2yFullaa(a,i,a1,i1)+= tpppp(a,i,a1,i1)
            PREPARE T2yFullaa(a1,i1,a,i)+= t2pppp(a1,i1,a,i)
#
      ENDPARDO a, i, a1, i1 
#
      PARDO a, i, a1, i1 
#
           #REQUEST            VYaaii(a,a1,i,i1) a  
            REQUEST            VYaajj(a,a1,i,i1) a  
            REQUEST            VYiabj(i,a1,a,i1) a  
            GET                Dpq_a(a,a1) 
            GET                Dpq_a(a1,i) 
           #tpppp(a,a1,i,i1) = VYaaii(a,a1,i,i1) 
            tpppp(a,a1,i,i1) = VYiabj(i,a1,a,i1)  
            tpppp(a,a1,i,i1)-= VYaajj(a,a1,i,i1)  
            tpppp(a,a1,i,i1)*= -1.0  
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           DIii. 
#           ----- 
#
            tpp(i,i1)       = tpppp(a,a1,i,i1)*Dpq_a(a,a1) 
            tpp(i,i1)      *= -1.0  
            PUT DIii(i,i1) += tpp(i,i1) 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            tpp(a,i1)       = tpppp(a,a1,i,i1)*Dpq_a(a1,i)
            tpp(a,i1)      *= -1.0 
            PUT DXai(a,i1) += tpp(a,i1)  
#
      ENDPARDO a, i, a1, i1 
#
      PARDO a, a1, a2, i 
#
           #REQUEST            VYaaai(a2,a,a1,i) a 
            REQUEST            VYaabj(a2,a,a1,i) a 
            REQUEST            VYaabj(a1,a,a2,i) a 
            tpppp(a2,a,a1,i) = VYaabj(a1,a,a2,i) 
            tpppp(a2,a,a1,i)-= VYaabj(a2,a,a1,i) 
            tpppp(a2,a,a1,i)*= -1.0  
            GET                Dpq_a(a2,a) 
           #tpppp(a2,a,a1,i) = VYaaai(a2,a,a1,i) 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            DO i1 
#
               REQUEST           T1aiai_aa(a2,i1,a1,i) i  
               tpp(a,i1)       = tpppp(a2,a,a1,i)*T1aiai_aa(a2,i1,a1,i)  
               tpp(a,i1)      *= 0.5 
               PUT DXai(a,i1) += tpp(a,i1) 
#
            ENDDO i1 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            tpp(a1,i)       = tpppp(a2,a,a1,i)*Dpq_a(a2,a) 
            PUT DXai(a1,i) += tpp(a1,i) 
#
      ENDPARDO a, a1, a2, i 
#
#     Add contributions to DXai from 'direct' intermediates. 
#     ------------------------------------------------------ 
#
      PARDO a, a1 
#
           GET VDD_aa(a,a1)
#
           DO i 
#
              GET              Uyaa(a1,i) 
              tpp(a,i)       = VDD_aa(a,a1)*Uyaa(a1,i) 
              PUT DXai(a,i) += tpp(a,i)  
#
           ENDDO i 
#
      ENDPARDO a, a1 
#
      PARDO a, i, a1, i1 
#
           REQUEST          VT_aa(a,i,a1,i1) a 
           GET              Uyaa(a1,i1) 
#
           tpp(a,i)       = VT_aa(a,i,a1,i1)*Uyaa(a1,i1) 
           tpp(a,i)      *= 0.5  
           PUT DXai(a,i) += tpp(a,i)  
#
      ENDPARDO a, i, a1, i1 
#
#     dV^{ik}_{jl}/dy next  
#     -------------------- 
#
      PARDO i, i1, i2, i3 
#
            REQUEST VYiiii(i,i2,i1,i3) i 
            tpppp(i,i2,i1,i3) = VYiiii(i,i2,i1,i3)  
#
#           Compute contribution to density derivatives. 
#           -------------------------------------------- 
#
            GET               Dpq_a(i1,i3) 
            tpp(i,i2)       = tpppp(i,i2,i1,i3)*Dpq_a(i1,i3)
            tpp(i,i2)      *= -1.0 
            PUT DIii(i,i2) += tpp(i,i2)  
#
      ENDPARDO i, i1, i2, i3 
#
      PARDO i, i1, a, i2 
#
            REQUEST            VYaiii(a,i2,i,i1) a  
            GET                Dpq_a(a,i2) 
            GET                Dpq_a(i1,i) 
            tpppp(a,i2,i,i1) = VYaiii(a,i2,i,i1)  
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           Dai. 
#           ---- 
#
            DO a1 
#
               REQUEST           T1aiai_aa(a1,i1,a,i2) a  
               tpp(a1,i)       = T1aiai_aa(a1,i1,a,i2)*tpppp(a,i2,i,i1)
               tpp(a1,i)      *= -0.5 
               PUT DIai(a1,i) += tpp(a1,i)  
#
            ENDDO a1 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            DO a1 
#
               REQUEST           T1aiai_aa(a1,i1,a,i2) a  
               tpp(a1,i)       = T1aiai_aa(a1,i1,a,i2)*tpppp(a,i2,i,i1)
               tpp(a1,i)      *= -0.5 
               PUT DXai(a1,i) += tpp(a1,i) 
#
            ENDDO a1 
#
#           DIii. 
#           ----- 
#
            tpp(i,i1)       = tpppp(a,i2,i,i1)*Dpq_a(a,i2)
            tpp(i,i1)      *= -1.0  
            t2pp(i1,i)      = tpp(i,i1) 
            PUT DIii(i,i1) += tpp(i,i1) 
            PUT DIii(i1,i) += t2pp(i1,i) 
#
            tpp(a,i2)       = tpppp(a,i2,i,i1)*Dpq_a(i1,i)
            PUT DXai(a,i2) += tpp(a,i2) 
#
      ENDPARDO i, i1, a, i2 
#
      ENDPROC DERVYFULLAA  
#     -------------------  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC FORMDXAI   
#     -------------  
#
#     Contributions of the y-derivative of the intermediate Xai used 
#     in the Z-vector equations is computed. Note that the individual 
#     terms have been rearranged from the original version to scale 
#     better. A description of the contributions can be found in that 
#     version, but it is noted that contributions coming from 
#     complete integral derivatives are done 'directly' in the routines
#     where they are computed.  
#     ----------------------------------------------------------------- 
#
#     Alpha-alpha block. 
#     ------------------ 
#
      PARDO a, i, i1, i2  
#
#           Contribution from Dyii. 
#           ----------------------- 
#
            REQUEST          VSpipi(a,i,i2,i1) a  
            GET              Dyii(i1,i2) 
            tpp(a,i)       = VSpipi(a,i,i2,i1)*Dyii(i1,i2) 
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i, i1, i2  
#
      PARDO a, a1, i1, i2  
#
            REQUEST T2yFullaa(a,i1,a1,i2) a  
#
            DO i
#
               REQUEST          VSpipi(a1,i2,i,i1)    i  
               tpp(a,i)       = T2yFullaa(a,i1,a1,i2)*VSpipi(a1,i2,i,i1)
               tpp(a,i)      *= -0.5 
               PUT DXai(a,i) += tpp(a,i) 
#
            ENDDO i 
#
      ENDPARDO a, a1, i1, i2  
#
      PARDO a, a1, b, j
#
            REQUEST Vaabj(a1,a,b,j) b
#
            DO i
#
               REQUEST          T2yFullab(a1,i,b,j) b
               tpp(a,i)       = Vaabj(a1,a,b,j)*T2yFullab(a1,i,b,j)
               PUT DXai(a,i) += tpp(a,i)
#
            ENDDO i
#
      ENDPARDO a, a1, b, j 
#
      PARDO a, i1, b, j  
#
            REQUEST T2yFullab(a,i1,b,j) b  
#
            DO i 
#
               REQUEST          Vpiqj(i,i1,b,j) b  
               tpp(a,i)       = T2yFullab(a,i1,b,j)*Vpiqj(i,i1,b,j) 
               tpp(a,i)      *= -1.0  
               PUT DXai(a,i) += tpp(a,i) 
#
            ENDDO i 
#
      ENDPARDO a, i1, b, j  
#
      PARDO a, i, a1, a2  
#
            REQUEST VSaaai(a2,a1,a,i) a  
            GET     Dyaa(a2,a1) 
#
            DO i1 
#
               REQUEST            T2yFullaa(a2,i1,a,i) i  
               t1pp(a1,i1)      = VSaaai(a2,a1,a,i)*T2yFullaa(a2,i1,a,i) 
               t1pp(a1,i1)     *= 0.5 
               PUT DXai(a1,i1) += t1pp(a1,i1) 
#
            ENDDO i1 
#
            tpp(a,i)       = VSaaai(a2,a1,a,i)*Dyaa(a2,a1) 
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i, a1, a2  
#
      PARDO b, i, a, b1  
#
            REQUEST Vbbai(b1,b,a,i) a  
            GET     Dyaa(b1,b)  
#
            tpp(a,i)       = Vbbai(b1,b,a,i)*Dyaa(b1,b) 
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO b, i, a, b1  
#
      PARDO a, i, j, j1  
#
            REQUEST          Vpiqj(a,i,j1,j) a 
            GET              Dyii(j1,j) 
#
            tpp(a,i)       = Vpiqj(a,i,j1,j)*Dyii(j1,j) 
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i, j, j1  
#
      PARDO a, i 
#
            tpp(a,i) = 0.0 
#
#           Contributions to Dxai/Dy involving unperturbed integrals 
#           are complete. 
#           --------------------------------------------------------- 
#
#           Add contribution from derivative of fock-matrix. 
#           ------------------------------------------------ 
#
            DO i1 
               GET         Dpq_a(a,i1) 
               GET         Fya(i,i1) 
               t3ai(a,i) = Dpq_a(a,i1)*Fya(i,i1) 
               tpp(a,i) -= t3ai(a,i)                
            ENDDO i1 
# 
            DO a1 
               GET         Dpq_a(a1,i) 
               GET         Fya(a,a1) 
               t3ai(a,i) = Dpq_a(a1,i)*Fya(a,a1) 
               tpp(a,i) += t3ai(a,i)                
            ENDDO a1 
#
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i 
#
#
      ENDPROC FORMDXAI   
#     ----------------  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
         PROC UPDATE_DAI 
#        --------------- 
#
         PARDO a, i 
#
               GET        Dainew_a(a,i) 
               GET        Daiold_a(a,i) 
               Tai(a,i) = Dainew_a(a,i) 
#              execute energy_denominator Tai(a,i) 
               Tai(a,i) -= Daiold_a(a,i) 
#
               if kiter == 1 
                  PUT e1ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 2 
                  PUT e2ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 3 
                  PUT e3ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 4 
                  PUT e4ai(a,i) = tai(a,i) 
               endif 
#
               if kiter >= 5 
                  PUT e5ai(a,i) = tai(a,i) 
               endif 
#
         ENDPARDO a, i 
#
         PARDO b, j 
#
               GET        Dainew_b(b,j) 
               GET        Daiold_b(b,j) 
               Tbj(b,j) = Dainew_b(b,j) 
#              execute energy_denominator Tbj(b,j) 
               Tbj(b,j) -= Daiold_b(b,j) 
#
               if kiter == 1 
                  PUT e1bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter == 2 
                  PUT e2bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter == 3 
                  PUT e3bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter == 4 
                  PUT e4bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter >= 5 
                  PUT e5bj(b,j) = tbj(b,j) 
               endif 
#
         ENDPARDO b, j 
#
         ENDPROC UPDATE_DAI 
#        ------------------ 
#
# ----------------------------------------------------------------------------------------
# 
# ----------------------------------------------------------------------------------------
#
      PROC MOVE_DAI 
#     ------------- 
#
      PARDO a, i
#
            GET        Daiold_a(a,i)
            tai(a,i) = Daiold_a(a,i)
#
            if kiter == 1
               PUT d1ai(a,i) = tai(a,i)
            endif
#
            if kiter == 2
               PUT d2ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 3
               PUT d3ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 4
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
            if kiter >= 5
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
      ENDPARDO a, i
#
      PARDO b, j
#
            GET        Daiold_b(b,j)
            tbj(b,j) = Daiold_b(b,j)
#
            if kiter == 1
               PUT d1bj(b,j) = tbj(b,j)
            endif
#
            if kiter == 2
               PUT d2bj(b,j) = tbj(b,j)
            endif
#
            if kiter == 3
               PUT d3bj(b,j) = tbj(b,j)
            endif
#
            if kiter == 4
               PUT d4bj(b,j) = tbj(b,j)
            endif
#
            if kiter >= 5
               PUT d4bj(b,j) = tbj(b,j)
            endif
#
      ENDPARDO b, j
#
      ENDPROC MOVE_DAI 
#     ---------------- 
# 
# ----------------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR
#    -----------------
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS
#    expansion are zero'd out.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR
#    --------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS
#    ---------------
#
#    Put the matrix elements of B into the sip 'B' matrix.
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS
#    ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to Dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-1 amplitudes
           GET e2ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to Dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-1 amplitudes
           GET e2bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb22 += b22
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------
#
     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-2 amplitudes
           GET D1ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-1 amplitudes
           GET e2ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form Dbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-2 amplitudes
           GET D1bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-1 amplitudes
           GET e2bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS1
#    -------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute server_barrier
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-2 amplitudes
           GET e2ai(a,i)    # kiter-1 amplitudes
           GET e3ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-2 amplitudes
           GET e2bj(b,j)    # kiter-1 amplitudes
           GET e3bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
              etemp = e1bj(b,j)*e3bj(b,j)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
              etemp = e2bj(b,j)*e3bj(b,j)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3bj(b,j)*e3bj(b,j)
              b33  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb33 += b33
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-3 amplitudes
           GET D1ai(a,i)     # kiter-2 amplitudes
           GET D2ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-2 amplitudes
           GET e2ai(a,i)     # kiter-1 amplitudes
           GET e3ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form tbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-3 amplitudes
           GET D1bj(b,j)     # kiter-2 amplitudes
           GET D2bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-2 amplitudes
           GET e2bj(b,j)     # kiter-1 amplitudes
           GET e3bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d2bj(b,j)
           t1bj(b,j)    += e3bj(b,j)
           t1bj(b,j)    *= c3
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS2
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-3 amplitudes
           GET e2ai(a,i)    # kiter-2 amplitudes
           GET e3ai(a,i)    # kiter-1 amplitudes
           GET e4ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-3 amplitudes
           GET e2bj(b,j)    # kiter-2 amplitudes
           GET e3bj(b,j)    # kiter-1 amplitudes
           GET e4bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
              etemp = e1bj(b,j)*e3bj(b,j)
              b13  += etemp
#
              etemp = e1bj(b,j)*e4bj(b,j)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
              etemp = e2bj(b,j)*e3bj(b,j)
              b23  += etemp
#
              etemp = e2bj(b,j)*e4bj(b,j)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3bj(b,j)*e3bj(b,j)
              b33  += etemp
#
              etemp = e3bj(b,j)*e4bj(b,j)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4bj(b,j)*e4bj(b,j)
              b44  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb44 += b44
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-4 amplitudes
           GET D1ai(a,i)     # kiter-3 amplitudes
           GET D2ai(a,i)     # kiter-2 amplitudes
           GET D3ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-3 amplitudes
           GET e2ai(a,i)     # kiter-2 amplitudes
           GET e3ai(a,i)     # kiter-1 amplitudes
           GET e4ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form tbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-4 amplitudes
           GET D1bj(b,j)     # kiter-3 amplitudes
           GET D2bj(b,j)     # kiter-2 amplitudes
           GET D3bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-3 amplitudes
           GET e2bj(b,j)     # kiter-2 amplitudes
           GET e3bj(b,j)     # kiter-1 amplitudes
           GET e4bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d2bj(b,j)
           t1bj(b,j)    += e3bj(b,j)
           t1bj(b,j)    *= c3
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d3bj(b,j)
           t1bj(b,j)    += e4bj(b,j)
           t1bj(b,j)    *= c4
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS3
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-4 amplitudes
           GET e2ai(a,i)    # kiter-3 amplitudes
           GET e3ai(a,i)    # kiter-2 amplitudes
           GET e4ai(a,i)    # kiter-1 amplitudes
           GET e5ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
              etemp = e1ai(a,i)*e5ai(a,i)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
              etemp = e2ai(a,i)*e5ai(a,i)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
              etemp = e3ai(a,i)*e5ai(a,i)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
              etemp = e4ai(a,i)*e5ai(a,i)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5ai(a,i)*e5ai(a,i)
              b55  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-4 amplitudes
           GET e2bj(b,j)    # kiter-3 amplitudes
           GET e3bj(b,j)    # kiter-2 amplitudes
           GET e4bj(b,j)    # kiter-1 amplitudes
           GET e5bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
              etemp = e1bj(b,j)*e3bj(b,j)
              b13  += etemp
#
              etemp = e1bj(b,j)*e4bj(b,j)
              b14  += etemp
#
              etemp = e1bj(b,j)*e5bj(b,j)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
              etemp = e2bj(b,j)*e3bj(b,j)
              b23  += etemp
#
              etemp = e2bj(b,j)*e4bj(b,j)
              b24  += etemp
#
              etemp = e2bj(b,j)*e5bj(b,j)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3bj(b,j)*e3bj(b,j)
              b33  += etemp
#
              etemp = e3bj(b,j)*e4bj(b,j)
              b34  += etemp
#
              etemp = e3bj(b,j)*e5bj(b,j)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4bj(b,j)*e4bj(b,j)
              b44  += etemp
#
              etemp = e4bj(b,j)*e5bj(b,j)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5bj(b,j)*e5bj(b,j)
              b55  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb15 += b15
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb25 += b25
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb35 += b35
     collective Tb44 += b44
     collective Tb45 += b45
     collective Tb55 += b55
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     c5 = Tb55
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-5 amplitudes
           GET D1ai(a,i)     # kiter-4 amplitudes
           GET D2ai(a,i)     # kiter-3 amplitudes
           GET D3ai(a,i)     # kiter-2 amplitudes
           GET D4ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-4 amplitudes
           GET e2ai(a,i)     # kiter-3 amplitudes
           GET e3ai(a,i)     # kiter-2 amplitudes
           GET e4ai(a,i)     # kiter-1 amplitudes
           GET e5ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d4ai(a,i)
           t1ai(a,i)    += e5ai(a,i)
           t1ai(a,i)    *= c5
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form tbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-5 amplitudes
           GET D1bj(b,j)     # kiter-4 amplitudes
           GET D2bj(b,j)     # kiter-3 amplitudes
           GET D3bj(b,j)     # kiter-2 amplitudes
           GET D4bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-4 amplitudes
           GET e2bj(b,j)     # kiter-3 amplitudes
           GET e3bj(b,j)     # kiter-2 amplitudes
           GET e4bj(b,j)     # kiter-1 amplitudes
           GET e5bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d2bj(b,j)
           t1bj(b,j)    += e3bj(b,j)
           t1bj(b,j)    *= c3
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d3bj(b,j)
           t1bj(b,j)    += e4bj(b,j)
           t1bj(b,j)    *= c4
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d4bj(b,j)
           t1bj(b,j)    += e5bj(b,j)
           t1bj(b,j)    *= c5
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
#
#    0 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET d1ai(a,i)
           PUT d0ai(a,i) = d1ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d1bj(b,j)
           PUT d0bj(b,j) = d1bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier 
#
#    2 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET e2ai(a,i)
           PUT e1ai(a,i) = e2ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e2bj(b,j)
           PUT e1bj(b,j) = e2bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET d2ai(a,i)
           PUT d1ai(a,i) = d2ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d2bj(b,j)
           PUT d1bj(b,j) = d2bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     PARDO a, i
           GET e3ai(a,i)
           PUT e2ai(a,i) = e3ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e3bj(b,j)
           PUT e2bj(b,j) = e3bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET d3ai(a,i)
           PUT d2ai(a,i) = d3ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d3bj(b,j)
           PUT d2bj(b,j) = d3bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
#    4 --> 3
#    ---------------------------------------------------
#
     PARDO a, i
           GET e4ai(a,i)
           PUT e3ai(a,i) = e4ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e4bj(b,j)
           PUT e3bj(b,j) = e4bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET d4ai(a,i)
           PUT d3ai(a,i) = d4ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d4bj(b,j)
           PUT d3bj(b,j) = d4bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     PARDO a, i
           GET e5ai(a,i)
           PUT e4ai(a,i) = e5ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e5bj(b,j)
           PUT e4bj(b,j) = e5bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET daiold_a(a,i)
           PUT d4ai(a,i) = daiold_a(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET daiold_b(b,j)  
           PUT d4bj(b,j) = daiold_b(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC MOVE4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC DENSAI
#     -----------
#
#     Create distributed denisty arrays. 
#     --------------------------------- 
#
      create Dai_a 
      create Dai_b 
      create Dainew_a 
      create Dainew_b 
      create Daiold_a 
      create Daiold_b 
      CREATE D0ai
      CREATE D1ai
      CREATE D2ai
      CREATE D3ai
      CREATE D4ai
#
      CREATE D0bj
      CREATE D1bj
      CREATE D2bj
      CREATE D3bj
      CREATE D4bj
#
      CREATE e1ai
      CREATE e2ai
      CREATE e3ai
      CREATE e4ai
      CREATE e5ai
#
      CREATE e1bj
      CREATE e2bj
      CREATE e3bj
      CREATE e4bj
      CREATE e5bj
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.000000001
      execute sip_barrier
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i 
#
            GET                 Xai_a(a,i)
            tai(a,i)          = Xai_a(a,i) 
            execute             energy_denominator tai(a,i) 
            PUT Daiold_a(a,i) = tai(a,i) 
            PUT D0ai(a,i)     = tai(a,i) 
#
      ENDPARDO a, i 
#
      PARDO b, j 
#
            GET                 Xai_b(b,j)
            tbj(b,j)          = Xai_b(b,j) 
            execute             energy_denominator tbj(b,j) 
            PUT Daiold_b(b,j) = tbj(b,j) 
            PUT D0bj(b,j)     = tbj(b,j) 
#
      ENDPARDO b, j 
#
      execute sip_barrier 
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
#
         PARDO a, i
#
               GET        Xai_a(a,i)
               tai(a,i) = Xai_a(a,i)
#
               DO a1
               DO i1
#
                  REQUEST             VSpipi(a,i,a1,i1) a
                  REQUEST             Vaaii(a,a1,i1,i)  a 
                  REQUEST             Viaai(i,a,a1,i1)  a 
#
                  GET                 Daiold_a(a1,i1)
#
                  Taiai(a,i,a1,i1)  = VSpipi(a,i,a1,i1)
                  T3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)
                  T4aiai(a,i,a1,i1) = Viaai(i,a,a1,i1)
#
                  Taiai(a,i,a1,i1) -= T3aiai(a,i,a1,i1)
                  Taiai(a,i,a1,i1) += T4aiai(a,i,a1,i1)
#
                  t1ai(a,i)         = Taiai(a,i,a1,i1)*Daiold_a(a1,i1)
                  tai(a,i)         += t1ai(a,i)
#
               ENDDO i1
               ENDDO a1
#
               DO b
               DO j
#
                  REQUEST           Vpiqj(a,i,b,j) a 
                  REQUEST           Viabj(i,a,b,j) a 
                  GET               Daiold_b(b,j)
#
                  Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
                  T1aibj(a,i,b,j) = Viabj(i,a,b,j)
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
                  t1ai(a,i)       = Taibj(a,i,b,j)*Daiold_b(b,j)
                  tai(a,i)       += t1ai(a,i)
#
               ENDDO j
               ENDDO b
#
               execute energy_denominator tai(a,i)
               PUT Dainew_a(a,i)        = tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i
#
         PARDO b, j
#
               GET        Xai_b(b,j)
               tbj(b,j) = Xai_b(b,j)
#
               DO b1
               DO j1
#
                  REQUEST             VSqjqj(b,j,b1,j1) b 
                  REQUEST             Vbbjj(b,b1,j1,j)  b 
                  REQUEST             Vjbbj(j,b,b1,j1)  b 
                  GET                 Daiold_b(b1,j1)
#
                  Tbjbj(b,j,b1,j1)  = VSqjqj(b,j,b1,j1)
                  T3bjbj(b,j,b1,j1) = Vbbjj(b,b1,j1,j)
                  T4bjbj(b,j,b1,j1) = Vjbbj(j,b,b1,j1)
#
                  Tbjbj(b,j,b1,j1) -= T3bjbj(b,j,b1,j1)
                  Tbjbj(b,j,b1,j1) += T4bjbj(b,j,b1,j1)
#
                  t1bj(b,j)         = Tbjbj(b,j,b1,j1)*Daiold_b(b1,j1)
                  tbj(b,j)         += t1bj(b,j)
#
               ENDDO j1
               ENDDO b1
#
               DO a
               DO i
#
                  REQUEST           Vpiqj(a,i,b,j) a 
                  REQUEST           Viabj(i,a,b,j) a 
                  GET               Daiold_a(a,i)
#
                  Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
                  T1aibj(a,i,b,j) = Viabj(i,a,b,j)
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
                  t1bj(b,j)       = Taibj(a,i,b,j)*Daiold_a(a,i)
                  tbj(b,j)       += t1bj(b,j)
#
               ENDDO i
               ENDDO a
#
               execute energy_denominator tbj(b,j)
               PUT Dainew_b(b,j)        = tbj(b,j)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tbj(b,j)*tbj(b,j)
               esum += etemp
#
         ENDPARDO b, j
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI
         execute server_barrier 
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one. 
#        ------------------------------------- 
#
         PARDO a, i 
               GET                 Dainew_a(a,i) 
               PUT Daiold_a(a,i) = Dainew_a(a,i) 
         ENDPARDO a, i 
#
         PARDO b, j 
               GET                 Dainew_b(b,j) 
               PUT Daiold_b(b,j) = Dainew_b(b,j) 
         ENDPARDO b, j 
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI
#
      ENDDO kiter
#
      execute sip_barrier
#
#     Put results into the proper arrays. 
#     ----------------------------------- 
#
      PARDO a, i
            GET               Dainew_a(a,i)
            tpp(i,a)        = Dainew_a(a,i)
            PUT Dai_a(a,i)  = Dainew_a(a,i)
            PUT Dpq_a(a,i) += Dainew_a(a,i)
            PUT Dpq_a(i,a) += tpp(i,a)
      ENDPARDO a, i
#
      PARDO b, j
            GET               Dainew_b(b,j)
            tqq(j,b)        = Dainew_b(b,j)
            PUT Dai_b(b,j)  = Dainew_b(b,j)
            PUT Dpq_b(b,j) += Dainew_b(b,j)
            PUT Dpq_b(j,b) += tqq(j,b)
      ENDPARDO b, j
#
       PARDO a, i, i1
#
             GET                Dainew_a(a,i1)
             Tai(a,i)         = Dainew_a(a,i1)*Fock_a(i1,i)
             Tai(a,i)        *= -1.0
             PUT Iai_a(a,i) += Tai(a,i) 
#
       ENDPARDO a, i, i1 
#
       PARDO b, j, j1
#
             GET                Dainew_b(b,j1)
             Tbj(b,j)         = Dainew_b(b,j1)*Fock_a(j1,j)
             Tbj(b,j)        *= -1.0
             PUT Iai_b(b,j) += Tbj(b,j)
#
       ENDPARDO b, j, j1 
#
      ENDPROC DENSAI
#     --------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC FORMDDAI  
#     -------------
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.000000001
      execute sip_barrier
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i 
#
            GET                 DXai(a,i)
            tai(a,i)          = DXai(a,i) 
            execute             energy_denominator tai(a,i) 
            PUT Daiold_a(a,i) = tai(a,i) 
            PUT D0ai(a,i)     = tai(a,i) 
#
      ENDPARDO a, i 
#
      execute sip_barrier
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
#
         PARDO a, i
#
               GET        DXai(a,i)
               tai(a,i) = DXai(a,i)   
#
               DO a1
               DO i1
#
                  REQUEST             VSpipi(a,i,a1,i1) a 
                  REQUEST             Vaaii(a,a1,i1,i)  a 
                  REQUEST             Viaai(i,a,a1,i1)  a 
#
                  GET                 Daiold_a(a1,i1)
#
                  Taiai(a,i,a1,i1)  = VSpipi(a,i,a1,i1)
                  T3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)
                  T4aiai(a,i,a1,i1) = Viaai(i,a,a1,i1)
#
                  Taiai(a,i,a1,i1) -= T3aiai(a,i,a1,i1)
                  Taiai(a,i,a1,i1) += T4aiai(a,i,a1,i1)
#
                  t1ai(a,i)         = Taiai(a,i,a1,i1)*Daiold_a(a1,i1)
                  tai(a,i)         += t1ai(a,i)
#
               ENDDO i1
               ENDDO a1
#
               DO b
               DO j
#
                  REQUEST           Vpiqj(a,i,b,j) a 
                  REQUEST           Viabj(i,a,b,j) a 
                  GET               Daiold_a(b,j)
#
                  Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
                  T1aibj(a,i,b,j) = Viabj(i,a,b,j)
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
                  t1ai(a,i)       = Taibj(a,i,b,j)*Daiold_a(b,j)
                  tai(a,i)       += t1ai(a,i)
#
               ENDDO j
               ENDDO b
#
               execute energy_denominator    tai(a,i)
               PUT Dainew_a(a,i)           = tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI
         execute server_barrier 
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one.
#        -------------------------------------
#
         PARDO a, i
               GET                 Dainew_a(a,i)
               PUT Daiold_a(a,i) = Dainew_a(a,i)
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI
#
      ENDDO kiter
#
      execute sip_barrier
#
#     Put results into proper arrays Dyai. 
#     ------------------------------------ 
#
      PARDO a, i 
            GET Dainew_a(a,i) 
            PUT Dyai(a,i) = Dainew_a(a,i) 
      ENDPARDO a, i 
#
      ENDPROC FORMDDAI
#     ----------------
#
# ---------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC FORM_UYAI  
#     --------------
#
#     Put arrays into proper places and apply orthonormality condition.
#     -----------------------------------------------------------------
#
      PARDO a, i
            GET             CPHFa(a,i,jatom,jx) 
            GET             Sya(a,i)
            tai(a,i)      = CPHFa(a,i,jatom,jx)
            PUT Uyaa(a,i) = tai(a,i)
#
            tai(a,i)     += Sya(a,i)
            tia(i,a)      = tai(a,i)
            tia(i,a)     *= -1.0
#
            PUT Uyaa(i,a) = tia(i,a)

      ENDPARDO a, i
#
#     PARDO b, j
#           GET             CPHFb(b,j,jatom,jx) 
#           GET             Syb(b,j)
#           tbj(b,j)      = CPHFb(b,j,jatom,jx)
#           PUT Uybb(b,j) = tbj(b,j)
#
#           tbj(b,j)     += Syb(b,j)
#           tjb(j,b)      = tbj(b,j)
#           tjb(j,b)     *= -1.0
#
#           PUT Uybb(j,b) = tjb(j,b)
#
#     ENDPARDO b, j 
#
      execute sip_barrier 
#
      ENDPROC FORM_UYAI  
#     -----------------
#
# ---------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC PUT_UXAI  
#     -------------
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            GET              CPHFa(a,i,iatom,ix) 
            GET              Sxa(a,i)
            tai(a,i)       = CPHFa(a,i,iatom,ix)  
#
            PUT Uxaa(a,i)  = tai(a,i)  
#
            tai(a,i)      += Sxa(a,i) 
            tia(i,a)       = tai(a,i) 
            tia(i,a)      *= -1.0  
#
            PUT Uxaa(i,a)  = tia(i,a) 

      ENDPARDO a, i 
#
      ENDPROC PUT_UXAI  
#     ----------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC PUT_UYAI  
#     -------------
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            GET              CPHFa(a,i,jatom,jx) 
            GET              Sya(a,i)
            tai(a,i)       = CPHFa(a,i,jatom,jx)  
#
            PUT Uyaa(a,i)  = tai(a,i)  
#
            tai(a,i)      += Sya(a,i) 
            tia(i,a)       = tai(a,i) 
            tia(i,a)      *= -1.0  
#
            PUT Uyaa(i,a)  = tia(i,a) 

      ENDPARDO a, i 
#
      execute sip_barrier 
#
      ENDPROC PUT_UYAI  
#     ----------------
#
# ---------------------------------------------------------------------------
#
#
#
# ---------------------------------------------------------------------------
#
      PROC VT_XAI 
#     ----------- 
#
#     The intermediates used to remove the 4-virtual arrays are constructed. 
#
#     Create one-particle intermediates used in this routine and used
#     later in the 'direct' computation. 
#     ----------------------------------------------------------------------- 
#
      create VD_aa
      create VDX_aa
      create VD_bb
      create VDX_bb
      create D_aa 
      create D_bb 
      create VDD_aa  
      create VDD_bb  
      create VXX_aa  
      create VXX_bb  
      execute sip_barrier
#
#     Form backtransformed virtual-virtual block of the density matrix. 
#     ----------------------------------------------------------------- 
#
#     alpha-alpha block. 
#     ------------------ 
#
      PARDO a, a1 
#
           GET Dpq_a(a,a1) 
#
           DO mu 
#
              txp(mu,a1) = Dpq_a(a,a1)*ca(mu,a)  
#
              DO nu 
#
                 txx(mu,nu)       = txp(mu,a1)*ca(nu,a1) 
                 PUT D_aa(mu,nu) += txx(mu,nu)
#
              ENDDO nu 
#
           ENDDO mu 
#
      ENDPARDO a, a1 
#
#     beta-beta block. 
#     ---------------- 
#
      PARDO b, b1 
#
           GET Dpq_b(b,b1) 
#
           DO mu 
#
              txq(mu,b1) = Dpq_b(b,b1)*ca(mu,b)  
#
              DO nu 
#
                 txx(mu,nu)       = txq(mu,b1)*ca(nu,b1) 
                 PUT D_bb(mu,nu) += txx(mu,nu)
#
              ENDDO nu 
#
           ENDDO mu 
#
      ENDPARDO b, b1 
#
#     Form Half back transformed cluster arrays
#     -----------------------------------------
#
      PARDO a1, i1, i
#
           allocate LLaiai(*,i,a1,i1)
#
           DO a
#
              REQUEST              T1aiai_aa(a,i,a1,i1) i1
              REQUEST              T1aiai_aa(a,i1,a1,i) i1
              LLaiai(a,i,a1,i1)  = T1aiai_aa(a,i,a1,i1)
              Taiai(a,i,a1,i1)   = T1aiai_aa(a,i1,a1,i)
              LLaiai(a,i,a1,i1) -= Taiai(a,i,a1,i1)
#
           ENDDO a
#
           DO lambda
#
              Txipi(lambda,i,a1,i1) = 0.0
#
              DO a
#
                 Txiai(lambda,i,a1,i1)   = LLaiai(a,i,a1,i1)*ca(lambda,a)
                 Txipi(lambda,i,a1,i1)  += Txiai(lambda,i,a1,i1)
#
              ENDDO a
#
              PREPARE T1AO_aa(lambda,i,a1,i1) = Txipi(lambda,i,a1,i1)
#
           ENDDO lambda
#
           deallocate LLaiai(*,i,a1,i1)
#
      ENDPARDO a1, i1, i
#
      PARDO b1, j1, j
#
           allocate LLbjbj(*,j,b1,j1)
#
           DO b
#
              REQUEST              T1bjbj_bb(b,j,b1,j1) j1
              REQUEST              T1bjbj_bb(b,j1,b1,j) j1
              LLbjbj(b,j,b1,j1)  = T1bjbj_bb(b,j,b1,j1)
              Tbjbj(b,j,b1,j1)   = T1bjbj_bb(b,j1,b1,j)
              LLbjbj(b,j,b1,j1) -= Tbjbj(b,j,b1,j1)
#
           ENDDO b
#
           DO lambda
#
              Txjqj(lambda,j,b1,j1) = 0.0
#
              DO b
#
                 Txjbj(lambda,j,b1,j1)   = LLbjbj(b,j,b1,j1)*ca(lambda,b)
                 Txjqj(lambda,j,b1,j1)  += Txjbj(lambda,j,b1,j1)
#
              ENDDO b
#
              PREPARE T1AO_bb(lambda,j,b1,j1) = Txjqj(lambda,j,b1,j1)
#
           ENDDO lambda
#
           deallocate LLbjbj(*,j,b1,j1)
#
      ENDPARDO b1, j1, j
#
      PARDO b, j, i
#
           allocate LLaibj(*,i,b,j)
#
           DO a
#
              REQUEST            T1aibj_ab(a,i,b,j) i
              LLaibj(a,i,b,j)  = T1aibj_ab(a,i,b,j)
#
           ENDDO a
#
           DO lambda
#
              Txiqj(lambda,i,b,j) = 0.0
#
              DO a
#
                 Txibj(lambda,i,b,j)   = LLaibj(a,i,b,j)*ca(lambda,a)
                 Txiqj(lambda,i,b,j)  += Txibj(lambda,i,b,j)
#
              ENDDO a
#
              PREPARE T1AO_ab(lambda,i,b,j) = Txiqj(lambda,i,b,j)
#
           ENDDO lambda
#
           deallocate LLaibj(*,i,b,j)
#
      ENDPARDO b, j, i
#
      execute server_barrier 
#
      PARDO lambda, i, i1
#
           allocate Lxiai(lambda,i,*,i1)
#
           DO a1
#
              REQUEST                 T1AO_aa(lambda,i,a1,i1) i1
              Lxiai(lambda,i,a1,i1) = T1AO_aa(lambda,i,a1,i1)
#
           ENDDO a1
#
           DO sigma
#
              Txixi(lambda,i,sigma,i1)  = 0.0
#
              DO a1
#
                 T1xixi(lambda,i,sigma,i1) = Lxiai(lambda,i,a1,i1)*ca(sigma,a1)
                 Txixi(lambda,i,sigma,i1)  += T1xixi(lambda,i,sigma,i1)
#
              ENDDO a1
#
              PREPARE TAO_aa(lambda,i,sigma,i1) = Txixi(lambda,i,sigma,i1)
#
           ENDDO sigma
#
           deallocate Lxiai(lambda,i,*,i1)
#
      ENDPARDO lambda, i, i1
#
      PARDO lambda, j, j1
#
           allocate Lxjbj(lambda,j,*,j1)
#
           DO b1
#
              REQUEST                 T1AO_bb(lambda,j,b1,j1) j1
              Lxjbj(lambda,j,b1,j1) = T1AO_bb(lambda,j,b1,j1)
#
           ENDDO b1
#
           DO sigma
#
              Txjxj(lambda,j,sigma,j1)  = 0.0
#
              DO b1
#
                 T1xjxj(lambda,j,sigma,j1) = Lxjbj(lambda,j,b1,j1)*ca(sigma,b1)
                 Txjxj(lambda,j,sigma,j1)  += T1xjxj(lambda,j,sigma,j1)
#
              ENDDO b1
#
              PREPARE TAO_bb(lambda,j,sigma,j1) = Txjxj(lambda,j,sigma,j1)
#
           ENDDO sigma
#
           deallocate Lxjbj(lambda,j,*,j1)
#
      ENDPARDO lambda, j, j1
#
      PARDO lambda, i, j
#
           allocate Lxibj(lambda,i,*,j)
#
           DO b
#
              REQUEST               T1AO_ab(lambda,i,b,j) j
              Lxibj(lambda,i,b,j) = T1AO_ab(lambda,i,b,j)
#
           ENDDO b 
#
           DO sigma
#
              Txixj(lambda,i,sigma,j) = 0.0
#
              DO b
#
                 T1xixj(lambda,i,sigma,j) = Lxibj(lambda,i,b,j)*ca(sigma,b)
                 Txixj(lambda,i,sigma,j) += T1xixj(lambda,i,sigma,j)
#
              ENDDO b
#
              PREPARE TAO_ab(lambda,i,sigma,j) = Txixj(lambda,i,sigma,j)
#
           ENDDO sigma
#
           deallocate Lxibj(lambda,i,*,j)
#
      ENDPARDO lambda, i, j
#
      execute server_barrier
      execute sip_barrier
#
#     Contract AOINT with half back transformed Amplitudes
#     ----------------------------------------------------
#
      PARDO mu, nu
#
           allocate L1xixi(mu,*,nu,*)
           allocate L1xjxj(mu,*,nu,*)
           allocate L1xixj(mu,*,nu,*)
#
           DO lambda
           DO sigma
#
              compute_integrals aoint(lambda,mu,sigma,nu)
#
              GET                      D_aa(sigma,nu) 
              GET                      D_aa(mu,sigma) 
              GET                      D_bb(sigma,nu) 
              GET                      D_bb(mu,sigma) 
#
              txx(lambda,mu)         = aoint(lambda,mu,sigma,nu)*D_aa(sigma,nu)  
              PUT VD_aa(lambda,mu)  += txx(lambda,mu) 
#
              txx(lambda,nu)         = aoint(lambda,mu,sigma,nu)*D_aa(mu,sigma) 
              PUT VDX_aa(lambda,nu) += txx(lambda,nu) 
#
              txx(lambda,mu)         = aoint(lambda,mu,sigma,nu)*D_bb(sigma,nu)  
              PUT VD_bb(lambda,mu)  += txx(lambda,mu) 
#
              txx(lambda,nu)         = aoint(lambda,mu,sigma,nu)*D_bb(mu,sigma) 
              PUT VDX_bb(lambda,nu) += txx(lambda,nu) 
#
              DO i
              DO i1
#
                 REQUEST               TAO_aa(lambda,i,sigma,i1) i1
                 Txixi(mu,i,nu,i1)   = aoint(lambda,mu,sigma,nu)*TAO_aa(lambda,i,sigma,i1)
                 L1xixi(mu,i,nu,i1) += Txixi(mu,i,nu,i1)
#
              ENDDO i1
              ENDDO i
#
              DO j
              DO j1
#
                 REQUEST               TAO_bb(lambda,j,sigma,j1) j1
                 Txjxj(mu,j,nu,j1)   = aoint(lambda,mu,sigma,nu)*TAO_bb(lambda,j,sigma,j1)
                 L1xjxj(mu,j,nu,j1) += Txjxj(mu,j,nu,j1)
#
              ENDDO j1
              ENDDO j
#
              DO i
              DO j
#
                 REQUEST              TAO_ab(lambda,i,sigma,j) j
                 Txixj(mu,i,nu,j)   = aoint(lambda,mu,sigma,nu)*TAO_ab(lambda,i,sigma,j)
                 L1xixj(mu,i,nu,j) += Txixj(mu,i,nu,j)
#
              ENDDO j
              ENDDO i
#
           ENDDO sigma
           ENDDO lambda
#
           DO i
           DO i1
#
              PREPARE T2AO_aa(mu,i,nu,i1) = L1xixi(mu,i,nu,i1)
#
           ENDDO i1
           ENDDO i
#
           DO j
           DO j1
#
              PREPARE T2AO_bb(mu,j,nu,j1) = L1xjxj(mu,j,nu,j1)
#
           ENDDO j1
           ENDDO j
#
           DO i
           DO j
#
              PREPARE T2AO_ab(mu,i,nu,j) = L1xixj(mu,i,nu,j)
#
           ENDDO j
           ENDDO i
#
           deallocate L1xixi(mu,*,nu,*)
           deallocate L1xjxj(mu,*,nu,*)
           deallocate L1xixj(mu,*,nu,*)
#
      ENDPARDO  mu, nu
      execute sip_barrier 
      execute server_barrier 
#
#     Perform final transformation
#     ----------------------------
#
      PARDO a, a1, i, i1
#
           T1aiai(a,i,a1,i1) = 0.0
#
           DO nu
#
              Taixi(a,i,nu,i1) = 0.0
#
              DO mu
#
                 REQUEST             T2AO_aa(mu,i,nu,i1) i1
                 T1aixi(a,i,nu,i1) = T2AO_aa(mu,i,nu,i1)*ca(mu,a)
                 Taixi(a,i,nu,i1) += T1aixi(a,i,nu,i1)
#
              ENDDO mu
#
              T2aiai(a,i,a1,i1)  = Taixi(a,i,nu,i1)*ca(nu,a1)
              T1aiai(a,i,a1,i1) += T2aiai(a,i,a1,i1)
#
           ENDDO nu
#
           PREPARE VT_aa(a,i,a1,i1) = T1aiai(a,i,a1,i1)
#
      ENDPARDO a, a1, i, i1
#
      PARDO b, b1, j, j1
#
           T1bjbj(b,j,b1,j1) = 0.0
#
           DO nu
#
              Tbjxj(b,j,nu,j1) = 0.0
#
              DO mu
#
                 REQUEST             T2AO_bb(mu,j,nu,j1) j1
                 T1bjxj(b,j,nu,j1) = T2AO_bb(mu,j,nu,j1)*ca(mu,b)
                 Tbjxj(b,j,nu,j1) += T1bjxj(b,j,nu,j1)
#
              ENDDO mu
#
              T2bjbj(b,j,b1,j1)  = Tbjxj(b,j,nu,j1)*ca(nu,b1)
              T1bjbj(b,j,b1,j1) += T2bjbj(b,j,b1,j1)
#
           ENDDO nu
#
           PREPARE VT_bb(b,j,b1,j1) = T1bjbj(b,j,b1,j1)
#
      ENDPARDO b, b1, j, j1
#
      PARDO a, b, i, j
#
           T1aibj(a,i,b,j) = 0.0
#
           DO nu
#
              Taixj(a,i,nu,j) = 0.0
#
              DO mu
#
                 REQUEST            T2AO_ab(mu,i,nu,j) j
                 T1aixj(a,i,nu,j) = T2AO_ab(mu,i,nu,j)*ca(mu,a)
                 Taixj(a,i,nu,j) += T1aixj(a,i,nu,j)
#
              ENDDO mu
#
              T2aibj(a,i,b,j)  = Taixj(a,i,nu,j)*ca(nu,b)
              T1aibj(a,i,b,j) += T2aibj(a,i,b,j)
#
           ENDDO nu
#
           PREPARE VT_ab(a,i,b,j) = T1aibj(a,i,b,j)
#
      ENDPARDO a, b, i, j
#
      execute server_barrier 
#
      PARDO a, a1 
#
            tpp(a,a1) = 0.0 
#
            DO mu 
#
               txp(mu,a1) = 0.0 
#
               DO nu 
#
                  GET           VD_aa(mu,nu) 
                  GET           VDX_aa(mu,nu) 
                  txx(mu,nu)  = VD_aa(mu,nu) 
                  txx(mu,nu) -= VDX_aa(mu,nu) 
#
                  t1xp(mu,a1) = txx(mu,nu)*ca(nu,a1) 
                  txp(mu,a1) += t1xp(mu,a1) 
#
               ENDDO nu 
#
               t1pp(a,a1) = txp(mu,a1)*ca(mu,a) 
               tpp(a,a1) += t1pp(a,a1) 
#
            ENDDO mu 
#
            PUT VDD_aa(a,a1) = tpp(a,a1) 
#
            tpp(a,a1) = 0.0 
#
            DO mu 
#
               txp(mu,a1) = 0.0 
#
               DO nu 
#
                  GET           VD_bb(mu,nu) 
                  t1xp(mu,a1) = VD_bb(mu,nu)*ca(nu,a1) 
                  txp(mu,a1) += t1xp(mu,a1) 
#
               ENDDO nu 
#
               t1pp(a,a1) = txp(mu,a1)*ca(mu,a) 
               tpp(a,a1) += t1pp(a,a1) 
#
            ENDDO mu 
#
            PUT VXX_aa(a,a1) = tpp(a,a1) 
#
      ENDPARDO a, a1 
#
      PARDO b, b1 
#
            tqq(b,b1) = 0.0 
#
            DO mu 
#
               txq(mu,b1) = 0.0 
#
               DO nu 
#
                  GET           VD_bb(mu,nu) 
                  GET           VDX_bb(mu,nu) 
                  txx(mu,nu)  = VD_bb(mu,nu) 
                  txx(mu,nu) -= VDX_bb(mu,nu) 
#
                  t1xq(mu,b1) = txx(mu,nu)*ca(nu,b1) 
                  txq(mu,b1) += t1xq(mu,b1) 
#
               ENDDO nu 
#
               t1qq(b,b1) = txq(mu,b1)*ca(mu,b) 
               tqq(b,b1) += t1qq(b,b1) 
#
            ENDDO mu 
#
            PUT VDD_bb(b,b1) = tqq(b,b1) 
#
            tqq(b,b1) = 0.0 
#
            DO mu 
#
               txq(mu,b1) = 0.0 
#
               DO nu 
#
                  GET           VD_aa(mu,nu) 
                  t1xq(mu,b1) = VD_aa(mu,nu)*ca(nu,b1) 
                  txq(mu,b1) += t1xq(mu,b1) 
#
               ENDDO nu 
#
               t1qq(b,b1) = txq(mu,b1)*ca(mu,b) 
               tqq(b,b1) += t1qq(b,b1) 
#
            ENDDO mu 
#
            PUT VXX_bb(b,b1) = tqq(b,b1) 
#
      ENDPARDO b, b1 
      execute sip_barrier
#
#     Remove one-particle arrays never used again. 
#     -------------------------------------------- 
#
      delete VD_aa
      delete VDX_aa
      delete VD_bb
      delete VDX_bb
      delete D_aa 
      delete D_bb 
#
      ENDPROC VT_XAI 
#     -------------- 
#
# ----------------------------------------------------------------------
#
# The transformed derivative integrals for ALL perturbations(iatom,ix) 
# are formed and stored in served arrays. VTpipi(a,i,a1,i1,iatom,ix), 
# VTqjqj(b,j,b1,j1,jatom,jx), VTpiqj(a,i,b,j,iatom,ix). 
# In addition the contributions to Hxa, Hxb, Fxa, Fxb, Qxai, and 
# Qxbj are formed. They are stored in the served arrays shown below.  
#
# Hxa --> HTa(p,p1,iatom,ix) 
# Hxb --> HTb(q,q1,iatom,ix) 
# Qxai--> QTai(p,p1,iatom,ix) 
# Qxbj--> QTbj(q,q1,iatom,ix) 
# QABxx-> QTABxx(mu,nu,iatom,ix)
# QAxx--> QTAxx(mu,nu,iatom,ix)
#
# ----------------------------------------------------------------------
#
      PROC ALLTRAN_VX_XIXI
#     --------------------
#
      create QTai
      create CPHFa 
      execute sip_barrier  
#
# Quantitities which depend on 1 perturbation are computed and stored 
# for ihess1 <= iatom <= ihess2. 
# ------------------------------------------------------------------- 
#
      DO iatom 
         IF iatom >= ihess1 
         IF iatom <= ihess2 
      DO ix 
#
      create Qxai
      create QAxx
      create QABxx
      create Sxa 
      create Sxb 
      create Uxaa 
#
#     Set flags --> perturbation.
#     ---------------------------
      execute set_flags2 dflags2(iatom,ix)
#
#     Zero out 'temporary' served arrays which hold the half transformed 
#     derivative integrals. 
#     ------------------------------------------------------------------ 
#
      PARDO mu, nu, i, j
            Txixj(mu,i,nu,j)          = 0.0
            prepare VXxixj(mu,i,nu,j) = Txixj(mu,i,nu,j)
      ENDPARDO mu, nu, i, j
#
      execute server_barrier
#
#     Compute integrals and perform first two stages of the transformation.
#     ---------------------------------------------------------------------
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     < nu
            WHERE lambda < sigma
#
#              Compute the derivative integrals 
#              -------------------------------- 
# 
               execute der2_comp saoint(mu,nu,lambda,sigma)
#
#              Perform first two stages of transformation 
#              ------------------------------------------- 
#
               DO j
#
                  V0xxxj(mu,nu,lambda,j) = saoint(mu,nu,lambda,sigma)*ca(sigma,j)
                  V2xxxj(mu,nu,sigma,j)  = saoint(mu,nu,lambda,sigma)*ca(lambda,j)
#
                  DO i
                     Txixj(mu,i,lambda,j)          = V0xxxj(mu,nu,lambda,j)*ca(nu,i)
                     prepare VXxixj(mu,i,lambda,j) += Txixj(mu,i,lambda,j)
#
                     T1xixj(mu,i,sigma,j)          = V2xxxj(mu,nu,sigma,j)*ca(nu,i)
                     prepare VXxixj(mu,i,sigma,j)  += T1xixj(mu,i,sigma,j)
                  ENDDO i
#
                  DO i
                     Txixj(nu,i,lambda,j)          = V0xxxj(mu,nu,lambda,j)*ca(mu,i)
                     prepare VXxixj(nu,i,lambda,j) += Txixj(nu,i,lambda,j)
#
                     T1xixj(nu,i,sigma,j)          = V2xxxj(mu,nu,sigma,j)*ca(mu,i)
                     prepare VXxixj(nu,i,sigma,j)  += T1xixj(nu,i,sigma,j)
                  ENDDO i
#
               ENDDO j
#
#              Update QAxx, QBxx, and QABxx
#              ----------------------------
#
               t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
               t1xx(mu,sigma)     *= -1.0
               PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
               t3xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfa(sigma,nu)
               t3xx(mu,lambda)     *= -1.0
               PUT QAxx(mu,lambda) += t3xx(mu,lambda)
#
               t5xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,mu)
               t5xx(nu,sigma)     *= -1.0
               PUT QAxx(nu,sigma) += t5xx(nu,sigma)
#
               t7xx(nu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfa(sigma,mu)
               t7xx(nu,lambda)     *= -1.0
               PUT QAxx(nu,lambda) += t7xx(nu,lambda)
#
               t9xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,sigma)
               t9xx(mu,nu)        *= 4.0 # 2.0 
               PUT QABxx(mu,nu)   += t9xx(mu,nu)
#
               txx(nu,mu)          = t9xx(mu,nu)
               PUT QABxx(nu,mu)   += txx(nu,mu)
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     == nu
            WHERE lambda < sigma
#
               execute der2_comp saoint(mu,nu,lambda,sigma)
#
               DO j
#
                  V0xxxj(mu,nu,lambda,j) = saoint(mu,nu,lambda,sigma)*ca(sigma,j)
                  V2xxxj(mu,nu,sigma,j)  = saoint(mu,nu,lambda,sigma)*ca(lambda,j)
#
                  DO i
                     Txixj(mu,i,lambda,j)          = V0xxxj(mu,nu,lambda,j)*ca(nu,i)
                     prepare VXxixj(mu,i,lambda,j) += Txixj(mu,i,lambda,j)
#
                     T1xixj(mu,i,sigma,j)          = V2xxxj(mu,nu,sigma,j)*ca(nu,i)
                     prepare VXxixj(mu,i,sigma,j)  += T1xixj(mu,i,sigma,j)
                  ENDDO i
#
               ENDDO j
#
#              Update QAxx, QBxx, and QABxx
#              ----------------------------
#
               t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
               t1xx(mu,sigma)     *= -1.0
               PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
               t3xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfa(sigma,nu)
               t3xx(mu,lambda)     *= -1.0
               PUT QAxx(mu,lambda) += t3xx(mu,lambda)
#
               t5xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,sigma)
               t5xx(mu,nu)        *= 4.0 # 2.0
               PUT QABxx(mu,nu)   += t5xx(mu,nu)
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     < nu
            WHERE lambda == sigma
#
               execute der2_comp saoint(mu,nu,lambda,sigma)
#
               DO j
#
                  V0xxxj(mu,nu,lambda,j) = saoint(mu,nu,lambda,sigma)*ca(sigma,j)
#
                  DO i
#
                     Txixj(mu,i,lambda,j)          = V0xxxj(mu,nu,lambda,j)*ca(nu,i)
                     prepare VXxixj(mu,i,lambda,j) += Txixj(mu,i,lambda,j)
#
                     T1xixj(nu,i,lambda,j)         = V0xxxj(mu,nu,lambda,j)*ca(mu,i)
                     prepare VXxixj(nu,i,lambda,j) += T1xixj(nu,i,lambda,j)
#
                  ENDDO i
#
               ENDDO j
#
#              Update QAxx, QBxx, and QABxx
#              ----------------------------
#
               t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
               t1xx(mu,sigma)     *= -1.0
               PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
               t3xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,mu)
               t3xx(nu,sigma)     *= -1.0
               PUT QAxx(nu,sigma) += t3xx(nu,sigma)
#
               t5xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,sigma)
               t5xx(mu,nu)        *= 2.0  
               PUT QABxx(mu,nu)   += t5xx(mu,nu)
#
               txx(nu,mu)          = t5xx(mu,nu)
               PUT QABxx(nu,mu)   += txx(nu,mu)
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     == nu
            WHERE lambda == sigma
#
               execute der2_comp saoint(mu,nu,lambda,sigma)
#
               DO j
#
                  V0xxxj(mu,nu,lambda,j) = saoint(mu,nu,lambda,sigma)*ca(sigma,j)
#
                  DO i
#
                     Txixj(mu,i,lambda,j)          = V0xxxj(mu,nu,lambda,j)*ca(nu,i)
                     prepare VXxixj(mu,i,lambda,j) += Txixj(mu,i,lambda,j)
#
                  ENDDO i
#
               ENDDO j
#
#              Update QAxx, QBxx, and QABxx
#              ----------------------------
#
               t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
               t1xx(mu,sigma)     *= -1.0
               PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
               t1xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,sigma)
               t1xx(mu,nu)        *= 2.0  
               PUT QABxx(mu,nu)   += t1xx(mu,nu)
#
      ENDPARDO mu, nu, lambda, sigma
#
      execute server_barrier
      execute sip_barrier
#
#     Perform third stage of the transformation.
#     ------------------------------------------
#
#     Alpha/Alpha spin component.
#     ---------------------------
#
#     Alpha/Beta spin component.
#     --------------------------
#
      PARDO b, mu, i, j
#
            Txibj(mu,i,b,j) = 0.0
#
            DO nu
#
                REQUEST            VXxixj(mu,i,nu,j) j
                T1xibj(mu,i,b,j) = VXxixj(mu,i,nu,j)*ca(nu,b)
                Txibj(mu,i,b,j) += T1xibj(mu,i,b,j)
#
            ENDDO nu
#
            PREPARE VXxiqj(mu,i,b,j) = Txibj(mu,i,b,j)
#
      ENDPARDO b, mu, i, j
#
      create QA 
      create QB 
      execute server_barrier
#
#     Perform fourth stage of the transformation.
#     ------------------------------------------
#
      PARDO a, b, i, j
#
            Taibj(a,i,b,j) = 0.0
#
            DO mu
#
               REQUEST           VXxiqj(mu,i,b,j) b
               Tppqq(a,i,b,j)  = VXxiqj(mu,i,b,j)*ca(mu,a)
               Taibj(a,i,b,j) += tppqq(a,i,b,j)
#
            ENDDO mu
#
            PREPARE VTpiqj(a,i,b,j,iatom,ix) = Taibj(a,i,b,j)
#
      ENDPARDO a, b, i, j
#
      PARDO mu, nu 
            GET             QABxx(mu,nu) 
            GET             QAxx(mu,nu) 
            txx(mu,nu)    = QABxx(mu,nu) 
            txx(mu,nu)   += QAxx(mu,nu) 
            PUT QA(mu,nu) = txx(mu,nu) 
      ENDPARDO mu, nu 
#
#     Compute the transformed overlap derivative integrals 
#     ---------------------------------------------------- 
#
      PARDO mu, nu 
            execute overlap_der txx(mu,nu) 
            DO p 
               txp(mu,p) = txx(mu,nu)*ca(nu,p)  
               DO p1 
                  tpp(p1,p)       = txp(mu,p)*ca(mu,p1) 
                  PUT Sxa(p1,p)  += tpp(p1,p) 
               ENDDO p1  
            ENDDO p 
      ENDPARDO mu, nu 
#
      create Fxa
      create Hxa
      create Hxb
      create Hx_px
      create Hx_qx
      create Hx_pp
      create Hx_qq
      execute sip_barrier
      execute server_barrier
#
#     Finish the contribution to Qxai and Qxbj
#     ----------------------------------------
#
      PARDO mu, sigma, p
#
            GET                   QA(mu,sigma)
            tpx(p,sigma)        = ca(mu,p)*QA(mu,sigma)
            PUT Hx_px(p,sigma) += tpx(p,sigma)
#
      ENDPARDO mu, sigma, p 
#
      execute sip_barrier
      delete QA 
      delete QB 
#
      PARDO sigma, p, p1 
#
            GET                Hx_px(p,sigma)
            tpp(p,p1)        = Hx_px(p,sigma)*ca(sigma,p1)
            PUT Hx_pp(p,p1) += tpp(p,p1)
#
      ENDPARDO sigma, p, p1 
#
      execute sip_barrier
#
      PARDO p, p1
            GET              Hx_pp(p,p1)
            PUT Hxa(p,p1) += Hx_pp(p,p1)
      ENDPARDO p, p1
#
      PARDO a, a1
            GET              Hx_pp(a,a1)
            PUT Fxa(a,a1) += Hx_pp(a,a1)
      ENDPARDO a, a1
#
      PARDO a, i
            GET              Hx_pp(a,i)
            PUT Qxai(a,i) += Hx_pp(a,i)
      ENDPARDO a, i
#
      PARDO i, i1
            GET              Hx_pp(i,i1)
            PUT Fxa(i,i1) += Hx_pp(i,i1)
      ENDPARDO i, i1
#
      CALL QXAI_H 
      CALL Qx_XX 
#
      CALL HINTX_TRAN  
#
      execute sip_barrier
#
#     Put these arrays into the full served arrays. 
#     --------------------------------------------- 
#
      PARDO mu, nu
            GET                              QABxx(mu,nu)
            GET                              QAxx(mu,nu)
            PREPARE QTABxx(mu,nu,iatom,ix) = QABxx(mu,nu)
            PREPARE QTAxx(mu,nu,iatom,ix)  = QAxx(mu,nu)
      ENDPARDO mu, nu
#
      PARDO a, i
            GET                          Qxai(a,i)
            PUT QTai(a,i,iatom,ix)     = Qxai(a,i)
      ENDPARDO a, i
#
      PARDO p, p1
            GET                          Hxa(p,p1)
            PREPARE HTa(p,p1,iatom,ix) = Hxa(p,p1)
      ENDPARDO p, p1
#
      PARDO p, p1
            GET                          Sxa(p,p1)
            PREPARE STa(p,p1,iatom,ix) = Sxa(p,p1)
      ENDPARDO p, p1
#
      execute sip_barrier
      delete Hx_px
      delete Hx_qx
      delete Hx_pp
      delete Hx_qq
      delete Fxa
      delete Hxa
      delete Hxb
      delete Qxai
      delete QAxx
      delete QABxx
      delete Sxa 
      delete Sxb 
      delete Uxaa 
#
      execute print_scalar etemp 
#
      ENDDO ix 
         ENDIF 
         ENDIF 
      ENDDO iatom 
#
      deallocate LDHFa(*,*)  
      deallocate LDxx_a(*,*)  
#
      ENDPROC ALLTRAN_VX_XIXI
#     -----------------------
#
# ----------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC MOVE_CAI
#     -------------
#
      PARDO a, i, iatom, ix
         IF iatom >= ihess1 
         IF iatom <= ihess2 
#
            GET                   Caiold(a,i,iatom,ix)
            taixx(a,i,iatom,ix) = Caiold(a,i,iatom,ix)
#
            if kiter == 1
               PUT dT1ai(a,i,iatom,ix) = taixx(a,i,iatom,ix)
            endif
#
            if kiter == 2
               PUT dT2ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
            if kiter == 3
               PUT dT3ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
            if kiter == 4
               PUT dT4ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
            if kiter >= 5
               PUT dT4ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
         ENDIF # iatom >= ihess1 
         ENDIF # iatom <= ihess2 
      ENDPARDO a, i, iatom, ix
#
#     PARDO b, j, iatom, ix
#        IF iatom >= ihess1 
#        IF iatom <= ihess2 
#
#           GET                   Cbjold(b,j,iatom,ix)
#           tbjxx(b,j,iatom,ix) = Cbjold(b,j,iatom,ix)
#
#           if kiter == 1
#              PUT dT1bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#           endif
#
#           if kiter == 2
#              PUT dT2bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#           endif
#
#           if kiter == 3
#              PUT dT3bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#           endif
#
#           if kiter == 4
#              PUT dT4bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#           endif
#
#           if kiter >= 5
#              PUT dT4bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#           endif
#
#        ENDIF # iatom >= ihess1 
#        ENDIF # iatom <= ihess2 
#     ENDPARDO b, j, iatom, ix
#
      ENDPROC MOVE_CAI
#     ----------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
         PROC UPDATE_CAI
#        ---------------
#
         PARDO a, i, iatom, ix
            IF iatom >= ihess1 
            IF iatom <= ihess2 
#
               GET                        Cainew(a,i,iatom,ix)
               GET                        Caiold(a,i,iatom,ix)
               Taixx(a,i,iatom,ix)      = Cainew(a,i,iatom,ix)
#              execute energy_denominator Tai(a,i)
               Taixx(a,i,iatom,ix)     -= Caiold(a,i,iatom,ix)
#
               if kiter == 1
                  PUT eT1ai(a,i,iatom,ix) = taixx(a,i,iatom,ix)
               endif
#
               if kiter == 2
                  PUT eT2ai(a,i,iatom,ix) = taixx(a,i,iatom,ix)
               endif
#
               if kiter == 3
                  PUT eT3ai(a,i,iatom,ix) = taixx(a,i,iatom,ix)
               endif
#
               if kiter == 4
                  PUT eT4ai(a,i,iatom,ix) = taixx(a,i,iatom,ix)
               endif
#
               if kiter >= 5
                  PUT eT5ai(a,i,iatom,ix) = taixx(a,i,iatom,ix)
               endif
#
            ENDIF # iatom >= ihess1 
            ENDIF # iatom <= ihess2 
         ENDPARDO a, i, iatom, ix 
#
#        PARDO b, j, iatom, ix
#           IF iatom >= ihess1 
#           IF iatom <= ihess2 
#
#              GET                        Cbjnew(b,j,iatom,ix)
#              GET                        Cbjold(b,j,iatom,ix)
#              Tbjxx(b,j,iatom,ix)      = Cbjnew(b,j,iatom,ix)
#              execute energy_denominator Tbj(b,j)
#              Tbjxx(b,j,iatom,ix)     -= Cbjold(b,j,iatom,ix)
#
#              if kiter == 1
#                 PUT eT1bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#              endif
#
#              if kiter == 2
#                 PUT eT2bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#              endif
#
#              if kiter == 3
#                 PUT eT3bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#              endif
#
#              if kiter == 4
#                 PUT eT4bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#              endif
#
#              if kiter >= 5
#                 PUT eT5bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
#              endif
#
#           ENDIF # iatom >= ihess1 
#           ENDIF # iatom <= ihess2 
#        ENDPARDO b, j, iatom, ix
#
         ENDPROC UPDATE_CAI
#        ------------------
#
# --------------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC FORM_UCAI
#     --------------
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      enew  = 0.0
      ecrit = 0.00000001
      create Cainew
      create Caiold
#
      create eT1ai
      create eT2ai
      create eT3ai
      create eT4ai
      create eT5ai
      create dT1ai
      create dT2ai
      create dT3ai
      create dT4ai
      create dT0ai
#
      execute sip_barrier
#
#     Form initial guess --> DX/eps.
#     ------------------------------
#
      PARDO a, i, iatom, ix
        IF iatom >= ihess1 
        IF iatom <= ihess2 
            GET                        QTai(a,i,iatom,ix)
            tai(a,i)                 = QTai(a,i,iatom,ix)
            execute                    energy_denominator tai(a,i)
            t1ai(a,i)                = tai(a,i)
            PUT Caiold(a,i,iatom,ix) = tai(a,i)
            PUT DT0ai(a,i,iatom,ix)  = t1ai(a,i)
        ENDIF # iatom >= ihess1 
        ENDIF # iatom <= ihess2 
      ENDPARDO a, i, iatom, ix
#
#     PARDO b, j, iatom, ix
#       IF iatom >= ihess1 
#       IF iatom <= ihess2 
#           GET                        QTbj(b,j,iatom,ix)
#           tbj(b,j)                 = QTbj(b,j,iatom,ix)
#           execute                    energy_denominator tbj(b,j)
#           t1bj(b,j)                = tbj(b,j)
#           PUT Cbjold(b,j,iatom,ix) = tbj(b,j)
#           PUT DT0bj(b,j,iatom,ix)  = t1bj(b,j)
#       ENDIF # iatom >= ihess1 
#       ENDIF # iatom <= ihess2 
#     ENDPARDO b, j, iatom, ix
#
#     Form VSpipi + Viaai - Vaaii --> Xaiai
#     -------------------------------------
#
      PARDO a, i, a1, i1
            REQUEST                VSpipi(a,i,a1,i1) a
            REQUEST                Vaaii(a,a1,i1,i)  a
            REQUEST                Viaai(i,a,a1,i1)  a
            Taiai(a,i,a1,i1)     = VSpipi(a,i,a1,i1)
            T3aiai(a,i,a1,i1)    = Vaaii(a,a1,i1,i)
            T4aiai(a,i,a1,i1)    = Viaai(i,a,a1,i1)
            Taiai(a,i,a1,i1)    -= T3aiai(a,i,a1,i1)
            Taiai(a,i,a1,i1)    += T4aiai(a,i,a1,i1)
#
            PREPARE Xaiai(a,i,a1,i1) = Taiai(a,i,a1,i1)
      ENDPARDO a, i, a1, i1
#
      PARDO a, i, b, j
            REQUEST              Vpiqj(a,i,b,j) a
            REQUEST              Viabj(i,a,b,j) a
            Taibj(a,i,b,j)     = Vpiqj(a,i,b,j)
            T1aibj(a,i,b,j)    = Viabj(i,a,b,j)
            Taibj(a,i,b,j)    += T1aibj(a,i,b,j)
#
            PREPARE Xaibj(a,i,b,j) = Taibj(a,i,b,j)
      ENDPARDO a, i, b, j
#
#     PARDO b, j, b1, j1
#           REQUEST                VSqjqj(b,j,b1,j1) b
#           REQUEST                Vbbjj(b,b1,j1,j)  b
#           REQUEST                Vjbbj(j,b,b1,j1)  b
#           Tbjbj(b,j,b1,j1)     = VSqjqj(b,j,b1,j1)
#           T3bjbj(b,j,b1,j1)    = Vbbjj(b,b1,j1,j)
#           T4bjbj(b,j,b1,j1)    = Vjbbj(j,b,b1,j1)
#           Tbjbj(b,j,b1,j1)    -= T3bjbj(b,j,b1,j1)
#           Tbjbj(b,j,b1,j1)    += T4bjbj(b,j,b1,j1)
#
#           PREPARE Xbjbj(b,j,b1,j1) = Tbjbj(b,j,b1,j1)
#     ENDPARDO b, j, b1, j1
#
      execute sip_barrier
      execute server_barrier
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
         execute sip_barrier
#
         PARDO a, i, iatom, ix
           IF iatom >= ihess1 
           IF iatom <= ihess2 
               GET                           QTai(a,i,iatom,ix)
               tai(a,i)                    = QTai(a,i,iatom,ix)
               execute energy_denominator    tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               PUT Cainew(a,i,iatom,ix)    = tai(a,i)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
           ENDIF # iatom >= ihess1 
           ENDIF # iatom <= ihess2 
         ENDPARDO a, i, iatom, ix
#
#        PARDO b, j, iatom, ix
#          IF iatom >= ihess1 
#          IF iatom <= ihess2 
#              GET                         QTbj(b,j,iatom,ix)
#              tbj(b,j)                  = QTbj(b,j,iatom,ix)
#              execute energy_denominator  tbj(b,j)
#              etemp = tbj(b,j)*tbj(b,j)
#              PUT Cbjnew(b,j,iatom,ix)  = tbj(b,j)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#              esum += etemp
#          ENDIF # iatom >= ihess1 
#          ENDIF # iatom <= ihess2 
#        ENDPARDO b, j, iatom, ix
#
         execute sip_barrier
#
         PARDO a, i, a1, i1
#
            REQUEST Xaiai(a,i,a1,i1) a
#
            DO iatom
              IF iatom >= ihess1 
              IF iatom <= ihess2 
            DO ix
#
               GET                         Caiold(a1,i1,iatom,ix)
               t1ai(a1,i1)               = Caiold(a1,i1,iatom,ix)
               tai(a,i)                  = Xaiai(a,i,a1,i1)*t1ai(a1,i1)
               execute energy_denominator  tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               taixx(a,i,iatom,ix)       = tai(a,i)
               PUT Cainew(a,i,iatom,ix) += taixx(a,i,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix
              ENDIF # iatom >= ihess1 
              ENDIF # iatom <= ihess2 
            ENDDO iatom
#
         ENDPARDO a, i, a1, i1
#
         PARDO a, i, b, j
#
            REQUEST Xaibj(a,i,b,j) a
#
            DO iatom
              IF iatom >= ihess1 
              IF iatom <= ihess2 
            DO ix
#
               GET                         Caiold(b,j,iatom,ix)
               tbj(b,j)                  = Caiold(b,j,iatom,ix)
               tai(a,i)                  = Xaibj(a,i,b,j)*tbj(b,j)
               execute energy_denominator  tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               taixx(a,i,iatom,ix)       = tai(a,i)
               PUT Cainew(a,i,iatom,ix) += taixx(a,i,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix
              ENDIF # iatom >= ihess1 
              ENDIF # iatom <= ihess2 
            ENDDO iatom
#
#           DO iatom
#             IF iatom >= ihess1 
#             IF iatom <= ihess2 
#           DO ix
#
#              GET                          Caiold(a,i,iatom,ix)
#              tai(a,i)                   = Caiold(a,i,iatom,ix)
#              tbj(b,j)                   = Xaibj(a,i,b,j)*tai(a,i)
#              execute energy_denominator   tbj(b,j)
#              etemp = tbj(b,j)*tbj(b,j)
#              tbjxx(b,j,iatom,ix)        = tbj(b,j)
#              PUT Cbjnew(b,j,iatom,ix)  += tbjxx(b,j,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#              esum += etemp
#
#           ENDDO ix
#             ENDIF # iatom >= ihess1 
#             ENDIF # iatom <= ihess2 
#           ENDDO iatom
 
        ENDPARDO a, i, b, j
#
#        PARDO b, j, b1, j1
#
#           REQUEST Xbjbj(b,j,b1,j1) b
#
#           DO iatom
#             IF iatom >= ihess1 
#             IF iatom <= ihess2 
#           DO ix
#
#              GET                          Cbjold(b1,j1,iatom,ix)
#              t1bj(b1,j1)                = Cbjold(b1,j1,iatom,ix)
#              tbj(b,j)                   = Xbjbj(b,j,b1,j1)*t1bj(b1,j1)
#              execute energy_denominator   tbj(b,j)
#              etemp = tbj(b,j)*tbj(b,j)
#              tbjxx(b,j,iatom,ix)        = tbj(b,j)
#              PUT Cbjnew(b,j,iatom,ix)  += tbjxx(b,j,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#              esum += etemp
#
#           ENDDO ix
#             ENDIF # iatom >= ihess1 
#             ENDIF # iatom <= ihess2 
#           ENDDO iatom
#
#        ENDPARDO b, j, b1, j1
#
         execute sip_barrier 
         esum = 0.0  
         execute sip_barrier 
#
         PARDO a, i 
#
            DO iatom 
            DO ix   
#
               GET        Cainew(a,i,iatom,ix)
               tai(a,i) = Cainew(a,i,iatom,ix) 
               etemp    = tai(a,i)*tai(a,i)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix   
            ENDDO iatom 
#
         ENDPARDO a, i 
#
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_CAI
         execute server_barrier
         execute sip_barrier
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one.
#        -------------------------------------
#
         PARDO a, i, iatom, ix
            IF iatom >= ihess1 
            IF iatom <= ihess2 
               GET                        Cainew(a,i,iatom,ix)
               PUT Caiold(a,i,iatom,ix) = Cainew(a,i,iatom,ix)
               PUT Daiold_a(a,i)        = Cainew(a,i,iatom,ix) 
            ENDIF # iatom >= ihess1 
            ENDIF # iatom <= ihess2 
         ENDPARDO a, i, iatom, ix
#
#        PARDO b, j, iatom, ix
#           IF iatom >= ihess1 
#           IF iatom <= ihess2 
#              GET                        Cbjnew(b,j,iatom,ix)
#              PUT Cbjold(b,j,iatom,ix) = Cbjnew(b,j,iatom,ix)
#              PUT Daiold_b(b,j)        = Cbjnew(b,j,iatom,ix) 
#           ENDIF # iatom >= ihess1 
#           ENDIF # iatom <= ihess2 
#        ENDPARDO b, j, iatom, ix
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
         execute print_scalar eold 
#
         if kiter == 2
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom
               IF iatom >= ihess1 
               IF iatom <= ihess2 
            DO ix
               PARDO a, i
                     GET eT1ai(a,i,iatom,ix)
                     GET eT2ai(a,i,iatom,ix)
                     GET dT0ai(a,i,iatom,ix)
                     GET dT1ai(a,i,iatom,ix)
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix)
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix)
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix)
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix)
               ENDPARDO a, i
#              PARDO b, j
#                    GET eT1bj(b,j,iatom,ix)
#                    GET eT2bj(b,j,iatom,ix)
#                    GET dT0bj(b,j,iatom,ix)
#                    GET dT1bj(b,j,iatom,ix)
#                    PUT e1bj(b,j) = eT1bj(b,j,iatom,ix)
#                    PUT e2bj(b,j) = eT2bj(b,j,iatom,ix)
#                    PUT d0bj(b,j) = dT0bj(b,j,iatom,ix)
#                    PUT d1bj(b,j) = dT1bj(b,j,iatom,ix)
#              ENDPARDO b, j
               CALL DIIS1
               PARDO a, i 
                     GET Daiold_a(a,i) 
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i) 
               ENDPARDO a, i 
#              PARDO b, j 
#                    GET Daiold_b(b,j) 
#                    PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j) 
#              ENDPARDO b, j 
            ENDDO ix
               ENDIF # iatom >= ihess1 
               ENDIF # iatom <= ihess2 
            ENDDO iatom
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom
               IF iatom >= ihess1 
               IF iatom <= ihess2 
            DO ix
               PARDO a, i
                     GET eT1ai(a,i,iatom,ix)
                     GET eT2ai(a,i,iatom,ix)
                     GET eT3ai(a,i,iatom,ix)
                     GET dT0ai(a,i,iatom,ix)
                     GET dT1ai(a,i,iatom,ix)
                     GET dT2ai(a,i,iatom,ix)
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix)
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix)
                     PUT e3ai(a,i) = eT3ai(a,i,iatom,ix)
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix)
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix)
                     PUT d2ai(a,i) = dT2ai(a,i,iatom,ix)
               ENDPARDO a, i
#              PARDO b, j
#                    GET eT1bj(b,j,iatom,ix)
#                    GET eT2bj(b,j,iatom,ix)
#                    GET eT3bj(b,j,iatom,ix)
#                    GET dT0bj(b,j,iatom,ix)
#                    GET dT1bj(b,j,iatom,ix)
#                    GET dT2bj(b,j,iatom,ix)
#                    PUT e1bj(b,j) = eT1bj(b,j,iatom,ix)
#                    PUT e2bj(b,j) = eT2bj(b,j,iatom,ix)
#                    PUT e3bj(b,j) = eT3bj(b,j,iatom,ix)
#                    PUT d0bj(b,j) = dT0bj(b,j,iatom,ix)
#                    PUT d1bj(b,j) = dT1bj(b,j,iatom,ix)
#                    PUT d2bj(b,j) = dT2bj(b,j,iatom,ix)
#              ENDPARDO b, j
               CALL DIIS2
               PARDO a, i 
                     GET Daiold_a(a,i) 
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i) 
               ENDPARDO a, i 
#              PARDO b, j 
#                    GET Daiold_b(b,j) 
#                    PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j) 
#              ENDPARDO b, j 
            ENDDO ix
               ENDIF # iatom >= ihess1 
               ENDIF # iatom <= ihess2 
            ENDDO iatom
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom
               IF iatom >= ihess1 
               IF iatom <= ihess2 
            DO ix
               PARDO a, i
                     GET eT1ai(a,i,iatom,ix)
                     GET eT2ai(a,i,iatom,ix)
                     GET eT3ai(a,i,iatom,ix)
                     GET eT4ai(a,i,iatom,ix)
                     GET dT0ai(a,i,iatom,ix)
                     GET dT1ai(a,i,iatom,ix)
                     GET dT2ai(a,i,iatom,ix)
                     GET dT3ai(a,i,iatom,ix)
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix)
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix)
                     PUT e3ai(a,i) = eT3ai(a,i,iatom,ix)
                     PUT e4ai(a,i) = eT4ai(a,i,iatom,ix)
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix)
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix)
                     PUT d2ai(a,i) = dT2ai(a,i,iatom,ix)
                     PUT d3ai(a,i) = dT3ai(a,i,iatom,ix)
               ENDPARDO a, i
#              PARDO b, j
#                    GET eT1bj(b,j,iatom,ix)
#                    GET eT2bj(b,j,iatom,ix)
#                    GET eT3bj(b,j,iatom,ix)
#                    GET eT4bj(b,j,iatom,ix)
#                    GET dT0bj(b,j,iatom,ix)
#                    GET dT1bj(b,j,iatom,ix)
#                    GET dT2bj(b,j,iatom,ix)
#                    GET dT3bj(b,j,iatom,ix)
#                    PUT e1bj(b,j) = eT1bj(b,j,iatom,ix)
#                    PUT e2bj(b,j) = eT2bj(b,j,iatom,ix)
#                    PUT e3bj(b,j) = eT3bj(b,j,iatom,ix)
#                    PUT e4bj(b,j) = eT4bj(b,j,iatom,ix)
#                    PUT d0bj(b,j) = dT0bj(b,j,iatom,ix)
#                    PUT d1bj(b,j) = dT1bj(b,j,iatom,ix)
#                    PUT d2bj(b,j) = dT2bj(b,j,iatom,ix)
#                    PUT d3bj(b,j) = dT3bj(b,j,iatom,ix)
#              ENDPARDO b, j
               CALL DIIS3
               PARDO a, i 
                     GET Daiold_a(a,i) 
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i) 
               ENDPARDO a, i 
#              PARDO b, j 
#                    GET Daiold_b(b,j) 
#                    PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j) 
#              ENDPARDO b, j 
            ENDDO ix
               ENDIF # iatom >= ihess1 
               ENDIF # iatom <= ihess2 
            ENDDO iatom
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom
               IF iatom >= ihess1 
               IF iatom <= ihess2 
            DO ix
               PARDO a, i
                     GET eT1ai(a,i,iatom,ix)
                     GET eT2ai(a,i,iatom,ix)
                     GET eT3ai(a,i,iatom,ix)
                     GET eT4ai(a,i,iatom,ix)
                     GET eT5ai(a,i,iatom,ix)
                     GET dT0ai(a,i,iatom,ix)
                     GET dT1ai(a,i,iatom,ix)
                     GET dT2ai(a,i,iatom,ix)
                     GET dT3ai(a,i,iatom,ix)
                     GET dT4ai(a,i,iatom,ix)
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix)
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix)
                     PUT e3ai(a,i) = eT3ai(a,i,iatom,ix)
                     PUT e4ai(a,i) = eT4ai(a,i,iatom,ix)
                     PUT e5ai(a,i) = eT5ai(a,i,iatom,ix)
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix)
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix)
                     PUT d2ai(a,i) = dT2ai(a,i,iatom,ix)
                     PUT d3ai(a,i) = dT3ai(a,i,iatom,ix)
                     PUT d4ai(a,i) = dT4ai(a,i,iatom,ix)
               ENDPARDO a, i
#              PARDO b, j
#                    GET eT1bj(b,j,iatom,ix)
#                    GET eT2bj(b,j,iatom,ix)
#                    GET eT3bj(b,j,iatom,ix)
#                    GET eT4bj(b,j,iatom,ix)
#                    GET eT5bj(b,j,iatom,ix)
#                    GET dT0bj(b,j,iatom,ix)
#                    GET dT1bj(b,j,iatom,ix)
#                    GET dT2bj(b,j,iatom,ix)
#                    GET dT3bj(b,j,iatom,ix)
#                    GET dT4bj(b,j,iatom,ix)
#                    PUT e1bj(b,j) = eT1bj(b,j,iatom,ix)
#                    PUT e2bj(b,j) = eT2bj(b,j,iatom,ix)
#                    PUT e3bj(b,j) = eT3bj(b,j,iatom,ix)
#                    PUT e4bj(b,j) = eT4bj(b,j,iatom,ix)
#                    PUT e5bj(b,j) = eT5bj(b,j,iatom,ix)
#                    PUT d0bj(b,j) = dT0bj(b,j,iatom,ix)
#                    PUT d1bj(b,j) = dT1bj(b,j,iatom,ix)
#                    PUT d2bj(b,j) = dT2bj(b,j,iatom,ix)
#                    PUT d3bj(b,j) = dT3bj(b,j,iatom,ix)
#                    PUT d4bj(b,j) = dT4bj(b,j,iatom,ix)
#              ENDPARDO b, j
               CALL DIIS4
               CALL MOVE4
               PARDO a, i 
                     GET Daiold_a(a,i) 
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i) 
               ENDPARDO a, i 
#              PARDO b, j 
#                    GET Daiold_b(b,j) 
#                    PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j) 
#              ENDPARDO b, j 
               PARDO a, i
                     GET e1ai(a,i)
                     GET e2ai(a,i)
                     GET e3ai(a,i)
                     GET e4ai(a,i)
                     GET e5ai(a,i)
                     GET d0ai(a,i)
                     GET d1ai(a,i)
                     GET d2ai(a,i)
                     GET d3ai(a,i)
                     GET d4ai(a,i)
                     PUT eT1ai(a,i,iatom,ix) = e1ai(a,i)
                     PUT eT2ai(a,i,iatom,ix) = e2ai(a,i)
                     PUT eT3ai(a,i,iatom,ix) = e3ai(a,i)
                     PUT eT4ai(a,i,iatom,ix) = e4ai(a,i)
                     PUT eT5ai(a,i,iatom,ix) = e5ai(a,i)
                     PUT dT0ai(a,i,iatom,ix) = d0ai(a,i)
                     PUT dT1ai(a,i,iatom,ix) = d1ai(a,i)
                     PUT dT2ai(a,i,iatom,ix) = d2ai(a,i)
                     PUT dT3ai(a,i,iatom,ix) = d3ai(a,i)
                     PUT dT4ai(a,i,iatom,ix) = d4ai(a,i)
               ENDPARDO a, i
#              PARDO b, j
#                    GET e1bj(b,j)
#                    GET e2bj(b,j)
#                    GET e3bj(b,j)
#                    GET e4bj(b,j)
#                    GET e5bj(b,j)
#                    GET d0bj(b,j)
#                    GET d1bj(b,j)
#                    GET d2bj(b,j)
#                    GET d3bj(b,j)
#                    GET d4bj(b,j)
#                    PUT eT1bj(b,j,iatom,ix) = e1bj(b,j)
#                    PUT eT2bj(b,j,iatom,ix) = e2bj(b,j)
#                    PUT eT3bj(b,j,iatom,ix) = e3bj(b,j)
#                    PUT eT4bj(b,j,iatom,ix) = e4bj(b,j)
#                    PUT eT5bj(b,j,iatom,ix) = e5bj(b,j)
#                    PUT dT0bj(b,j,iatom,ix) = d0bj(b,j)
#                    PUT dT1bj(b,j,iatom,ix) = d1bj(b,j)
#                    PUT dT2bj(b,j,iatom,ix) = d2bj(b,j)
#                    PUT dT3bj(b,j,iatom,ix) = d3bj(b,j)
#                    PUT dT4bj(b,j,iatom,ix) = d4bj(b,j)
#              ENDPARDO b, j
               execute sip_barrier 
            ENDDO ix
               ENDIF # iatom >= ihess1 
               ENDIF # iatom <= ihess2 
            ENDDO iatom
#
         endif # kiter == 5
#
         execute sip_barrier 
         CALL MOVE_CAI
#
      ENDDO kiter
#
      execute sip_barrier
#
#     Put arrays into proper places and apply orthonormality condition.
#     -----------------------------------------------------------------
#
      PARDO a, i, iatom, ix
         IF iatom >= ihess1 
         IF iatom <= ihess2 
            GET                       Cainew(a,i,iatom,ix)
            PUT CPHFa(a,i,iatom,ix) = Cainew(a,i,iatom,ix)
         ENDIF # iatom >= ihess1 
         ENDIF # iatom <= ihess2 
      ENDPARDO a, i, iatom, ix
#
#     PARDO b, j, iatom, ix
#        IF iatom >= ihess1 
#        IF iatom <= ihess2 
#           GET                       Cbjnew(b,j,iatom,ix)
#           PUT CPHFb(b,j,iatom,ix) = Cbjnew(b,j,iatom,ix)
#        ENDIF # iatom >= ihess1 
#        ENDIF # iatom <= ihess2 
#     ENDPARDO b, j, iatom, ix
#
      PARDO a, i, iatom, ix 
         IF iatom >= ihess1 
         IF iatom <= ihess2 
            REQUEST                   STa(a,i,iatom,ix) a 
            GET                       Cainew(a,i,iatom,ix) 
#
            tppss(a,i,iatom,ix)     = Cainew(a,i,iatom,ix) 
            tppss(a,i,iatom,ix)    += STa(a,i,iatom,ix)  
            t1ppss(i,a,iatom,ix)    = tppss(a,i,iatom,ix)  
            t1ppss(i,a,iatom,ix)   *= -1.0  
#
            PUT CPHFa(i,a,iatom,ix) = t1ppss(i,a,iatom,ix) 
         ENDIF # iatom >= ihess1 
         ENDIF # iatom <= ihess2 
      ENDPARDO a, i, iatom, ix 
#
#     PARDO b, j, iatom, ix 
#        IF iatom >= ihess1 
#        IF iatom <= ihess2 
#           REQUEST                   STb(b,j,iatom,ix) b
#           GET                       CPHFb(b,j,iatom,ix) 
#
#           tqqss(b,j,iatom,ix)     = CPHFb(b,j,iatom,ix) 
#           tqqss(b,j,iatom,ix)    += STb(b,j,iatom,ix)  
#           t1qqss(j,b,iatom,ix)    = tqqss(b,j,iatom,ix)  
#           t1qqss(j,b,iatom,ix)   *= -1.0  
#
#           PUT CPHFb(j,b,iatom,ix) = t1qqss(j,b,iatom,ix) 
#        ENDIF # iatom >= ihess1 
#        ENDIF # iatom <= ihess2 
#     ENDPARDO b, j, iatom, ix 
#
      PARDO a, a1, iatom, ix 
         IF iatom >= ihess1 
         IF iatom <= ihess2 
            REQUEST                    STa(a,a1,iatom,ix) a 
            tppss(a,a1,iatom,ix)     = STa(a,a1,iatom,ix) 
            tppss(a,a1,iatom,ix)    *= -0.5 
            PUT CPHFa(a,a1,iatom,ix) = tppss(a,a1,iatom,ix)  
         ENDIF # iatom >= ihess1 
         ENDIF # iatom <= ihess2 
      ENDPARDO a, a1, iatom, ix 
#
      PARDO i, i1, iatom, ix 
         IF iatom >= ihess1 
         IF iatom <= ihess2 
            REQUEST                    STa(i,i1,iatom,ix) i 
            tppss(i,i1,iatom,ix)     = STa(i,i1,iatom,ix) 
            tppss(i,i1,iatom,ix)    *= -0.5 
            PUT CPHFa(i,i1,iatom,ix) = tppss(i,i1,iatom,ix)  
         ENDIF # iatom >= ihess1 
         ENDIF # iatom <= ihess2 
      ENDPARDO i, i1, iatom, ix 
#
#     PARDO b, b1, iatom, ix 
#        IF iatom >= ihess1 
#        IF iatom <= ihess2 
#           REQUEST                    STb(b,b1,iatom,ix) b 
#           tqqss(b,b1,iatom,ix)     = STb(b,b1,iatom,ix) 
#           tqqss(b,b1,iatom,ix)    *= -0.5 
#           PUT CPHFb(b,b1,iatom,ix) = tqqss(b,b1,iatom,ix)  
#        ENDIF # iatom >= ihess1 
#        ENDIF # iatom <= ihess2 
#     ENDPARDO b, b1, iatom, ix 
#
#     PARDO j, j1, iatom, ix 
#        IF iatom >= ihess1 
#        IF iatom <= ihess2 
#           REQUEST                    STb(j,j1,iatom,ix) j 
#           tqqss(j,j1,iatom,ix)     = STb(j,j1,iatom,ix) 
#           tqqss(j,j1,iatom,ix)    *= -0.5 
#           PUT CPHFb(j,j1,iatom,ix) = tqqss(j,j1,iatom,ix)  
#        ENDIF # iatom >= ihess1 
#        ENDIF # iatom <= ihess2 
#     ENDPARDO j, j1, iatom, ix 
#
      execute sip_barrier
      delete Cainew
      delete Caiold
#
      delete eT1ai
      delete eT2ai
      delete eT3ai
      delete eT4ai
      delete eT5ai
      delete dT1ai
      delete dT2ai
      delete dT3ai
      delete dT4ai
      delete dT0ai
#
      ENDPROC FORM_UCAI
#     -----------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
#                  BEGIN  MAIN PROGRAM 
#
# ---------------------------------------------------------------------------
#
# First compute unperturbed quantities
# ------------------------------------
#
#     1. 2-electron integral transformation 
#     2. First order amplitudes T2aiai, T2bjbj, T2aibj   
#     3. Intermediate Ipq/Xai  
#     4. Density Dpq  
#
# 1. Two-electron integral transformation. 
# ---------------------------------------- 
#
      CALL TRAN_UHF
      execute server_barrier
      execute sip_barrier
#
# 2. First order amplitudes T2aiai, T2bjbj, T2aibj, t1ai, t2bj. 
# -------------------------------------------------------------  
#
      ecrit = 0.00000001 
#
      CALL T2AA_REFERANCE #--> compute the uhf referance amplitudes T2aa  
      CALL T2BB_REFERANCE #--> compute the uhf referance amplitudes T2bb  
      CALL T2AB_REFERANCE #--> compute the uhf referance amplitudes T2bb  
      CALL UHF_ENERGY     #--> compute final total uhf correlation energy 
      execute sip_barrier 
      execute server_barrier 
#
# 3. Occupied-occupied and virtual-virtual blocks of the density.
# ---------------------------------------------------------------
#
      CALL DENSIJ
      CALL DENSAB
      CALL HFDENS
      execute sip_barrier 
#
# 4. One-particle intermediates Ipq and Xai and virtual-occupied block of the density.
# ------------------------------------------------------------------------------------
#
      CALL PINTER
      execute sip_barrier 
      CALL DENSAI
      execute sip_barrier 
      CALL I11 
      execute sip_barrier 
#
# 5. Compute 'directly' computed intermediates. 
# --------------------------------------------- 
#
      allocate La(*,*) 
      execute sip_barrier
      DO p 
      DO mu 
         La(p,mu) = ca(mu,p) 
      ENDDO mu 
      ENDDO p 
#
      CALL VT_XAI 
#
# Done compute unperturbed quantities.
# ------------------------------------
#
#     Now consider the contributions from second-derivative integrals.
#     ----------------------------------------------------------------
#
#     Transform the intermediates I to the AO basis.
#     ----------------------------------------------
#
      CALL I_TRANS
      CALL I_HF
#
#     Transform the one-particle density to the AO basis.
#     ---------------------------------------------------
#
      CALL D_TRANS
      execute sip_barrier 
#
#     'Contract' the backtransformed intermediates with S''.
#     ------------------------------------------------------
#
      CALL SXY_CONT   # Passed 
#
#     'Contract' the backtransformed density with H''.
#     ------------------------------------------------
#
      CALL DXY_CONT # Passed  
#
#     'Contract' the backtransformed gamma array with <mu nu|lambda sigma>^x.
#     -----------------------------------------------------------------------
#
      allocate LDHFa(*,*)  
      allocate LDxx_a(*,*)  
      execute sip_barrier 
#
      DO mu 
      DO nu 
         GET             DHFa(mu,nu) 
         GET             Dxx_a(mu,nu) 
         LDHFa(mu,nu)  = DHFa(mu,nu) 
         LDxx_a(mu,nu) = Dxx_a(mu,nu) 
      ENDDO nu 
      ENDDO mu 
      execute sip_barrier 
#
      CALL GIJAB_BT 
      CALL GIJAB_CONT_NEW  
#
#     Compute quantities depending on the perturbed two-electron derivative
#     integrals. 
#     --------------------------------------------------------------------- 
#
      CALL ALLTRAN_VX_XIXI
      CALL FORM_UCAI 
      create Lhess 
#
# Loop over unique Hessian elements. The Hessian will be viewed as a two
# dimensional array HESS(x,y). The first loop will be over y the second
# over x. Contributions from products of first derivatives will be
# considered first.
# ----------------------------------------------------------------------
#
      create Qxai 
      create Fxa
      create Hxa
      create Hxb
      create QAxx
      create QABxx 
      create Sxa 
      create Sxb 
#
      create Uxaa 
#
      DO jatom 
#
      IF jatom >= jhess1 
      IF jatom <= jhess2 
#
      DO jx 
#
         create Dyaa 
         create Dyii  
         create Dyai 
         create DIii  
         create DIaa  
         create DIai 
         create DXai 
         create Sya 
         execute sip_barrier 
#
#        Set flags --> perturbation. 
#        --------------------------- 
#
         execute set_flags2 dflags2(jatom,jx)   
#
#        Compute the perturbed quantities DTpppi, DTqqqj, DTppqi
#        and DTqqpi.
#        --> Transformed first-derivative two-electron integrals.
#        ------------------------------------------------------------
#
         CALL DINT_TRAN 
#
#        Compute the perturbed quantities Fya and Fyb, Sya and Syb.
#        --> Transformed first-derivative one-electron integrals.
#        ------------------------------------------------------------
#
         CALL SINTY_TRAN 
#
#        Compute CHF coefficients. 
#        ------------------------- 
#
        #CALL Uy_XX  
        #execute sip_barrier 
        #CALL PUT_UYAI 
#
        #CALL QYAI_H
         execute sip_barrier
         CALL Uy_XX
         execute sip_barrier
         CALL FORM_UYAI
#
# Now put Uyaa into a static array SUyaa
# -------------------------------------- 
#
         etemp = 1.
         execute print_scalar etemp
         allocate SUyaa(*,*) 
         DO p 
         DO p1 
            GET           Uyaa(p,p1) 
            tpp(p,p1)   = Uyaa(p,p1) 
            SUyaa(p,p1) = tpp(p,p1) 
         ENDDO p1 
         ENDDO p 
         execute sip_barrier 
#
         CALL FINTY_TRAN 
         execute sip_barrier 
#
#        Prepare perturbed arrays used to complete the HF hessian. 
#        --------------------------------------------------------- 
#
         CALL FSCF_HESS 
         execute sip_barrier 

#        Compute complete two-electron integral derivatives AND 
#        complete derivatives of T-amplitudes. 
#        --------------------------------------------------- 
#
         CALL DERVYFULLAB  
         CALL DERVYFULLAA   
         execute sip_barrier 
         execute server_barrier 
#
#        Compute complete derivative of the density. 
#        ------------------------------------------- 
#
         CALL FORMDDIJ 
         CALL FORMDDAB 
         execute sip_barrier 
#
         CALL FORMDXAI   
         execute sip_barrier 
         CALL FORMDDAI 
         execute sip_barrier 
#
#        Compute complete derivatives of the one-particle intermediates Ipq. 

#
         CALL DERIIJ 
         CALL DERIAB  
         CALL DERIAI 
#
#        Compute single particle intermediates used in parts 1-6 
#        ------------------------------------------------------- 
         CALL FORM_P1 
         CALL FORM_P5 
         CALL PART6 
         execute sip_barrier 
#
#        Finish parts 1-6 
#        ---------------- 
         CALL FINISH_P1 
#
         DO iatom 
#
         IF iatom >= ihess1 
         IF iatom <= ihess2 
#
         DO ix 
#
#           Zero out the hessian element. 
#           ----------------------------- 
#
            hessxy                   = 0.0 
            phessxy                  = 0.0 
            thess(jatom,jx,iatom,ix) = 1.0 
#
            hessyx                   = 0.0 
            phessyx                  = 0.0 
            xhess(iatom,ix,jatom,jx) = 1.0 
#
#           Set flags --> perturbation. 
#           --------------------------- 
#
            execute set_flags2 dflags2(iatom,ix)   
#
#           Form transformed perturbed two-electron integrals. 
#           -------------------------------------------------- 
#
            CALL TRAN_VX_XIXI 
            execute sip_barrier 
#
#           Compute the perturbed quantities Fxa and Fxb, Sxa and Sxb.
#           --> Transformed first-derivative one-electron integrals.
#           ----------------------------------------------------------
#
            CALL SINTX_TRAN 
#
#           Compute CHF coefficients. 
#           ------------------------- 
#
            CALL Ux_XX  
            CALL PUT_UXAI 
            execute sip_barrier 
#
#           Compute contributions to the Hessian 
#           ------------------------------------ 
#
            CALL PART1 # CHECKED  
            CALL PART2 # CHECKED 
            CALL PART3 # CHECKED  
            CALL PART4 # CHECKED  
############CALL PART6 # CHECKED  
            execute print_scalar hessxy  
#
#           Remove x-perturbed distributed arrays. 
#           -------------------------------------- 
#
            execute sip_barrier
#
           #delete Hxa 
           #delete Hxb 
#
           #delete Fxa 
           #delete Sxa 
           #delete Sxb 
           #delete Uxaa  
           #delete Qxai 
#
           #delete QAxx
           #delete QABxx
#
            execute sip_barrier
            execute server_barrier
#
            collective phessxy       += hessxy  
            thess(jatom,jx,iatom,ix) *= phessxy  
            execute                     read_hess thess(jatom,jx,iatom,ix) 
#
            collective phessyx       += hessyx  
            xhess(iatom,ix,jatom,jx) *= phessyx  
            execute                     read_hess xhess(iatom,ix,jatom,jx) 
#
         ENDDO ix 
#
         ENDIF 
         ENDIF 
#
         ENDDO iatom 
#
#        Remove distributed arrays not used anymore. 
#        ------------------------------------------- 
#
         execute sip_barrier 
         etemp = 2.
         execute print_scalar etemp
         deallocate SUyaa(*,*) 
        #DO p 
        #DO p1 
        #   tpp(p,p1)   = 0.0  
        #   SUyaa(p,p1) = tpp(p,p1) 
        #ENDDO p1 
        #ENDDO p 
#
         delete Dyaa 
         delete Dyii 
         delete Dyai 
         delete DIii 
         delete DIaa 
         delete DIai 
         delete DXai 
#
         delete Fya 
         delete Fyb 
         delete Sya 
         delete Uyaa  
         delete Qyai 
         delete dhfya 
         delete dhfyb 
         delete whfya 
         delete whfyb 
#
        #delete QAyy 
        #delete QByy 
#
      ENDDO jx 
#
      ENDIF 
      ENDIF 
#
      ENDDO jatom 
#
      etemp = 0.0 
      esum = 0.0 
      execute sip_barrier 
#
#     Complete the Hessian by including terms accumuated in 
#     Lhess and Rhess. 
#     ------------------------------------------------------ 
#
      DO jatom 
      IF jatom >= jhess1 
      IF jatom <= jhess2 
      DO jx 
         DO iatom 
         DO ix 
            GET                        Lhess(jatom,jx,iatom,ix) 
            execute                    read_hess Lhess(jatom,jx,iatom,ix) 
         ENDDO ix 
         ENDDO iatom 
      ENDDO jx 
      ENDIF 
      ENDIF 
      ENDDO jatom 
#
      execute sip_barrier 
#
#     Print out the final hessian without the nuclear-nuclear contribution. 
#     --------------------------------------------------------------------- 
#
                   ENDSIAL RHF_HESS_SV1_OPT2  
#
# ---------------------------------------------------------------------------
#
#
