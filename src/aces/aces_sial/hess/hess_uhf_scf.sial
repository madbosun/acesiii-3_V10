#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                    SIAL UHF_HESS_SCF   
#
# ---------------------------------------------------------------------------
#
#    PROCEDURE                 OPITIMIZATION 
#
# ---------------------------------------------------------------------------
#
#    PROC TRAN_TRAN2           DONE 
#    PROC TRAN_TRAN3           DONE 
#    PROC TRAN_TRAN4           DONE 
#    PROC CREATE_MOINTS        DONE 
#    PROC TRAN_UHF             DONE 
#    PROC UHF_ENERGY           DONE 
#    PROC T2AA_REFERANCE       DONE 
#    PROC T2BB_REFERANCE       DONE 
#    PROC T2AB_REFERANCE       DONE 
#    PROC PINTER               DONE 
#    PROC DENSIJ
#    PROC DENSAB
#    PROC DENSAI
#    PROC FORM_UYAI            DONE  
#    PROC FORM_UXAI            DONE  
#    PROC DINT_TRAN 
#    PROC TRAN_VX_XIXI         DONE  
#    PROC QYAI_H 
#    PROC QXAI_H 
#    PROC FINTY_TRAN 
#    PROC FINTX_TRAN 
#    PROC SINTY_TRAN 
#    PROC SINTX_TRAN 
#    PROC Uy_XX                DONE  
#    PROC Ux_XX                DONE  
#    PROC I_TRANS
#    PROC D_TRANS
#    PROC I_HF
#    PROC HFDENS
#    PROC I11
#    PROC SXY_CONT
#    PROC DXY_CONT
#    PROC GIJAB_CONT
#    PROC FSCF_HESS               DONE  
#    PROC FORMDDAB 
#    PROC FORMDDIJ 
#    PROC PART1                   DONE  
#    PROC PART2                   DONE  
#    PROC PART4                   DONE  
#    PROC PART5                   DONE  
#    PROC PART6                   DONE  
#    PROC DERIIJ                  DONE  
#    PROC DERIAB                  DONE  
#    PROC DERIAI                  DONE  
#    PROC PART3                   DONE  
#    PROC DERVYFULLAB             DONE  
#    PROC DERVYFULLAA             DONE 
#    PROC DERVYFULLBB             DONE  
#    PROC DT2AMP                  OBSOLETE  
#
# ---------------------------------------------------------------------------
#
# Final set of of fully transformed integrals INCLUDING the 4-virtual ones.
#
# ---------------------------------------------------------------------------
#
#                          Integral     Type
#                         ------------------------
#                         VSpipi       SERVED  
#                         Vaaii        SERVED  
#                         Viaai        SERVED 
#                         VSaaai       SERVED  
#
#                         VSqjqj       SERVED  
#                         Vbbjj        SERVED  
#                         Vjbbj        SERVED  
#                         VSbbbj       SERVED  
#
#                         Vbbii        SERVED  
#                         Vjbii        SERVED  
#                         Vbbai        SERVED  
#                         Vpiqj        SERVED  
#                         Vaajj        SERVED  
#                         Viabj        SERVED  
#                         Vaabj        SERVED  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
# Declare indices. 
# ---------------- 
#
     index   kiter  = 1, 100 
     index   iatom  = 1, natoms  
     index   ix     = 1, 3 # 3  
     index   jatom  = 1, natoms  
     index   jx     = 1, 3 # 3  
#
     aoindex mu     = 1, norb
     aoindex nu     = 1, norb
     aoindex lambda = 1, norb
     aoindex sigma  = 1, norb
#
     moaindex i = baocc, eaocc
     moaindex i1= baocc, eaocc
     moaindex i2= baocc, eaocc
     moaindex i3= baocc, eaocc
     moaindex i4= baocc, eaocc
#
     moaindex a = bavirt, eavirt
     moaindex a1= bavirt, eavirt
     moaindex a2= bavirt, eavirt
     moaindex a3= bavirt, eavirt
     moaindex a4= bavirt, eavirt
#
     mobindex j = bbocc, ebocc
     mobindex j1= bbocc, ebocc
     mobindex j2= bbocc, ebocc
     mobindex j3= bbocc, ebocc
     mobindex j4= bbocc, ebocc
#
     mobindex b = bbvirt, ebvirt
     mobindex b1= bbvirt, ebvirt
     mobindex b2= bbvirt, ebvirt
     mobindex b3= bbvirt, ebvirt
     mobindex b4= bbvirt, ebvirt
#
     moaindex p = baocc, eavirt
     moaindex p1= baocc, eavirt
     moaindex p2= baocc, eavirt
     moaindex p3= baocc, eavirt
#
     mobindex q = bbocc, ebvirt
     mobindex q1= bbocc, ebvirt
     mobindex q2= bbocc, ebvirt
     mobindex q3= bbocc, ebvirt
#
# Declare served arrays. 
# ----------------------
#
     temp saoint(mu,nu,lambda,sigma) 
     static dflags2(jatom,jx) 
     static dflags4(jatom,jx,iatom,ix) 
     temp thess(jatom,jx,iatom,ix) 
     temp xhess(iatom,ix,jatom,jx) 
     served CPHFa(a,i,iatom,ix) 
     served CPHFb(b,j,iatom,ix) 
#
# Declare served arrays which are used to hold the perturbed quantities 
# depending on the two-electrin derivative integrals. 
# --------------------------------------------------------------------- 
#
#    served FTa(p,p1,iatom,ix)
#    served FTb(q,q1,iatom,ix)
#
     distributed QTai(a,i,iatom,ix)
     distributed QTbj(b,j,iatom,ix)
     distributed ovl_der(mu,nu,iatom,ix)
     distributed h_der(mu,nu,iatom,ix)
     distributed Cainew(a,i,iatom,ix)
     distributed Caiold(a,i,iatom,ix)
     distributed Cbjold(b,j,iatom,ix)
     distributed Cbjnew(b,j,iatom,ix)
     temp taixx(a,i,iatom,ix)
     temp tbjxx(b,j,iatom,ix)
     distributed eT1ai(a,i,iatom,ix) 
     distributed eT2ai(a,i,iatom,ix) 
     distributed eT3ai(a,i,iatom,ix) 
     distributed eT4ai(a,i,iatom,ix) 
     distributed eT5ai(a,i,iatom,ix) 
     distributed dT0ai(a,i,iatom,ix) 
     distributed dT1ai(a,i,iatom,ix) 
     distributed dT2ai(a,i,iatom,ix) 
     distributed dT3ai(a,i,iatom,ix) 
     distributed dT4ai(a,i,iatom,ix) 
     distributed dT5ai(a,i,iatom,ix) 
     distributed eT1bj(b,j,iatom,ix) 
     distributed eT2bj(b,j,iatom,ix) 
     distributed eT3bj(b,j,iatom,ix) 
     distributed eT4bj(b,j,iatom,ix) 
     distributed eT5bj(b,j,iatom,ix) 
     distributed dT0bj(b,j,iatom,ix) 
     distributed dT1bj(b,j,iatom,ix) 
     distributed dT2bj(b,j,iatom,ix) 
     distributed dT3bj(b,j,iatom,ix) 
     distributed dT4bj(b,j,iatom,ix) 
     distributed dT5bj(b,j,iatom,ix) 
#
     distributed QTABxx(mu,nu,iatom,ix)
     distributed QTAxx(mu,nu,iatom,ix)
     distributed QTBxx(mu,nu,iatom,ix) 
#
     served Xaiai(a,i,a1,i1) 
     served Xaibj(a,i,b1,j1) 
     served Xbjbj(b,j,b1,j1) 
#
# Declare distributed arrays. 
# --------------------------- 
#
     served Vxixi(mu,i,nu,i1) 
     served Vxixj(mu,i,nu,j) 
     served Vxjxj(mu,j,nu,j1) 
#
     served Viixx(i,i1,mu,nu)  
     served Viixb(i,i1,mu,b) 
     served Viibb(i,i1,b1,b) 
#
     distributed Daiold_a(a,i) 
     distributed Daiold_b(b,j) 
     distributed Dainew_a(a,i) 
     distributed Dainew_b(b,j) 
     distributed Iij_a(i,i1) 
     distributed Iij_b(j,j1) 
     distributed Iai_a(a,i) 
     distributed Iai_b(b,j) 
     distributed Iab_a(a,a1) 
     distributed Iab_b(b,b1) 
     distributed Ipq_a(p,p1) 
     distributed Ipq_b(q,q1) 
     distributed Xai_a(a,i) 
     distributed Xai_b(b,j) 
     distributed Ixx_a(mu,nu) 
     distributed Ixx_b(mu,nu) 
     distributed Dxx_a(mu,nu) 
     distributed Dxx_b(mu,nu) 
     distributed Dpq_a(p,p1) 
     distributed Dpq_b(q,q1) 
     distributed Ihf(mu,nu) 
     distributed Dhfa(mu,nu) 
     distributed Dhfb(mu,nu) 
     distributed Dhfmo_a(p,p1) 
     distributed Dhfmo_b(q,q1) 
     local LDhfa(mu,nu) 
     local LDhfb(mu,nu) 
     local Lpipi(p1,i,p,i1)  
     local Laaii(a1,a,i,i1) 
     local Liaai(i,a1,a,i1) 
     local Lqjqj(q1,j,q,j1)  
     local Lbbjj(b1,b,j,j1) 
     local Ljbbj(j,b1,b,j1) 
     local Lbbii(b1,b,i,i1) 
     local Laajj(a1,a,j,j1) 
     local Liabj(i,a,b,j) 
     local Liixb(i,i1,mu,b) 
     local Liibb(i,i1,b1,b) 
     local Lpiqj(p,i,q,j) 
     local L0xxxi(mu,nu,lambda,i)
     local L0xxxj(mu,nu,lambda,j)
     temp txixx(lambda,i,mu,nu) 
     temp txxix(nu,mu,i,lambda) 
     temp txjxx(lambda,j,mu,nu) 
     temp txxjx(nu,mu,j,lambda) 
#
     distributed Uxaa(p,p1) 
     distributed Uyaa(p,p1) 
     distributed Uxbb(q,q1) 
     distributed Uybb(q,q1) 
     distributed Fxaa(p,p1) 
     distributed Fyaa(p,p1) 
     distributed Fxbb(q,q1) 
     distributed Fybb(q,q1) 
     distributed Fxai(a,i) 
     distributed Fxbj(b,j) 
     distributed Fya(p,p1) 
     distributed Fyb(q,q1) 
     distributed Fxa(p,p1) 
     distributed Fxb(q,q1) 

     distributed Hxa(p,p1) 
     distributed Hxb(q,q1) 
     distributed Hya(p,p1) 
     distributed Hyb(q,q1) 
     distributed Hx_xp(mu,p) 
     distributed Hx_xq(mu,q) 
     distributed Hx_px(p,mu) 
     distributed Hx_qx(q,mu) 
     distributed Hx_pp(p,p1) 
     distributed Hx_qq(q,q1) 

     distributed Sya(p,p1) 
     distributed Syb(q,q1) 
     distributed Sxa(p,p1) 
     distributed Sxb(q,q1) 
     distributed FA(p,p1) 
     distributed FB(q,q1) 
     distributed Qyai(a,i)  
     distributed Qybj(b,j)  
     distributed Qxai(a,i)  
     distributed Qxbj(b,j)  
#
     distributed QAByy(mu,sigma) 
     distributed QAyy(mu,sigma) 
     distributed QByy(mu,sigma) 
     distributed QABxx(mu,sigma) 
     distributed QAxx(mu,sigma) 
     distributed QBxx(mu,sigma) 
     distributed QAB(mu,sigma) 
     distributed QA(mu,sigma) 
     distributed QB(mu,sigma) 
     distributed Uyai(a,i)   
     distributed Uybj(b,j)   
     distributed Uxai(a,i)   
     distributed Uxbj(b,j)   
     distributed Uyaiold(a,i)   
     distributed Uybjold(b,j)   
     distributed Uxaiold(a,i)   
     distributed Uxbjold(b,j)   
     distributed XAB(mu,nu) 
     distributed XA(mu,nu) 
     distributed XB(mu,nu) 
     distributed YAB(mu,nu) 
     distributed YA(mu,nu) 
     distributed YB(mu,nu) 
     distributed Ha(p,p1) 
     distributed Hb(q,q1) 
     distributed ID_a(p,p1)  
     distributed ID_b(q,q1)  
#
     distributed cya(mu,p) 
     distributed cyb(mu,q) 
     distributed cxa(mu,p) 
     distributed cxb(mu,q) 
     distributed dhfya(mu,nu) 
     distributed dhfyb(mu,nu) 
     distributed dhfxa(mu,nu) 
     distributed dhfxb(mu,nu) 
     distributed whfya(mu,nu) 
     distributed whfyb(mu,nu) 
     distributed whfa(mu,nu) 
     distributed whfb(mu,nu) 
     distributed D1pp(p,p1) 
     distributed D2pp(p,p1) 
     distributed D1qq(q,q1) 
     distributed D2qq(q,q1) 
#
# Declare arrays used in the transformation of the two-electron integrals. 
# ------------------------------------------------------------------------ 
#
      served Sxixi(mu,i,nu,i1) 
      served Sxixj(mu,i,nu,j) 
      served Sxjxj(mu,j,nu,j1) 
#
      served Vxxxi(mu,nu,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
      served Vxipi(mu,i,p,i1)
      served Vixai(i,mu,a,i1)
      served Vxaii(mu,a,i,i1)
      served Vxaai(mu,a1,a,i)
      served Vxxai(mu,nu,a,i)
      served Vxxxa(mu,nu,lambda,a) 
      served Vxxaa(mu,nu,a1,a) 
      served Vxaaa(mu,a2,a1,a) 
#
      served VSpipi(p1,i,p,i1)
      served Viaai(i,a1,a,i1)
      served Vaaii(a,a1,i,i1)
      served VSaaai(a2,a,a1,i)
#
      served Vxxxj(mu,nu,lambda,j)
      served Vxxjj(mu,nu,j1,j)
      served Vjxxj(j1,nu,lambda,j)
      served Vxjqj(mu,j,q,j1)
      served Vxbjj(mu,b,j,j1)
      served Vxbbj(mu,b1,b,j)
      served Vxxbj(mu,nu,b,j)
      served Vjxbj(j,mu,b,j1)
      served Vxxxb(mu,nu,lambda,b) 
      served Vxxbb(mu,nu,b1,b) 
      served Vxbbb(mu,b2,b1,b) 
      served VSqjqj(q1,j,q,j1)
      served Vjbbj(j,b1,b,j1)
      served Vbbjj(b,b1,j,j1)
      served VSbbbj(b2,b,b1,j)
#
      served Vxbii(mu,b,i,i1)
      served Vxbai(mu,b,a,i)
      served Vxabb(mu,a,b1,b) 
      served Vjbii(j,b,i,i1)
      served Vbbii(b,b1,i,i1)
      served Vbbai(b,b1,a,i)
#
      served Vxiqj(mu,i,q,j)
      served Vxajj(mu,a,j,j1)
      served Vxabj(mu,a,b,j)
      served Vxxij(mu,nu,i,j)
      served Vixxj(i,mu,nu,j)
      served Vixbj(i,mu,b,j)
      served Vpiqj(p,i,q,j)
      served Vaajj(a,a1,j,j1)
      served Viabj(i,a,b,j)
      served Vaabj(a,a1,b,j)
      temp Txjxj(mu,j1,lambda,j)
      temp T1xjxj(mu,j1,lambda,j)
      temp Txxjj(mu,nu,j1,j)
      temp T1xxjj(mu,nu,j1,j)
      temp Tjjxx(j1,nu,lambda,j)
      temp Tjxxj(j1,nu,lambda,j)
      temp T1jxxj(j1,nu,lambda,j)
      temp Txjqj(mu,j,q,j1)
      temp T1xjqj(mu,j,q,j1)
      temp Tqjqj(q1,j,q,j1)
      temp T1qjqj(q1,j,q,j1)
      temp Tjxbj(j,mu,b,j1)
      temp T1jxbj(j,mu,b,j1)
      temp Txbjj(mu,b,j,j1)
      temp T1xbjj(mu,b,j,j1)
      temp Tjbbj(j,b1,b,j1)
      temp T1jbbj(j,b1,b,j1)
      temp Tbbjj(b,b1,j,j1)
      temp T1bbjj(b,b1,j,j1)
      temp Txbbj(mu,b1,b,j)
      temp T1xbbj(mu,b1,b,j)
      temp Tbbbj(b2,b,b1,j)
      temp T1bbbj(b2,b,b1,j)
      temp Txxbj(mu,nu,b,j)
      temp Txixj(mu,i,nu,j)
      temp T1xixj(mu,i,nu,j)
      temp Txiqj(mu,i,q,j)
      temp T1xiqj(mu,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp T1piqj(p,i,q,j)
      temp Tiixx(i,i1,mu,nu)
      temp Tiixb(i,i1,mu,b)
      temp Tiibb(i,i1,b1,b)
      temp Txajj(mu,a,j,j1)
      temp T1xajj(mu,a,j,j1)
      temp Taajj(a,a1,j,j1)
      temp T1aajj(a,a1,j,j1)
      temp Txabj(mu,a,b,j)
      temp T1xabj(mu,a,b,j)
      temp Tixxj(i,mu,nu,j)
      temp Tixbj(i,mu,b,j)
      temp T1ixbj(i,mu,b,j)
      temp Tiabj(i,a,b,j)
      temp T1iabj(i,a,b,j)
      temp Taabj(a,a1,b,j)
      temp T1aabj(a,a1,b,j)
#
      temp Txbii(mu,b,i,i1)
      temp T1xbii(mu,b,i,i1)
      temp Tbbii(b,b1,i,i1)
      temp T1bbii(b,b1,i,i1)
      temp Tjbii(j,b,i,i1)
      temp T1jbii(j,b,i,i1)
      temp Txbai(mu,b,a,i)
      temp T1xbai(mu,b,a,i)
      temp Tbbai(b,b1,a,i)
      temp T1bbai(b,b1,a,i)
#
      temp Taaai(a,a1,a2,i)
      temp T1aaai(a,a1,a2,i)
      temp Txxai(mu,nu,a,i)
      temp Txaai(mu,a,a1,i)
      temp T1xaai(mu,a,a1,i)
      temp Txaii(mu,a,i,i1)
      temp T1xaii(mu,a,i,i1)
      temp Tiaai(i,a,a1,i1)
      temp T1iaai(i,a,a1,i1)
      temp Taaii(a,a1,i,i1)
      temp T1aaii(a,a1,i,i1)
      temp T1xxai(mu,nu,a,i)
      temp Tixai(i,mu,a,i1)
      temp T1ixai(i,mu,a,i1)
      temp Txipi(mu,i,p1,i1)
      temp T1xipi(mu,i,p1,i1)
      temp Tpipi(p,i,p1,i1)
      temp T1pipi(p,i,p1,i1)
      temp T1xxbj(mu,nu,b,j)
#
      temp Txxij(mu,nu,i,j)
      temp T1xxij(mu,nu,i,j)
      temp T1ixxj(i,mu,nu,j)
      temp Txxxi(mu,nu,lambda,i)
      temp T1xxxi(mu,nu,lambda,i)
      temp Txxxj(mu,nu,lambda,j)
      temp T1xxxj(mu,nu,lambda,j)
      temp Txixi(mu,i,nu,i1)
      temp T1xixi(mu,i,nu,i1)
      temp Txxii(mu,nu,i1,i)
      temp T1xxii(mu,nu,i1,i)
      temp Tixxi(i1,mu,nu,i)
      temp T1ixxi(i1,mu,nu,i)
      temp V0xxxi(mu,nu,lambda,i) 
      temp V2xxxi(mu,nu,sigma,i)  
      temp V0xxxj(mu,nu,lambda,j) 
      temp V2xxxj(mu,nu,sigma,j)  
#
      temp Txxxa(mu,nu,lambda,a)
      temp T1xxxa(mu,nu,lambda,a)
      temp Txxaa(mu,nu,a1,a)
      temp T1xxaa(mu,nu,a1,a)
      temp Txaaa(mu,a2,a1,a)
      temp T1xaaa(mu,a2,a1,a)
      temp Taaaa(a3,a2,a1,a)
      temp T1aaaa(a3,a2,a1,a)
#
      temp Txxxb(mu,nu,lambda,b)
      temp T1xxxb(mu,nu,lambda,b)
      temp Txxbb(mu,nu,b1,b)
      temp T1xxbb(mu,nu,b1,b)
      temp Txbbb(mu,b2,b1,b)
      temp T1xbbb(mu,b2,b1,b)
      temp Tbbbb(b3,b2,b1,b)
      temp T1bbbb(b3,b2,b1,b)
#
      temp Txabb(mu,a2,b1,b)
      temp T1xabb(mu,a2,b1,b)
      temp Taabb(a3,a2,b1,b)
      temp T1aabb(a3,a2,b1,b)
#
      temp tiiaa(i,i1,a,a1) 
      temp t1iiaa(i,i1,a,a1) 
      temp taiia(a,i,i1,a1) 
      temp t1aiia(a,i,i1,a1) 
#
      temp tjjbb(j,j1,b,b1) 
      temp t1jjbb(j,j1,b,b1) 
      temp tbjjb(b,j,j1,b1) 
      temp t1bjjb(b,j,j1,b1) 
#
      temp TSxxxx(mu,nu,lambda,sigma)
      temp T1xxxx(mu,nu,lambda,sigma)
      temp T2xxxx(mu,nu,lambda,sigma)
      temp T3xxxx(mu,nu,lambda,sigma)
      temp T4xxxx(mu,nu,lambda,sigma)
      temp T5xxxx(mu,nu,lambda,sigma)
      temp T6xxxx(mu,nu,lambda,sigma)
      temp T7xxxx(mu,nu,lambda,sigma)
      temp T2xxxi(mu,nu,lambda,i)
      temp T3xxxi(mu,nu,lambda,i)
      temp T4xxxi(mu,nu,lambda,i)
      temp T2xxxj(mu,nu,lambda,j)
      temp T3xxxj(mu,nu,lambda,j)
      temp T4xxxj(mu,nu,lambda,j)
      temp TAxxxi(mu,lambda,nu,i1)
      temp TBxxxi(mu,lambda,sigma,i1)
      temp TAxxxj(mu,lambda,nu,j1)
      temp TBxxxj(mu,lambda,sigma,j1)
#
# Declare integral arrays
# ------------------------
#
      served AOINT(mu,nu,lambda,sigma)
      local TAOINT(mu,nu,lambda,sigma)
      local L1xxxi(mu,nu,lambda,i)
      local L2xxxi(mu,lambda,nu,i)
      local L3xxxi(lambda,mu,nu,i)
      local L1xxxj(mu,nu,lambda,j)
      local L2xxxj(mu,lambda,nu,j)
      local L3xxxj(lambda,mu,nu,j)
      local Lxixi(mu,i,lambda,i1)
      local Lxxii(mu,nu,i,i1)
      local Lixxi(i,nu,lambda,i1)
      local Lxjxj(mu,j,lambda,j1)
      local Lxxjj(mu,nu,j,j1)
      local Ljxxj(j,nu,lambda,j1)
      local Lxxai(mu,nu,a,i)
      local Lxxbj(mu,nu,b,j)
      local Lxixj(mu,i,lambda,j)
      local Lixxj(i,nu,lambda,j)
      local Lxipi(mu,i,p,i1)
      local Lxaii(mu,a,i,i1)
      local Lixai(i,mu,a,i1)
      local L1xaai(mu,a,a1,i)
      local L2xaai(mu,a,a2,i)
      local Lxjqj(mu,j,q,j1)
      local Lxbjj(mu,b,j,j1)
      local Ljxbj(j,mu,b,j1)
      local Lxbbj(mu,b,b1,j)
      local Lxbii(mu,b,i,i1)
      local Lxbai(mu,b,a,i)
      local Lxiqj(mu,i,q,j)
      local Lxajj(mu,a,j,j1)
      local Lixbj(i,mu,b,j)
      local Lxabj(mu,a,b,j)
      local L1xbbj(mu,b,b1,j)
      local Lxxxa(mu,nu,lambda,a) 
      local Lxxxb(mu,nu,lambda,b) 
      local Lxxaa(mu,nu,a1,a) 
      local Lxxbb(mu,nu,b1,b) 
      local Lxaaa(mu,a,a1,a2) 
      local Lxbbb(mu,b,b1,b2) 
      local Lxabb(mu,a2,b1,b2) 
      local Laiai(a,i,a1,i1) 
      local Lbjbj(b,j,b1,j1) 
      local Laibj(a,i,b,j) 
#
      local LX1xixi(mu,i1,lambda,i) 
      local LX1xjxj(mu,j1,lambda,j) 
      local LX1xixj(mu,i,lambda,j) 
      local L2xixi(mu,i,nu,i1) 
      local L2xjxj(mu,j,nu,j1) 
      local L2xixj(mu,i,nu,j) 
      local L3xipi(mu,i,a,i1) 
      local L3xjqj(mu,j,b,j1) 
      local L3xiqj(mu,i,b,j) 
#
# Declare temporary arrays. 
# ------------------------- 
#
     temp Txxxp(mu,nu,lambda,p) 
     temp T1xxxp(mu,nu,lambda,p) 
     temp Txxpp(mu,nu,p1,p) 
     temp T1xxpp(mu,nu,p1,p) 
     temp Txppp(mu,p2,p1,p) 
     temp T1xppp(mu,p2,p1,p) 
     temp Tpppp(p3,p2,p1,p) 
     temp T1pppp(p3,p2,p1,p) 
     temp T2pppp(p3,p2,p1,p) 
     temp T3pppp(p3,p2,p1,p) 
#
     temp Txxxq(mu,nu,lambda,q) 
     temp T1xxxq(mu,nu,lambda,q) 
     temp Txxqq(mu,nu,q1,q) 
     temp T1xxqq(mu,nu,q1,q) 
     temp Txqqq(mu,q2,q1,q) 
     temp T1xqqq(mu,q2,q1,q) 
     temp Tqqqq(q3,q2,q1,q) 
     temp T1qqqq(q3,q2,q1,q) 
     temp T2qqqq(q3,q2,q1,q) 
     temp T3qqqq(q3,q2,q1,q) 
#
     temp Txpqq(mu,p,q1,q) 
     temp T1xpqq(mu,p,q1,q) 
     temp Tppqq(p1,p,q1,q) 
     temp T1ppqq(p1,p,q1,q) 
     temp T2ppqq(p1,p,q1,q) 
     temp Tqqpp(q,q1,p,p1) 
     temp T1qqpp(q,q1,p,p1) 
     temp T2qqpp(q,q1,p,p1) 
#
     temp Taiai(a,i,a1,i1) 
     temp T1aiai(a,i,a1,i1) 
     temp T2aiai(a,i,a1,i1) 
     temp T3aiai(a,i,a1,i1) 
     temp T4aiai(a,i,a1,i1) 
     temp Tbjbj(b,j,b1,j1) 
     temp T1bjbj(b,j,b1,j1) 
     temp T2bjbj(b,j,b1,j1) 
     temp T3bjbj(b,j,b1,j1) 
     temp T4bjbj(b,j,b1,j1) 
     temp Taibj(a,i,b,j) 
     temp T1aibj(a,i,b,j) 
     temp T2aibj(a,i,b,j) 
#
     temp Taiii(a,i,i1,i2)  
     temp T1aiii(a,i,i1,i2) 
     temp Taijj(a,i,j1,j) 
     temp T1aijj(a,i,j1,j) 
     temp Tbjjj(b,j,j2,j1)  
     temp T1bjjj(b,j,j2,j1) 
     temp Tiibj(i1,i,b,j)  
     temp T1iibj(i1,i,b,j) 
#
     temp Txiai(mu,i,a1,i1)
     temp T1xiai(mu,i,a1,i1)
     temp Txjbj(mu,j,b1,j1) 
     temp T1xjbj(mu,j,b1,j1) 
     temp Txibj(mu,i,b,j) 
     temp T1xibj(mu,i,b,j) 
     temp Txxxx(mu,lambda,nu,sigma) 
     temp Txxpi(mu,nu,p,i) 
     temp Txxqj(mu,nu,q,j) 
     temp Txppi(mu,p1,p,i) 
     temp Txqqj(mu,q1,q,j) 
     temp Txqpi(mu,q,p,i) 
     temp Txpqj(mu,p,q,j) 
     temp Tpppi(p,p1,p2,i) 
     temp Tqqqj(q,q1,q2,j) 
     temp Tppqj(p,p1,q,j) 
     temp Tqqpi(q,q1,p,i) 
#
     temp T1pppi(p,p1,p2,i) 
     temp T1qqqj(q,q1,q2,j) 
     temp T1ppqj(p,p1,q,j) 
     temp T1qqpi(q,q1,p,i) 
#
     temp Tii(i,i1) 
     temp T1ii(i,i1) 
     temp Tjj(j,j1) 
     temp T1jj(j,j1) 
     temp Taa(a,a1) 
     temp T1aa(a,a1) 
     temp Tbb(b,b1) 
     temp T1bb(b,b1) 
     temp Tai(a,i) 
     temp T1ai(a,i) 
     temp T2ai(a,i) 
     temp T3ai(a,i) 
     temp T4ai(a,i) 
     temp Tbj(b,j)
     temp T1bj(b,j)
     temp T2bj(b,j)
     temp T3bj(b,j)
     temp T4bj(b,j)
     temp Tia(i,a) 
     temp T1ia(i,a) 
     temp Tjb(j,b) 
     temp T1jb(j,b) 
     temp Txi(mu,i) 
     temp T1xi(mu,i) 
     temp Txj(mu,j) 
     temp T1xj(mu,j) 
     temp Txx(mu,nu) 
     temp Txa(mu,a) 
     temp Txb(mu,b) 
     temp tpp(p,p1) 
     temp t1pp(p,p1) 
     temp t2pp(p,p1) 
     temp t3pp(p,p1) 
     temp t4pp(p,p1) 
     temp tqq(q,q1) 
     temp t1qq(q,q1) 
     temp t2qq(q,q1) 
     temp t3qq(q,q1) 
     temp tpi(p,i) 
     temp t1pi(p,i) 
     temp tqj(q,j) 
     temp t1qj(q,j) 
#
     temp t1xx(mu,nu) 
     temp t2xx(mu,nu) 
     temp t3xx(mu,nu) 
     temp t4xx(mu,nu) 
     temp t5xx(mu,nu) 
     temp t6xx(mu,nu) 
     temp t7xx(mu,nu) 
     temp t8xx(mu,nu) 
     temp t9xx(mu,nu) 
     temp tpx(p,mu) 
     temp t1px(p,mu) 
     temp tqx(q,mu) 
     temp t1qx(q,mu) 
     temp txp(mu,p) 
     temp t1xp(mu,p) 
     temp txq(mu,q) 
     temp t1xq(mu,q) 
     temp tax(a,sigma) 
     temp tbx(b,sigma) 
#
# Declare local arrays. 
# --------------------- 

     temp daoint(mu,nu,lambda,sigma)
     temp faoint(mu,nu,lambda,sigma)
     temp D2(mu,lambda,nu,sigma)  
     local L1xxxp(mu,nu,lambda,p) 
     local L1xxxq(mu,nu,lambda,q) 
     local Lxxpp(mu,nu,p1,p) 
     local Lxxqq(mu,nu,q1,q) 
     local Lxppp(mu,p2,p1,p) 
     local Lxqqq(mu,q2,q1,q) 
     local Lxpqq(mu,p,q1,q) 
#
     local L1aiai(a,i2,a1,i1) 
     local L1aibj(a,i2,b,j) 
     local L1bjai(b,j2,a,i) 
     local L1bjbj(b,j2,b1,j1) 
     local L2aiai(a2,i,a1,i1) 
     local L2aibj(a1,i,b,j) 
     local L2bjbj(b2,j,b1,j1) 
     local L2bjai(b1,j,a,i) 
     local Dxxxi(mu,lambda,nu,i) 
     local Dxxxj(mu,lambda,nu,j) 
     local Exxpi(mu,lambda,p,i) 
     local Exxqj(mu,lambda,q,j) 
     local Fxppi(mu,p1,p,i) 
     local Fxqpi(mu,q,p,i) 
     local Fxqqj(mu,q1,q,j) 
     local Fxpqj(mu,p,q,j) 
     local Fpppi(p2,p1,p,i) 
     local Fqqqj(q2,q1,q,j) 
     local Fqqpi(q1,q,p,i) 
     local Fppqj(p1,p,q,j) 
#
     distributed zeta_a(p,p1) 
     distributed zeta_b(q,q1) 
     distributed zeta(mu,nu)  
#
# One-particle arrays used in 'NEW' implimentation. 
# ------------------------------------------------- 
#
#
     distributed VYaibj(a,i,b,j) 
     distributed VYaajj(a,a1,j1,j)
     distributed VYbbii(b,b1,i1,i)
     distributed VYiabj(i,a,b,j) 
     distributed VYbbai(b1,b,a,i)
     distributed VYaabj(a1,a,b,j) 
     distributed VYiijj(i,i1,j,j1)
     distributed VYiibj(i,i1,b,j) 
     distributed VYjjai(j,j1,a,i)  
#
     distributed VYaiai(a,i,a1,i1) 
     distributed VYaaii(a,a1,i,i1) 
     distributed VYiaai(i,a1,a,i1) 
     distributed VYaaai(a2,a,a1,i) 
     distributed VYiiii(i,i2,i1,i3)
     distributed VYaiii(a,i2,i,i1) 
#
     distributed VYbjbj(b,j,b1,j1) 
     distributed VYbbjj(b,b1,j,j1) 
     distributed VYjbbj(j,b1,b,j1) 
     distributed VYbbbj(b2,b,b1,j) 
     distributed VYjjjj(j,j2,j1,j3)
     distributed VYbjjj(b,j2,j,j1) 
#
# Arrays and scalars  used in iterative computation of Dai
# --------------------------------------------------------
#
      distributed Doldai_a(a,i)
      distributed Dnewai_a(a,i)
      distributed Doldai_b(b,j)
      distributed Dnewai_b(b,j)
#
      distributed D0ai(a,i)
      distributed D1ai(a,i)
      distributed D2ai(a,i)
      distributed D3ai(a,i)
      distributed D4ai(a,i)
#
      distributed D0bj(b,j)
      distributed D1bj(b,j)
      distributed D2bj(b,j)
      distributed D3bj(b,j)
      distributed D4bj(b,j)
#
      distributed e1ai(a,i)
      distributed e2ai(a,i)
      distributed e3ai(a,i)
      distributed e4ai(a,i)
      distributed e5ai(a,i)
#
      distributed e1bj(b,j)
      distributed e2bj(b,j)
      distributed e3bj(b,j)
      distributed e4bj(b,j)
      distributed e5bj(b,j)
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510
#
       scalar b66
       scalar b67
       scalar b68
       scalar b69
       scalar b610
#
       scalar b77
       scalar b78
       scalar b79
       scalar b710
#
       scalar b88
       scalar b89
       scalar b810
#
       scalar b99
       scalar b910
#
       scalar b1010
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510
#
       scalar Tb66
       scalar Tb67
       scalar Tb68
       scalar Tb69
       scalar Tb610
#
       scalar Tb77
       scalar Tb78
       scalar Tb79
       scalar Tb710
#
       scalar Tb88
       scalar Tb89
       scalar Tb810
#
       scalar Tb99
       scalar Tb910
#
       scalar Tb1010
#
       scalar c1
       scalar c2
       scalar c3
       scalar c4
       scalar c5
       scalar c6
       scalar c7
       scalar c8
       scalar c9
       scalar c10
#
# Arrays used in 'direct' computation of Vabcd terms. 
# ---------------------------------------------------
#
     served TAO_aa(lambda,i,sigma,i1)
     served TAO_bb(lambda,j,sigma,j1)
     served TAO_ab(lambda,i,sigma,j)
     served T1AO_aa(lambda,i,a,i1)
     served T1AO_bb(lambda,j,b,j1)
     served T1AO_ab(lambda,i,b,j)
     served T2AO_aa(lambda,i,sigma,i1)
     served T2AO_bb(lambda,j,sigma,j1)
     served T2AO_ab(lambda,i,sigma,j)
     served VT_aa(a,i,a1,i1) 
     served VT_ab(a,i,b,j) 
     served VT_bb(b,j,b1,j1) 
     distributed VD_aa(mu,nu) 
     distributed VDX_aa(mu,nu) 
     distributed VD_bb(mu,nu) 
     distributed VDX_bb(mu,nu) 
     distributed D_aa(mu,nu) 
     distributed D_bb(mu,nu) 
     distributed VDD_aa(a,a1) 
     distributed VDD_bb(b,b1) 
     distributed VXX_aa(a,a1) 
     distributed VXX_bb(b,b1) 
     local LLaiai(a,i,a1,i1) 
     local LLbjbj(b,j,b1,j1) 
     local LLaibj(a,i,b,j) 
     local Lxiai(lambda,i,a1,i1) 
     local Lxjbj(lambda,j,b1,j1) 
     local Lxibj(lambda,i,b,j) 
     local L1xixi(mu,i,nu,i1) 
     local L1xixj(mu,i,nu,j) 
     local L1xjxj(mu,j,nu,j1) 
     temp  Taixi(a,i,nu,i1) 
     temp  T1aixi(a,i,nu,i1) 
     temp  Tbjxj(b,j,nu,j1) 
     temp  T1bjxj(b,j,nu,j1) 
     temp  Taixj(a,i,nu,j) 
     temp  T1aixj(a,i,nu,j) 
#
# Declare scalars. 
# ---------------- 
#
     scalar eold  
     scalar enew 
     scalar ecrit 
     scalar esum 
     scalar etemp 
     scalar ediff 
     scalar ecorra 
     scalar ecorrb 
     scalar ecorraa 
     scalar ecorrbb 
     scalar ecorrab 
     scalar ecorrT 
     scalar hessxy 
     scalar phessxy 
     scalar hessyx 
     scalar phessyx 
     scalar doit  
     scalar dcrit   
#
#    ------------------------------------------------------------------------
#
#    Perform the first two stages of the transformation in two N5 steps.
#
     PROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
#
          allocate taoint(mu,nu,lambda,*)
#
          DO sigma
#
             compute_integrals            saoint(mu,nu,lambda,sigma)
             taoint(mu,nu,lambda,sigma) = saoint(mu,nu,lambda,sigma)
#
          ENDDO sigma
#
          DO i
#
             Txxxi(mu,nu,lambda,i) = 0.0
#
              DO sigma
#
                 T1xxxi(mu,nu,lambda,i)  = taoint(mu,nu,lambda,sigma)*ca(sigma,i)
                 Txxxi(mu,nu,lambda,i)  += T1xxxi(mu,nu,lambda,i)
#
              ENDDO sigma
#
              PREPARE Vxxxi(mu,nu,lambda,i)  = Txxxi(mu,nu,lambda,i)
#
          ENDDO i
#
          DO j
#
             Txxxj(mu,nu,lambda,j) = 0.0
#
              DO sigma
#
                 T1xxxj(mu,nu,lambda,j)  = taoint(mu,nu,lambda,sigma)*cb(sigma,j)
                 Txxxj(mu,nu,lambda,j)  += T1xxxj(mu,nu,lambda,j)
#
              ENDDO sigma
#
              PREPARE Vxxxj(mu,nu,lambda,j)  = Txxxj(mu,nu,lambda,j)
#
          ENDDO j
#
          deallocate taoint(mu,nu,lambda,*)
#
     ENDPARDO mu, nu, lambda
#
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
           allocate L1xxxi(mu,nu,*,i)
#
           DO lambda
#
              REQUEST                  Vxxxi(mu,nu,lambda,i) i
              L1xxxi(mu,nu,lambda,i) = Vxxxi(mu,nu,lambda,i)
#
           ENDDO lambda
#
           DO i1
#
              Txxii(mu,nu,i1,i) = 0.0
#
              DO lambda
#
                 T1xxii(mu,nu,i1,i) = L1xxxi(mu,nu,lambda,i)*ca(lambda,i1)
                 Txxii(mu,nu,i1,i) += T1xxii(mu,nu,i1,i)
#
              ENDDO lambda
#
              PREPARE Vxxii(mu,nu,i1,i) = Txxii(mu,nu,i1,i)
#
           ENDDO i1
#
           DO a
#
              Txxai(mu,nu,a,i) = 0.0
#
              DO lambda
#
                 T1xxai(mu,nu,a,i) = L1xxxi(mu,nu,lambda,i)*ca(lambda,a)
                 Txxai(mu,nu,a,i) += T1xxai(mu,nu,a,i)
#
              ENDDO lambda
#
              PREPARE Vxxai(mu,nu,a,i) = Txxai(mu,nu,a,i)
#
           ENDDO a
#
           deallocate L1xxxi(mu,nu,*,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
           allocate L2xxxi(mu,*,nu,i)
#
           DO lambda
#
              REQUEST                  Vxxxi(mu,lambda,nu,i) i
              L2xxxi(mu,lambda,nu,i) = Vxxxi(mu,lambda,nu,i)
#
           ENDDO lambda
#
           DO i1
#
              Txixi(mu,i1,nu,i) = 0.0
#
              DO lambda
#
                 T1xixi(mu,i1,nu,i) = L2xxxi(mu,lambda,nu,i)*ca(lambda,i1)
                 Txixi(mu,i1,nu,i) += T1xixi(mu,i1,nu,i)
#
              ENDDO lambda
#
              PREPARE Sxixi(mu,i1,nu,i) = Txixi(mu,i1,nu,i)
#
           ENDDO i1
#
           deallocate L2xxxi(mu,*,nu,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
           allocate L3xxxi(*,mu,nu,i)
#
           DO lambda
#
              REQUEST                  Vxxxi(lambda,mu,nu,i) i
              L3xxxi(lambda,mu,nu,i) = Vxxxi(lambda,mu,nu,i)
#
           ENDDO lambda
#
           DO i1
#
              Tixxi(i1,mu,nu,i) = 0.0
#
              DO lambda
#
                 T1ixxi(i1,mu,nu,i) = L3xxxi(lambda,mu,nu,i)*ca(lambda,i1)
                 Tixxi(i1,mu,nu,i) += T1ixxi(i1,mu,nu,i)
#
              ENDDO lambda
#
              PREPARE Vixxi(i1,mu,nu,i) = Tixxi(i1,mu,nu,i)
#
           ENDDO i1
#
           deallocate L3xxxi(*,mu,nu,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, j
#
           allocate L1xxxj(mu,nu,*,j)
#
           DO lambda
#
              REQUEST                  Vxxxj(mu,nu,lambda,j) j
              L1xxxj(mu,nu,lambda,j) = Vxxxj(mu,nu,lambda,j)
#
           ENDDO lambda
#
           DO j1
#
              Txxjj(mu,nu,j1,j) = 0.0
#
              DO lambda
#
                 T1xxjj(mu,nu,j1,j) = L1xxxj(mu,nu,lambda,j)*cb(lambda,j1)
                 Txxjj(mu,nu,j1,j) += T1xxjj(mu,nu,j1,j)
#
              ENDDO lambda
#
              PREPARE Vxxjj(mu,nu,j1,j) = Txxjj(mu,nu,j1,j)
#
           ENDDO j1
#
           DO b
#
              Txxbj(mu,nu,b,j) = 0.0
#
              DO lambda
#
                 T1xxbj(mu,nu,b,j) = L1xxxj(mu,nu,lambda,j)*cb(lambda,b)
                 Txxbj(mu,nu,b,j) += T1xxbj(mu,nu,b,j)
#
              ENDDO lambda
#
              PREPARE Vxxbj(mu,nu,b,j) = Txxbj(mu,nu,b,j)
#
           ENDDO b
#
           DO i
#
              Txxij(mu,nu,i,j) = 0.0
#
              DO lambda
#
                 T1xxij(mu,nu,i,j) = L1xxxj(mu,nu,lambda,j)*ca(lambda,i)
                 Txxij(mu,nu,i,j) += T1xxij(mu,nu,i,j)
#
              ENDDO lambda
#
              PREPARE Vxxij(mu,nu,i,j) = Txxij(mu,nu,i,j)
#
           ENDDO i
#
           deallocate L1xxxj(mu,nu,*,j)
#
     ENDPARDO mu, nu, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, j
#
           allocate L2xxxj(mu,*,nu,j)
#
           DO lambda
#
              REQUEST                  Vxxxj(mu,lambda,nu,j) j
              L2xxxj(mu,lambda,nu,j) = Vxxxj(mu,lambda,nu,j)
#
           ENDDO lambda
#
           DO j1
#
              Txjxj(mu,j1,nu,j) = 0.0
#
              DO lambda
#
                 T1xjxj(mu,j1,nu,j) = L2xxxj(mu,lambda,nu,j)*cb(lambda,j1)
                 Txjxj(mu,j1,nu,j) += T1xjxj(mu,j1,nu,j)
#
              ENDDO lambda
#
              PREPARE Sxjxj(mu,j1,nu,j) = Txjxj(mu,j1,nu,j)
#
           ENDDO j1
#
           DO i
#
              Txixj(mu,i,nu,j) = 0.0
#
              DO lambda
#
                 T1xixj(mu,i,nu,j) = L2xxxj(mu,lambda,nu,j)*ca(lambda,i)
                 Txixj(mu,i,nu,j) += T1xixj(mu,i,nu,j)
#
              ENDDO lambda
#
              PREPARE Sxixj(mu,i,nu,j) = Txixj(mu,i,nu,j)
#
           ENDDO i
#
           deallocate L2xxxj(mu,*,nu,j)
#
     ENDPARDO mu, nu, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, j
#
           allocate L3xxxj(*,mu,nu,j)
#
           DO lambda
#
              REQUEST                  Vxxxj(lambda,mu,nu,j) j
              L3xxxj(lambda,mu,nu,j) = Vxxxj(lambda,mu,nu,j)
#
           ENDDO lambda
#
           DO j1
#
              Tjxxj(j1,mu,nu,j) = 0.0
#
              DO lambda
#
                 T1jxxj(j1,mu,nu,j) = L3xxxj(lambda,mu,nu,j)*cb(lambda,j1)
                 Tjxxj(j1,mu,nu,j) += T1jxxj(j1,mu,nu,j)
#
              ENDDO lambda
#
              PREPARE Vjxxj(j1,mu,nu,j) = Tjxxj(j1,mu,nu,j)
#
           ENDDO j1
#
           DO i
#
              Tixxj(i,mu,nu,j) = 0.0
#
              DO lambda
#
                 T1ixxj(i,mu,nu,j) = L3xxxj(lambda,mu,nu,j)*ca(lambda,i)
                 Tixxj(i,mu,nu,j) += T1ixxj(i,mu,nu,j)
#
              ENDDO lambda
#
              PREPARE Vixxj(i,mu,nu,j) = Tixxj(i,mu,nu,j)
#
           ENDDO i
#
           deallocate L3xxxj(*,mu,nu,j)
#
     ENDPARDO mu, nu, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.
#
     PROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, i1
#
           allocate Lxixi(mu,i,*,i1)
#
           DO nu
#
              REQUEST             Sxixi(mu,i,nu,i1) i1
              Lxixi(mu,i,nu,i1) = Sxixi(mu,i,nu,i1)
#
           ENDDO nu
#
           DO p
#
              Txipi(mu,i,p,i1) = 0.0
#
              DO nu
#
                 T1xipi(mu,i,p,i1) = Lxixi(mu,i,nu,i1)*ca(nu,p)
                 Txipi(mu,i,p,i1) += T1xipi(mu,i,p,i1)
#
              ENDDO nu
#
              PREPARE Vxipi(mu,i,p,i1) = Txipi(mu,i,p,i1)
#
           ENDDO p
#
           deallocate Lxixi(mu,i,*,i1)
#
     ENDPARDO mu, i, i1
#
#    ------------------------------------------------------------------------
#
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, i1
#
           allocate Lxxii(mu,*,i,i1)
#
           DO nu
#
              REQUEST             Vxxii(mu,nu,i,i1) i1
              Lxxii(mu,nu,i,i1) = Vxxii(mu,nu,i,i1)
#
           ENDDO nu
#
           DO a
#
              Txaii(mu,a,i,i1) = 0.0
#
              DO nu
#
                 T1xaii(mu,a,i,i1) = Lxxii(mu,nu,i,i1)*ca(nu,a)
                 Txaii(mu,a,i,i1) += T1xaii(mu,a,i,i1)

              ENDDO nu
#
              PREPARE Vxaii(mu,a,i,i1) = Txaii(mu,a,i,i1)
#
           ENDDO a
#
           DO b
#
              Txbii(mu,b,i,i1) = 0.0
#
              DO nu
#
                 T1xbii(mu,b,i,i1) = Lxxii(mu,nu,i,i1)*cb(nu,b)
                 Txbii(mu,b,i,i1) += T1xbii(mu,b,i,i1)
#
              ENDDO nu
#
              PREPARE Vxbii(mu,b,i,i1) = Txbii(mu,b,i,i1)
#
           ENDDO b
#
           deallocate Lxxii(mu,*,i,i1)
#
     ENDPARDO mu, i, i1
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, i1
#
           allocate Lixxi(i,mu,*,i1)
#
           DO nu
#
              REQUEST             Vixxi(i,mu,nu,i1) i1
              Lixxi(i,mu,nu,i1) = Vixxi(i,mu,nu,i1)
#
           ENDDO nu
#
           DO a
#
              Tixai(i,mu,a,i1) = 0.0
#
              DO nu
#
                 T1ixai(i,mu,a,i1) = Lixxi(i,mu,nu,i1)*ca(nu,a)
                 Tixai(i,mu,a,i1) += T1ixai(i,mu,a,i1)

              ENDDO nu
#
              PREPARE Vixai(i,mu,a,i1) = Tixai(i,mu,a,i1)
#
           ENDDO a
#
           deallocate Lixxi(i,mu,*,i1)
#
     ENDPARDO mu, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, a, i
#
           allocate Lxxai(mu,*,a,i)
#
           DO nu
#
              REQUEST Vxxai(mu,nu,a,i) i
              Lxxai(mu,nu,a,i) = Vxxai(mu,nu,a,i)
#
           ENDDO nu
#
           DO a1
#
              Txaai(mu,a1,a,i) = 0.0
#
              DO nu
#
                 T1xaai(mu,a1,a,i) = Lxxai(mu,nu,a,i)*ca(nu,a1)
                 Txaai(mu,a1,a,i) += T1xaai(mu,a1,a,i)
#
              ENDDO nu
#
              PREPARE Vxaai(mu,a1,a,i) = Txaai(mu,a1,a,i)
#
           ENDDO a1
#
           DO b
#
              Txbai(mu,b,a,i) = 0.0
#
              DO nu
#
                 T1xbai(mu,b,a,i) = Lxxai(mu,nu,a,i)*cb(nu,b)
                 Txbai(mu,b,a,i) += T1xbai(mu,b,a,i)
#
              ENDDO nu
#
              PREPARE Vxbai(mu,b,a,i) = Txbai(mu,b,a,i)
#
           ENDDO b
#
           deallocate Lxxai(mu,*,a,i)
#
     ENDPARDO mu, a, i
#
#    ------------------------------------------------------------------------
#
     PARDO mu, j, j1
#
           allocate Lxjxj(mu,j,*,j1)
#
           DO nu
#
              REQUEST             Sxjxj(mu,j,nu,j1) j1
              Lxjxj(mu,j,nu,j1) = Sxjxj(mu,j,nu,j1)
#
           ENDDO nu
#
           DO q
#
              Txjqj(mu,j,q,j1) = 0.0
#
              DO nu
#
                 T1xjqj(mu,j,q,j1) = Lxjxj(mu,j,nu,j1)*cb(nu,q)
                 Txjqj(mu,j,q,j1) += T1xjqj(mu,j,q,j1)
#
              ENDDO nu
#
              PREPARE Vxjqj(mu,j,q,j1) = Txjqj(mu,j,q,j1)
#
           ENDDO q
#
           deallocate Lxjxj(mu,j,*,j1)
#
     ENDPARDO mu, j, j1
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PARDO mu, j, j1
#
           allocate Lxxjj(mu,*,j,j1)
#
           DO nu
#
              REQUEST             Vxxjj(mu,nu,j,j1) j1
              Lxxjj(mu,nu,j,j1) = Vxxjj(mu,nu,j,j1)
#
           ENDDO nu
#
           DO b
#
              Txbjj(mu,b,j,j1) = 0.0
#
              DO nu
#
                 T1xbjj(mu,b,j,j1) = Lxxjj(mu,nu,j,j1)*cb(nu,b)
                 Txbjj(mu,b,j,j1) += T1xbjj(mu,b,j,j1)
#
              ENDDO nu
#
              PREPARE Vxbjj(mu,b,j,j1) = Txbjj(mu,b,j,j1)
#
           ENDDO b
#
           DO a
#
              Txajj(mu,a,j,j1) = 0.0
#
              DO nu
#
                 T1xajj(mu,a,j,j1) = Lxxjj(mu,nu,j,j1)*ca(nu,a)
                 Txajj(mu,a,j,j1) += T1xajj(mu,a,j,j1)
#
              ENDDO nu
#
              PREPARE Vxajj(mu,a,j,j1) = Txajj(mu,a,j,j1)
#
           ENDDO a
#
           deallocate Lxxjj(mu,*,j,j1)
#
     ENDPARDO mu, j, j1
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PARDO mu, j, j1
#
           allocate Ljxxj(j,mu,*,j1)
#
           DO nu
#
              REQUEST             Vjxxj(j,mu,nu,j1) j1
              Ljxxj(j,mu,nu,j1) = Vjxxj(j,mu,nu,j1)
#
           ENDDO nu
#
           DO b
#
              Tjxbj(j,mu,b,j1) = 0.0
#
              DO nu
#
                 T1jxbj(j,mu,b,j1) = Ljxxj(j,mu,nu,j1)*cb(nu,b)
                 Tjxbj(j,mu,b,j1) += T1jxbj(j,mu,b,j1)

              ENDDO nu
#
              PREPARE Vjxbj(j,mu,b,j1) = Tjxbj(j,mu,b,j1)
#
           ENDDO b
#
           deallocate Ljxxj(j,mu,*,j1)
#
     ENDPARDO mu, j, j1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, b, j
#
           allocate Lxxbj(mu,*,b,j)
#
           DO nu
#
              REQUEST Vxxbj(mu,nu,b,j) j
              Lxxbj(mu,nu,b,j) = Vxxbj(mu,nu,b,j)
#
           ENDDO nu
#
           DO b1
#
              Txbbj(mu,b1,b,j) = 0.0
#
              DO nu
#
                 T1xbbj(mu,b1,b,j) = Lxxbj(mu,nu,b,j)*cb(nu,b1)
                 Txbbj(mu,b1,b,j) += T1xbbj(mu,b1,b,j)
#
              ENDDO nu
#
              PREPARE Vxbbj(mu,b1,b,j) = Txbbj(mu,b1,b,j)
#
           ENDDO b1
#
           DO a
#
              Txabj(mu,a,b,j) = 0.0
#
              DO nu
#
                 T1xabj(mu,a,b,j) = Lxxbj(mu,nu,b,j)*ca(nu,a)
                 Txabj(mu,a,b,j) += T1xabj(mu,a,b,j)
#
              ENDDO nu
#
              PREPARE Vxabj(mu,a,b,j) = Txabj(mu,a,b,j)
#
           ENDDO a
#
           deallocate Lxxbj(mu,*,b,j)
#
     ENDPARDO mu, b, j
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, j
#
           allocate Lxixj(mu,i,*,j)
#
           DO nu
#
              REQUEST            Sxixj(mu,i,nu,j) j
              Lxixj(mu,i,nu,j) = Sxixj(mu,i,nu,j)
#
           ENDDO nu
#
           DO q
#
              Txiqj(mu,i,q,j) = 0.0
#
              DO nu
#
                 T1xiqj(mu,i,q,j) = Lxixj(mu,i,nu,j)*cb(nu,q)
                 Txiqj(mu,i,q,j) += T1xiqj(mu,i,q,j)
#
              ENDDO nu
#
              PREPARE Vxiqj(mu,i,q,j) = Txiqj(mu,i,q,j)
#
           ENDDO q
#
           deallocate Lxixj(mu,i,*,j)
#
     ENDPARDO mu, i, j
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, j
#
           allocate Lixxj(i,mu,*,j)
#
           DO nu
#
              REQUEST            Vixxj(i,mu,nu,j) j
              Lixxj(i,mu,nu,j) = Vixxj(i,mu,nu,j)
#
           ENDDO nu
#
           DO b
#
              Tixbj(i,mu,b,j) = 0.0
#
              DO nu
#
                 T1ixbj(i,mu,b,j) = Lixxj(i,mu,nu,j)*cb(nu,b)
                 Tixbj(i,mu,b,j) += T1ixbj(i,mu,b,j)
#
              ENDDO nu
#
              PREPARE Vixbj(i,mu,b,j) = Tixbj(i,mu,b,j)
#
           ENDDO b
#
           deallocate Lixxj(i,mu,*,j)
#
     ENDPARDO mu, i, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
#
     ENDPROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PARDO p, i, i1
#
           allocate Lxipi(*,i,p,i1) 
#
           DO mu 
#
              REQUEST             Vxipi(mu,i,p,i1) i1 
              REQUEST             Vxipi(mu,i1,p,i) i
              Lxipi(mu,i,p,i1)  = Vxipi(mu,i,p,i1)
              Txipi(mu,i,p,i1)  = Vxipi(mu,i1,p,i)
              Lxipi(mu,i,p,i1) -= Txipi(mu,i,p,i1)
#
           ENDDO mu
#
           DO p1
#
              Tpipi(p1,i,p,i1) = 0.0
#
              DO mu
#
                 T1pipi(p1,i,p,i1) = Lxipi(mu,i,p,i1)*ca(mu,p1)
                 Tpipi(p1,i,p,i1) += T1pipi(p1,i,p,i1)
#
              ENDDO mu
#
              PREPARE VSpipi(p1,i,p,i1) = Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
           deallocate Lxipi(*,i,p,i1)
#
     ENDPARDO p, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO a, i, i1
#
           allocate Lxaii(*,a,i,i1)
#
           DO mu
#
              REQUEST            Vxaii(mu,a,i,i1) i1
              Lxaii(mu,a,i,i1) = Vxaii(mu,a,i,i1)
#
           ENDDO mu
#
           DO a1
#
              Taaii(a1,a,i,i1) = 0.0
#
              DO mu
#
                 T1aaii(a1,a,i,i1) = Lxaii(mu,a,i,i1)*ca(mu,a1)
                 Taaii(a1,a,i,i1) += T1aaii(a1,a,i,i1)
#
              ENDDO mu
#
              PREPARE Vaaii(a1,a,i,i1) = Taaii(a1,a,i,i1)
#
           ENDDO a1
#
           deallocate Lxaii(*,a,i,i1)
#
     ENDPARDO a, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO a, i, i1
#
           allocate Lixai(i,*,a,i1)
#
           DO mu
#
              REQUEST            Vixai(i,mu,a,i1) i1
              Lixai(i,mu,a,i1) = Vixai(i,mu,a,i1)
#
           ENDDO mu
#
           DO a1
#
              Tiaai(i,a1,a,i1) = 0.0
#
              DO mu
#
                 T1iaai(i,a1,a,i1) = Lixai(i,mu,a,i1)*ca(mu,a1)
                 Tiaai(i,a1,a,i1) += T1iaai(i,a1,a,i1)
#
              ENDDO mu
#
              PREPARE Viaai(i,a1,a,i1) = Tiaai(i,a1,a,i1)
#
           ENDDO a1
#
           deallocate Lixai(i,*,a,i1)
#
     ENDPARDO a, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO a, a1, i
#
           allocate L1xaai(*,a,a1,i)
#
           DO mu
#
              REQUEST              Vxaai(mu,a,a1,i) i
              L1xaai(mu,a,a1,i)  = Vxaai(mu,a,a1,i)
#
           ENDDO mu
#
           DO a2
#
              Taaai(a2,a,a1,i) = 0.0
#
              DO mu
#
                 T1aaai(a2,a,a1,i) = L1xaai(mu,a,a1,i)*ca(mu,a2)
                 Taaai(a2,a,a1,i) += T1aaai(a2,a,a1,i)
#
              ENDDO mu
#
              T1aaai(a1,a,a2,i)           = Taaai(a2,a,a1,i)
              T1aaai(a1,a,a2,i)          *= -1.0
              PREPARE VSaaai(a2,a,a1,i)  += Taaai(a2,a,a1,i)
              PREPARE VSaaai(a1,a,a2,i)  += T1aaai(a1,a,a2,i)
#
           ENDDO a2
#
           deallocate L1xaai(*,a,a1,i)
#
     ENDPARDO a, a1, i
#
#    ------------------------------------------------------------------------
#
     PARDO q, j, j1
#
           allocate Lxjqj(*,j,q,j1)
#
           DO mu
#
              REQUEST             Vxjqj(mu,j,q,j1) j1
              REQUEST             Vxjqj(mu,j1,q,j) j1
              Lxjqj(mu,j,q,j1)  = Vxjqj(mu,j,q,j1)
              Txjqj(mu,j,q,j1)  = Vxjqj(mu,j1,q,j)
              Lxjqj(mu,j,q,j1) -= Txjqj(mu,j,q,j1)
#
           ENDDO mu
#
           DO q1
#
              Tqjqj(q1,j,q,j1) = 0.0
#
              DO mu
#
                 T1qjqj(q1,j,q,j1)      = Lxjqj(mu,j,q,j1)*cb(mu,q1)
                 Tqjqj(q1,j,q,j1)      += T1qjqj(q1,j,q,j1)
#
              ENDDO mu
#
              PREPARE VSqjqj(q1,j,q,j1) = Tqjqj(q1,j,q,j1)
#
           ENDDO q1
#
           deallocate Lxjqj(*,j,q,j1)
#
     ENDPARDO q, j, j1
#
#    ------------------------------------------------------------------------
#
     PARDO b, j, j1
#
           allocate Lxbjj(*,b,j,j1)
#
           DO mu
#
              REQUEST            Vxbjj(mu,b,j,j1) j1
              Lxbjj(mu,b,j,j1) = Vxbjj(mu,b,j,j1)
#
           ENDDO mu
#
           DO b1
#
              Tbbjj(b1,b,j,j1) = 0.0
#
              DO mu
#
                 T1bbjj(b1,b,j,j1) = Lxbjj(mu,b,j,j1)*cb(mu,b1)
                 Tbbjj(b1,b,j,j1) += T1bbjj(b1,b,j,j1)
#
              ENDDO mu
#
              PREPARE Vbbjj(b1,b,j,j1) = Tbbjj(b1,b,j,j1)
#
           ENDDO b1
#
           deallocate Lxbjj(*,b,j,j1)
#
     ENDPARDO b, j, j1
#
#    ------------------------------------------------------------------------
#
     PARDO b, j, j1
#
           allocate Ljxbj(j,*,b,j1)
#
           DO mu
#
              REQUEST            Vjxbj(j,mu,b,j1) j1
              Ljxbj(j,mu,b,j1) = Vjxbj(j,mu,b,j1)
#
           ENDDO mu
#
           DO b1
#
              Tjbbj(j,b1,b,j1) = 0.0
#
              DO mu
#
                 T1jbbj(j,b1,b,j1) = Ljxbj(j,mu,b,j1)*cb(mu,b1)
                 Tjbbj(j,b1,b,j1) += T1jbbj(j,b1,b,j1)
#
              ENDDO mu
#
              PREPARE Vjbbj(j,b1,b,j1) = Tjbbj(j,b1,b,j1)
#
           ENDDO b1
#
           deallocate Ljxbj(j,*,b,j1)
#
     ENDPARDO b, j, j1
#
#    ------------------------------------------------------------------------
#
     PARDO b, b1, j
#
           allocate L1xbbj(*,b,b1,j)
#
           DO mu
#
              REQUEST              Vxbbj(mu,b,b1,j) j
              L1xbbj(mu,b,b1,j)  = Vxbbj(mu,b,b1,j)
#
           ENDDO mu
#
           DO b2
#
              Tbbbj(b2,b,b1,j) = 0.0
#
              DO mu
#
                 T1bbbj(b2,b,b1,j) = L1xbbj(mu,b,b1,j)*cb(mu,b2)
                 Tbbbj(b2,b,b1,j) += T1bbbj(b2,b,b1,j)
#
              ENDDO mu
#
              T1bbbj(b1,b,b2,j)           = Tbbbj(b2,b,b1,j)
              T1bbbj(b1,b,b2,j)          *= -1.0
              PREPARE VSbbbj(b2,b,b1,j)  += Tbbbj(b2,b,b1,j)
              PREPARE VSbbbj(b1,b,b2,j)  += T1bbbj(b1,b,b2,j)
#
           ENDDO b2
#
           deallocate L1xbbj(*,b,b1,j)
#
     ENDPARDO b, b1, j
#
#    ------------------------------------------------------------------------
#
     PARDO b, i, i1
#
           allocate Lxbii(*,b,i,i1)
#
           DO mu
#
              REQUEST            Vxbii(mu,b,i,i1) i1
              Lxbii(mu,b,i,i1) = Vxbii(mu,b,i,i1)
#
           ENDDO mu
#
           DO b1
#
              Tbbii(b1,b,i,i1) = 0.0
#
              DO mu
#
                 T1bbii(b1,b,i,i1) = Lxbii(mu,b,i,i1)*cb(mu,b1)
                 Tbbii(b1,b,i,i1) += T1bbii(b1,b,i,i1)
#
              ENDDO mu
#
              PREPARE Vbbii(b1,b,i,i1) = Tbbii(b1,b,i,i1)
#
           ENDDO b1
#
           deallocate Lxbii(*,b,i,i1)
#
     ENDPARDO b, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO b, i, i1
#
           allocate Lxbii(*,b,i,i1)
#
           DO mu
#
              REQUEST            Vxbii(mu,b,i,i1) i1
              Lxbii(mu,b,i,i1) = Vxbii(mu,b,i,i1)
#
           ENDDO mu
#
           DO j
#
              Tjbii(j,b,i,i1) = 0.0
#
              DO mu
#
                 T1jbii(j,b,i,i1) = Lxbii(mu,b,i,i1)*cb(mu,j)
                 Tjbii(j,b,i,i1) += T1jbii(j,b,i,i1)
#
              ENDDO mu
#
              PREPARE Vjbii(j,b,i,i1) = Tjbii(j,b,i,i1)
#
           ENDDO j
#
           deallocate Lxbii(*,b,i,i1)
#
     ENDPARDO b, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO b, a, i
#
           allocate Lxbai(*,b,a,i)
#
           DO mu
#
              REQUEST           Vxbai(mu,b,a,i) i
              Lxbai(mu,b,a,i) = Vxbai(mu,b,a,i)
#
           ENDDO mu
#
           DO b1
#
              Tbbai(b1,b,a,i) = 0.0
#
              DO mu
#
                 T1bbai(b1,b,a,i) = Lxbai(mu,b,a,i)*cb(mu,b1)
                 Tbbai(b1,b,a,i) += T1bbai(b1,b,a,i)
#
              ENDDO mu
#
              PREPARE Vbbai(b1,b,a,i) = Tbbai(b1,b,a,i)
#
           ENDDO b1
#
           deallocate Lxbai(*,b,a,i)
#
     ENDPARDO b, a, i
#
#    ------------------------------------------------------------------------
#
     PARDO q, i, j
#
           allocate Lxiqj(*,i,q,j)
#
           DO mu
#
              REQUEST           Vxiqj(mu,i,q,j) j
              Lxiqj(mu,i,q,j) = Vxiqj(mu,i,q,j)
#
           ENDDO mu
#
           DO p
#
              Tpiqj(p,i,q,j) = 0.0
#
              DO mu
#
                 T1piqj(p,i,q,j) = Lxiqj(mu,i,q,j)*ca(mu,p)
                 Tpiqj(p,i,q,j) += T1piqj(p,i,q,j)
#
              ENDDO mu
#
              PREPARE Vpiqj(p,i,q,j) = Tpiqj(p,i,q,j)
#
           ENDDO p
#
           deallocate Lxiqj(*,i,q,j)
#
     ENDPARDO q, i, j
#
#    ------------------------------------------------------------------------
#
     PARDO a, j, j1
#
           allocate Lxajj(*,a,j,j1)
#
           DO mu
#
              REQUEST            Vxajj(mu,a,j,j1) j1
              Lxajj(mu,a,j,j1) = Vxajj(mu,a,j,j1)
#
           ENDDO mu
#
           DO a1
#
              Taajj(a1,a,j,j1) = 0.0
#
              DO mu
#
                 T1aajj(a1,a,j,j1) = Lxajj(mu,a,j,j1)*ca(mu,a1)
                 Taajj(a1,a,j,j1) += T1aajj(a1,a,j,j1)
#
              ENDDO mu
#
              PREPARE Vaajj(a1,a,j,j1) = Taajj(a1,a,j,j1)
#
           ENDDO a1
#
           deallocate Lxajj(*,a,j,j1)
#
     ENDPARDO a, j, j1
#
#    ------------------------------------------------------------------------
#
     PARDO b, i, j
#
           allocate Lixbj(i,*,b,j)
#
           DO mu
#
              REQUEST           Vixbj(i,mu,b,j) j
              Lixbj(i,mu,b,j) = Vixbj(i,mu,b,j)
#
           ENDDO mu
#
           DO a
#
              Tiabj(i,a,b,j) = 0.0
#
              DO mu
#
                 T1iabj(i,a,b,j) = Lixbj(i,mu,b,j)*ca(mu,a)
                 Tiabj(i,a,b,j) += T1iabj(i,a,b,j)
#
              ENDDO mu
#
              PREPARE Viabj(i,a,b,j) = Tiabj(i,a,b,j)
#
           ENDDO a
#
           deallocate Lixbj(i,*,b,j)
#
     ENDPARDO b, i, j
#
#    ------------------------------------------------------------------------
#
     PARDO a, b, j
#
           allocate Lxabj(*,a,b,j)
#
           DO mu
#
              REQUEST           Vxabj(mu,a,b,j) j
              Lxabj(mu,a,b,j) = Vxabj(mu,a,b,j)
#
           ENDDO mu
#
           DO a1
#
              Taabj(a1,a,b,j) = 0.0
#
              DO mu
#
                 T1aabj(a1,a,b,j) = Lxabj(mu,a,b,j)*ca(mu,a1)
                 Taabj(a1,a,b,j) += T1aabj(a1,a,b,j)
#
              ENDDO mu
#
              PREPARE Vaabj(a1,a,b,j) = Taabj(a1,a,b,j)
#
           ENDDO a1
#
           deallocate Lxabj(*,a,b,j)
#
     ENDPARDO a, b, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier 
#
     ENDPROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Create the distributed two-particle transformed integral arrays.
#
     PROC CREATE_MOINTS
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     ENDPROC CREATE_MOINTS
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF_OLD 
#
         CALL CREATE_MOINTS  # --> create the distributed two-particle
                             #     transformed integral arrays.
         CALL TRAN_TRAN2     # --> performs the first two stages of the
                             #     two-electron integral transformation.
         CALL TRAN_TRAN3     # --> performs the third stage
                             #     two-electron integral transformation.
         CALL TRAN_TRAN4     # --> performs the fourth stage of the
                             #     two-electron integral transformation.
#
     ENDPROC TRAN_UHF_OLD 
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_XXII
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, nu, lambda
#     
           allocate L0xxxi(mu,nu,lambda,*)
           allocate L0xxxj(mu,nu,lambda,*)
#     
           DO sigma
#     
                 compute_integrals AOINT(mu,nu,lambda,sigma)
#
                 DO i
#     
                    V0xxxi(mu,nu,lambda,i) = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                    L0xxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i)
#
                 ENDDO i
#
                 DO j
#     
                    V0xxxj(mu,nu,lambda,j) = AOINT(mu,nu,lambda,sigma)*cb(sigma,j)
                    L0xxxj(mu,nu,lambda,j) += V0xxxj(mu,nu,lambda,j)
#
                 ENDDO j
# 
           ENDDO sigma
#     
           DO i
#     
              txixx(lambda,i,mu,nu) = L0xxxi(mu,nu,lambda,i)
              txxix(nu,mu,i,lambda) = L0xxxi(mu,nu,lambda,i)
#     
              DO i1
#     
                 Txixi(lambda,i,mu,i1)      = txixx(lambda,i,mu,nu)*ca(nu,i1)
                 prepare Vxixi(lambda,i,mu,i1) += Txixi(lambda,i,mu,i1)
#
              ENDDO i1
#     
              DO j1
#     
                 Txixj(lambda,i,mu,j1)      = txixx(lambda,i,mu,nu)*cb(nu,j1)
                 prepare Vxixj(lambda,i,mu,j1) += Txixj(lambda,i,mu,j1)
#
              ENDDO j1
#
              DO i1
#
                 Txxii(nu,mu,i,i1)  = txxix(nu,mu,i,lambda)*ca(lambda,i1)
                 prepare Vxxii(nu,mu,i,i1) += Txxii(nu,mu,i,i1)
#
              ENDDO i1
#
              DO i1
#
                 Tixxi(i1,nu,lambda,i)  = L0xxxi(mu,nu,lambda,i)*ca(mu,i1)
                 prepare Vixxi(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i)
#
              ENDDO i1
#
           ENDDO i
#     
           DO j
#     
              txjxx(lambda,j,mu,nu) = L0xxxj(mu,nu,lambda,j)
              txxjx(nu,mu,j,lambda) = L0xxxj(mu,nu,lambda,j)
#     
              DO j1
#     
                 Txjxj(lambda,j,mu,j1)      = txjxx(lambda,j,mu,nu)*cb(nu,j1)
                 prepare Vxjxj(lambda,j,mu,j1) += Txjxj(lambda,j,mu,j1)
#
              ENDDO j1
#
              DO j1
#
                 Txxjj(nu,mu,j,j1)  = txxjx(nu,mu,j,lambda)*cb(lambda,j1)
                 prepare Vxxjj(nu,mu,j,j1) += Txxjj(nu,mu,j,j1)
#
              ENDDO j1
#
              DO j1
#
                 Tjxxj(j1,nu,lambda,j)  = L0xxxj(mu,nu,lambda,j)*cb(mu,j1)
                 prepare Vjxxj(j1,nu,lambda,j) += Tjxxj(j1,nu,lambda,j)
#
              ENDDO j1
#
           ENDDO j
#     
           DO j
#     
              DO i1
#
                 Tixxj(i1,nu,lambda,j)  = L0xxxj(mu,nu,lambda,j)*ca(mu,i1)
                 prepare Vixxj(i1,nu,lambda,j) += Tixxj(i1,nu,lambda,j)
#
              ENDDO i1
#
           ENDDO j
#
           deallocate L0xxxi(mu,nu,lambda,*)
           deallocate L0xxxj(mu,nu,lambda,*)
#
     ENDPARDO mu, nu, lambda 
#
     execute sip_barrier
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_XXII
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_PIPI
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, i, i1  
#
           allocate Lxipi(mu,i,*,i1) 
#
           DO nu 
#
              REQUEST Vxixi(mu,i,nu,i1) i 
#
              DO p
                 Txipi(mu,i,p,i1)  = Vxixi(mu,i,nu,i1)*ca(nu,p)
                 Lxipi(mu,i,p,i1) += Txipi(mu,i,p,i1)
              ENDDO p
#
           ENDDO nu 
#
           DO p 
#
              PREPARE Vxipi(mu,i,p,i1) = Lxipi(mu,i,p,i1) 
#
           ENDDO p 
#
           deallocate Lxipi(mu,i,*,i1) 
#
     ENDPARDO mu, i, i1
#
     execute sip_barrier
     execute server_barrier
#    discard Vxixi
#
     PARDO p, i, i1
#
           allocate Lpipi(*,i,p,i1) 
#
           DO mu 
#
              REQUEST            Vxipi(mu,i,p,i1) i 
              REQUEST            Vxipi(mu,i1,p,i) i 
              Txipi(mu,i,p,i1) = Vxipi(mu,i1,p,i) 
              Txipi(mu,i,p,i1)-= Vxipi(mu,i,p,i1) 
              Txipi(mu,i,p,i1)*= -1.0  
#
              DO p1
#
                #Tpipi(p1,i,p,i1)   = Vxipi(mu,i,p,i1)*ca(mu,p1)
                #T1pipi(p1,i,p,i1)  = Vxipi(mu,i1,p,i)*ca(mu,p1)
                #Tpipi(p1,i,p,i1)  -= T1pipi(p1,i,p,i1)  
#
                 Tpipi(p1,i,p,i1)   = Txipi(mu,i,p,i1)*ca(mu,p1)
                 Lpipi(p1,i,p,i1)  += Tpipi(p1,i,p,i1) 
#
              ENDDO p1
#
           ENDDO mu 
#
           DO p1 
#
              PREPARE VSpipi(p1,i,p,i1) = Lpipi(p1,i,p,i1) 
#
           ENDDO p1 
#
           deallocate Lpipi(*,i,p,i1) 
#
     ENDPARDO p, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxipi
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_PIPI
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_AAII
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, i, i1
#
           allocate Lxaii(mu,*,i,i1) 
#
           DO nu 
#
              REQUEST Vxxii(mu,nu,i,i1) i
#
              DO a
                 Txaii(mu,a,i,i1)  = Vxxii(mu,nu,i,i1)*ca(nu,a)
                 Lxaii(mu,a,i,i1) += Txaii(mu,a,i,i1)
              ENDDO a
#
           ENDDO nu 
#
           DO a 
#
              PREPARE Vxaii(mu,a,i,i1) = Lxaii(mu,a,i,i1) 
#
           ENDDO a 
#
           deallocate Lxaii(mu,*,i,i1) 
#
     ENDPARDO mu, i, i1
#
     execute sip_barrier
     execute server_barrier
#
     PARDO a, i, i1
#
           allocate Laaii(*,a,i,i1) 
#
           DO mu 
#
              REQUEST Vxaii(mu,a,i,i1) i
#
              DO a1
#
                 Taaii(a1,a,i,i1)  = Vxaii(mu,a,i,i1)*ca(mu,a1)
                 Laaii(a1,a,i,i1) += Taaii(a1,a,i,i1)
#
              ENDDO a1
#
           ENDDO mu 
#
           DO a1 
#
              PREPARE Vaaii(a1,a,i,i1) = Laaii(a1,a,i,i1) 
#
           ENDDO a1 
#
           deallocate Laaii(*,a,i,i1) 
#
     ENDPARDO a, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxaii
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_AAII
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_IAAI
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, i, i1
#
           allocate Lixai(i,mu,*,i1) 
#
           DO nu 
#
              REQUEST Vixxi(i,mu,nu,i1) i 
#
              DO a
#
                 Tixai(i,mu,a,i1)  = Vixxi(i,mu,nu,i1)*ca(nu,a)
                 Lixai(i,mu,a,i1) += Tixai(i,mu,a,i1)
#
              ENDDO a
#
           ENDDO nu 
#
           DO a 
#
              PREPARE Vixai(i,mu,a,i1) = Lixai(i,mu,a,i1)
#
           ENDDO a 
#
           deallocate Lixai(i,mu,*,i1) 
#
     ENDPARDO mu, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vixxi
#
     PARDO a, i, i1
#
           allocate Liaai(i,*,a,i1) 
#
           DO mu 
#
              REQUEST Vixai(i,mu,a,i1) i 
#
              DO a1
#
                 Tiaai(i,a1,a,i1)  = Vixai(i,mu,a,i1)*ca(mu,a1)
                 Liaai(i,a1,a,i1) += Tiaai(i,a1,a,i1)
#
              ENDDO a1
#
           ENDDO mu 
#
           DO a1 
#
              PREPARE Viaai(i,a1,a,i1) = Liaai(i,a1,a,i1)
#
           ENDDO a1 
#
           deallocate Liaai(i,*,a,i1) 
#
     ENDPARDO a, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vixai
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_IAAI
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_QJQJ
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, j, j1
#
           allocate Lxjqj(mu,j,*,j1) 
#
           DO nu 
#
              REQUEST Vxjxj(mu,j,nu,j1) j 
#
              DO q
#
                 Txjqj(mu,j,q,j1)  = Vxjxj(mu,j,nu,j1)*cb(nu,q)
                 Lxjqj(mu,j,q,j1) += Txjqj(mu,j,q,j1)
#
              ENDDO q
#
           ENDDO nu 
#
           DO q 
#
              PREPARE Vxjqj(mu,j,q,j1) = Lxjqj(mu,j,q,j1)
#
           ENDDO q 
#
           deallocate Lxjqj(mu,j,*,j1) 
#
     ENDPARDO mu, j, j1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxjxj
#
     PARDO q, j, j1
#
           allocate Lqjqj(*,j,q,j1) 
#
           DO mu 
#
              REQUEST            Vxjqj(mu,j,q,j1) j 
              REQUEST            Vxjqj(mu,j1,q,j) j 
              Txjqj(mu,j,q,j1) = Vxjqj(mu,j1,q,j) 
              Txjqj(mu,j,q,j1)-= Vxjqj(mu,j,q,j1) 
              Txjqj(mu,j,q,j1)*= -1.0  
#
              DO q1
#
                #Tqjqj(q1,j,q,j1)   = Vxjqj(mu,j,q,j1)*cb(mu,q1)
                #T1qjqj(q1,j,q,j1)  = Vxjqj(mu,j1,q,j)*cb(mu,q1)
                #Tqjqj(q1,j,q,j1)  -= T1qjqj(q1,j,q,j1) 
                 Tqjqj(q1,j,q,j1)   = Txjqj(mu,j,q,j1)*cb(mu,q1)
                 Lqjqj(q1,j,q,j1)  += Tqjqj(q1,j,q,j1)
#
              ENDDO q1
#
           ENDDO mu 
#
           DO q1 
#
              PREPARE VSqjqj(q1,j,q,j1) = Lqjqj(q1,j,q,j1)
#
           ENDDO q1 
#
           deallocate Lqjqj(*,j,q,j1) 
#
     ENDPARDO q, j, j1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxjqj
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_QJQJ
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_BBJJ
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, j, j1
#
           allocate Lxbjj(mu,*,j,j1) 
#
           DO nu 
#
              REQUEST Vxxjj(mu,nu,j,j1) j 
#
              DO b
#
                 Txbjj(mu,b,j,j1)  = Vxxjj(mu,nu,j,j1)*cb(nu,b)
                 Lxbjj(mu,b,j,j1) += Txbjj(mu,b,j,j1)
#
              ENDDO b
#
           ENDDO nu 
#
           DO b 
#
              PREPARE Vxbjj(mu,b,j,j1) = Lxbjj(mu,b,j,j1)
#
           ENDDO b 
#
           deallocate Lxbjj(mu,*,j,j1) 
#
     ENDPARDO mu, j, j1
#
     execute sip_barrier
     execute server_barrier
#
     PARDO b, j, j1
#
           allocate Lbbjj(*,b,j,j1) 
#
           DO mu 
#
              REQUEST Vxbjj(mu,b,j,j1) j 
#
              DO b1
#
                 Tbbjj(b1,b,j,j1)  = Vxbjj(mu,b,j,j1)*cb(mu,b1)
                 Lbbjj(b1,b,j,j1) += Tbbjj(b1,b,j,j1)
#
              ENDDO b1
#
           ENDDO mu 
#
           DO b1
#
              PREPARE Vbbjj(b1,b,j,j1) = Lbbjj(b1,b,j,j1)
#
           ENDDO b1
#
           deallocate Lbbjj(*,b,j,j1) 
#
     ENDPARDO b, j, j1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxbjj
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_BBJJ
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_JBBJ
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, j, j1
#
           allocate Ljxbj(j,mu,*,j1) 
#
           DO nu 
#
              REQUEST Vjxxj(j,mu,nu,j1) j 
#
              DO b
#
                 Tjxbj(j,mu,b,j1)  = Vjxxj(j,mu,nu,j1)*cb(nu,b)
                 Ljxbj(j,mu,b,j1) += Tjxbj(j,mu,b,j1)
#
              ENDDO b
#
           ENDDO nu 
#
           DO b
#
              PREPARE Vjxbj(j,mu,b,j1) = Ljxbj(j,mu,b,j1)
#
           ENDDO b
#
           deallocate Ljxbj(j,nu,*,j1) 
#
     ENDPARDO mu, j, j1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vjxxj
#
     PARDO b, j, j1
#
           allocate Ljbbj(j,*,b,j1) 
#
           DO mu 
#
              REQUEST Vjxbj(j,mu,b,j1) j 
#
              DO b1
#
                 Tjbbj(j,b1,b,j1)  = Vjxbj(j,mu,b,j1)*cb(mu,b1)
                 Ljbbj(j,b1,b,j1) += Tjbbj(j,b1,b,j1)
#
              ENDDO b1
#
           ENDDO mu 
#
           DO b1
#
              PREPARE Vjbbj(j,b1,b,j1) = Ljbbj(j,b1,b,j1)
#
           ENDDO b1
#
           deallocate Ljbbj(j,*,b,j1) 
#
     ENDPARDO b, j, j1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vjxbj
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_JBBJ
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_BBII
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, i, i1
#
           allocate Lxbii(mu,*,i,i1) 
#
           DO nu 
#
              REQUEST Vxxii(mu,nu,i,i1) i 
#
              DO b
#
                 Txbii(mu,b,i,i1)  = Vxxii(mu,nu,i,i1)*cb(nu,b)
                 Lxbii(mu,b,i,i1) += Txbii(mu,b,i,i1)
#
              ENDDO b
#
           ENDDO nu 
#
           DO b
#
              PREPARE Vxbii(mu,b,i,i1) = Lxbii(mu,b,i,i1)
#
           ENDDO b
#
           deallocate Lxbii(mu,*,i,i1) 
#
     ENDPARDO mu, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxxii
#
     PARDO b, i, i1
#
           allocate Lbbii(*,b,i,i1) 
#
           DO mu 
#
              REQUEST Vxbii(mu,b,i,i1) i 
#
              DO b1
#
                 Tbbii(b1,b,i,i1)  = Vxbii(mu,b,i,i1)*cb(mu,b1)
                 Lbbii(b1,b,i,i1) += Tbbii(b1,b,i,i1)
#
              ENDDO b1
#
           ENDDO mu 
#
           DO b1
#
              PREPARE Vbbii(b1,b,i,i1) = Lbbii(b1,b,i,i1)
#
           ENDDO b1
#
           deallocate Lbbii(*,b,i,i1) 
#
     ENDPARDO  b, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxbii
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_BBII
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_AAJJ
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, j, j1
#
           allocate Lxajj(mu,*,j,j1) 
#
           DO nu 
#
              REQUEST Vxxjj(mu,nu,j,j1) j 
#
              DO a
#
                 Txajj(mu,a,j,j1)  = Vxxjj(mu,nu,j,j1)*ca(nu,a)
                 Lxajj(mu,a,j,j1) += Txajj(mu,a,j,j1)
#
              ENDDO a
#
           ENDDO nu 
#
           DO a
#
              PREPARE Vxajj(mu,a,j,j1) = Lxajj(mu,a,j,j1)
#
           ENDDO a
#
           deallocate Lxajj(mu,*,j,j1) 
#
     ENDPARDO mu, j, j1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxxjj
#
     PARDO a, j, j1
#
           allocate Laajj(*,a,j,j1) 
#
           DO mu 
#
              REQUEST Vxajj(mu,a,j,j1) j
#
              DO a1
#
                 Taajj(a1,a,j,j1)  = Vxajj(mu,a,j,j1)*ca(mu,a1)
                 Laajj(a1,a,j,j1) += Taajj(a1,a,j,j1)
#
              ENDDO a1
#
           ENDDO mu 
#
           DO a1
#
              PREPARE Vaajj(a1,a,j,j1) = Laajj(a1,a,j,j1)
#
           ENDDO a1
#
           deallocate Laajj(*,a,j,j1) 
#
     ENDPARDO  a, j, j1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxajj
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_AAJJ
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_IABJ
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, i, j
#
           allocate Lixbj(i,mu,*,j) 
#
           DO nu 
#
              REQUEST Vixxj(i,mu,nu,j) i
#
              DO b
#
                 Tixbj(i,mu,b,j)  = Vixxj(i,mu,nu,j)*cb(nu,b)
                 Lixbj(i,mu,b,j) += Tixbj(i,mu,b,j)
#
              ENDDO b
#
           ENDDO nu 
#
           DO b
#
              PREPARE Vixbj(i,mu,b,j) = Lixbj(i,mu,b,j)
#
           ENDDO b
#
           deallocate Lixbj(i,mu,*,j) 
#
     ENDPARDO mu, i, j
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vixxj
#
     PARDO b, i, j
#
           allocate Liabj(i,*,b,j) 
#
           DO mu 
#
              REQUEST Vixbj(i,mu,b,j) i
#
              DO a
#
                 Tiabj(i,a,b,j)  = Vixbj(i,mu,b,j)*ca(mu,a)
                 Liabj(i,a,b,j) += Tiabj(i,a,b,j)
#
              ENDDO a
#
           ENDDO mu 
#
           DO a
#
              PREPARE Viabj(i,a,b,j) = Liabj(i,a,b,j)
#
           ENDDO a
#
           deallocate Liabj(i,*,b,j) 
#
     ENDPARDO b, i, j
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vixbj
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_IABJ
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_IIBB
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, i, i1
#
           allocate Liixb(i,i1,mu,*) 
#
           DO nu 
#
              REQUEST Viixx(i,i1,mu,nu) i 
#
              DO b
#
                 Tiixb(i,i1,mu,b)  = Viixx(i,i1,mu,nu)*cb(nu,b)
                 Liixb(i,i1,mu,b) += Tiixb(i,i1,mu,b)
#
              ENDDO b
#
           ENDDO nu 
#
           DO b
#
              PREPARE Viixb(i,i1,mu,b) = Liixb(i,i1,mu,b)
#
           ENDDO b
#
           deallocate Liixb(i,i1,mu,*) 
#
     ENDPARDO mu, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Viixx
#
     PARDO b, i, i1
#
           allocate Liibb(i,i1,*,b) 
#
           DO mu 
#
              REQUEST Viixb(i,i1,mu,b) i
#
              DO b1
#
                 Tiibb(i,i1,b1,b)  = Viixb(i,i1,mu,b)*cb(mu,b1)
                 Liibb(i,i1,b1,b) += Tiibb(i,i1,b1,b)
#
              ENDDO b1
#
           ENDDO mu 
#
           DO b1
#
              PREPARE Viibb(i,i1,b1,b) = Liibb(i,i1,b1,b)
#
           ENDDO b1
#
           deallocate Liibb(i,i1,*,b) 
#
     ENDPARDO b, i, i1
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Viixb
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_IIBB
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_PIQJ
#
#    ------------------------------------------------------------------------
#
     execute sip_barrier
#
     PARDO mu, i, j
#
           allocate Lxiqj(mu,i,*,j) 
#
           DO nu 
#
              REQUEST Vxixj(mu,i,nu,j) i
#
              DO q
#
                 Txiqj(mu,i,q,j)  = Vxixj(mu,i,nu,j)*cb(nu,q)
                 Lxiqj(mu,i,q,j) += Txiqj(mu,i,q,j)
#
              ENDDO q
#
           ENDDO nu 
#
           DO q
#
              PREPARE Vxiqj(mu,i,q,j) = Lxiqj(mu,i,q,j)
#
           ENDDO q
#
           deallocate Lxiqj(mu,i,*,j) 
#
     ENDPARDO mu, i, j
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxixj
#
     PARDO q, i, j
#
           allocate Lpiqj(*,i,q,j) 
#
           DO mu 
#
              REQUEST Vxiqj(mu,i,q,j) i 
#
              DO p
#
                 Tpiqj(p,i,q,j)  = Vxiqj(mu,i,q,j)*ca(mu,p)
                 Lpiqj(p,i,q,j) += Tpiqj(p,i,q,j)
#
              ENDDO p
#
           ENDDO mu 
#
           DO p
#
              PREPARE Vpiqj(p,i,q,j) = Lpiqj(p,i,q,j)
#
           ENDDO p
#
           deallocate Lpiqj(*,i,q,j) 
#
     ENDPARDO q, i, j
#
     execute sip_barrier
     execute server_barrier
#    DISCARD Vxiqj
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_PIQJ
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_PPPP
#
#    ------------------------------------------------------------------------
#
          CALL TRAN_XXII
          CALL TRAN_PIPI
          CALL TRAN_AAII
          CALL TRAN_IAAI
#
          CALL TRAN_QJQJ
          CALL TRAN_BBJJ
          CALL TRAN_JBBJ
#
          CALL TRAN_PIQJ
          CALL TRAN_AAJJ
          CALL TRAN_IABJ
#
          CALL TRAN_BBII
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_PPPP
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF 
# 
         CALL TRAN_PPPP  
#
     ENDPROC TRAN_UHF 
# 
#    ------------------------------------------------------------------------ 
#
#
# -----------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------  
#
# The two-electron integral deivative <mn|ls>^l is computed
# and transformed to the MO basis for use in constructing
# the Hessian. The transformation is performed in 4 steps as
# is usually done. Since there will always be one occupied index
# in the Hessian computation the 4-types of integrals are computed. 
#
# 1. DTpppi
# 2. DTqqqj
# 3. DTppqj  
# 4. DTqqpi   
#
# Note that the integrals are not antisymmetrized in the transformation. 
#
# --------------------------------------------------------------------------- 
#
      PROC DINT_TRAN 
#     --------------  
#
      create Qyai 
      create Qybj 
      create Fya 
      create Fyb 
      execute sip_barrier 
      execute server_barrier 
#
#     Finish the contribution to Qyai and Qybj 
#     ---------------------------------------- 
#
      PARDO mu, sigma  
#
            GET               QAByy(mu,sigma) 
            GET               QAyy(mu,sigma) 
            GET               QByy(mu,sigma) 
#
            txx(mu,sigma)   = QAByy(mu,sigma) + QAyy(mu,sigma) 
#
            DO i
#
               tpx(i,sigma) = ca(mu,i)*txx(mu,sigma)
#
               DO i1 
#
                  tpp(i,i1)       = tpx(i,sigma)*ca(sigma,i1)
                  PUT Fya(i,i1) += tpp(i,i1)
#
               ENDDO i1 
#
            ENDDO i
#
            t1xx(mu,sigma)  = QAByy(mu,sigma) + QByy(mu,sigma) 
#
            DO j
#
               tqx(j,sigma) = cb(mu,j)*t1xx(mu,sigma)
#
               DO j1  
#
                  tqq(j,j1)       = tqx(j,sigma)*cb(sigma,j1)
                  PUT Fyb(j,j1) += tqq(j,j1)
#
               ENDDO j1  
#
            ENDDO j
#
      ENDPARDO mu, sigma  
#
      execute sip_barrier 
#
      ENDPROC DINT_TRAN 
#     -----------------  
#
# ---------------------------------------------------------------------- 
#
      PROC DINT_GET 
#     ------------- 
#
      create QAyy 
      create QByy 
      create QAByy 
      execute sip_barrier 
#
      PARDO mu, nu
            GET QTABxx(mu,nu,jatom,jx) 
            GET QTAxx(mu,nu,jatom,jx)  
            GET QTBxx(mu,nu,jatom,jx)  
            PUT QAByy(mu,nu) = QTABxx(mu,nu,jatom,jx)   
            PUT QAyy(mu,nu)  = QTAxx(mu,nu,jatom,jx)   
            PUT QByy(mu,nu)  = QTBxx(mu,nu,jatom,jx)   
      ENDPARDO mu, nu 
#
      execute sip_barrier 
#
      ENDPROC DINT_GET 
#     ---------------- 
#
# ----------------------------------------------------------------------  
#
# The two-electron integral derivative <mn|ls>^l is computed
# and transformed to the MO basis for use in constructing
# the Hessian. The transformation is performed in 3 steps as
# as only the vovo integrals are needed. 
#
# 1. VXpipi  
# 1. VXqjqj  
# 1. VXpiqj  
#
# Note that the integrals are not antisymmetrized in the transformation. 
#
# ---------------------------------------------------------------------- 
#
      PROC TRAN_VX_XIXI  
#     ----------------- 
#
     #create Qxai 
     #create Qxbj  
     #create Fxa
     #create Fxb
     #create Hxa
     #create Hxb
      create QAxx
      create QBxx
      create QABxx 
#     execute server_barrier 
      execute sip_barrier 
#
      PARDO mu, nu
            GET QTABxx(mu,nu,iatom,ix) 
            GET QTAxx(mu,nu,iatom,ix)   
            GET QTBxx(mu,nu,iatom,ix)  
            PUT QABxx(mu,nu) = QTABxx(mu,nu,iatom,ix)   
            PUT QAxx(mu,nu)  = QTAxx(mu,nu,iatom,ix)   
            PUT QBxx(mu,nu)  = QTBxx(mu,nu,iatom,ix)   
      ENDPARDO mu, nu 
#
      execute sip_barrier
#
      ENDPROC TRAN_VX_XIXI  
#     --------------------  
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC QYAI_H 
#     ----------- 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Qxai and Qxbj  
#           ------------------------------ 
#
            DO a 
#
               tpx(a,nu) = ca(mu,a)*txx(mu,nu)   
#
               DO i 
#
                  tpp(a,i)       = tpx(a,nu)*ca(nu,i) 
                  PUT Qyai(a,i) += tpp(a,i) 
#
               ENDDO i  
#
            ENDDO a 
#
            DO b 
#
               tqx(b,nu) = cb(mu,b)*txx(mu,nu)   
#
               DO j 
#
                  tqq(b,j)       = tqx(b,nu)*cb(nu,j) 
                  PUT Qybj(b,j) += tqq(b,j) 
#
               ENDDO j  
#
            ENDDO b 
#
      ENDPARDO mu, nu 
#
      ENDPROC QYAI_H 
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC QXAI_H 
#     ----------- 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Qxai and Qxbj  
#           ------------------------------ 
#
            DO a 
#
               tpx(a,nu) = txx(mu,nu)*ca(mu,a)  
#
               DO i 
#
                  tpp(a,i)       = tpx(a,nu)*ca(nu,i) 
                  PUT Qxai(a,i) += tpp(a,i) 
#
               ENDDO i  
#
            ENDDO a 
#
            DO b 
#
               tqx(b,nu) = txx(mu,nu)*cb(mu,b)  
#
               DO j 
#
                  tqq(b,j)       = tqx(b,nu)*cb(nu,j) 
                  PUT Qxbj(b,j) += tqq(b,j) 
#
               ENDDO j  
#
            ENDDO b 
#
      ENDPARDO mu, nu 
#
      ENDPROC QXAI_H 
#     -------------- 
#
# ---------------------------------------------------------------------------
#
      PROC FINTY_TRAN 
#     --------------- 
#
#     The transformed first-derivative fock matrix is computed. The 
#     perturbation is defined by jatom, jx and jcenter and the 
#     final arrays are Fya and Fyb. 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Fya and Fyb 
#           ---------------------------- 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO i1 
#
                  tpp(i1,i)      = txp(mu,i)*ca(mu,i1) 
                  PUT Fya(i1,i) += tpp(i1,i) 
#
               ENDDO i1  
#
            ENDDO i 
#
            DO j 
#
               txq(mu,j) = txx(mu,nu)*cb(nu,j)  
#
               DO j1 
#
                  tqq(j1,j)      = txq(mu,j)*cb(mu,j1) 
                  PUT Fyb(j1,j) += tqq(j1,j) 
#
               ENDDO j1  
#
            ENDDO j 
#
      ENDPARDO mu, nu 
#
      execute sip_barrier 
#
#     Add contributions from overlap derivatives and two-electron integrals  
#     --------------------------------------------------------------------- 
#
#     alpha-alpha occupied-occupied block 
#     ----------------------------------- 
#
      PARDO i, i1 
#
            tii(i,i1) = 0.0 
#
            DO i2 
#
               if i1 == i2 
#
               GET           Sya(i,i2) 
               t1ii(i,i1)  = Sya(i,i2)*Fock_a(i1,i2) 
               t1ii(i,i1) *= -0.5  
               tii(i,i1)  += t1ii(i,i1) 
#
               endif 
#
            ENDDO i2 
#
            DO i2 
#
               if i == i2 
#
               GET           Sya(i2,i1) 
               t1ii(i,i1)  = Sya(i2,i1)*Fock_a(i2,i) 
               t1ii(i,i1) *= -0.5  
               tii(i,i1)  += t1ii(i,i1) 
#
               endif 
#
            ENDDO i2 
#
            DO i2 
            DO i3 
#
               REQUEST      VSpipi(i,i1,i2,i3) i
               GET          Sya(i3,i2) 
#
               t1ii(i,i1) = VSpipi(i,i1,i2,i3)*Sya(i3,i2)  
               tii(i,i1) -= t1ii(i,i1) 
#
            ENDDO i3 
            ENDDO i2
#
            DO j 
            DO j1 
#
               REQUEST      Vpiqj(i,i1,j,j1) i
               GET          Syb(j1,j) 
#
               t1ii(i,i1) = Vpiqj(i,i1,j,j1)*Syb(j1,j)  
               tii(i,i1) -= t1ii(i,i1) 
#
            ENDDO j1 
            ENDDO j 
#
            DO a2 
            DO i2 
#
               REQUEST              VSpipi(i1,i,a2,i2) i 
               REQUEST              VSpipi(i,i1,a2,i2) i 
               GET                  Uyaa(a2,i2) 
#
               tpppp(i,i1,a2,i2)  = VSpipi(i1,i,a2,i2) 
               t1pppp(i,i1,a2,i2) = VSpipi(i,i1,a2,i2) 
               tpppp(i,i1,a2,i2) += t1pppp(i,i1,a2,i2) 
#
               t1ii(i,i1)         = tpppp(i,i1,a2,i2)*Uyaa(a2,i2) 
               tii(i,i1)         += t1ii(i,i1) 
#
            ENDDO i2 
            ENDDO a2 
#
            DO b 
            DO j 
#
               REQUEST            Vpiqj(i1,i,b,j) i
               REQUEST            Vpiqj(i,i1,b,j) i
               GET                Uybb(b,j) 
#
               tppqq(i,i1,b,j)  = Vpiqj(i1,i,b,j) 
               t1ppqq(i,i1,b,j) = Vpiqj(i,i1,b,j) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j) 
#
               t1ii(i,i1)       = tppqq(i,i1,b,j)*Uybb(b,j) 
               tii(i,i1)       += t1ii(i,i1) 
#
            ENDDO j 
            ENDDO b 
#
            PUT Fya(i,i1) += tii(i,i1)  
#
      ENDPARDO i, i1 
#
#     beta-beta occupied-occupied block 
#     ----------------------------------- 
#
      PARDO j, j1 
#
            tjj(j,j1) = 0.0 
#
            DO j2 
#
               if j1 == j2 
#
               GET           Syb(j,j2) 
               t1jj(j,j1)  = Syb(j,j2)*Fock_b(j1,j2) 
               t1jj(j,j1) *= -0.5  
               tjj(j,j1)  += t1jj(j,j1) 
#
               endif 
#
            ENDDO j2 
#
            DO j2 
#
               if j2 == j 
#
               GET           Syb(j2,j1) 
               t1jj(j,j1)  = Syb(j2,j1)*Fock_b(j2,j) 
               t1jj(j,j1) *= -0.5  
               tjj(j,j1)  += t1jj(j,j1) 
#
               endif 
#
            ENDDO j2 
#
            DO j2 
            DO j3 
#
               REQUEST      VSqjqj(j,j1,j2,j3) j
               GET          Syb(j3,j2) 
#
               t1jj(j,j1) = VSqjqj(j,j1,j2,j3)*Syb(j3,j2)  
               tjj(j,j1) -= t1jj(j,j1) 
#
            ENDDO j3 
            ENDDO j2
#
            DO i 
            DO i1 
#
               REQUEST      Vpiqj(i,i1,j,j1) i
               GET          Sya(i1,i) 
#
               t1jj(j,j1) = Vpiqj(i,i1,j,j1)*Sya(i1,i)  
               tjj(j,j1) -= t1jj(j,j1) 
#
            ENDDO i1 
            ENDDO i 
#
            DO b2 
            DO j2 
#
               REQUEST              VSqjqj(j1,j,b2,j2) j
               REQUEST              VSqjqj(j,j1,b2,j2) j 
               GET                  Uybb(b2,j2) 
#
               tqqqq(j,j1,b2,j2)  = VSqjqj(j1,j,b2,j2) 
               t1qqqq(j,j1,b2,j2) = VSqjqj(j,j1,b2,j2) 
               tqqqq(j,j1,b2,j2) += t1qqqq(j,j1,b2,j2) 
#
               t1jj(j,j1)         = tqqqq(j,j1,b2,j2)*Uybb(b2,j2) 
               tjj(j,j1)         += t1jj(j,j1) 
#
            ENDDO j2 
            ENDDO b2 
#
            DO a 
            DO i 
#
               REQUEST            Vpiqj(a,i,j1,j) a
               REQUEST            Vpiqj(a,i,j,j1) a
               GET                Uyaa(a,i) 
#
               tqqpp(j,j1,a,i)  = Vpiqj(a,i,j1,j) 
               t1qqpp(j,j1,a,i) = Vpiqj(a,i,j,j1) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i) 
#
               t1jj(j,j1)       = tqqpp(j,j1,a,i)*Uyaa(a,i) 
               tjj(j,j1)       += t1jj(j,j1) 
#
            ENDDO i 
            ENDDO a 
#
            PUT Fyb(j,j1) += tjj(j,j1)  
#
      ENDPARDO j, j1 
#
      ENDPROC FINTY_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC SINTY_TRAN 
#     --------------- 
#
#     The transformed first-derivative overlap matrix is computed. The 
#     perturbation is defined by jatom, jx and jcenter and the 
#     final arrays are Sya and Syb. 
#
      create Sya 
      create Syb 
#
      execute sip_barrier 
#
      PARDO mu, nu 
#
            txx(mu,nu)  = 0.0 
#
            execute overlap_der txx(mu,nu) 
#
            DO p 
#
               txp(mu,p) = txx(mu,nu)*ca(nu,p)  
#
               DO p1 
#
                  tpp(p1,p)       = txp(mu,p)*ca(mu,p1) 
                  PUT Sya(p1,p)  += tpp(p1,p) 
#
               ENDDO p1  
#
            ENDDO p 
#
            DO q 
#
               txq(mu,q) = txx(mu,nu)*cb(nu,q)  
#
               DO q1 
#
                  tqq(q1,q)       = txq(mu,q)*cb(mu,q1) 
                  PUT Syb(q1,q)  += tqq(q1,q) 
#
               ENDDO q1  
#
            ENDDO q 
#
      ENDPARDO mu, nu 

      execute sip_barrier 
#
      ENDPROC SINTY_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC SINTX_TRAN 
#     --------------- 
#
#     The transformed first-derivative overlap matrix is computed. The 
#     perturbation is defined by iatom, ix and icenter and the 
#     final arrays are Sxa and Sxb. 
#
     #create Sxa 
     #create Sxb 
#
     #execute sip_barrier 
#
      PARDO mu, nu 
#
           #execute overlap_der txx(mu,nu) 
            GET ovl_der(mu,nu,iatom,ix) 
            txx(mu,nu) = ovl_der(mu,nu,iatom,ix) 
#
#           Compute contributions to HF hessian. 
#           ------------------------------------ 
#
            GET            whfya(mu,nu) 
            GET            whfyb(mu,nu) 
            t1xx(mu,nu)  = whfya(mu,nu) 
            t1xx(mu,nu) += whfyb(mu,nu) 
            etemp        = txx(mu,nu)*t1xx(mu,nu) 
            etemp       *= 0.5 
            hessxy      += etemp 
            hessyx      += etemp 
#
      ENDPARDO mu, nu 
#
      PARDO mu, nu 
#
#           Compute contributions to the HF hessian. 
#           ---------------------------------------- 
#
            GET            dhfya(mu,nu) 
            GET            dhfyb(mu,nu) 
#
            GET            QTABxx(mu,nu,iatom,ix) 
            GET            QTAxx(mu,nu,iatom,ix) 
            GET            QTBxx(mu,nu,iatom,ix) 
#
           #execute fock_der txx(mu,nu) 
            GET h_der(mu,nu,iatom,ix) 
            txx(mu,nu) = h_der(mu,nu,iatom,ix) 
#
            t1xx(mu,nu)  = txx(mu,nu) 
            t2xx(mu,nu)  = QTABxx(mu,nu,iatom,ix) 
            t3xx(mu,nu)  = QTAxx(mu,nu,iatom,ix) 
            t1xx(mu,nu) += t2xx(mu,nu) 
            t1xx(mu,nu) += t3xx(mu,nu) 

            etemp        = t1xx(mu,nu)*dhfya(mu,nu) 
            etemp       *= 0.5 
            hessxy      += etemp 
            hessyx      += etemp 

            t1xx(mu,nu)  = txx(mu,nu) 
            t3xx(mu,nu)  = QTBxx(mu,nu,iatom,ix) 
            t1xx(mu,nu) += t2xx(mu,nu) 
            t1xx(mu,nu) += t3xx(mu,nu) 

            etemp        = t1xx(mu,nu)*dhfyb(mu,nu) 
            etemp       *= 0.5 
            hessxy      += etemp 
            hessyx      += etemp 
#
      ENDPARDO mu, nu 
#
      ENDPROC SINTX_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC Uy_XX  
#     ----------- 
#
      create Uyaa 
      create Uybb 
      execute sip_barrier 
#
      PARDO mu, nu 
#
            execute overlap_der txx(mu,nu) 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO i1 
#
                  tpp(i1,i)       = txp(mu,i)*ca(mu,i1) 
                  tpp(i1,i)      *= -0.5  
                  PUT Uyaa(i1,i) += tpp(i1,i) 
#
               ENDDO i1  
#
            ENDDO i 
#
            DO j 
#
               txq(mu,j) = txx(mu,nu)*cb(nu,j)  
#
               DO j1 
#
                  tqq(j1,j)       = txq(mu,j)*cb(mu,j1) 
                  tqq(j1,j)      *= -0.5  
                  PUT Uybb(j1,j) += tqq(j1,j) 
#
               ENDDO j1  
#
            ENDDO j 
#
      ENDPARDO mu, nu 
#
      ENDPROC Uy_XX  
#     ------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC Ux_XX  
#     ----------- 
#
      create Uxaa 
      create Uxbb 
#
      execute sip_barrier 
#
      PARDO mu, nu 
#
            txx(mu,nu)        = 0.0 
            execute overlap_der txx(mu,nu) 
#
            DO a 
#
               txp(mu,a) = txx(mu,nu)*ca(nu,a)  
#
               DO a1 
#
                  tpp(a1,a)       = txp(mu,a)*ca(mu,a1) 
                  tpp(a1,a)      *= -0.5  
                  PUT Uxaa(a1,a) += tpp(a1,a) 
#
               ENDDO a1  
#
            ENDDO a 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO i1 
#
                  tpp(i1,i)       = txp(mu,i)*ca(mu,i1) 
                  tpp(i1,i)      *= -0.5  
                  PUT Uxaa(i1,i) += tpp(i1,i) 
#
               ENDDO i1  
#
            ENDDO i 
#
            DO j 
#
               txq(mu,j) = txx(mu,nu)*cb(nu,j)  
#
               DO j1 
#
                  tqq(j1,j)       = txq(mu,j)*cb(mu,j1) 
                  tqq(j1,j)      *= -0.5  
                  PUT Uxbb(j1,j) += tqq(j1,j) 
#
               ENDDO j1  
#
            ENDDO j 
#
            DO b 
#
               txq(mu,b) = txx(mu,nu)*cb(nu,b)  
#
               DO b1 
#
                  tqq(b1,b)       = txq(mu,b)*cb(mu,b1) 
                  tqq(b1,b)      *= -0.5  
                  PUT Uxbb(b1,b) += tqq(b1,b) 
#
               ENDDO b1  
#
            ENDDO b 
#
      ENDPARDO mu, nu 
#
      ENDPROC Ux_XX  
#     ------------- 
#
      PROC Qx_XX 
#     ---------- 
#
#     Form the virtual-occupied block of the Q array --> Qxai, Qxbj
#     -------------------------------------------------------------
#
#     Qxai first
#     ----------
#
      PARDO a, i
#
            tai(a,i) = 0.0 # Fxa(a,i)
#
            DO i1
#
               GET         Sxa(a,i1)
#
               DO i2
#
                  REQUEST     VSpipi(a,i,i2,i1) i 
                  GET         Sxa(i1,i2)
                  t1ai(a,i) = VSpipi(a,i,i2,i1)*Sxa(i1,i2)
                  tai(a,i) -= t1ai(a,i)
#
               ENDDO i2
#
               t1ai(a,i) = Sxa(a,i1)*Fock_a(i,i1)
               tai(a,i) -= t1ai(a,i)
            ENDDO i1
#
            DO j
            DO j1
#
               REQUEST     Vpiqj(a,i,j1,j) a 
               GET         Sxb(j,j1)
               t1ai(a,i) = Vpiqj(a,i,j1,j)*Sxb(j,j1)
               tai(a,i) -= t1ai(a,i)
#
            ENDDO j1
            ENDDO j
#
            PUT Qxai(a,i) += tai(a,i)
#
      ENDPARDO a, i
#
#     Qxbj next
#     ---------
#
      PARDO b, j
#
            tbj(b,j) = 0.0 #Fxb(b,j)
#
            DO j1
#
               GET         Sxb(b,j1)
#
               DO j2
#
                  REQUEST     VSqjqj(b,j,j2,j1) b 
                  GET         Sxb(j1,j2)
                  t1bj(b,j) = VSqjqj(b,j,j2,j1)*Sxb(j1,j2)
                  tbj(b,j) -= t1bj(b,j)
#
               ENDDO j2
#
               t1bj(b,j) = Sxb(b,j1)*Fock_b(j,j1)
               tbj(b,j) -= t1bj(b,j)
            ENDDO j1
#
            DO i
            DO i1
#
               REQUEST     Vpiqj(i1,i,b,j) b 
               GET         Sxa(i,i1)
               t1bj(b,j) = Vpiqj(i1,i,b,j)*Sxa(i,i1)
               tbj(b,j) -= t1bj(b,j)
#
            ENDDO i1
            ENDDO i
#
            PUT Qxbj(b,j) += tbj(b,j)
#
      ENDPARDO b, j
#
      ENDPROC Qx_XX  
#     ------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC I_TRANS
#     ------------
#
      create Ixx_a 
      create Ixx_b 
      create Ihf 
      execute sip_barrier 
#
#     1. Iij_a
#     --------
#
      PARDO i, i1
#
            GET Ipq_a(i,i1)
#
            DO mu
#
               Txi(mu,i1) = ca(mu,i)*Ipq_a(i,i1)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i1)*ca(nu,i1)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO i, i1
#
#     2. Iij_b
#     --------
#
      PARDO j, j1
#
            GET Ipq_b(j,j1)
#
            DO mu
#
               Txj(mu,j1) = cb(mu,j)*Ipq_b(j,j1)
#
               DO nu
#
                  Txx(mu,nu)        = Txj(mu,j1)*cb(nu,j1)
                  PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO j, j1
#
#     3. Iab_a
#     --------
#
      PARDO a, a1
#
            GET Ipq_a(a,a1)
#
            DO mu
#
               Txa(mu,a1) = ca(mu,a)*Ipq_a(a,a1)
#
               DO nu
#
                  Txx(mu,nu)        = Txa(mu,a1)*ca(nu,a1)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, a1
#
#     4. Iab_b
#     --------
#
      PARDO b, b1
#
            GET Ipq_b(b,b1)
#
            DO mu
#
               Txb(mu,b1) = cb(mu,b)*Ipq_b(b,b1)
#
               DO nu
#
                  Txx(mu,nu)        = Txb(mu,b1)*cb(nu,b1)
                  PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO b, b1
#
#     5. Iai_a
#     --------
#
      PARDO a, i
#
#           GET Ipq_a(a,i)
            GET Ipq_a(i,a)
#
            DO mu
#
               Txi(mu,i)  = ca(mu,a)*Ipq_a(i,a)
#              T1xi(mu,i) = ca(mu,a)*Ipq_a(i,a)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i)*ca(nu,i)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
                  T1xx(nu,mu)       = Txx(mu,nu) 
                  PUT Ixx_a(nu,mu) += T1xx(nu,mu)
#
#                 Txx(mu,nu)        = T1xi(mu,i)*ca(nu,i)
#                 PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, i
#
#     6. Iai_b
#     --------
#
      PARDO b, j
#
#           GET Ipq_b(b,j)
            GET Ipq_b(j,b)
#
            DO mu
#
               Txj(mu,j)  = cb(mu,b)*Ipq_b(j,b)
#              T1xj(mu,j) = cb(mu,b)*Ipq_b(j,b)
#
               DO nu
#
                  Txx(mu,nu)        = Txj(mu,j)*cb(nu,j)
                  PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
                  T1xx(nu,mu)       = Txx(mu,nu) 
                  PUT Ixx_b(nu,mu) += T1xx(nu,mu)
#
#                 Txx(mu,nu)        = T1xj(mu,j)*cb(nu,j)
#                 PUT Ixx_b(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO b, j
#
      ENDPROC I_TRANS
#     ---------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC I_HF
#     --------
#
      create Ihf 
      execute sip_barrier 
#
      PARDO mu, nu, i
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               T1xi(nu,i) = ca(nu,i1)*fock_a(i,i1)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)      = ca(mu,i)*Txi(nu,i)
            T1xx(mu,nu)     = Txx(mu,nu) 
            PUT Ihf(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i
#
      PARDO mu, nu, j
#
            Txj(nu,j) = 0.0
#
            DO j1
#
               T1xj(nu,j) = cb(nu,j1)*fock_b(j,j1)
               Txj(nu,j) -= T1xj(nu,j)
#
            ENDDO j1
#
            Txx(mu,nu)      = cb(mu,j)*Txj(nu,j)
            T1xx(mu,nu)     = Txx(mu,nu)
            PUT Ihf(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, j
#
      execute sip_barrier 
#
      ENDPROC I_HF
#     ------------
#
# ---------------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
      create Dhfa 
      create Dhfb 
      execute sip_barrier 
#
      PARDO mu, nu, i
#
            Txi(nu,i)        = ca(nu,i)
            Txx(mu,nu)       = ca(mu,i)*Txi(nu,i)
            PUT Dhfa(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i
#
      PARDO mu, nu, j
#
            Txj(nu,j)        = cb(nu,j)
            Txx(mu,nu)       = cb(mu,j)*Txj(nu,j)
            PUT Dhfb(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, j
      allocate LDHFa(*,*) 
      allocate LDHFb(*,*) 
      execute sip_barrier 
      DO mu 
      DO nu 
         GET             Dhfa(mu,nu) 
         GET             Dhfb(mu,nu) 
         LDhfa(mu,nu) = Dhfa(mu,nu) 
         LDhfb(mu,nu) = Dhfb(mu,nu) 
      ENDDO nu 
      ENDDO mu 
#
      ENDPROC HFDENS
#     --------------
#
# ---------------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------------
#
      PROC SXY_CONT
#     -------------
#
# Contract with the second derivative integrals
# --------------------------------------
#
      PARDO mu, nu
#
            GET             Ihf(mu,nu) 
            txx(mu,nu)    = Ihf(mu,nu) 
            EXECUTE SCONTXY txx(mu,nu)
# 
      ENDPARDO mu, nu
#
      ENDPROC SXY_CONT
#     ----------------
#
# ---------------------------------------------------------------------------------
#
      PROC DXY_CONT
#     -------------
#
# Contract with the second derivative integrals
# --------------------------------------
#
      PARDO mu, nu
#
            GET             Dhfa(mu,nu)
            GET             Dhfb(mu,nu)
            Txx(mu,nu)    = Dhfa(mu,nu)
            Txx(mu,nu)   += Dhfb(mu,nu)
            EXECUTE HCONTXY Txx(mu,nu)
#
      ENDPARDO mu, nu
#
      ENDPROC DXY_CONT
#     ----------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC GIJAB_CONT
#     ---------------
#
#     Complete backtransformation and 'contract' with second derivative integral.
#     ---------------------------------------------------------------------------
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu < lambda
              WHERE nu < sigma
#
#             Get 1-particle pieces
#             ---------------------
#
#             HF only
#             -------
              Txx(mu,lambda)             = LDHFa(mu,lambda)
              Txxxx(mu,lambda,nu,sigma)  = Txx(mu,lambda)^LDHFa(nu,sigma)
#
              T1xx(mu,lambda)            = LDHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = T1xx(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T2xxxx(mu,lambda,nu,sigma)
#
              T3xxxx(mu,lambda,nu,sigma) = LDHFb(mu,lambda)^LDHFa(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T3xxxx(mu,lambda,nu,sigma)
#
              T2xx(mu,sigma)             = LDHFa(mu,sigma)
              T2xx(mu,sigma)            *= 0.5  
              T4xxxx(mu,lambda,nu,sigma) = T2xx(mu,sigma)^LDHFa(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
#
              T3xx(mu,sigma)             = LDHFb(mu,sigma)
              T3xx(mu,sigma)            *= 0.5  
              T5xxxx(mu,lambda,nu,sigma) = T3xx(mu,sigma)^LDHFb(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
              T4xx(mu,nu)                = LDHFa(mu,nu)
              T4xx(mu,nu)               *= 0.5  
              T6xxxx(mu,lambda,nu,sigma) = T4xx(mu,nu)^LDHFa(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
              T5xx(mu,nu)                = LDHFb(mu,nu)
              T5xx(mu,nu)               *= 0.5  
              T7xxxx(mu,lambda,nu,sigma) = T5xx(mu,nu)^LDHFb(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T7xxxx(mu,lambda,nu,sigma)
#
              Txxxx(mu,lambda,nu,sigma) *= 2.0 # 0.5*4.0 
#
#             Contract density with integral derivatives
#             ------------------------------------------
              execute compute_Sderivative_integrals Txxxx(mu,lambda,nu,sigma)
#
        ENDPARDO mu, nu, lambda, sigma   
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu == lambda
              WHERE nu < sigma
#
#             Get 1-particle pieces
#             ---------------------
#
#             HF only
#             -------
              Txx(mu,lambda)             = LDHFa(mu,lambda)
              Txxxx(mu,lambda,nu,sigma)  = Txx(mu,lambda)^LDHFa(nu,sigma)
#
              Txx(mu,lambda)             = LDHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = LDHFa(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = LDHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFa(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = LDHFa(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^LDHFa(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = LDHFb(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^LDHFb(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = LDHFa(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^LDHFa(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = LDHFb(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^LDHFb(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txxxx(mu,lambda,nu,sigma) *= 0.5
              TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
#             Get the separable part
#             ----------------------
              TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#             Contract density with integral derivatives
#             ------------------------------------------
              execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
        ENDPARDO mu, nu, lambda, sigma   
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu < lambda
              WHERE nu == sigma
#
#             Get 1-particle pieces
#             ---------------------
#
#             HF only
#             -------
              Txx(mu,lambda)             = LDHFa(mu,lambda)
              Txxxx(mu,lambda,nu,sigma)  = Txx(mu,lambda)^LDHFa(nu,sigma)
#
              Txx(mu,lambda)             = LDHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = LDHFa(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = LDHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFa(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = LDHFa(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^LDHFa(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = LDHFb(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^LDHFb(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = LDHFa(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^LDHFa(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = LDHFb(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^LDHFb(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txxxx(mu,lambda,nu,sigma) *= 0.5
              TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
#             Get the separable part
#             ----------------------
              TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#             Contract density with integral derivatives
#             ------------------------------------------
              execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)
#
        ENDPARDO mu, nu, lambda, sigma   
#
        PARDO mu, nu, lambda, sigma   
#
              WHERE mu == lambda
              WHERE nu == sigma
#
#             Get 1-particle pieces
#             ---------------------
#
#             HF only
#             -------
              Txx(mu,lambda)             = LDHFa(mu,lambda)
              Txxxx(mu,lambda,nu,sigma)  = Txx(mu,lambda)^LDHFa(nu,sigma)
#
              Txx(mu,lambda)             = LDHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = LDHFa(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = LDHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^LDHFa(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = LDHFa(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^LDHFa(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = LDHFb(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^LDHFb(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = LDHFa(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^LDHFa(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = LDHFb(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^LDHFb(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txxxx(mu,lambda,nu,sigma) *= 0.5
              TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute compute_Sderivative_integrals TSxxxx(mu,lambda,nu,sigma)

        ENDPARDO mu, nu, lambda, sigma   
#
      ENDPROC GIJAB_CONT
#     ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC FSCF_HESS 
#     -------------- 
#
      create cya 
      create cyb 
      create dhfya 
      create dhfyb 
      create whfya 
      create whfyb 
      execute sip_barrier 
#
#     Compute derivatives of coefficients. 
#     ------------------------------------ 
#
      PARDO mu, i 
#
           txp(mu,i) = 0.0 
#
           DO p1 
#
              GET          Uyaa(p1,i) 
              t1xp(mu,i) = ca(mu,p1)*Uyaa(p1,i) 
              txp(mu,i) += t1xp(mu,i) 
#
           ENDDO p1 
#
           PUT cya(mu,i) = txp(mu,i) 
#
      ENDPARDO mu, i 
#
      PARDO mu, j 
#
           txq(mu,j) = 0.0 
#
           DO q1 
#
              GET          Uybb(q1,j) 
              t1xq(mu,j) = cb(mu,q1)*Uybb(q1,j) 
              txq(mu,j) += t1xq(mu,j) 
#
           ENDDO q1 
#
           PUT cyb(mu,j) = txq(mu,j) 
#
      ENDPARDO mu, j 
#
      execute sip_barrier 
#
#     Form derivatives of HF density. 
#     ------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component. 
#           ---------------- 
#
            txx(mu,nu) = 0.0 
#
            DO i 
#
               GET           cya(mu,i) 
               GET           cya(nu,i) 
#
               t1xx(mu,nu) = cya(mu,i)*ca(nu,i) 
               txx(mu,nu) += t1xx(mu,nu) 
#
               t1xx(mu,nu) = ca(mu,i)*cya(nu,i) 
               txx(mu,nu) += t1xx(mu,nu) 
#
            ENDDO i 
#
            PUT dhfya(mu,nu) = txx(mu,nu) 
#
#           beta component. 
#           --------------- 
#
            txx(mu,nu) = 0.0 
#
            DO j 
#
               GET           cyb(mu,j) 
               GET           cyb(nu,j) 
#
               t1xx(mu,nu) = cyb(mu,j)*cb(nu,j) 
               txx(mu,nu) += t1xx(mu,nu) 
#
               t1xx(mu,nu) = cb(mu,j)*cyb(nu,j) 
               txx(mu,nu) += t1xx(mu,nu) 
#
            ENDDO j 
#
            PUT dhfyb(mu,nu) = txx(mu,nu) 
#
      ENDPARDO mu, nu 
#
#     Compute derivatives of weighted HF density. 
#     ------------------------------------------- 
#
      PARDO mu, nu, i  
#
#           piece 1. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               GET          cya(nu,i1) 
               T1xi(nu,i) = cya(nu,i1)*fock_a(i1,i)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)        = ca(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      PARDO mu, nu, i  
#
#           piece 2. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               T1xi(nu,i) = ca(nu,i1)*fock_a(i1,i)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            get                 cya(mu,i) 
            Txx(mu,nu)        = cya(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      PARDO mu, nu, i  
#
#           piece 3. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               get          fya(i1,i) 
               T1xi(nu,i) = ca(nu,i1)*fya(i1,i) 
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)        = ca(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      PARDO mu, nu 
#
            DO j 
#
#           piece 1. 
#           -------- 
#
            Txj(nu,j) = 0.0
#
            DO j1
#
               GET          cyb(nu,j1) 
               T1xj(nu,j) = cyb(nu,j1)*fock_b(j1,j)
               Txj(nu,j) -= T1xj(nu,j)
#
            ENDDO j1
#
            Txx(mu,nu)        = cb(mu,j)*Txj(nu,j)
            PUT whfyb(mu,nu) += Txx(mu,nu)
#
            ENDDO j 
#
#           piece 2. 
#           -------- 
#
            DO j 
#
            GET cyb(mu,j) 
            Txj(nu,j) = 0.0
#
            DO j1
#
               T1xj(nu,j) = cb(nu,j1)*fock_b(j1,j)
               Txj(nu,j) -= T1xj(nu,j)
#
            ENDDO j1
#
            Txx(mu,nu)        = cyb(mu,j)*Txj(nu,j)
            PUT whfyb(mu,nu) += Txx(mu,nu)
#
            ENDDO j 
#
#           piece 3. 
#           -------- 
#
            DO j 
#
            Txj(nu,j) = 0.0
#
            DO j1
#
               get          fyb(j1,j) 
               T1xj(nu,j) = cb(nu,j1)*fyb(j1,j) 
               Txj(nu,j) -= T1xj(nu,j)
#
            ENDDO j1
#
            Txx(mu,nu)        = cb(mu,j)*Txj(nu,j)
            PUT whfyb(mu,nu) += Txx(mu,nu)
#
            ENDDO j 
#
      ENDPARDO mu, nu 
#
      execute sip_barrier 
#
      delete cya 
      delete cyb 
#
      ENDPROC FSCF_HESS 
#     ----------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
         PROC UPDATE_DAI 
#        --------------- 
#
         PARDO a, i 
#
               GET        Dainew_a(a,i) 
               GET        Daiold_a(a,i) 
               Tai(a,i) = Dainew_a(a,i) 
#              execute energy_denominator Tai(a,i) 
               Tai(a,i) -= Daiold_a(a,i) 
#
               if kiter == 1 
                  PUT e1ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 2 
                  PUT e2ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 3 
                  PUT e3ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 4 
                  PUT e4ai(a,i) = tai(a,i) 
               endif 
#
               if kiter >= 5 
                  PUT e5ai(a,i) = tai(a,i) 
               endif 
#
         ENDPARDO a, i 
#
         PARDO b, j 
#
               GET        Dainew_b(b,j) 
               GET        Daiold_b(b,j) 
               Tbj(b,j) = Dainew_b(b,j) 
#              execute energy_denominator Tbj(b,j) 
               Tbj(b,j) -= Daiold_b(b,j) 
#
               if kiter == 1 
                  PUT e1bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter == 2 
                  PUT e2bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter == 3 
                  PUT e3bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter == 4 
                  PUT e4bj(b,j) = tbj(b,j) 
               endif 
#
               if kiter >= 5 
                  PUT e5bj(b,j) = tbj(b,j) 
               endif 
#
         ENDPARDO b, j 
#
         ENDPROC UPDATE_DAI 
#        ------------------ 
#
# ----------------------------------------------------------------------------------------
# 
# ----------------------------------------------------------------------------------------
#
      PROC MOVE_DAI 
#     ------------- 
#
      PARDO a, i
#
            GET        Daiold_a(a,i)
            tai(a,i) = Daiold_a(a,i)
#
            if kiter == 1
               PUT d1ai(a,i) = tai(a,i)
            endif
#
            if kiter == 2
               PUT d2ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 3
               PUT d3ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 4
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
            if kiter >= 5
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
      ENDPARDO a, i
#
      PARDO b, j
#
            GET        Daiold_b(b,j)
            tbj(b,j) = Daiold_b(b,j)
#
            if kiter == 1
               PUT d1bj(b,j) = tbj(b,j)
            endif
#
            if kiter == 2
               PUT d2bj(b,j) = tbj(b,j)
            endif
#
            if kiter == 3
               PUT d3bj(b,j) = tbj(b,j)
            endif
#
            if kiter == 4
               PUT d4bj(b,j) = tbj(b,j)
            endif
#
            if kiter >= 5
               PUT d4bj(b,j) = tbj(b,j)
            endif
#
      ENDPARDO b, j
#
      ENDPROC MOVE_DAI 
#     ---------------- 
# 
# ----------------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR
#    -----------------
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS
#    expansion are zero'd out.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR
#    --------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS
#    ---------------
#
#    Put the matrix elements of B into the sip 'B' matrix.
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS
#    ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to Dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-1 amplitudes
           GET e2ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to Dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-1 amplitudes
           GET e2bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb22 += b22
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------
#
     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-2 amplitudes
           GET D1ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-1 amplitudes
           GET e2ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form Dbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-2 amplitudes
           GET D1bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-1 amplitudes
           GET e2bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS1
#    -------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute server_barrier
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-2 amplitudes
           GET e2ai(a,i)    # kiter-1 amplitudes
           GET e3ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-2 amplitudes
           GET e2bj(b,j)    # kiter-1 amplitudes
           GET e3bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
              etemp = e1bj(b,j)*e3bj(b,j)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
              etemp = e2bj(b,j)*e3bj(b,j)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3bj(b,j)*e3bj(b,j)
              b33  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb33 += b33
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-3 amplitudes
           GET D1ai(a,i)     # kiter-2 amplitudes
           GET D2ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-2 amplitudes
           GET e2ai(a,i)     # kiter-1 amplitudes
           GET e3ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form tbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-3 amplitudes
           GET D1bj(b,j)     # kiter-2 amplitudes
           GET D2bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-2 amplitudes
           GET e2bj(b,j)     # kiter-1 amplitudes
           GET e3bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d2bj(b,j)
           t1bj(b,j)    += e3bj(b,j)
           t1bj(b,j)    *= c3
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS2
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-3 amplitudes
           GET e2ai(a,i)    # kiter-2 amplitudes
           GET e3ai(a,i)    # kiter-1 amplitudes
           GET e4ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-3 amplitudes
           GET e2bj(b,j)    # kiter-2 amplitudes
           GET e3bj(b,j)    # kiter-1 amplitudes
           GET e4bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
              etemp = e1bj(b,j)*e3bj(b,j)
              b13  += etemp
#
              etemp = e1bj(b,j)*e4bj(b,j)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
              etemp = e2bj(b,j)*e3bj(b,j)
              b23  += etemp
#
              etemp = e2bj(b,j)*e4bj(b,j)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3bj(b,j)*e3bj(b,j)
              b33  += etemp
#
              etemp = e3bj(b,j)*e4bj(b,j)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4bj(b,j)*e4bj(b,j)
              b44  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb44 += b44
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-4 amplitudes
           GET D1ai(a,i)     # kiter-3 amplitudes
           GET D2ai(a,i)     # kiter-2 amplitudes
           GET D3ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-3 amplitudes
           GET e2ai(a,i)     # kiter-2 amplitudes
           GET e3ai(a,i)     # kiter-1 amplitudes
           GET e4ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form tbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-4 amplitudes
           GET D1bj(b,j)     # kiter-3 amplitudes
           GET D2bj(b,j)     # kiter-2 amplitudes
           GET D3bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-3 amplitudes
           GET e2bj(b,j)     # kiter-2 amplitudes
           GET e3bj(b,j)     # kiter-1 amplitudes
           GET e4bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d2bj(b,j)
           t1bj(b,j)    += e3bj(b,j)
           t1bj(b,j)    *= c3
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d3bj(b,j)
           t1bj(b,j)    += e4bj(b,j)
           t1bj(b,j)    *= c4
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS3
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-4 amplitudes
           GET e2ai(a,i)    # kiter-3 amplitudes
           GET e3ai(a,i)    # kiter-2 amplitudes
           GET e4ai(a,i)    # kiter-1 amplitudes
           GET e5ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
              etemp = e1ai(a,i)*e5ai(a,i)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
              etemp = e2ai(a,i)*e5ai(a,i)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
              etemp = e3ai(a,i)*e5ai(a,i)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
              etemp = e4ai(a,i)*e5ai(a,i)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5ai(a,i)*e5ai(a,i)
              b55  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET e1bj(b,j)    # kiter-4 amplitudes
           GET e2bj(b,j)    # kiter-3 amplitudes
           GET e3bj(b,j)    # kiter-2 amplitudes
           GET e4bj(b,j)    # kiter-1 amplitudes
           GET e5bj(b,j)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1bj(b,j)*e1bj(b,j)
              b11  += etemp
#
              etemp = e1bj(b,j)*e2bj(b,j)
              b12  += etemp
#
              etemp = e1bj(b,j)*e3bj(b,j)
              b13  += etemp
#
              etemp = e1bj(b,j)*e4bj(b,j)
              b14  += etemp
#
              etemp = e1bj(b,j)*e5bj(b,j)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2bj(b,j)*e2bj(b,j)
              b22  += etemp
#
              etemp = e2bj(b,j)*e3bj(b,j)
              b23  += etemp
#
              etemp = e2bj(b,j)*e4bj(b,j)
              b24  += etemp
#
              etemp = e2bj(b,j)*e5bj(b,j)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3bj(b,j)*e3bj(b,j)
              b33  += etemp
#
              etemp = e3bj(b,j)*e4bj(b,j)
              b34  += etemp
#
              etemp = e3bj(b,j)*e5bj(b,j)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4bj(b,j)*e4bj(b,j)
              b44  += etemp
#
              etemp = e4bj(b,j)*e5bj(b,j)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5bj(b,j)*e5bj(b,j)
              b55  += etemp
#
     ENDPARDO b, j
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb15 += b15
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb25 += b25
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb35 += b35
     collective Tb44 += b44
     collective Tb45 += b45
     collective Tb55 += b55
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     c5 = Tb55
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-5 amplitudes
           GET D1ai(a,i)     # kiter-4 amplitudes
           GET D2ai(a,i)     # kiter-3 amplitudes
           GET D3ai(a,i)     # kiter-2 amplitudes
           GET D4ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-4 amplitudes
           GET e2ai(a,i)     # kiter-3 amplitudes
           GET e3ai(a,i)     # kiter-2 amplitudes
           GET e4ai(a,i)     # kiter-1 amplitudes
           GET e5ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d4ai(a,i)
           t1ai(a,i)    += e5ai(a,i)
           t1ai(a,i)    *= c5
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
#    Form tbj_old.
#    -------------
#
     PARDO b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0bj(b,j)     # kiter-5 amplitudes
           GET D1bj(b,j)     # kiter-4 amplitudes
           GET D2bj(b,j)     # kiter-3 amplitudes
           GET D3bj(b,j)     # kiter-2 amplitudes
           GET D4bj(b,j)     # kiter-1 amplitudes
#
           GET e1bj(b,j)     # kiter-4 amplitudes
           GET e2bj(b,j)     # kiter-3 amplitudes
           GET e3bj(b,j)     # kiter-2 amplitudes
           GET e4bj(b,j)     # kiter-1 amplitudes
           GET e5bj(b,j)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tbj_old.
#          --------------------------------------------------------
#
           t1bj(b,j)     = d0bj(b,j)
           t1bj(b,j)    += e1bj(b,j)
           t1bj(b,j)    *= c1
           tbj(b,j)      = t1bj(b,j)
#
           t1bj(b,j)     = d1bj(b,j)
           t1bj(b,j)    += e2bj(b,j)
           t1bj(b,j)    *= c2
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d2bj(b,j)
           t1bj(b,j)    += e3bj(b,j)
           t1bj(b,j)    *= c3
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d3bj(b,j)
           t1bj(b,j)    += e4bj(b,j)
           t1bj(b,j)    *= c4
           tbj(b,j)     += t1bj(b,j)
#
           t1bj(b,j)     = d4bj(b,j)
           t1bj(b,j)    += e5bj(b,j)
           t1bj(b,j)    *= c5
           tbj(b,j)     += t1bj(b,j)
#
           PUT Daiold_b(b,j) = tbj(b,j)
#
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC DIIS4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
#
#    0 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET d1ai(a,i)
           PUT d0ai(a,i) = d1ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d1bj(b,j)
           PUT d0bj(b,j) = d1bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier 
#
#    2 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET e2ai(a,i)
           PUT e1ai(a,i) = e2ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e2bj(b,j)
           PUT e1bj(b,j) = e2bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET d2ai(a,i)
           PUT d1ai(a,i) = d2ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d2bj(b,j)
           PUT d1bj(b,j) = d2bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     PARDO a, i
           GET e3ai(a,i)
           PUT e2ai(a,i) = e3ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e3bj(b,j)
           PUT e2bj(b,j) = e3bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET d3ai(a,i)
           PUT d2ai(a,i) = d3ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d3bj(b,j)
           PUT d2bj(b,j) = d3bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
#    4 --> 3
#    ---------------------------------------------------
#
     PARDO a, i
           GET e4ai(a,i)
           PUT e3ai(a,i) = e4ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e4bj(b,j)
           PUT e3bj(b,j) = e4bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET d4ai(a,i)
           PUT d3ai(a,i) = d4ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET d4bj(b,j)
           PUT d3bj(b,j) = d4bj(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     PARDO a, i
           GET e5ai(a,i)
           PUT e4ai(a,i) = e5ai(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET e5bj(b,j)
           PUT e4bj(b,j) = e5bj(b,j)
     ENDPARDO b, j
#
     PARDO a, i
           GET daiold_a(a,i)
           PUT d4ai(a,i) = daiold_a(a,i)
     ENDPARDO a, i
#
     PARDO b, j
           GET daiold_b(b,j)  
           PUT d4bj(b,j) = daiold_b(b,j)
     ENDPARDO b, j
#
     execute sip_barrier
#
     ENDPROC MOVE4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC CDENSAI
#     ------------
#
#     Create distributed denisty arrays. 
#     --------------------------------- 
#
      create Dainew_a 
      create Dainew_b 
      create Daiold_a 
      create Daiold_b 
      CREATE D0ai
      CREATE D1ai
      CREATE D2ai
      CREATE D3ai
      CREATE D4ai
#
      CREATE D0bj
      CREATE D1bj
      CREATE D2bj
      CREATE D3bj
      CREATE D4bj
#
      CREATE e1ai
      CREATE e2ai
      CREATE e3ai
      CREATE e4ai
      CREATE e5ai
#
      CREATE e1bj
      CREATE e2bj
      CREATE e3bj
      CREATE e4bj
      CREATE e5bj
#
      ENDPROC CDENSAI
#     --------------
#
# ---------------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC FORM_UYAI  
#     --------------
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            REQUEST         CPHFa(a,i,jatom,jx) a 
            GET             Sya(a,i) 
            tai(a,i)      = CPHFa(a,i,jatom,jx)
            PUT Uyaa(a,i) = tai(a,i)  
#
            tai(a,i)     += Sya(a,i) 
            tia(i,a)      = tai(a,i) 
            tia(i,a)     *= -1.0  
#
            PUT Uyaa(i,a) = tia(i,a) 

      ENDPARDO a, i 
#
      PARDO b, j 
            REQUEST         CPHFb(b,j,jatom,jx) b
            GET             Syb(b,j) 
            tbj(b,j)      = CPHFb(b,j,jatom,jx)
            PUT Uybb(b,j) = tbj(b,j) 
#
            tbj(b,j)     += Syb(b,j) 
            tjb(j,b)      = tbj(b,j) 
            tjb(j,b)     *= -1.0  
#
            PUT Uybb(j,b) = tjb(j,b) 
#
      ENDPARDO b, j 
#
      execute sip_barrier 
#
      ENDPROC FORM_UYAI  
#     -----------------
#
# ---------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC FORM_UXAI  
#     --------------
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.000000001
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i 
#
            GET                 Qxai(a,i)
            tai(a,i)          = Qxai(a,i) 
            execute             energy_denominator tai(a,i) 
            t1ai(a,i)         = tai(a,i)  
            PUT Daiold_a(a,i) = tai(a,i) 
            PUT D0ai(a,i)     = t1ai(a,i) 
#
      ENDPARDO a, i 
#
      PARDO b, j 
#
            GET                 Qxbj(b,j)
            tbj(b,j)          = Qxbj(b,j) 
            execute             energy_denominator tbj(b,j) 
            t1bj(b,j)         = tbj(b,j) 
            PUT Daiold_b(b,j) = tbj(b,j) 
            PUT D0bj(b,j)     = t1bj(b,j)
#
      ENDPARDO b, j 
#
      execute sip_barrier 
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
#
         PARDO a, i
#
               GET                           Qxai(a,i)
               tai(a,i)                    = Qxai(a,i)
#
               execute energy_denominator    tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               PUT Dainew_a(a,i)           = tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               esum += etemp
#
         ENDPARDO a, i
#
         PARDO b, j
#
               GET        Qxbj(b,j)
               tbj(b,j) = Qxbj(b,j)
#
               execute energy_denominator    tbj(b,j)
               etemp = tbj(b,j)*tbj(b,j)
               PUT Dainew_b(b,j)           = tbj(b,j)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               esum += etemp
#
         ENDPARDO b, j
#
         execute sip_barrier 
#
         PARDO a, i, a1, i1 
#
               REQUEST             VSpipi(a,i,a1,i1) a
               REQUEST             Vaaii(a,a1,i1,i)  a
               REQUEST             Viaai(i,a,a1,i1)  a 
               GET                 Daiold_a(a1,i1)
#
               Taiai(a,i,a1,i1)  = VSpipi(a,i,a1,i1)
               T3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)
               T4aiai(a,i,a1,i1) = Viaai(i,a,a1,i1)
#
               Taiai(a,i,a1,i1) -= T3aiai(a,i,a1,i1)
               Taiai(a,i,a1,i1) += T4aiai(a,i,a1,i1)
#
               tai(a,i)          = Taiai(a,i,a1,i1)*Daiold_a(a1,i1)
#
               execute energy_denominator    tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               PUT Dainew_a(a,i)          += tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               esum += etemp
#
         ENDPARDO a, i, a1, i1 
#
         PARDO a, i, b, j 
#
               REQUEST           Vpiqj(a,i,b,j) a 
               REQUEST           Viabj(i,a,b,j) a 
               GET               Daiold_b(b,j)
#
               Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
               T1aibj(a,i,b,j) = Viabj(i,a,b,j)
               Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
               tai(a,i)        = Taibj(a,i,b,j)*Daiold_b(b,j)
#
               execute energy_denominator    tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               PUT Dainew_a(a,i)          += tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               esum += etemp
#
         ENDPARDO a, i, b, j 
#
         PARDO b, j, b1, j1 
#
               REQUEST             VSqjqj(b,j,b1,j1) b
               REQUEST             Vbbjj(b,b1,j1,j)  b 
               REQUEST             Vjbbj(j,b,b1,j1)  b 
               GET                 Daiold_b(b1,j1)
#
               Tbjbj(b,j,b1,j1)  = VSqjqj(b,j,b1,j1)
               T3bjbj(b,j,b1,j1) = Vbbjj(b,b1,j1,j)
               T4bjbj(b,j,b1,j1) = Vjbbj(j,b,b1,j1)
#
               Tbjbj(b,j,b1,j1) -= T3bjbj(b,j,b1,j1)
               Tbjbj(b,j,b1,j1) += T4bjbj(b,j,b1,j1)
#
               tbj(b,j)          = Tbjbj(b,j,b1,j1)*Daiold_b(b1,j1)
#
               execute energy_denominator    tbj(b,j)
               etemp = tbj(b,j)*tbj(b,j)
               PUT Dainew_b(b,j)          += tbj(b,j)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               esum += etemp
#
         ENDPARDO b, j, b1, j1 
#
         PARDO b, j, a, i 
#
               REQUEST           Vpiqj(a,i,b,j) a 
               REQUEST           Viabj(i,a,b,j) a 
               GET               Daiold_a(a,i)
#
               Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
               T1aibj(a,i,b,j) = Viabj(i,a,b,j)
               Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
               tbj(b,j)        = Taibj(a,i,b,j)*Daiold_a(a,i)
#
               execute energy_denominator    tbj(b,j)
               etemp = tbj(b,j)*tbj(b,j)
               PUT Dainew_b(b,j)          += tbj(b,j)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               esum += etemp
#
         ENDPARDO b, j, a, i 
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI
         execute server_barrier 
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one.
#        -------------------------------------
#
         PARDO a, i
               GET                 Dainew_a(a,i)
               PUT Daiold_a(a,i) = Dainew_a(a,i)
         ENDPARDO a, i
#
         PARDO b, j
               GET                 Dainew_b(b,j)
               PUT Daiold_b(b,j) = Dainew_b(b,j)
         ENDPARDO b, j
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
#
         if kiter == 2
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI
#
      ENDDO kiter
#
      execute sip_barrier 
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            GET              Dainew_a(a,i)
            GET              Sxa(a,i)
#
            tai(a,i)       = Dainew_a(a,i) 
            t1ai(a,i)      = Dainew_a(a,i) + Sxa(a,i) 

            PUT Uxaa(a,i)  = tai(a,i) 
            PREPARE CPHFa(a,i,iatom,ix) = Dainew_a(a,i) 
#
            tia(i,a)       = t1ai(a,i) 
            tia(i,a)      *= -1.0  
#
            PUT Uxaa(i,a)  = tia(i,a) 

      ENDPARDO a, i 
#
      PARDO b, j 
            GET              Dainew_b(b,j)
            GET              Sxb(b,j) 
#
            tbj(b,j)       = Dainew_b(b,j) 
            t1bj(b,j)      = Dainew_b(b,j) + Sxb(b,j)
            PUT Uxbb(b,j)  = tbj(b,j) 
            PREPARE CPHFb(b,j,iatom,ix) = Dainew_b(b,j) 
#
            tjb(j,b)       = t1bj(b,j) 
            tjb(j,b)      *= -1.0  
#
            PUT Uxbb(j,b)  = tjb(j,b) 
#
      ENDPARDO b, j 
#
      execute sip_barrier 
#
      ENDPROC FORM_UXAI  
#     -----------------
#
# ---------------------------------------------------------------------------
#
      PROC PUT_UXAI  
#     -------------
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            REQUEST CPHFa(a,i,iatom,ix) a 
            GET              Sxa(a,i)
            tai(a,i)       = CPHFa(a,i,iatom,ix)  
#
            t1ai(a,i)      = tai(a,i) + Sxa(a,i) 
            PUT Uxaa(a,i)  = tai(a,i)  
#
            tia(i,a)       = t1ai(a,i) 
            tia(i,a)      *= -1.0  
#
            PUT Uxaa(i,a)  = tia(i,a) 

      ENDPARDO a, i 
#
      PARDO b, j 
            REQUEST CPHFb(b,j,iatom,ix) b  
            GET              Sxb(b,j) 
            tbj(b,j)       = CPHFb(b,j,iatom,ix)  
#
            t1bj(b,j)      = tbj(b,j) + Sxb(b,j)
            PUT Uxbb(b,j)  = tbj(b,j) 
#
            tjb(j,b)       = t1bj(b,j) 
            tjb(j,b)      *= -1.0  
#
            PUT Uxbb(j,b)  = tjb(j,b) 
#
      ENDPARDO b, j 
#
      execute sip_barrier 
#
      ENDPROC PUT_UXAI  
#     ----------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC PUT_UYAI  
#     -------------
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            REQUEST CPHFa(a,i,jatom,jx) a 
            GET              Sya(a,i)
            tai(a,i)       = CPHFa(a,i,jatom,jx)  
#
            t1ai(a,i)      = tai(a,i) + Sya(a,i) 
            PUT Uyaa(a,i)  = tai(a,i)  
#
            tia(i,a)       = t1ai(a,i) 
            tia(i,a)      *= -1.0  
#
            PUT Uyaa(i,a)  = tia(i,a) 

      ENDPARDO a, i 
#
      PARDO b, j 
            REQUEST CPHFb(b,j,jatom,jx) b  
            GET              Syb(b,j) 
            tbj(b,j)       = CPHFb(b,j,jatom,jx)  
#
            t1bj(b,j)      = tbj(b,j) + Syb(b,j)
            PUT Uybb(b,j)  = tbj(b,j) 
#
            tjb(j,b)       = t1bj(b,j) 
            tjb(j,b)      *= -1.0  
#
            PUT Uybb(j,b)  = tjb(j,b) 
#
      ENDPARDO b, j 
#
      execute sip_barrier 
#
      ENDPROC PUT_UYAI  
#     ----------------
#
# ---------------------------------------------------------------------------
#
# ----------------------------------------------------------------------
#
# The transformed derivative integrals for ALL perturbations(iatom,ix) 
# are formed and stored in served arrays. VTpipi(a,i,a1,i1,iatom,ix), 
# VTqjqj(b,j,b1,j1,jatom,jx), VTpiqj(a,i,b,j,iatom,ix). 
# In addition the contributions to Hxa, Hxb, Fxa, Fxb, Qxai, and 
# Qxbj are formed. They are stored in the served arrays shown below.  
#
# Fxa --> FTa(q,q1,iatom,ix) 
# Fxb --> FTb(q,q1,iatom,ix) 
# Qxai--> QTai(p,p1,iatom,ix) 
# Qxbj--> QTbj(q,q1,iatom,ix) 
# QABxx-> QTABxx(mu,nu,iatom,ix)
# QAxx--> QTAxx(mu,nu,iatom,ix)
# QBxx--> QTBxx(mu,nu,iatom,ix)
#
# ----------------------------------------------------------------------
#
      PROC ALLTRAN_VX_XIXI
#     --------------------
#
      create QTai 
      create QTbj 
      create ovl_der 
      create h_der 
      create QTABxx 
      create QTAxx 
      create QTBxx 
#
      DO iatom 
         IF iatom >= ihess1 
         IF iatom <= ihess2 
      DO ix 
#
      create Qxai
      create Qxbj
      create QAxx
      create QBxx
      create QABxx
      create Sxa 
      create Sxb 
      create Uxaa 
      create Uxbb 
      execute sip_barrier 
#
#     Set flags --> perturbation.
#     ---------------------------
      execute set_flags2 dflags2(iatom,ix)
#
#     Compute the transformed overlap derivative integrals 
#     ---------------------------------------------------- 
#
      PARDO mu, nu 
#
            execute overlap_der txx(mu,nu) 
            execute fock_der t1xx(mu,nu) 
            PUT ovl_der(mu,nu,iatom,ix) = txx(mu,nu) 
            PUT h_der(mu,nu,iatom,ix) = t1xx(mu,nu) 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO p1 
#
                  tpp(p1,i)       = txp(mu,i)*ca(mu,p1) 
                  PUT Sxa(p1,i)  += tpp(p1,i) 
#
               ENDDO p1  
#
            ENDDO i 
#
            DO j 
#
               txq(mu,j) = txx(mu,nu)*cb(nu,j)  
#
               DO q1 
#
                  tqq(q1,j)       = txq(mu,j)*cb(mu,q1) 
                  PUT Sxb(q1,j)  += tqq(q1,j) 
#
               ENDDO q1  
#
            ENDDO j 
#
      ENDPARDO mu, nu 
#
#     Compute integrals and perform first two stages of the transformation.
#     ---------------------------------------------------------------------
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     < nu
            WHERE lambda < sigma
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
               #GET                   Dhfa(lambda,sigma)
               #GET                   Dhfb(lambda,sigma)
               #GET                   Dhfa(lambda,nu)
               #GET                   Dhfb(lambda,nu)
               #GET                   Dhfa(sigma,nu)
               #GET                   Dhfb(sigma,nu)
               #GET                   Dhfa(lambda,mu)
               #GET                   Dhfb(lambda,mu)
               #GET                   Dhfa(sigma,mu)
               #GET                   Dhfb(sigma,mu)
#
                execute der2_comp saoint(mu,nu,lambda,sigma)
#
                txx(lambda,sigma)   = LDhfa(lambda,sigma)
                txx(lambda,sigma)  += LDhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t2xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfb(lambda,nu)
                t2xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t2xx(mu,sigma)
#
                t3xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfa(sigma,nu)
                t3xx(mu,lambda)     *= -1.0
                PUT QAxx(mu,lambda) += t3xx(mu,lambda)
#
                t4xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfb(sigma,nu)
                t4xx(mu,lambda)     *= -1.0
                PUT QBxx(mu,lambda) += t4xx(mu,lambda)
#
                t5xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,mu)
                t5xx(nu,sigma)     *= -1.0
                PUT QAxx(nu,sigma) += t5xx(nu,sigma)
#
                t6xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfb(lambda,mu)
                t6xx(nu,sigma)     *= -1.0
                PUT QBxx(nu,sigma) += t6xx(nu,sigma)
#
                t7xx(nu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfa(sigma,mu)
                t7xx(nu,lambda)     *= -1.0
                PUT QAxx(nu,lambda) += t7xx(nu,lambda)
#
                t8xx(nu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfb(sigma,mu)
                t8xx(nu,lambda)     *= -1.0
                PUT QBxx(nu,lambda) += t8xx(nu,lambda)
#
                t9xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                t9xx(mu,nu)        *= 2.0
                txx(nu,mu)          = t9xx(mu,nu)
                PUT QABxx(mu,nu)   += t9xx(mu,nu)
                PUT QABxx(nu,mu)   += txx(nu,mu)
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     == nu
            WHERE lambda < sigma
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
               #GET                   Dhfa(lambda,sigma)
               #GET                   Dhfb(lambda,sigma)
               #GET                   Dhfa(lambda,nu)
               #GET                   Dhfb(lambda,nu)
               #GET                   Dhfa(sigma,nu)
               #GET                   Dhfb(sigma,nu)
               #GET                   Dhfa(lambda,mu)
               #GET                   Dhfb(lambda,mu)
#
                execute der2_comp saoint(mu,nu,lambda,sigma)
#
                txx(lambda,sigma)   = LDhfa(lambda,sigma)
                txx(lambda,sigma)  += LDhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t2xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfb(lambda,nu)
                t2xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t2xx(mu,sigma)
#
                t3xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfa(sigma,nu)
                t3xx(mu,lambda)     *= -1.0
                PUT QAxx(mu,lambda) += t3xx(mu,lambda)
#
                t4xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*LDhfb(sigma,nu)
                t4xx(mu,lambda)     *= -1.0
                PUT QBxx(mu,lambda) += t4xx(mu,lambda)
#
                t5xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                t5xx(mu,nu)        *= 2.0
                PUT QABxx(mu,nu)   += t5xx(mu,nu)
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     < nu
            WHERE lambda == sigma
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
               #GET                   Dhfa(lambda,sigma)
               #GET                   Dhfb(lambda,sigma)
               #GET                   Dhfa(lambda,nu)
               #GET                   Dhfb(lambda,nu)
               #GET                   Dhfa(lambda,mu)
               #GET                   Dhfb(lambda,mu)
#
                execute der2_comp saoint(mu,nu,lambda,sigma)
#
                txx(lambda,sigma)   = LDhfa(lambda,sigma)
                txx(lambda,sigma)  += LDhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t2xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfb(lambda,nu)
                t2xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t2xx(mu,sigma)
#
                t3xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,mu)
                t3xx(nu,sigma)     *= -1.0
                PUT QAxx(nu,sigma) += t3xx(nu,sigma)
#
                t4xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfb(lambda,mu)
                t4xx(nu,sigma)     *= -1.0
                PUT QBxx(nu,sigma) += t4xx(nu,sigma)
#
                t5xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                txx(nu,mu)          = t5xx(mu,nu)
                PUT QABxx(mu,nu)   += t5xx(mu,nu)
#
                PUT QABxx(nu,mu)   += txx(nu,mu)
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            WHERE mu     == nu
            WHERE lambda == sigma
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
               #GET                   Dhfa(lambda,sigma)
               #GET                   Dhfb(lambda,sigma)
               #GET                   Dhfa(lambda,nu)
               #GET                   Dhfb(lambda,nu)
#
                execute der2_comp saoint(mu,nu,lambda,sigma)
#
                txx(lambda,sigma)   = LDhfa(lambda,sigma)
                txx(lambda,sigma)  += LDhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t2xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*LDhfb(lambda,nu)
                t2xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t2xx(mu,sigma)
#
                t3xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                PUT QABxx(mu,nu)   += t3xx(mu,nu)
#
      ENDPARDO mu, nu, lambda, sigma
#
#     create Fxa
#     create Fxb
#     create Hxa
#     create Hxb
      create Hx_px
      create Hx_qx
      create Hx_pp
      create Hx_qq
      execute sip_barrier
#
#     Finish the contribution to Qxai and Qxbj
#     ----------------------------------------
#
      PARDO mu, sigma
#
            GET               QABxx(mu,sigma)
            GET               QAxx(mu,sigma)
            GET               QBxx(mu,sigma)
#
            txx(mu,sigma)   = QABxx(mu,sigma) + QAxx(mu,sigma)
#
            DO p
#
               tpx(p,sigma)        = ca(mu,p)*txx(mu,sigma)
               PUT Hx_px(p,sigma) += tpx(p,sigma)
#
            ENDDO p
#
            t1xx(mu,sigma)  = QABxx(mu,sigma) + QBxx(mu,sigma)
#
            DO q
#
               tqx(q,sigma)        = cb(mu,q)*t1xx(mu,sigma)
               PUT Hx_qx(q,sigma) += tqx(q,sigma)
#
            ENDDO q
#
      ENDPARDO mu, sigma
#
      execute sip_barrier
#
      PARDO sigma, p
#
            GET Hx_px(p,sigma)
#
            DO i1
#
               tpp(p,i1)        = Hx_px(p,sigma)*ca(sigma,i1)
               PUT Hx_pp(p,i1) += tpp(p,i1)
#
            ENDDO i1
#
      ENDPARDO sigma, p
#
      PARDO sigma, q
#
            GET Hx_qx(q,sigma)
#
            DO j1
#
               tqq(q,j1)        = Hx_qx(q,sigma)*cb(sigma,j1)
               PUT Hx_qq(q,j1) += tqq(q,j1)
#
            ENDDO j1
#
      ENDPARDO sigma, q
#
      execute sip_barrier
#
      PARDO a, i
            GET              Hx_pp(a,i)
            PUT Qxai(a,i) += Hx_pp(a,i)
      ENDPARDO a, i
#
      PARDO b, j
            GET              Hx_qq(b,j)
            PUT Qxbj(b,j) += Hx_qq(b,j)
      ENDPARDO b, j
#
      execute sip_barrier
#
      CALL QXAI_H 
      CALL Qx_XX 
######CALL FORM_UXAI 
#
######CALL FINTX_TRAN  
#
      execute sip_barrier
#
#     Put these arrays into the full served arrays. 
#     --------------------------------------------- 
#
      PARDO mu, nu
            GET                          QABxx(mu,nu)
            GET                          QAxx(mu,nu)
            GET                          QBxx(mu,nu)
            PUT QTABxx(mu,nu,iatom,ix) = QABxx(mu,nu)
            PUT QTAxx(mu,nu,iatom,ix)  = QAxx(mu,nu)
            PUT QTBxx(mu,nu,iatom,ix)  = QBxx(mu,nu)
      ENDPARDO mu, nu
#
      PARDO a, i 
            GET Qxai(a,i) 
            PUT QTai(a,i,iatom,ix) = Qxai(a,i)  
      ENDPARDO a, i 
#
      PARDO b, j 
            GET Qxbj(b,j) 
            PUT QTbj(b,j,iatom,ix) = Qxbj(b,j)   
      ENDPARDO b, j 
#
      execute sip_barrier
      delete Hx_px
      delete Hx_qx
      delete Hx_pp
      delete Hx_qq
#     delete Fxa
#     delete Fxb
#     delete Hxa
#     delete Hxb
      delete Qxai
      delete Qxbj
      delete QAxx
      delete QBxx
      delete QABxx
      delete Sxa 
      delete Sxb 
      delete Uxaa 
      delete Uxbb 
#
      execute print_scalar etemp 
#
      ENDDO ix 
         ENDIF 
         ENDIF 
      ENDDO iatom 
#
      ENDPROC ALLTRAN_VX_XIXI
#     -----------------------
# 
# ----------------------------------------------------------------------------------------
#
      PROC MOVE_CAI 
#     ------------- 
#
      PARDO a, i, iatom, ix 
#
            GET                   Caiold(a,i,iatom,ix)
            taixx(a,i,iatom,ix) = Caiold(a,i,iatom,ix)
#
            if kiter == 1
               PUT dT1ai(a,i,iatom,ix) = taixx(a,i,iatom,ix)
            endif
#
            if kiter == 2
               PUT dT2ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
            if kiter == 3
               PUT dT3ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
            if kiter == 4
               PUT dT4ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
            if kiter >= 5
               PUT dT4ai(a,i,iatom,ix) = Taixx(a,i,iatom,ix)
            endif
#
      ENDPARDO a, i, iatom, ix 
#
      PARDO b, j, iatom, ix 
#
            GET                   Cbjold(b,j,iatom,ix)
            tbjxx(b,j,iatom,ix) = Cbjold(b,j,iatom,ix)
#
            if kiter == 1
               PUT dT1bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
            endif
#
            if kiter == 2
               PUT dT2bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
            endif
#
            if kiter == 3
               PUT dT3bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
            endif
#
            if kiter == 4
               PUT dT4bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
            endif
#
            if kiter >= 5
               PUT dT4bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix)
            endif
#
      ENDPARDO b, j, iatom, ix 
#
      ENDPROC MOVE_CAI 
#     ---------------- 
# 
# ----------------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
         PROC UPDATE_CAI 
#        --------------- 
#
         PARDO a, i, iatom, ix  
#
               GET                   Cainew(a,i,iatom,ix) 
               GET                   Caiold(a,i,iatom,ix) 
               Taixx(a,i,iatom,ix) = Cainew(a,i,iatom,ix) 
#              execute energy_denominator Tai(a,i) 
               Taixx(a,i,iatom,ix) -= Caiold(a,i,iatom,ix) 
#
               if kiter == 1 
                  PUT eT1ai(a,i,iatom,ix) = taixx(a,i,iatom,ix) 
               endif 
#
               if kiter == 2 
                  PUT eT2ai(a,i,iatom,ix) = taixx(a,i,iatom,ix) 
               endif 
#
               if kiter == 3 
                  PUT eT3ai(a,i,iatom,ix) = taixx(a,i,iatom,ix) 
               endif 
#
               if kiter == 4 
                  PUT eT4ai(a,i,iatom,ix) = taixx(a,i,iatom,ix) 
               endif 
#
               if kiter >= 5 
                  PUT eT5ai(a,i,iatom,ix) = taixx(a,i,iatom,ix) 
               endif 
#
         ENDPARDO a, i, iatom, ix  
#
         PARDO b, j, iatom, ix  
#
               GET        Cbjnew(b,j,iatom,ix) 
               GET        Cbjold(b,j,iatom,ix) 
               Tbjxx(b,j,iatom,ix) = Cbjnew(b,j,iatom,ix) 
#              execute energy_denominator Tbj(b,j) 
               Tbjxx(b,j,iatom,ix) -= Cbjold(b,j,iatom,ix) 
#
               if kiter == 1 
                  PUT eT1bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix) 
               endif 
#
               if kiter == 2 
                  PUT eT2bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix) 
               endif 
#
               if kiter == 3 
                  PUT eT3bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix) 
               endif 
#
               if kiter == 4 
                  PUT eT4bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix) 
               endif 
#
               if kiter >= 5 
                  PUT eT5bj(b,j,iatom,ix) = tbjxx(b,j,iatom,ix) 
               endif 
#
         ENDPARDO b, j, iatom, ix  
#
         ENDPROC UPDATE_CAI 
#        ------------------ 
#
# ----------------------------------------------------------------------------------------
# 
#
# ----------------------------------------------------------------------------
#
      PROC FORM_UCAI  
#     --------------
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.00001
      create Cainew 
      create Caiold 
      create Cbjnew 
      create Cbjold 
#
      create eT1ai
      create eT2ai
      create eT3ai
      create eT4ai
      create eT5ai
      create dT1ai
      create dT2ai
      create dT3ai
      create dT4ai
      create dT0ai
      create eT1bj
      create eT2bj
      create eT3bj
      create eT4bj
      create eT5bj
      create dT1bj
      create dT2bj
      create dT3bj
      create dT4bj
      create dT0bj
#
      execute sip_barrier 
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i, iatom, ix  
            GET                        QTai(a,i,iatom,ix)
            tai(a,i)                 = QTai(a,i,iatom,ix) 
            execute                    energy_denominator tai(a,i) 
            t1ai(a,i)                = tai(a,i) 
            PUT Caiold(a,i,iatom,ix) = tai(a,i) 
            PUT DT0ai(a,i,iatom,ix)  = t1ai(a,i) 
      ENDPARDO a, i, iatom, ix  
#
      PARDO b, j, iatom, ix  
            GET                        QTbj(b,j,iatom,ix)
            tbj(b,j)                 = QTbj(b,j,iatom,ix) 
            execute                    energy_denominator tbj(b,j) 
            t1bj(b,j)                = tbj(b,j) 
            PUT Cbjold(b,j,iatom,ix) = tbj(b,j) 
            PUT DT0bj(b,j,iatom,ix)  = t1bj(b,j)
      ENDPARDO b, j, iatom, ix  
#
#     Form VSpipi + Viaai - Vaaii --> Xaiai 
#     ------------------------------------- 
#
      PARDO a, i, a1, i1 
            REQUEST                VSpipi(a,i,a1,i1) a
            REQUEST                Vaaii(a,a1,i1,i)  a
            REQUEST                Viaai(i,a,a1,i1)  a 
            Taiai(a,i,a1,i1)     = VSpipi(a,i,a1,i1)
            T3aiai(a,i,a1,i1)    = Vaaii(a,a1,i1,i)
            T4aiai(a,i,a1,i1)    = Viaai(i,a,a1,i1)
            Taiai(a,i,a1,i1)    -= T3aiai(a,i,a1,i1)
            Taiai(a,i,a1,i1)    += T4aiai(a,i,a1,i1)
#
            PREPARE Xaiai(a,i,a1,i1) = Taiai(a,i,a1,i1) 
      ENDPARDO a, i, a1, i1 
#
      PARDO a, i, b, j 
            REQUEST              Vpiqj(a,i,b,j) a 
            REQUEST              Viabj(i,a,b,j) a 
            Taibj(a,i,b,j)     = Vpiqj(a,i,b,j)
            T1aibj(a,i,b,j)    = Viabj(i,a,b,j)
            Taibj(a,i,b,j)    += T1aibj(a,i,b,j)
#
            PREPARE Xaibj(a,i,b,j) = Taibj(a,i,b,j)
      ENDPARDO a, i, b, j 
#
      PARDO b, j, b1, j1 
            REQUEST                VSqjqj(b,j,b1,j1) b
            REQUEST                Vbbjj(b,b1,j1,j)  b 
            REQUEST                Vjbbj(j,b,b1,j1)  b 
            Tbjbj(b,j,b1,j1)     = VSqjqj(b,j,b1,j1)
            T3bjbj(b,j,b1,j1)    = Vbbjj(b,b1,j1,j)
            T4bjbj(b,j,b1,j1)    = Vjbbj(j,b,b1,j1)
            Tbjbj(b,j,b1,j1)    -= T3bjbj(b,j,b1,j1)
            Tbjbj(b,j,b1,j1)    += T4bjbj(b,j,b1,j1)
#
            PREPARE Xbjbj(b,j,b1,j1) = Tbjbj(b,j,b1,j1)  
      ENDPARDO b, j, b1, j1 
#
      execute sip_barrier 
      execute server_barrier 
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
         execute sip_barrier
#
         PARDO a, i, iatom, ix 
               GET                           QTai(a,i,iatom,ix)
               tai(a,i)                    = QTai(a,i,iatom,ix)
               execute energy_denominator    tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               PUT Cainew(a,i,iatom,ix)    = tai(a,i)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
         ENDPARDO a, i, iatom, ix 
#
         PARDO b, j, iatom, ix 
               GET                         QTbj(b,j,iatom,ix)
               tbj(b,j)                  = QTbj(b,j,iatom,ix)
               execute energy_denominator  tbj(b,j)
               etemp = tbj(b,j)*tbj(b,j)
               PUT Cbjnew(b,j,iatom,ix)  = tbj(b,j)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
         ENDPARDO b, j, iatom, ix 
#
         execute sip_barrier 
#
         PARDO a, i, a1, i1 
#
            REQUEST Xaiai(a,i,a1,i1) a  
#
            DO iatom 
            DO ix  
#
               GET                         Caiold(a1,i1,iatom,ix)
               t1ai(a1,i1)               = Caiold(a1,i1,iatom,ix) 
               tai(a,i)                  = Xaiai(a,i,a1,i1)*t1ai(a1,i1)
               execute energy_denominator  tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               taixx(a,i,iatom,ix)       = tai(a,i) 
               PUT Cainew(a,i,iatom,ix) += taixx(a,i,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix  
            ENDDO iatom 
#
         ENDPARDO a, i, a1, i1 
#
         PARDO a, i, b, j 
#
            REQUEST Xaibj(a,i,b,j) a  
#
            DO iatom 
            DO ix  
#
               GET                         Cbjold(b,j,iatom,ix)
               tbj(b,j)                  = Cbjold(b,j,iatom,ix)  
               tai(a,i)                  = Xaibj(a,i,b,j)*tbj(b,j)
               execute energy_denominator  tai(a,i)
               etemp = tai(a,i)*tai(a,i)
               taixx(a,i,iatom,ix)       = tai(a,i) 
               PUT Cainew(a,i,iatom,ix) += taixx(a,i,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix
            ENDDO iatom
#
            DO iatom
            DO ix
#
               GET                         Caiold(a,i,iatom,ix)
               tai(a,i)                   = Caiold(a,i,iatom,ix) 
               tbj(b,j)                   = Xaibj(a,i,b,j)*tai(a,i)
               execute energy_denominator   tbj(b,j)
               etemp = tbj(b,j)*tbj(b,j)
               tbjxx(b,j,iatom,ix)        = tbj(b,j) 
               PUT Cbjnew(b,j,iatom,ix)  += tbjxx(b,j,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix  
            ENDDO iatom 
#
         ENDPARDO a, i, b, j  
#
         PARDO b, j, b1, j1 
#
            REQUEST Xbjbj(b,j,b1,j1) b  
#
            DO iatom 
            DO ix  
#
               GET                          Cbjold(b1,j1,iatom,ix)
               t1bj(b1,j1)                = Cbjold(b1,j1,iatom,ix) 
               tbj(b,j)                   = Xbjbj(b,j,b1,j1)*t1bj(b1,j1)
               execute energy_denominator   tbj(b,j)
               etemp = tbj(b,j)*tbj(b,j)
               tbjxx(b,j,iatom,ix)        = tbj(b,j) 
               PUT Cbjnew(b,j,iatom,ix)  += tbjxx(b,j,iatom,ix)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix  
            ENDDO iatom 
#
         ENDPARDO b, j, b1, j1 
#
         execute sip_barrier 
         esum = 0.0 
         execute sip_barrier 
#
         PARDO a, i
#
            DO iatom 
            DO ix  
#
               GET        Cainew(a,i,iatom,ix)
               tai(a,i) = Cainew(a,i,iatom,ix) 
               etemp    = tai(a,i)*tai(a,i)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix  
            ENDDO iatom 
#
         ENDPARDO a, i 
#
         PARDO b, j
#
            DO iatom 
            DO ix  
#
               GET        Cbjnew(b,j,iatom,ix)
               tbj(b,j) = Cbjnew(b,j,iatom,ix) 
               etemp    = tbj(b,j)*tbj(b,j)
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
               esum += etemp
#
            ENDDO ix  
            ENDDO iatom 
#
         ENDPARDO b, j 
#
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_CAI
         execute server_barrier 
         execute sip_barrier 
#
         collective enew += esum
#
#        Reset 'old' density to 'current' one.
#        -------------------------------------
#
         PARDO a, i, iatom, ix
               GET                        Cainew(a,i,iatom,ix)
               PUT Caiold(a,i,iatom,ix) = Cainew(a,i,iatom,ix)
               PUT Daiold_a(a,i)        = Cainew(a,i,iatom,ix)
         ENDPARDO a, i, iatom, ix
#
         PARDO b, j, iatom, ix
               GET                        Cbjnew(b,j,iatom,ix)
               PUT Cbjold(b,j,iatom,ix) = Cbjnew(b,j,iatom,ix)
               PUT Daiold_b(b,j)        = Cbjnew(b,j,iatom,ix)
         ENDPARDO b, j, iatom, ix
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
         execute print_scalar eold
#
         if kiter == 2
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom 
            DO ix 
               PARDO a, i 
                     GET eT1ai(a,i,iatom,ix) 
                     GET eT2ai(a,i,iatom,ix) 
                     GET dT0ai(a,i,iatom,ix) 
                     GET dT1ai(a,i,iatom,ix) 
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix) 
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix) 
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix) 
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix) 
               ENDPARDO a, i 
               PARDO b, j 
                     GET eT1bj(b,j,iatom,ix) 
                     GET eT2bj(b,j,iatom,ix) 
                     GET dT0bj(b,j,iatom,ix) 
                     GET dT1bj(b,j,iatom,ix) 
                     PUT e1bj(b,j) = eT1bj(b,j,iatom,ix) 
                     PUT e2bj(b,j) = eT2bj(b,j,iatom,ix) 
                     PUT d0bj(b,j) = dT0bj(b,j,iatom,ix) 
                     PUT d1bj(b,j) = dT1bj(b,j,iatom,ix) 
               ENDPARDO b, j 
               CALL DIIS1
               PARDO a, i
                     GET Daiold_a(a,i)
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i)
               ENDPARDO a, i
               PARDO b, j
                     GET Daiold_b(b,j)
                     PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j)
               ENDPARDO b, j
            ENDDO ix 
            ENDDO iatom 
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom 
            DO ix 
               PARDO a, i 
                     GET eT1ai(a,i,iatom,ix) 
                     GET eT2ai(a,i,iatom,ix) 
                     GET eT3ai(a,i,iatom,ix) 
                     GET dT0ai(a,i,iatom,ix) 
                     GET dT1ai(a,i,iatom,ix) 
                     GET dT2ai(a,i,iatom,ix) 
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix) 
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix) 
                     PUT e3ai(a,i) = eT3ai(a,i,iatom,ix) 
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix) 
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix) 
                     PUT d2ai(a,i) = dT2ai(a,i,iatom,ix) 
               ENDPARDO a, i 
               PARDO b, j 
                     GET eT1bj(b,j,iatom,ix) 
                     GET eT2bj(b,j,iatom,ix) 
                     GET eT3bj(b,j,iatom,ix) 
                     GET dT0bj(b,j,iatom,ix) 
                     GET dT1bj(b,j,iatom,ix) 
                     GET dT2bj(b,j,iatom,ix) 
                     PUT e1bj(b,j) = eT1bj(b,j,iatom,ix) 
                     PUT e2bj(b,j) = eT2bj(b,j,iatom,ix) 
                     PUT e3bj(b,j) = eT3bj(b,j,iatom,ix) 
                     PUT d0bj(b,j) = dT0bj(b,j,iatom,ix) 
                     PUT d1bj(b,j) = dT1bj(b,j,iatom,ix) 
                     PUT d2bj(b,j) = dT2bj(b,j,iatom,ix) 
               ENDPARDO b, j 
               CALL DIIS2
               PARDO a, i
                     GET Daiold_a(a,i)
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i)
               ENDPARDO a, i
               PARDO b, j
                     GET Daiold_b(b,j)
                     PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j)
               ENDPARDO b, j
            ENDDO ix 
            ENDDO iatom 
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom 
            DO ix 
               PARDO a, i 
                     GET eT1ai(a,i,iatom,ix) 
                     GET eT2ai(a,i,iatom,ix) 
                     GET eT3ai(a,i,iatom,ix) 
                     GET eT4ai(a,i,iatom,ix) 
                     GET dT0ai(a,i,iatom,ix) 
                     GET dT1ai(a,i,iatom,ix) 
                     GET dT2ai(a,i,iatom,ix) 
                     GET dT3ai(a,i,iatom,ix) 
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix) 
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix) 
                     PUT e3ai(a,i) = eT3ai(a,i,iatom,ix) 
                     PUT e4ai(a,i) = eT4ai(a,i,iatom,ix) 
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix) 
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix) 
                     PUT d2ai(a,i) = dT2ai(a,i,iatom,ix) 
                     PUT d3ai(a,i) = dT3ai(a,i,iatom,ix) 
               ENDPARDO a, i 
               PARDO b, j 
                     GET eT1bj(b,j,iatom,ix) 
                     GET eT2bj(b,j,iatom,ix) 
                     GET eT3bj(b,j,iatom,ix) 
                     GET eT4bj(b,j,iatom,ix) 
                     GET dT0bj(b,j,iatom,ix) 
                     GET dT1bj(b,j,iatom,ix) 
                     GET dT2bj(b,j,iatom,ix) 
                     GET dT3bj(b,j,iatom,ix) 
                     PUT e1bj(b,j) = eT1bj(b,j,iatom,ix) 
                     PUT e2bj(b,j) = eT2bj(b,j,iatom,ix) 
                     PUT e3bj(b,j) = eT3bj(b,j,iatom,ix) 
                     PUT e4bj(b,j) = eT4bj(b,j,iatom,ix) 
                     PUT d0bj(b,j) = dT0bj(b,j,iatom,ix) 
                     PUT d1bj(b,j) = dT1bj(b,j,iatom,ix) 
                     PUT d2bj(b,j) = dT2bj(b,j,iatom,ix) 
                     PUT d3bj(b,j) = dT3bj(b,j,iatom,ix) 
               ENDPARDO b, j 
               CALL DIIS3
               PARDO a, i
                     GET Daiold_a(a,i)
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i)
               ENDPARDO a, i
               PARDO b, j
                     GET Daiold_b(b,j)
                     PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j)
               ENDPARDO b, j
            ENDDO ix 
            ENDDO iatom 
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get updated amplitudes based on DIIS procedure.
#           -----------------------------------------------
            DO iatom 
            DO ix 
               PARDO a, i 
                     GET eT1ai(a,i,iatom,ix) 
                     GET eT2ai(a,i,iatom,ix) 
                     GET eT3ai(a,i,iatom,ix) 
                     GET eT4ai(a,i,iatom,ix) 
                     GET eT5ai(a,i,iatom,ix) 
                     GET dT0ai(a,i,iatom,ix) 
                     GET dT1ai(a,i,iatom,ix) 
                     GET dT2ai(a,i,iatom,ix) 
                     GET dT3ai(a,i,iatom,ix) 
                     GET dT4ai(a,i,iatom,ix) 
                     PUT e1ai(a,i) = eT1ai(a,i,iatom,ix) 
                     PUT e2ai(a,i) = eT2ai(a,i,iatom,ix) 
                     PUT e3ai(a,i) = eT3ai(a,i,iatom,ix) 
                     PUT e4ai(a,i) = eT4ai(a,i,iatom,ix) 
                     PUT e5ai(a,i) = eT5ai(a,i,iatom,ix) 
                     PUT d0ai(a,i) = dT0ai(a,i,iatom,ix) 
                     PUT d1ai(a,i) = dT1ai(a,i,iatom,ix) 
                     PUT d2ai(a,i) = dT2ai(a,i,iatom,ix) 
                     PUT d3ai(a,i) = dT3ai(a,i,iatom,ix) 
                     PUT d4ai(a,i) = dT4ai(a,i,iatom,ix) 
               ENDPARDO a, i 
               PARDO b, j 
                     GET eT1bj(b,j,iatom,ix) 
                     GET eT2bj(b,j,iatom,ix) 
                     GET eT3bj(b,j,iatom,ix) 
                     GET eT4bj(b,j,iatom,ix) 
                     GET eT5bj(b,j,iatom,ix) 
                     GET dT0bj(b,j,iatom,ix) 
                     GET dT1bj(b,j,iatom,ix) 
                     GET dT2bj(b,j,iatom,ix) 
                     GET dT3bj(b,j,iatom,ix) 
                     GET dT4bj(b,j,iatom,ix) 
                     PUT e1bj(b,j) = eT1bj(b,j,iatom,ix) 
                     PUT e2bj(b,j) = eT2bj(b,j,iatom,ix) 
                     PUT e3bj(b,j) = eT3bj(b,j,iatom,ix) 
                     PUT e4bj(b,j) = eT4bj(b,j,iatom,ix) 
                     PUT e5bj(b,j) = eT5bj(b,j,iatom,ix) 
                     PUT d0bj(b,j) = dT0bj(b,j,iatom,ix) 
                     PUT d1bj(b,j) = dT1bj(b,j,iatom,ix) 
                     PUT d2bj(b,j) = dT2bj(b,j,iatom,ix) 
                     PUT d3bj(b,j) = dT3bj(b,j,iatom,ix) 
                     PUT d4bj(b,j) = dT4bj(b,j,iatom,ix) 
               ENDPARDO b, j 
               CALL DIIS4
               CALL MOVE4 
               PARDO a, i
                     GET Daiold_a(a,i)
                     PUT Caiold(a,i,iatom,ix) = Daiold_a(a,i)
               ENDPARDO a, i
               PARDO b, j
                     GET Daiold_b(b,j)
                     PUT Cbjold(b,j,iatom,ix) = Daiold_b(b,j)
               ENDPARDO b, j
               PARDO a, i
                     GET e1ai(a,i)
                     GET e2ai(a,i)
                     GET e3ai(a,i)
                     GET e4ai(a,i)
                     GET e5ai(a,i)
                     GET d0ai(a,i)
                     GET d1ai(a,i)
                     GET d2ai(a,i)
                     GET d3ai(a,i)
                     GET d4ai(a,i)
                     PUT eT1ai(a,i,iatom,ix) = e1ai(a,i)
                     PUT eT2ai(a,i,iatom,ix) = e2ai(a,i)
                     PUT eT3ai(a,i,iatom,ix) = e3ai(a,i)
                     PUT eT4ai(a,i,iatom,ix) = e4ai(a,i)
                     PUT eT5ai(a,i,iatom,ix) = e5ai(a,i)
                     PUT dT0ai(a,i,iatom,ix) = d0ai(a,i)
                     PUT dT1ai(a,i,iatom,ix) = d1ai(a,i)
                     PUT dT2ai(a,i,iatom,ix) = d2ai(a,i)
                     PUT dT3ai(a,i,iatom,ix) = d3ai(a,i)
                     PUT dT4ai(a,i,iatom,ix) = d4ai(a,i)
               ENDPARDO a, i
               PARDO b, j
                     GET e1bj(b,j)
                     GET e2bj(b,j)
                     GET e3bj(b,j)
                     GET e4bj(b,j)
                     GET e5bj(b,j)
                     GET d0bj(b,j)
                     GET d1bj(b,j)
                     GET d2bj(b,j)
                     GET d3bj(b,j)
                     GET d4bj(b,j)
                     PUT eT1bj(b,j,iatom,ix) = e1bj(b,j)
                     PUT eT2bj(b,j,iatom,ix) = e2bj(b,j)
                     PUT eT3bj(b,j,iatom,ix) = e3bj(b,j)
                     PUT eT4bj(b,j,iatom,ix) = e4bj(b,j)
                     PUT eT5bj(b,j,iatom,ix) = e5bj(b,j)
                     PUT dT0bj(b,j,iatom,ix) = d0bj(b,j)
                     PUT dT1bj(b,j,iatom,ix) = d1bj(b,j)
                     PUT dT2bj(b,j,iatom,ix) = d2bj(b,j)
                     PUT dT3bj(b,j,iatom,ix) = d3bj(b,j)
                     PUT dT4bj(b,j,iatom,ix) = d4bj(b,j)
               ENDPARDO b, j
            ENDDO ix 
            ENDDO iatom 
#
         endif # kiter == 5
#
         execute sip_barrier 
         CALL MOVE_CAI
#
      ENDDO kiter
#
      execute sip_barrier 
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i, iatom, ix  
            GET                           Cainew(a,i,iatom,ix)
            PREPARE CPHFa(a,i,iatom,ix) = Cainew(a,i,iatom,ix)  
      ENDPARDO a, i, iatom, ix  
#
      PARDO b, j, iatom, ix  
            GET                           Cbjnew(b,j,iatom,ix)
            PREPARE CPHFb(b,j,iatom,ix) = Cbjnew(b,j,iatom, ix) 
      ENDPARDO b, j, iatom, ix  
#
      execute sip_barrier 
      delete Cainew 
      delete Caiold 
      delete Cbjnew 
      delete Cbjold 
#
      delete eT1ai
      delete eT2ai
      delete eT3ai
      delete eT4ai
      delete eT5ai
      delete dT1ai
      delete dT2ai
      delete dT3ai
      delete dT4ai
      delete dT0ai
      delete eT1bj
      delete eT2bj
      delete eT3bj
      delete eT4bj
      delete eT5bj
      delete dT1bj
      delete dT2bj
      delete dT3bj
      delete dT4bj
      delete dT0bj
#
      ENDPROC FORM_UCAI  
#     -----------------
#
# ----------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
#                  BEGIN  MAIN PROGRAM 
#
# ---------------------------------------------------------------------------
#
# First compute unperturbed quantities
# ------------------------------------
#
#     1. 2-electron integral transformation 
#     2. First order amplitudes T2aiai, T2bjbj, T2aibj   
#     3. Intermediate Ipq/Xai  
#     4. Density Dpq  
#
# 1. Two-electron integral transformation. 
# ---------------------------------------- 
#
      execute sip_barrier 
      execute print_scalar etemp 
      CALL TRAN_UHF
      execute print_scalar etemp 
#
# 2. First order amplitudes T2aiai, T2bjbj, T2aibj, t1ai, t2bj. 
# -------------------------------------------------------------  
#
      ecrit = 0.00000001 
#
      execute sip_barrier 
      execute server_barrier 
#
# 3. Occupied-occupied and virtual-virtual blocks of the density.
# ---------------------------------------------------------------
#
     #CALL DENSIJ
     #CALL DENSAB
      CALL HFDENS
      execute print_scalar etemp 
      execute sip_barrier 
#
# 4. One-particle intermediates Ipq and Xai and virtual-occupied block of the density.
# ------------------------------------------------------------------------------------
#
     #CALL PINTER
     #execute sip_barrier 
      CALL CDENSAI
      execute print_scalar etemp 
     #execute sip_barrier 
#
# 5. Compute 'directly' computed intermediates. 
# --------------------------------------------- 
#
# Done compute unperturbed quantities.
# ------------------------------------
#
#     Now consider the contributions from second-derivative integrals.
#     ----------------------------------------------------------------
#
#     Transform the intermediates I to the AO basis.
#     ----------------------------------------------
#
      CALL I_HF
      execute print_scalar etemp 
#
#     Transform the one-particle density to the AO basis.
#     ---------------------------------------------------
#
      execute sip_barrier 
#
#     'Contract' the backtransformed intermediates with S''.
#     ------------------------------------------------------
#
      CALL SXY_CONT   # Passed 
      execute print_scalar etemp 
#
#     'Contract' the backtransformed density with H''.
#     ------------------------------------------------
#
      CALL DXY_CONT # Passed  
      execute print_scalar etemp 
#
#     'Contract' the backtransformed gamma array with <mu nu|lambda sigma>^x.
#     -----------------------------------------------------------------------
#
      execute sip_barrier
      CALL GIJAB_CONT  
      execute sip_barrier
      execute print_scalar etemp 
#
#     Compute quantities depending on the perturbed two-electron derivative
#     integrals. 
#     --------------------------------------------------------------------- 
#
      CALL ALLTRAN_VX_XIXI
      execute sip_barrier
      execute print_scalar etemp 
      CALL FORM_UCAI  
      execute print_scalar etemp 
      execute sip_barrier
#
# Loop over unique Hessian elements. The Hessian will be viewed as a two
# dimensional array HESS(x,y). The first loop will be over y the second
# over x. Contributions from products of first derivatives will be
# considered first.
# ----------------------------------------------------------------------
#
      DO jatom 
#
      IF jatom >= jhess1 
      IF jatom <= jhess2 
#
      DO jx 
#
         execute sip_barrier 
         execute server_barrier 
#
#        Set flags --> perturbation. 
#        --------------------------- 
#
         execute set_flags2 dflags2(jatom,jx)   
#
#        Compute the perturbed quantities DTpppi, DTqqqj, DTppqi
#        and DTqqpi.
#        --> Transformed first-derivative two-electron integrals.
#        ------------------------------------------------------------
#
         CALL DINT_GET  
         CALL DINT_TRAN 
#
#        Compute the perturbed quantities Fya and Fyb, Sya and Syb.
#        --> Transformed first-derivative one-electron integrals.
#        ------------------------------------------------------------
#
         CALL SINTY_TRAN 
#
#        Compute CHF coefficients. 
#        ------------------------- 
#
#########CALL QYAI_H
         CALL Uy_XX
         execute sip_barrier
         CALL FORM_UYAI
         execute sip_barrier
#
         CALL FINTY_TRAN 
         execute sip_barrier 
#
#        Prepare perturbed arrays used to complete the HF hessian. 
#        --------------------------------------------------------- 
#
         CALL FSCF_HESS 
         execute sip_barrier 

#        Compute complete two-electron integral derivatives AND 
#        complete derivatives of T-amplitudes. 
#        --------------------------------------------------- 
#
         DO iatom 
#
         IF iatom >= ihess1 
         IF iatom <= ihess2 
#
         DO ix 
#
#           Zero out the hessian element. 
#           ----------------------------- 
#
            hessxy                   = 0.0 
            phessxy                  = 0.0 
            thess(jatom,jx,iatom,ix) = 1.0 
#
            hessyx                   = 0.0 
            phessyx                  = 0.0 
            xhess(iatom,ix,jatom,jx) = 1.0 
#
#           Set flags --> perturbation. 
#           --------------------------- 
#
            execute set_flags2 dflags2(iatom,ix)   
#
#           Form transformed perturbed two-electron integrals. 
#           -------------------------------------------------- 
#
           #CALL TRAN_VX_XIXI 
            execute sip_barrier 
#
#           Compute the perturbed quantities Fxa and Fxb, Sxa and Sxb.
#           --> Transformed first-derivative one-electron integrals.
#           ----------------------------------------------------------
#
            CALL SINTX_TRAN 
#
#           Remove x-perturbed distributed arrays. 
#           -------------------------------------- 
#
            execute sip_barrier
            execute print_scalar hessxy  
#
           #delete Hxa 
           #delete Hxb 
#
           #delete Fxa 
           #delete Fxb 
           #delete Sxa 
           #delete Sxb 
           #delete Uxaa  
           #delete Uxbb  
           #delete Qxai 
           #delete Qxbj 
#
           #delete QAxx
           #delete QBxx
           #delete QABxx
#
            execute server_barrier
#
            collective phessxy       += hessxy  
            thess(jatom,jx,iatom,ix) *= phessxy  
            execute                     read_hess thess(jatom,jx,iatom,ix) 
#
            collective phessyx       += hessyx  
            xhess(iatom,ix,jatom,jx) *= phessyx  
            execute                     read_hess xhess(iatom,ix,jatom,jx) 
#
         ENDDO ix 
#
         ENDIF 
         ENDIF 
#
         ENDDO iatom 
#
#        Remove distributed arrays not used anymore. 
#        ------------------------------------------- 
#
         execute sip_barrier 
#
         delete Fya 
         delete Fyb 
         delete Sya 
         delete Syb 
         delete Uyaa  
         delete Uybb  
         delete Qyai 
         delete Qybj 
         delete dhfya 
         delete dhfyb 
         delete whfya 
         delete whfyb 
#
         delete QAyy 
         delete QByy 
         delete QAByy 
#
      ENDDO jx 
#
      ENDIF 
      ENDIF 
#
      ENDDO jatom 
#
#     Print out the final hessian without the nuclear-nuclear contribution. 
#     --------------------------------------------------------------------- 
#
                   ENDSIAL UHF_HESS_SCF   
#
# ---------------------------------------------------------------------------
#
