#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                    SIAL UHF_HESS_SV1_OPT2  
#
# ---------------------------------------------------------------------------
#
#    PROCEDURE                 OPITIMIZATION 
#
# ---------------------------------------------------------------------------
#
#    PROC TRAN_TRAN2           DONE 
#    PROC TRAN_TRAN3           DONE 
#    PROC TRAN_TRAN4           DONE 
#    PROC CREATE_MOINTS        DONE 
#    PROC TRAN_UHF             DONE 
#    PROC UHF_ENERGY           DONE 
#    PROC T2AA_REFERANCE       DONE 
#    PROC T2BB_REFERANCE       DONE 
#    PROC T2AB_REFERANCE       DONE 
#    PROC PINTER               DONE 
#    PROC DENSIJ
#    PROC DENSAB
#    PROC DENSAI
#    PROC FORM_UYAI            DONE  
#    PROC FORM_UXAI            DONE  
#    PROC DINT_TRAN 
#    PROC TRAN_VX_XIXI         DONE  
#    PROC QYAI_H 
#    PROC QXAI_H 
#    PROC FINTY_TRAN 
#    PROC FINTX_TRAN 
#    PROC SINTY_TRAN 
#    PROC SINTX_TRAN 
#    PROC Uy_XX                DONE  
#    PROC Ux_XX                DONE  
#    PROC I_TRANS
#    PROC D_TRANS
#    PROC I_HF
#    PROC HFDENS
#    PROC I11
#    PROC SXY_CONT
#    PROC DXY_CONT
#    PROC GIJAB_CONT
#    PROC FSCF_HESS               DONE  
#    PROC FORMDDAB 
#    PROC FORMDDIJ 
#    PROC PART1                   DONE  
#    PROC PART2                   DONE  
#    PROC PART4                   DONE  
#    PROC PART5                   DONE  
#    PROC PART6                   DONE  
#    PROC DERIIJ                  DONE  
#    PROC DERIAB                  DONE  
#    PROC DERIAI                  DONE  
#    PROC PART3                   DONE  
#    PROC DERVYFULLAB             DONE  
#    PROC DERVYFULLAA             DONE 
#    PROC DERVYFULLBB             DONE  
#    PROC FORMDXAI                DONE 
#    PROC FORMDDAI                DONE 
#    PROC DT2AMP                  OBSOLETE  
#
# ---------------------------------------------------------------------------
#
# Final set of of fully transformed integrals INCLUDING the 4-virtual ones.
#
# ---------------------------------------------------------------------------
#
#                          Integral     Type
#                         ------------------------
#                         VSpipi       SERVED  
#                         Vaaii        SERVED  
#                         Viaai        SERVED 
#                         VSaaai       SERVED  
#                         Vaaai        SERVED  
#
#                         Vpiqj        SERVED  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
# Declare indices. 
# ---------------- 
#
     index   kiter  = 1, 500 
     index   iatom  = 1, natoms  
     index   ix     = 1, 3  
     index   jatom  = 1, natoms  
     index   jx     = 1, 3  
#
     aoindex mu     = 1, norb
     aoindex nu     = 1, norb
     aoindex lambda = 1, norb
     aoindex sigma  = 1, norb
#
     moaindex i = baocc, eaocc
     moaindex i1= baocc, eaocc
     moaindex i2= baocc, eaocc
     moaindex i3= baocc, eaocc
     moaindex i4= baocc, eaocc
#
     moaindex a = bavirt, eavirt
     moaindex a1= bavirt, eavirt
     moaindex a2= bavirt, eavirt
     moaindex a3= bavirt, eavirt
     moaindex a4= bavirt, eavirt
#
     moaindex j = baocc, eaocc
     moaindex j1= baocc, eaocc
     moaindex j2= baocc, eaocc
     moaindex j3= baocc, eaocc
     moaindex j4= baocc, eaocc
#
     moaindex b = bavirt, eavirt
     moaindex b1= bavirt, eavirt
     moaindex b2= bavirt, eavirt
     moaindex b3= bavirt, eavirt
     moaindex b4= bavirt, eavirt
#
     moaindex p = baocc, eavirt
     moaindex p1= baocc, eavirt
     moaindex p2= baocc, eavirt
     moaindex p3= baocc, eavirt
#
     moaindex q = baocc, eavirt
     moaindex q1= baocc, eavirt
     moaindex q2= baocc, eavirt
     moaindex q3= baocc, eavirt
#
# Declare served arrays. 
# ----------------------
#
     served saoint(mu,nu,lambda,sigma) 
     static dflagsi2(iatom,ix) 
     static dflagsj2(jatom,jx) 
     static dflags4(jatom,jx,iatom,ix) 
     temp thess(jatom,jx,iatom,ix) 
     temp xhess(iatom,ix,jatom,jx) 
#
# Declare distributed arrays. 
# --------------------------- 
#
     served VXxixi(mu,i,nu,i1) 
     served VXxixj(mu,i,nu,j) 
     served VXxjxj(mu,j,nu,j1) 
     served VXxipi(mu,i,a1,i1) 
     served VXxiqj(mu,i,b,j) 
     served VXxjqj(mu,j,b1,j1) 
     served VXpipi(a,i,a1,i1) 
#
     served Vxixi(mu,i,nu,i1) 
     served Vxixj(mu,i,nu,j) 
#
     served T1aiai_aa(a,i,a1,i1)#----|  
     served T1aibj_ab(a,i,b,j)  #    |--> Unperturbed amplitudes   
     served DTpppi(p,p1,p2,i)#-------|  
#
     served T2yFullaa(a,i,a1,i1)#    |  
     served T2yFullab(a,i,b,j)#      |  
#
     served DTxxpi(mu,nu,p,i) 
     served DTxppi(mu,p1,p,i) 
     served DTxqpi(mu,q,p,i) 
#
     distributed Dij_a(i,i1)#-------------|  
     distributed Dab_a(a,a1)#             |  
     distributed Dai_a(a,i) #             |  
     distributed Daiold_a(a,i) 
     distributed Dainew_a(a,i) 
     distributed Iij_a(i,i1) 
     distributed Iai_a(a,i) 
     distributed Iab_a(a,a1) 
     distributed Ipq_a(p,p1) 
     distributed Xai_a(a,i) 
     distributed Ixx_a(mu,nu) 
     distributed Dxx_a(mu,nu) 
     distributed Dpq_a(p,p1) 
     distributed Ihf(mu,nu) 
     distributed Dhfa(mu,nu) 
     distributed Dhfb(mu,nu) 
#
     distributed Uxaa(p,p1) 
     distributed Uyaa(p,p1) 
     distributed Fxaa(p,p1) 
     distributed Fyaa(p,p1) 
     distributed Fxai(a,i) 
     distributed Fya(p,p1) 
     distributed Fxa(p,p1) 

     distributed Hxa(p,p1) 
     distributed Hya(p,p1) 
     distributed Sya(p,p1) 
     distributed Sxa(p,p1) 
     distributed FA(p,p1) 
     distributed FB(q,q1) 
     distributed Qyai(a,i)  
     distributed Qxai(a,i)  
#
     distributed QAByy(mu,sigma) 
     distributed QAyy(mu,sigma) 
     distributed QByy(mu,sigma) 
     distributed QABxx(mu,sigma) 
     distributed QAxx(mu,sigma) 
     distributed QBxx(mu,sigma) 
     distributed QAB(mu,sigma) 
     distributed QA(mu,sigma) 
     distributed QB(mu,sigma) 
     distributed Uyai(a,i)   
     distributed Uxai(a,i)   
     distributed Uyaiold(a,i)   
     distributed Uxaiold(a,i)   
     distributed XAB(mu,nu) 
     distributed XA(mu,nu) 
     distributed XB(mu,nu) 
     distributed YAB(mu,nu) 
     distributed YA(mu,nu) 
     distributed YB(mu,nu) 
     distributed Ha(p,p1) 
     distributed Hb(q,q1) 
     distributed ID_a(p,p1)  
     distributed ID_b(q,q1)  
#
     distributed cya(mu,p) 
     distributed cxa(mu,p) 
     distributed cxb(mu,q) 
     distributed dhfya(mu,nu) 
     distributed dhfxa(mu,nu) 
     distributed whfya(mu,nu) 
     distributed whfa(mu,nu) 
     distributed whfb(mu,nu) 
     distributed D1pp(p,p1) 
     distributed D2pp(p,p1) 
     distributed D1qq(q,q1) 
     distributed D2qq(q,q1) 
#
# Declare arrays used in the transformation of the two-electron integrals. 
# ------------------------------------------------------------------------ 
#
      served Sxixi(mu,i,nu,i1) 
      served Sxixj(mu,i,nu,j) 
      served Sxjxj(mu,j,nu,j1) 
#
      served Vxxxi(mu,nu,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
      served Vxipi(mu,i,p,i1)
      served Vixai(i,mu,a,i1)
      served Vxaii(mu,a,i,i1)
      served Vxaai(mu,a1,a,i)
      served Vxxai(mu,nu,a,i)
      served Vxxxa(mu,nu,lambda,a) 
      served Vxxaa(mu,nu,a1,a) 
      served Vxaaa(mu,a2,a1,a) 
#
      served VSpipi(p1,i,p,i1)
      served Viaai(i,a1,a,i1)
      served Vaaii(a,a1,i,i1)
      served Vaaai(a2,a,a1,i)
      served VSaaai(a2,a,a1,i)
#
      served Vxxxj(mu,nu,lambda,j)
      served Vxxjj(mu,nu,j1,j)
      served Vjxxj(j1,nu,lambda,j)
      served Vxjqj(mu,j,q,j1)
      served Vxbjj(mu,b,j,j1)
      served Vxbbj(mu,b1,b,j)
      served Vxxbj(mu,nu,b,j)
      served Vjxbj(j,mu,b,j1)
      served Vxxxb(mu,nu,lambda,b) 
      served Vxxbb(mu,nu,b1,b) 
      served Vxbbb(mu,b2,b1,b) 
#
      served Vxbii(mu,b,i,i1)
      served Vxbai(mu,b,a,i)
      served Vxabb(mu,a,b1,b) 
#
      served Vxiqj(mu,i,q,j)
      served Vxajj(mu,a,j,j1)
      served Vxabj(mu,a,b,j)
      served Vxxij(mu,nu,i,j)
      served Vixxj(i,mu,nu,j)
      served Vixbj(i,mu,b,j)
      served Vpiqj(p,i,q,j)
      temp Txjxj(mu,j1,lambda,j)
      temp T1xjxj(mu,j1,lambda,j)
      temp Txxjj(mu,nu,j1,j)
      temp T1xxjj(mu,nu,j1,j)
      temp Tjjxx(j1,nu,lambda,j)
      temp Tjxxj(j1,nu,lambda,j)
      temp T1jxxj(j1,nu,lambda,j)
      temp Txjqj(mu,j,q,j1)
      temp T1xjqj(mu,j,q,j1)
      temp Tqjqj(q1,j,q,j1)
      temp T1qjqj(q1,j,q,j1)
      temp Tjxbj(j,mu,b,j1)
      temp T1jxbj(j,mu,b,j1)
      temp Txbjj(mu,b,j,j1)
      temp T1xbjj(mu,b,j,j1)
      temp Tjbbj(j,b1,b,j1)
      temp T1jbbj(j,b1,b,j1)
      temp Tbbjj(b,b1,j,j1)
      temp T1bbjj(b,b1,j,j1)
      temp Txbbj(mu,b1,b,j)
      temp T1xbbj(mu,b1,b,j)
      temp Tbbbj(b2,b,b1,j)
      temp T1bbbj(b2,b,b1,j)
      temp Txxbj(mu,nu,b,j)
      temp Txixj(mu,i,nu,j)
      temp T1xixj(mu,i,nu,j)
      temp Txiqj(mu,i,q,j)
      temp T1xiqj(mu,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp T1piqj(p,i,q,j)
      temp Tiixx(i,i1,mu,nu)
      temp Tiixb(i,i1,mu,b)
      temp Tiibb(i,i1,b1,b)
      temp Txajj(mu,a,j,j1)
      temp T1xajj(mu,a,j,j1)
      temp Taajj(a,a1,j,j1)
      temp T1aajj(a,a1,j,j1)
      temp Txabj(mu,a,b,j)
      temp T1xabj(mu,a,b,j)
      temp Tixxj(i,mu,nu,j)
      temp Tixbj(i,mu,b,j)
      temp T1ixbj(i,mu,b,j)
      temp Tiabj(i,a,b,j)
      temp T1iabj(i,a,b,j)
      temp Taabj(a,a1,b,j)
      temp T1aabj(a,a1,b,j)
#
      temp Txbii(mu,b,i,i1)
      temp T1xbii(mu,b,i,i1)
      temp Tbbii(b,b1,i,i1)
      temp T1bbii(b,b1,i,i1)
      temp Tjbii(j,b,i,i1)
      temp T1jbii(j,b,i,i1)
      temp Txbai(mu,b,a,i)
      temp T1xbai(mu,b,a,i)
      temp Tbbai(b,b1,a,i)
      temp T1bbai(b,b1,a,i)
#
      temp Taaai(a,a1,a2,i)
      temp T1aaai(a,a1,a2,i)
      temp Txxai(mu,nu,a,i)
      temp Txaai(mu,a,a1,i)
      temp T1xaai(mu,a,a1,i)
      temp Txaii(mu,a,i,i1)
      temp T1xaii(mu,a,i,i1)
      temp Tiaai(i,a,a1,i1)
      temp T1iaai(i,a,a1,i1)
      temp Taaii(a,a1,i,i1)
      temp T1aaii(a,a1,i,i1)
      temp T1xxai(mu,nu,a,i)
      temp Tixai(i,mu,a,i1)
      temp T1ixai(i,mu,a,i1)
      temp Txipi(mu,i,p1,i1)
      temp T1xipi(mu,i,p1,i1)
      temp Tpipi(p,i,p1,i1)
      temp T1pipi(p,i,p1,i1)
      temp T1xxbj(mu,nu,b,j)
#
      temp Txxij(mu,nu,i,j)
      temp T1xxij(mu,nu,i,j)
      temp T1ixxj(i,mu,nu,j)
      temp Txxxi(mu,nu,lambda,i)
      temp T1xxxi(mu,nu,lambda,i)
      temp Txxxj(mu,nu,lambda,j)
      temp T1xxxj(mu,nu,lambda,j)
      temp Txixi(mu,i,nu,i1)
      temp T1xixi(mu,i,nu,i1)
      temp Txxii(mu,nu,i1,i)
      temp T1xxii(mu,nu,i1,i)
      temp Tixxi(i1,mu,nu,i)
      temp T1ixxi(i1,mu,nu,i)
      temp V0xxxi(mu,nu,lambda,i) 
      temp V2xxxi(mu,nu,sigma,i)  
      temp V0xxxj(mu,nu,lambda,j) 
      temp V2xxxj(mu,nu,sigma,j)  
#
      temp Txxxa(mu,nu,lambda,a)
      temp T1xxxa(mu,nu,lambda,a)
      temp Txxaa(mu,nu,a1,a)
      temp T1xxaa(mu,nu,a1,a)
      temp Txaaa(mu,a2,a1,a)
      temp T1xaaa(mu,a2,a1,a)
      temp Taaaa(a3,a2,a1,a)
      temp T1aaaa(a3,a2,a1,a)
#
      temp Txxxb(mu,nu,lambda,b)
      temp T1xxxb(mu,nu,lambda,b)
      temp Txxbb(mu,nu,b1,b)
      temp T1xxbb(mu,nu,b1,b)
      temp Txbbb(mu,b2,b1,b)
      temp T1xbbb(mu,b2,b1,b)
      temp Tbbbb(b3,b2,b1,b)
      temp T1bbbb(b3,b2,b1,b)
#
      temp Txabb(mu,a2,b1,b)
      temp T1xabb(mu,a2,b1,b)
      temp Taabb(a3,a2,b1,b)
      temp T1aabb(a3,a2,b1,b)
#
      temp tiiaa(i,i1,a,a1) 
      temp t1iiaa(i,i1,a,a1) 
      temp taiia(a,i,i1,a1) 
      temp t1aiia(a,i,i1,a1) 
#
      temp tjjbb(j,j1,b,b1) 
      temp t1jjbb(j,j1,b,b1) 
      temp tbjjb(b,j,j1,b1) 
      temp t1bjjb(b,j,j1,b1) 
#
      temp TSxxxx(mu,nu,lambda,sigma)
      temp T1xxxx(mu,nu,lambda,sigma)
      temp T2xxxi(mu,nu,lambda,i)
      temp T3xxxi(mu,nu,lambda,i)
      temp T4xxxi(mu,nu,lambda,i)
      temp T2xxxj(mu,nu,lambda,j)
      temp T3xxxj(mu,nu,lambda,j)
      temp T4xxxj(mu,nu,lambda,j)
      temp TAxxxi(mu,lambda,nu,i1)
      temp TBxxxi(mu,lambda,sigma,i1)
      temp TAxxxj(mu,lambda,nu,j1)
      temp TBxxxj(mu,lambda,sigma,j1)
#
# Declare integral arrays
# ------------------------
#
      served AOINT(mu,nu,lambda,sigma)
      local TAOINT(mu,nu,lambda,sigma)
      local L1xxxi(mu,nu,lambda,i)
      local L2xxxi(mu,lambda,nu,i)
      local L3xxxi(lambda,mu,nu,i)
      local L1xxxj(mu,nu,lambda,j)
      local L2xxxj(mu,lambda,nu,j)
      local L3xxxj(lambda,mu,nu,j)
      local Lxixi(mu,i,nu,i1)
      local Lxxii(mu,nu,i,i1)
      local Lixxi(i,mu,nu,i1)
      local Lxjxj(mu,j,nu,j1)
      local Lxxjj(mu,nu,j,j1)
      local Ljxxj(j,mu,nu,j1)
      local Lxxai(mu,nu,a,i)
      local Lxxbj(mu,nu,b,j)
      local Lxixj(mu,i,nu,j)
      local Lixxj(i,mu,nu,j)
      local Lxipi(mu,i,p,i1)
      local Lxaii(mu,a,i,i1)
      local Lixai(i,mu,a,i1)
      local L1xaai(mu,a,a1,i)
      local L2xaai(mu,a,a2,i)
      local Lxjqj(mu,j,q,j1)
      local Lxbjj(mu,b,j,j1)
      local Ljxbj(j,mu,b,j1)
      local Lxbbj(mu,b,b1,j)
      local Lxbii(mu,b,i,i1)
      local Lxbai(mu,b,a,i)
      local Lxiqj(mu,i,q,j)
      local Lxajj(mu,a,j,j1)
      local Lixbj(i,mu,b,j)
      local Lxabj(mu,a,b,j)
      local L1xbbj(mu,b,b1,j)
      local Lxxxa(mu,nu,lambda,a) 
      local Lxxxb(mu,nu,lambda,b) 
      local Lxxaa(mu,nu,a1,a) 
      local Lxxbb(mu,nu,b1,b) 
      local Lxaaa(mu,a,a1,a2) 
      local Lxbbb(mu,b,b1,b2) 
      local Lxabb(mu,a2,b1,b2) 
      local Laiai(a,i,a1,i1) 
      local Lbjbj(b,j,b1,j1) 
      local Laibj(a,i,b,j) 
#
      local LX1xixi(mu,i1,lambda,i) 
      local LX1xjxj(mu,j1,lambda,j) 
      local LX1xixj(mu,i,lambda,j) 
      local L2xixi(mu,i,nu,i1) 
      local L2xjxj(mu,j,nu,j1) 
      local L2xixj(mu,i,nu,j) 
      local L3xipi(mu,i,a,i1) 
      local L3xjqj(mu,j,b,j1) 
      local L3xiqj(mu,i,b,j) 
#
# Declare temporary arrays. 
# ------------------------- 
#
     temp Txxxp(mu,nu,lambda,p) 
     temp T1xxxp(mu,nu,lambda,p) 
     temp Txxpp(mu,nu,p1,p) 
     temp T1xxpp(mu,nu,p1,p) 
     temp Txppp(mu,p2,p1,p) 
     temp T1xppp(mu,p2,p1,p) 
     temp Tpppp(p3,p2,p1,p) 
     temp T1pppp(p3,p2,p1,p) 
     temp T2pppp(p3,p2,p1,p) 
     temp T3pppp(p3,p2,p1,p) 
#
     temp Txxxq(mu,nu,lambda,q) 
     temp T1xxxq(mu,nu,lambda,q) 
     temp Txxqq(mu,nu,q1,q) 
     temp T1xxqq(mu,nu,q1,q) 
     temp Txqqq(mu,q2,q1,q) 
     temp T1xqqq(mu,q2,q1,q) 
     temp Tqqqq(q3,q2,q1,q) 
     temp T1qqqq(q3,q2,q1,q) 
     temp T2qqqq(q3,q2,q1,q) 
     temp T3qqqq(q3,q2,q1,q) 
#
     temp Txpqq(mu,p,q1,q) 
     temp T1xpqq(mu,p,q1,q) 
     temp Tppqq(p1,p,q1,q) 
     temp T1ppqq(p1,p,q1,q) 
     temp T2ppqq(p1,p,q1,q) 
     temp Tqqpp(q,q1,p,p1) 
     temp T1qqpp(q,q1,p,p1) 
     temp T2qqpp(q,q1,p,p1) 
#
     temp Taiai(a,i,a1,i1) 
     temp T1aiai(a,i,a1,i1) 
     temp T2aiai(a,i,a1,i1) 
     temp T3aiai(a,i,a1,i1) 
     temp T4aiai(a,i,a1,i1) 
     temp Tbjbj(b,j,b1,j1) 
     temp T1bjbj(b,j,b1,j1) 
     temp T2bjbj(b,j,b1,j1) 
     temp T3bjbj(b,j,b1,j1) 
     temp T4bjbj(b,j,b1,j1) 
     temp Taibj(a,i,b,j) 
     temp T1aibj(a,i,b,j) 
     temp T2aibj(a,i,b,j) 
#
     temp Taiii(a,i,i1,i2)  
     temp T1aiii(a,i,i1,i2) 
     temp Taijj(a,i,j1,j) 
     temp T1aijj(a,i,j1,j) 
     temp Tbjjj(b,j,j2,j1)  
     temp T1bjjj(b,j,j2,j1) 
     temp Tiibj(i1,i,b,j)  
     temp T1iibj(i1,i,b,j) 
#
     temp Txiai(mu,i,a1,i1)
     temp T1xiai(mu,i,a1,i1)
     temp Txjbj(mu,j,b1,j1) 
     temp T1xjbj(mu,j,b1,j1) 
     temp Txibj(mu,i,b,j) 
     temp T1xibj(mu,i,b,j) 
     temp Txxxx(mu,lambda,nu,sigma) 
     temp Txxpi(mu,nu,p,i) 
     temp Txxqj(mu,nu,q,j) 
     temp Txppi(mu,p1,p,i) 
     temp Txqqj(mu,q1,q,j) 
     temp Txqpi(mu,q,p,i) 
     temp Txpqj(mu,p,q,j) 
     temp Tpppi(p,p1,p2,i) 
     temp Tqqqj(q,q1,q2,j) 
     temp Tppqj(p,p1,q,j) 
     temp Tqqpi(q,q1,p,i) 
#
     temp T1pppi(p,p1,p2,i) 
     temp T1qqqj(q,q1,q2,j) 
     temp T1ppqj(p,p1,q,j) 
     temp T1qqpi(q,q1,p,i) 
#
     temp Tii(i,i1) 
     temp T1ii(i,i1) 
     temp Tjj(j,j1) 
     temp T1jj(j,j1) 
     temp Taa(a,a1) 
     temp T1aa(a,a1) 
     temp Tbb(b,b1) 
     temp T1bb(b,b1) 
     temp Tai(a,i) 
     temp T1ai(a,i) 
     temp T2ai(a,i) 
     temp T3ai(a,i) 
     temp T4ai(a,i) 
     temp Tbj(b,j)
     temp T1bj(b,j)
     temp T2bj(b,j)
     temp T3bj(b,j)
     temp T4bj(b,j)
     temp Tia(i,a) 
     temp T1ia(i,a) 
     temp Tjb(j,b) 
     temp T1jb(j,b) 
     temp Txi(mu,i) 
     temp T1xi(mu,i) 
     temp Txj(mu,j) 
     temp T1xj(mu,j) 
     temp Txx(mu,nu) 
     temp Txa(mu,a) 
     temp Txb(mu,b) 
     temp tpp(p,p1) 
     temp t1pp(p,p1) 
     temp t2pp(p,p1) 
     temp t3pp(p,p1) 
     temp t4pp(p,p1) 
     temp tqq(q,q1) 
     temp t1qq(q,q1) 
     temp t2qq(q,q1) 
     temp t3qq(q,q1) 
     temp tpi(p,i) 
     temp t1pi(p,i) 
     temp tqj(q,j) 
     temp t1qj(q,j) 
#
     temp t1xx(mu,nu) 
     temp tpx(p,mu) 
     temp t1px(p,mu) 
     temp tqx(q,mu) 
     temp t1qx(q,mu) 
     temp txp(mu,p) 
     temp t1xp(mu,p) 
     temp txq(mu,q) 
     temp t1xq(mu,q) 
     temp tax(a,sigma) 
     temp tbx(b,sigma) 
#
# Declare local arrays. 
# --------------------- 

     temp daoint(mu,nu,lambda,sigma)
     temp faoint(mu,nu,lambda,sigma)
     temp D2(mu,lambda,nu,sigma)  
     local L1xxxp(mu,nu,lambda,p) 
     local L1xxxq(mu,nu,lambda,q) 
     local Lxxpp(mu,nu,p1,p) 
     local Lxxqq(mu,nu,q1,q) 
     local Lxppp(mu,p2,p1,p) 
     local Lxqqq(mu,q2,q1,q) 
     local Lxpqq(mu,p,q1,q) 
#
     local L1aiai(a,i2,a1,i1) 
     local L1aibj(a,i2,b,j) 
     local L1bjai(b,j2,a,i) 
     local L1bjbj(b,j2,b1,j1) 
     local L2aiai(a2,i,a1,i1) 
     local L2aibj(a1,i,b,j) 
     local L2bjbj(b2,j,b1,j1) 
     local L2bjai(b1,j,a,i) 
     local Dxxxi(mu,lambda,nu,i) 
     local Dxxxj(mu,lambda,nu,j) 
     local Exxpi(mu,lambda,p,i) 
     local Exxqj(mu,lambda,q,j) 
     local Fxppi(mu,p1,p,i) 
     local Fxqpi(mu,q,p,i) 
     local Fxqqj(mu,q1,q,j) 
     local Fxpqj(mu,p,q,j) 
     local Fpppi(p2,p1,p,i) 
     local Fqqqj(q2,q1,q,j) 
     local Fqqpi(q1,q,p,i) 
     local Fppqj(p1,p,q,j) 
#
     distributed zeta_a(p,p1) 
     distributed zeta_b(q,q1) 
     distributed zeta(mu,nu)  
#
# One-particle arrays used in 'NEW' implimentation. 
# ------------------------------------------------- 
#
     distributed Dyaa(a,a1) 
     distributed Dyii(i,i1)  
     distributed Dyai(a,i)  
     distributed DIii(i,i1)  
     distributed DIaa(a,a1)  
     distributed DIai(a,i)  
     distributed DXai(a,i)  
#
     distributed VYaibj(a,i,b,j) 
     distributed VYaajj(a,a1,j1,j)
     distributed VYbbii(b,b1,i1,i)
     distributed VYiabj(i,a,b,j) 
     distributed VYbbai(b1,b,a,i)
     distributed VYaabj(a1,a,b,j) 
     distributed VYiijj(i,i1,j,j1)
     distributed VYiibj(i,i1,b,j) 
     distributed VYjjai(j,j1,a,i)  
#
     distributed VYaiai(a,i,a1,i1) 
     distributed VYaaii(a,a1,i,i1) 
     distributed VYiaai(i,a1,a,i1) 
     distributed VYaaai(a2,a,a1,i) 
     distributed VYiiii(i,i2,i1,i3)
     distributed VYaiii(a,i2,i,i1) 
#
     distributed VYbjbj(b,j,b1,j1) 
     distributed VYbbjj(b,b1,j,j1) 
     distributed VYjbbj(j,b1,b,j1) 
     distributed VYbbbj(b2,b,b1,j) 
     distributed VYjjjj(j,j2,j1,j3)
     distributed VYbjjj(b,j2,j,j1) 
#
# Arrays and scalars  used in iterative computation of Dai
# --------------------------------------------------------
#
      distributed Doldai_a(a,i)
      distributed Dnewai_a(a,i)
      distributed Doldai_b(b,j)
      distributed Dnewai_b(b,j)
#
      distributed D0ai(a,i)
      distributed D1ai(a,i)
      distributed D2ai(a,i)
      distributed D3ai(a,i)
      distributed D4ai(a,i)
#
      distributed D0bj(b,j)
      distributed D1bj(b,j)
      distributed D2bj(b,j)
      distributed D3bj(b,j)
      distributed D4bj(b,j)
#
      distributed e1ai(a,i)
      distributed e2ai(a,i)
      distributed e3ai(a,i)
      distributed e4ai(a,i)
      distributed e5ai(a,i)
#
      distributed e1bj(b,j)
      distributed e2bj(b,j)
      distributed e3bj(b,j)
      distributed e4bj(b,j)
      distributed e5bj(b,j)
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510
#
       scalar b66
       scalar b67
       scalar b68
       scalar b69
       scalar b610
#
       scalar b77
       scalar b78
       scalar b79
       scalar b710
#
       scalar b88
       scalar b89
       scalar b810
#
       scalar b99
       scalar b910
#
       scalar b1010
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510
#
       scalar Tb66
       scalar Tb67
       scalar Tb68
       scalar Tb69
       scalar Tb610
#
       scalar Tb77
       scalar Tb78
       scalar Tb79
       scalar Tb710
#
       scalar Tb88
       scalar Tb89
       scalar Tb810
#
       scalar Tb99
       scalar Tb910
#
       scalar Tb1010
#
       scalar c1
       scalar c2
       scalar c3
       scalar c4
       scalar c5
       scalar c6
       scalar c7
       scalar c8
       scalar c9
       scalar c10
#
# Arrays used in 'direct' computation of Vabcd terms. 
# ---------------------------------------------------
#
     served TAO_aa(lambda,i,sigma,i1)
     served TAO_bb(lambda,j,sigma,j1)
     served TAO_ab(lambda,i,sigma,j)
     served T1AO_aa(lambda,i,a,i1)
     served T1AO_bb(lambda,j,b,j1)
     served T1AO_ab(lambda,i,b,j)
     served T2AO_aa(lambda,i,sigma,i1)
     served T2AO_bb(lambda,j,sigma,j1)
     served T2AO_ab(lambda,i,sigma,j)
     served VT_aa(a,i,a1,i1) 
     served VT_ab(a,i,b,j) 
     served VT_bb(b,j,b1,j1) 
     distributed VD_aa(mu,nu) 
     distributed VDX_aa(mu,nu) 
     distributed D_aa(mu,nu) 
     distributed VDD_aa(a,a1) 
     distributed VXX_aa(a,a1) 
     local LLaiai(a,i,a1,i1) 
     local LLbjbj(b,j,b1,j1) 
     local LLaibj(a,i,b,j) 
     local Lxiai(lambda,i,a1,i1) 
     local Lxjbj(lambda,j,b1,j1) 
     local Lxibj(lambda,i,b,j) 
     local L1xixi(mu,i,nu,i1) 
     local L1xixj(mu,i,nu,j) 
     local L1xjxj(mu,j,nu,j1) 
     temp  Taixi(a,i,nu,i1) 
     temp  T1aixi(a,i,nu,i1) 
     temp  Tbjxj(b,j,nu,j1) 
     temp  T1bjxj(b,j,nu,j1) 
     temp  Taixj(a,i,nu,j) 
     temp  T1aixj(a,i,nu,j) 
#
# Declare scalars. 
# ---------------- 
#
     scalar eold  
     scalar enew 
     scalar ecrit 
     scalar esum 
     scalar etemp 
     scalar ediff 
     scalar ecorra 
     scalar ecorrb 
     scalar ecorraa 
     scalar ecorrbb 
     scalar ecorrab 
     scalar ecorrT 
     scalar hessxy 
     scalar phessxy 
     scalar hessyx 
     scalar phessyx 
     scalar doit  
     scalar dcrit   
#
#    ------------------------------------------------------------------------
#
#    Perform the first two stages of the transformation in two N5 steps.
#
     PROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
#
          allocate taoint(mu,nu,lambda,*)
#
          DO sigma
#
             compute_integrals            saoint(mu,nu,lambda,sigma)
             taoint(mu,nu,lambda,sigma) = saoint(mu,nu,lambda,sigma)
#
          ENDDO sigma
#
          DO i
#
             Txxxi(mu,nu,lambda,i) = 0.0
#
              DO sigma
#
                 T1xxxi(mu,nu,lambda,i)  = taoint(mu,nu,lambda,sigma)*ca(sigma,i)
                 Txxxi(mu,nu,lambda,i)  += T1xxxi(mu,nu,lambda,i)
#
              ENDDO sigma
#
              PREPARE Vxxxi(mu,nu,lambda,i)  = Txxxi(mu,nu,lambda,i)
#
          ENDDO i
#
          deallocate taoint(mu,nu,lambda,*)
#
     ENDPARDO mu, nu, lambda
#
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
           allocate L1xxxi(mu,nu,*,i)
           allocate L2xxxi(mu,*,nu,i)
           allocate L3xxxi(*,mu,nu,i)
#
           DO lambda
#
              REQUEST Vxxxi(mu,nu,lambda,i) i
              REQUEST Vxxxi(mu,lambda,nu,i) i
              REQUEST Vxxxi(lambda,mu,nu,i) i
#
              L1xxxi(mu,nu,lambda,i) = Vxxxi(mu,nu,lambda,i)
              L2xxxi(mu,lambda,nu,i) = Vxxxi(mu,lambda,nu,i)
              L3xxxi(lambda,mu,nu,i) = Vxxxi(lambda,mu,nu,i)
#
           ENDDO lambda
#
           DO i1
#
              Txxii(mu,nu,i1,i) = 0.0
              Txixi(mu,i1,nu,i) = 0.0
              Tixxi(i1,mu,nu,i) = 0.0
#
              DO lambda
#
                 T1xxii(mu,nu,i1,i) = L1xxxi(mu,nu,lambda,i)*ca(lambda,i1)
                 Txxii(mu,nu,i1,i) += T1xxii(mu,nu,i1,i)
#
                 T1xixi(mu,i1,nu,i) = L2xxxi(mu,lambda,nu,i)*ca(lambda,i1)
                 Txixi(mu,i1,nu,i) += T1xixi(mu,i1,nu,i)
#
                 T1ixxi(i1,mu,nu,i) = L3xxxi(lambda,mu,nu,i)*ca(lambda,i1)
                 Tixxi(i1,mu,nu,i) += T1ixxi(i1,mu,nu,i)
#
              ENDDO lambda
#
              PREPARE Vxxii(mu,nu,i1,i) = Txxii(mu,nu,i1,i)
              PREPARE Sxixi(mu,i1,nu,i) = Txixi(mu,i1,nu,i)
              PREPARE Vixxi(i1,mu,nu,i) = Tixxi(i1,mu,nu,i)
#
           ENDDO i1
#
           DO a
#
              Txxai(mu,nu,a,i) = 0.0
#
              DO lambda
#
                 T1xxai(mu,nu,a,i) = L1xxxi(mu,nu,lambda,i)*ca(lambda,a)
                 Txxai(mu,nu,a,i) += T1xxai(mu,nu,a,i)
#
              ENDDO lambda
#
              PREPARE Vxxai(mu,nu,a,i) = Txxai(mu,nu,a,i)
#
           ENDDO a
#
           deallocate L1xxxi(mu,nu,*,i)
           deallocate L2xxxi(mu,*,nu,i)
           deallocate L3xxxi(*,mu,nu,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
#
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.
#
     PROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, i, i1
#
           allocate Lxixi(mu,i,*,i1)
           allocate Lxxii(mu,*,i,i1)
           allocate Lixxi(i,mu,*,i1)
#
           DO nu
#
              REQUEST Sxixi(mu,i,nu,i1) i1
              REQUEST Vxxii(mu,nu,i,i1) i1
              REQUEST Vixxi(i,mu,nu,i1) i1
#
              Lxixi(mu,i,nu,i1) = Sxixi(mu,i,nu,i1)
              Lxxii(mu,nu,i,i1) = Vxxii(mu,nu,i,i1)
              Lixxi(i,mu,nu,i1) = Vixxi(i,mu,nu,i1)
#
           ENDDO nu
#
           DO p
#
              Txipi(mu,i,p,i1) = 0.0
#
              DO nu
#
                 T1xipi(mu,i,p,i1) = Lxixi(mu,i,nu,i1)*ca(nu,p)
                 Txipi(mu,i,p,i1) += T1xipi(mu,i,p,i1)
#
              ENDDO nu
#
              PREPARE Vxipi(mu,i,p,i1) = Txipi(mu,i,p,i1)
#
           ENDDO p
#
           DO a
#
              Txaii(mu,a,i,i1) = 0.0
              Tixai(i,mu,a,i1) = 0.0
#
              DO nu
#
                 T1xaii(mu,a,i,i1) = Lxxii(mu,nu,i,i1)*ca(nu,a)
                 Txaii(mu,a,i,i1) += T1xaii(mu,a,i,i1)
#
                 T1ixai(i,mu,a,i1) = Lixxi(i,mu,nu,i1)*ca(nu,a)
                 Tixai(i,mu,a,i1) += T1ixai(i,mu,a,i1)

              ENDDO nu
#
              PREPARE Vxaii(mu,a,i,i1) = Txaii(mu,a,i,i1)
              PREPARE Vixai(i,mu,a,i1) = Tixai(i,mu,a,i1)
#
           ENDDO a
#
           DO b
#
              Txbii(mu,b,i,i1) = 0.0
#
              DO nu
#
                 T1xbii(mu,b,i,i1) = Lxxii(mu,nu,i,i1)*ca(nu,b)
                 Txbii(mu,b,i,i1) += T1xbii(mu,b,i,i1)
#
              ENDDO nu
#
              PREPARE Vxbii(mu,b,i,i1) = Txbii(mu,b,i,i1)
#
           ENDDO b
#
           deallocate Lxixi(mu,i,*,i1)
           deallocate Lxxii(mu,*,i,i1)
           deallocate Lixxi(i,mu,*,i1)
#
     ENDPARDO mu, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, a, i
#
           allocate Lxxai(mu,*,a,i)
#
           DO nu
#
              REQUEST Vxxai(mu,nu,a,i) i
              Lxxai(mu,nu,a,i) = Vxxai(mu,nu,a,i)
#
           ENDDO nu
#
           DO a1
#
              Txaai(mu,a1,a,i) = 0.0
#
              DO nu
#
                 T1xaai(mu,a1,a,i) = Lxxai(mu,nu,a,i)*ca(nu,a1)
                 Txaai(mu,a1,a,i) += T1xaai(mu,a1,a,i)
#
              ENDDO nu
#
              PREPARE Vxaai(mu,a1,a,i) = Txaai(mu,a1,a,i)
#
           ENDDO a1
#
           DO b
#
              Txbai(mu,b,a,i) = 0.0
#
              DO nu
#
                 T1xbai(mu,b,a,i) = Lxxai(mu,nu,a,i)*ca(nu,b)
                 Txbai(mu,b,a,i) += T1xbai(mu,b,a,i)
#
              ENDDO nu
#
              PREPARE Vxbai(mu,b,a,i) = Txbai(mu,b,a,i)
#
           ENDDO b
#
           deallocate Lxxai(mu,*,a,i)
#
     ENDPARDO mu, a, i
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
#
     ENDPROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PARDO p, i, i1
#
           allocate Lxipi(*,i,p,i1) 
#
           DO mu 
#
              REQUEST Vxipi(mu,i,p,i1) i1 
              REQUEST Vxipi(mu,i1,p,i) i
              Lxipi(mu,i,p,i1)  = Vxipi(mu,i,p,i1)
              Txipi(mu,i,p,i1)  = Vxipi(mu,i1,p,i)
              Lxipi(mu,i,p,i1) -= Txipi(mu,i,p,i1)
#
           ENDDO mu
#
           DO p1
#
              Tpipi(p1,i,p,i1) = 0.0
#
              DO mu
#
                 T1pipi(p1,i,p,i1) = Lxipi(mu,i,p,i1)*ca(mu,p1)
                 Tpipi(p1,i,p,i1) += T1pipi(p1,i,p,i1)
#
              ENDDO mu
#
              PREPARE VSpipi(p1,i,p,i1) = Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
           deallocate Lxipi(*,i,p,i1)
#
     ENDPARDO p, i, i1
#
     PARDO a, i, i1
#
           allocate Lxaii(*,a,i,i1)
           allocate Lixai(i,*,a,i1)
#
           DO mu
#
              REQUEST Vxaii(mu,a,i,i1) i1
              REQUEST Vixai(i,mu,a,i1) i1
#
              Lxaii(mu,a,i,i1) = Vxaii(mu,a,i,i1)
              Lixai(i,mu,a,i1) = Vixai(i,mu,a,i1)
#
           ENDDO mu
#
           DO a1
#
              Taaii(a1,a,i,i1) = 0.0
#
              DO mu
#
                 T1aaii(a1,a,i,i1) = Lxaii(mu,a,i,i1)*ca(mu,a1)
                 Taaii(a1,a,i,i1) += T1aaii(a1,a,i,i1)
#
              ENDDO mu
#
              PREPARE Vaaii(a1,a,i,i1) = Taaii(a1,a,i,i1)
#
           ENDDO a1
#
           deallocate Lxaii(*,a,i,i1)
#
           DO a1
#
              Tiaai(i,a1,a,i1) = 0.0
#
              DO mu
#
                 T1iaai(i,a1,a,i1) = Lixai(i,mu,a,i1)*ca(mu,a1)
                 Tiaai(i,a1,a,i1) += T1iaai(i,a1,a,i1)
#
              ENDDO mu
#
              PREPARE Viaai(i,a1,a,i1) = Tiaai(i,a1,a,i1)
#
           ENDDO a1
#
           deallocate Lixai(i,*,a,i1)
#
     ENDPARDO a, i, i1
#
     PARDO a, a1, i
#
           allocate L1xaai(*,a,a1,i)
#
           DO mu
#
              REQUEST Vxaai(mu,a,a1,i) i
#
              L1xaai(mu,a,a1,i)  = Vxaai(mu,a,a1,i)
#
           ENDDO mu
#
           DO a2
#
              Taaai(a2,a,a1,i) = 0.0
#
              DO mu
#
                 T1aaai(a2,a,a1,i) = L1xaai(mu,a,a1,i)*ca(mu,a2)
                 Taaai(a2,a,a1,i) += T1aaai(a2,a,a1,i)
#
              ENDDO mu
#
              T1aaai(a1,a,a2,i)           = Taaai(a2,a,a1,i)
              T1aaai(a1,a,a2,i)          *= -1.0
              PREPARE Vaaai(a2,a,a1,i)    = Taaai(a2,a,a1,i)
              PREPARE VSaaai(a2,a,a1,i)  += Taaai(a2,a,a1,i)
              PREPARE VSaaai(a1,a,a2,i)  += T1aaai(a1,a,a2,i)
#
           ENDDO a2
#
           deallocate L1xaai(*,a,a1,i)
#
     ENDPARDO a, a1, i
#
     PARDO q, i, j
#
           allocate Lxiqj(*,i,q,j)
#
           DO mu
#
              REQUEST Vxipi(mu,i,q,j) j
              Lxiqj(mu,i,q,j) = Vxipi(mu,i,q,j)
#
           ENDDO mu
#
           DO p
#
              Tpiqj(p,i,q,j) = 0.0
#
              DO mu
#
                 T1piqj(p,i,q,j) = Lxiqj(mu,i,q,j)*ca(mu,p)
                 Tpiqj(p,i,q,j) += T1piqj(p,i,q,j)
#
              ENDDO mu
#
              PREPARE Vpiqj(p,i,q,j) = Tpiqj(p,i,q,j)
#
           ENDDO p
#
           deallocate Lxiqj(*,i,q,j)
#
     ENDPARDO q, i, j
#
#    ------------------------------------------------------------------------
#
     execute server_barrier 
#
     ENDPROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Create the distributed two-particle transformed integral arrays.
#
     PROC CREATE_MOINTS
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     ENDPROC CREATE_MOINTS
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF
#
        #CALL CREATE_MOINTS  # --> create the distributed two-particle
                             #     transformed integral arrays.
         CALL TRAN_TRAN2     # --> performs the first two stages of the
                             #     two-electron integral transformation.
         CALL TRAN_TRAN3     # --> performs the third stage
                             #     two-electron integral transformation.
         CALL TRAN_TRAN4     # --> performs the fourth stage of the
                             #     two-electron integral transformation.
#
     ENDPROC TRAN_UHF
#
#    ------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC UHF_ENERGY
#     --------------------
#
#     'HF' terms
#     ----------
#
      esum    = 0.0
      ecorraa = 0.0
      PARDO a, a1, i, i1
#
            REQUEST VSpipi(a,i,a1,i1)    a 
            REQUEST T1aiai_aa(a,i,a1,i1) a 
#
            etemp = VSpipi(a,i,a1,i1)*T1aiai_aa(a,i,a1,i1)
            etemp = 0.2*etemp
            esum += etemp
#
      ENDPARDO a, a1, i, i1
#
      execute server_barrier
      collective ecorraa += esum
      execute print_scalar ecorraa
#
      ecorrbb = 0.0
      esum    = 0.0
      execute server_barrier
      collective ecorrbb += esum
      execute print_scalar ecorrbb
#
      ecorrab = 0.0
      esum    = 0.0
      PARDO a, b, i, j
#
            REQUEST     Vpiqj(a,i,b,j) a 
            REQUEST T1aibj_ab(a,i,b,j) a 
#
            etemp = T1aibj_ab(a,i,b,j)*Vpiqj(a,i,b,j)
            esum += etemp
#
      ENDPARDO a, b, i, j
      execute server_barrier
      collective ecorrab += esum
      execute print_scalar ecorrab
#
      ecorrT  = ecorraa
      ecorrT += ecorrbb
      ecorrT += ecorrab
      execute print_scalar ecorrT
#
      ENDPROC UHF_ENERGY
#     -----------------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC T2AA_REFERANCE
#     -------------------
#
#     Create distributed arrays used in the referance computation. 
#     ------------------------------------------------------------ 
#
#     First initialize the amplitudes.
#     --------------------------------
#
#     T2AA  
#     -----
#
      esum    = 0.0
      ecorraa = 0.0 
#
      PARDO a, a1, i, i1
#
            REQUEST                     VSpipi(a,i,a1,i1) a 
            taiai(a,i,a1,i1)          = VSpipi(a,i,a1,i1)
            execute energy_denominator  taiai(a,i,a1,i1)
            etemp                     = taiai(a,i,a1,i1)*VSpipi(a,i,a1,i1) 
            etemp                    *= 0.5 
            esum                     += etemp 
            PREPARE T1aiai_aa(a,i,a1,i1)  = taiai(a,i,a1,i1)
#
      ENDPARDO a, a1, i, i1
      execute server_barrier 
#
      collective ecorraa += esum
      execute print_scalar ecorraa 
#
      ENDPROC T2AA_REFERANCE
#     ----------------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC T2AB_REFERANCE
#     -------------------
#
#     Create distributed arrays used in the referance computation. 
#     ------------------------------------------------------------ 
#
#     First initialize the amplitudes.
#     --------------------------------
#
#     T2AB  
#     -----
#
      esum    = 0.0
      ecorrab = 0.0 
#
      PARDO a, b, i, j
#
            REQUEST                     Vpiqj(a,i,b,j) a 
            taibj(a,i,b,j)            = Vpiqj(a,i,b,j)
            execute energy_denominator  taibj(a,i,b,j)
            etemp                     = taibj(a,i,b,j)*Vpiqj(a,i,b,j) 
            esum                     += etemp 
            PREPARE T1aibj_ab(a,i,b,j)    = taibj(a,i,b,j)
#
      ENDPARDO a, b, i, j
      execute server_barrier 
#
      collective ecorrab += esum
      execute  print_scalar ecorrab 
#
      ecorrT             = ecorraa
      ecorrT            += ecorrbb
      ecorrT            += ecorrab
      execute print_scalar ecorrT
#
      ENDPROC T2AB_REFERANCE
#     ----------------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
#     Computed quantity    Description of quantity
#     --------------------------------------------
#
#     1. Iij_a
#     3. Iai_a
#     5. Iab_a
#     7. Xai_a
#
      PROC PINTER
#     -----------
#
#     Create distributed arrays. 
#     -------------------------- 
#
      create Iij_a
      create Iai_a
      create Iab_a
      create Ipq_a
      create Xai_a
      execute sip_barrier 
#
#     Start Iij_a
#     -----------
#
      PARDO i, i1 
#
            Tii(i,i1) = 0.0  
#
            DO i2 
#
               IF i2 == i 
#
                  GET          Dij_a(i1,i2)
                  T1ii(i,i1) = Dij_a(i1,i2)*Fock_a(i2,i)
                  Tii(i,i1) -= T1ii(i,i1) 
#
               ENDIF # i2 == i 
#
            ENDDO i2 
#
            PUT Iij_a(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1 
#
      PARDO a, a1, i1, i2
#
            REQUEST T1aiai_aa(a,i1,a1,i2) a 
#
            DO i
#
               REQUEST            VSpipi(a,i,a1,i2) a 
               Tii(i,i1)        = VSpipi(a,i,a1,i2)*T1aiai_aa(a,i1,a1,i2)
               Tii(i,i1)       *= -0.5
               PUT Iij_a(i,i1) += Tii(i,i1)
#
            ENDDO i
#
      ENDPARDO a, a1, i1, i2
#
      PARDO a, b, i1, j
#
            REQUEST T1aibj_ab(a,i1,b,j) a 
#
            DO i
#
               REQUEST            Vpiqj(a,i,b,j) a 
               Tii(i,i1)        = Vpiqj(a,i,b,j)*T1aibj_ab(a,i1,b,j)
               Tii(i,i1)       *= -1.0
               PUT Iij_a(i,i1) += Tii(i,i1)
#
            ENDDO i
#
      ENDPARDO a, b, i1, j
#
#     Finish Iij_a
#     ------------
#
#     Start Iai_a
#     -----------
#
      PARDO a, a1, i1, i2
#
            REQUEST T1aiai_aa(a,i1,a1,i2) a 
#
            DO i
#
               REQUEST           VSpipi(a1,i2,i,i1) a1 
               Tai(a,i)        = T1aiai_aa(a,i1,a1,i2)*VSpipi(a1,i2,i,i1)
               Tai(a,i)       *= -0.5
               PUT Iai_a(a,i) += Tai(a,i)
#
               tia(i,a)        = tai(a,i) 
               PUT Ipq_a(i,a) += tia(i,a) 
#
            ENDDO i
#
      ENDPARDO a, a1, i1, i2
#
      PARDO a, b, i1, j
#
            REQUEST T1aibj_ab(a,i1,b,j) a
#
            DO i
#
               REQUEST           Vpiqj(i,i1,b,j) j 
               Tai(a,i)        = T1aibj_ab(a,i1,b,j)*Vpiqj(i,i1,b,j)
               Tai(a,i)       *= -1.0
               PUT Iai_a(a,i) += Tai(a,i)
#
               tia(i,a)        = tai(a,i) 
               PUT Ipq_a(i,a) += tia(i,a) 
#
            ENDDO i
#
      ENDPARDO a, b, i1, j
#
#     Finish Iai_a
#     ------------
#
#     Start Iab_a
#     -----------

       PARDO a, a1, a2
#
             GET                Dab_a(a2,a1)
             Taa(a,a1)        = Dab_a(a2,a1)*Fock_a(a2,a)
             Taa(a,a1)       *= -1.0
             PUT Iab_a(a,a1) += Taa(a,a1)
#
       ENDPARDO a, a1, a2 
#
      PARDO a1, a2, i, i1
#
            REQUEST T1aiai_aa(a1,i,a2,i1) a1 
#
            DO a
#
               REQUEST            VSpipi(a,i,a2,i1) a 
               Taa(a,a1)        = VSpipi(a,i,a2,i1)*T1aiai_aa(a1,i,a2,i1)
               Taa(a,a1)       *= -0.5
               PUT Iab_a(a,a1) += Taa(a,a1)
#
            ENDDO a
#
      ENDPARDO a1, a2, i, i1
#
      PARDO a1, b, i, j
#
            REQUEST T1aibj_ab(a1,i,b,j) b 
#
            DO a
#
               REQUEST            Vpiqj(a,i,b,j) a 
               Taa(a,a1)        = Vpiqj(a,i,b,j)*T1aibj_ab(a1,i,b,j)
               Taa(a,a1)       *= -1.0  
               PUT Iab_a(a,a1) += Taa(a,a1)
#
            ENDDO a
#
      ENDPARDO a1, b, i, j
#
#     Finish Iab_a
#     ------------
#
      execute sip_barrier # --> Xai depends on Iai !
#
#     Start Xai_a
#     -----------
#
      PARDO a, i
#
            GET        Iai_a(a,i)
            Tai(a,i) = Iai_a(a,i)
#
            DO i1
            DO i2
#
               REQUEST             VSpipi(a,i,i2,i1) a 
               REQUEST             VSpipi(a,i,i1,i2) a 
               GET                 Dij_a(i2,i1)
#
               Taiii(a,i,i2,i1)  = VSpipi(a,i,i2,i1)
               T1aiii(a,i,i2,i1) = VSpipi(a,i,i1,i2)
               Taiii(a,i,i2,i1) += T1aiii(a,i,i2,i1)
               T1ai(a,i)         = Taiii(a,i,i2,i1)*Dij_a(i2,i1)
               T1ai(a,i)        *= 0.5
               Tai(a,i)         += T1ai(a,i)
#
            ENDDO i2
            ENDDO i1
#
            DO j
            DO j1
#
               REQUEST            Vpiqj(a,i,j1,j) a 
               REQUEST            Vpiqj(a,i,j,j1) a 
               GET                Dij_a(j1,j)
#
               Taijj(a,i,j1,j)  = Vpiqj(a,i,j1,j)
               T1aijj(a,i,j1,j) = Vpiqj(a,i,j,j1)
               Taijj(a,i,j1,j) += T1aijj(a,i,j1,j)
               T1ai(a,i)        = Taijj(a,i,j1,j)*Dij_a(j1,j)
               T1ai(a,i)       *= 0.5
               Tai(a,i)        += T1ai(a,i)
#
            ENDDO j1
            ENDDO j
#
            DO a1
            DO a2
#
               REQUEST             VSaaai(a2,a1,a,i) a 
               REQUEST             VSaaai(a1,a2,a,i) a 
               GET                 Dab_a(a2,a1)
#
               Taaai(a2,a1,a,i)  = VSaaai(a2,a1,a,i)
               T1aaai(a2,a1,a,i) = VSaaai(a1,a2,a,i)
               Taaai(a2,a1,a,i) += T1aaai(a2,a1,a,i)
               T1ai(a,i)         = Taaai(a2,a1,a,i)*Dab_a(a2,a1)
               T1ai(a,i)        *= 0.5
               Tai(a,i)         += T1ai(a,i)
#
               DO i1
#
                  REQUEST     T1aiai_aa(a1,i1,a2,i) i 
                  REQUEST     VSaaai(a2,a,a1,i1)    a 
#
                  T1ai(a,i) = VSaaai(a2,a,a1,i1)*T1aiai_aa(a1,i1,a2,i)
                  T1ai(a,i) *= 0.5
                  Tai(a,i) += T1ai(a,i)
#
               ENDDO i1
#
            ENDDO a2
            ENDDO a1
#
            DO b
            DO b1
#
               REQUEST            Vaaai(b1,b,a,i) a # Vppqq(a,i,b1,b)
               REQUEST            Vaaai(b,b1,a,i) a # Vppqq(a,i,b,b1)
               GET                Dab_a(b1,b)
#
               Tbbai(b1,b,a,i)  = Vaaai(b1,b,a,i)
               T1bbai(b1,b,a,i) = Vaaai(b,b1,a,i)
               Tbbai(b1,b,a,i) += T1bbai(b1,b,a,i)
               T1ai(a,i)        = Tbbai(b1,b,a,i)*Dab_a(b1,b)
               T1ai(a,i)       *= 0.5
               Tai(a,i)        += T1ai(a,i)
#
            ENDDO b1
            ENDDO b
#
            DO b
            DO a1
            DO j
#
               REQUEST      T1aibj_ab(a1,i,b,j) b 
               REQUEST      Vaaai(a1,a,b,j) a 
#
               T1ai(a,i)  = Vaaai(a1,a,b,j)*T1aibj_ab(a1,i,b,j)
               Tai(a,i)  += T1ai(a,i)
#
            ENDDO j
            ENDDO a1
            ENDDO b
#
            PUT Xai_a(a,i) = Tai(a,i)
#
      ENDPARDO a, i
#
#     Finish Xai_a
#     ------------
#
      execute sip_barrier
#
      ENDPROC PINTER
#     --------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC DENSIJ
#     -----------
#
#     Create distributed denisty arrays. 
#     --------------------------------- 
#
      create Dij_a 
      create Dpq_a 
#
      execute sip_barrier 
#
# ---------------------------------------------------------------------------
#
#     Start Dij_a
#     -----------
#
      PARDO a, a1, i1
#
            allocate L1aiai(a,*,a1,i1)
#
            DO i2
#
               REQUEST              T1aiai_aa(a,i2,a1,i1) a 
               L1aiai(a,i2,a1,i1) = T1aiai_aa(a,i2,a1,i1)
#
            ENDDO i2
#
            DO i
#
               REQUEST T1aiai_aa(a,i,a1,i1) a 
#
               DO i2
#
                  Tii(i,i2)        = T1aiai_aa(a,i,a1,i1)*L1aiai(a,i2,a1,i1)
                  Tii(i,i2)       *= -0.5
                  PUT Dij_a(i,i2) += Tii(i,i2)
                  PUT Dpq_a(i,i2) += Tii(i,i2)
#
               ENDDO i2
#
            ENDDO i
#
            deallocate L1aiai(a,*,a1,i1)
#
      ENDPARDO a, a1, i1
#
      PARDO a, b, j
#
            allocate L1aibj(a,*,b,j)
#
            DO i2
#
               REQUEST            T1aibj_ab(a,i2,b,j) a 
               L1aibj(a,i2,b,j) = T1aibj_ab(a,i2,b,j)
#
            ENDDO i2
#
            DO i
#
               REQUEST T1aibj_ab(a,i,b,j) a 
#
               DO i2
#
                  Tii(i,i2)        = T1aibj_ab(a,i,b,j)*L1aibj(a,i2,b,j)
                  Tii(i,i2)       *= -1.0
                  PUT Dij_a(i,i2) += Tii(i,i2)
                  PUT Dpq_a(i,i2) += Tii(i,i2)
#
               ENDDO i2
#
            ENDDO i
#
            deallocate L1aibj(a,*,b,j)
#
      ENDPARDO a, b, j
#
#     Finish Dij_a
#     ------------
#
# ---------------------------------------------------------------------------
#
      ENDPROC DENSIJ
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC DENSAB
#     -----------
#
# ---------------------------------------------------------------------------
#
#     Create distributed denisty arrays. 
#     --------------------------------- 
#
      create Dab_a 
#
      execute sip_barrier 
#
#     Start Dab_a
#     -----------
#
      PARDO i, i1, a1
#
            allocate L2aiai(*,i,a1,i1)
#
            DO a2
#
               REQUEST              T1aiai_aa(a2,i,a1,i1) i
               L2aiai(a2,i,a1,i1) = T1aiai_aa(a2,i,a1,i1)
#
            ENDDO a2
#
            DO a
#
               REQUEST T1aiai_aa(a,i,a1,i1) a
#
               DO a2
#
                  Taa(a,a2)        = T1aiai_aa(a,i,a1,i1)*L2aiai(a2,i,a1,i1)
                  Taa(a,a2)       *= 0.5
                  PUT Dab_a(a,a2) += Taa(a,a2)
                  PUT Dpq_a(a,a2) += Taa(a,a2)
#
               ENDDO a2
#
            ENDDO a
#
            deallocate L2aiai(*,i,a1,i1)
#
      ENDPARDO i, i1, a1
#
      PARDO i, j, b
#
            allocate L2aibj(*,i,b,j)
#
            DO a1
#
               REQUEST            T1aibj_ab(a1,i,b,j) b 
               L2aibj(a1,i,b,j) = T1aibj_ab(a1,i,b,j)
#
            ENDDO a1
#
            DO a
#
               REQUEST T1aibj_ab(a,i,b,j) a 
#
               DO a1
#
                  Taa(a,a1)        = T1aibj_ab(a,i,b,j)*L2aibj(a1,i,b,j)
                  PUT Dab_a(a,a1) += Taa(a,a1)
                  PUT Dpq_a(a,a1) += Taa(a,a1)
#
               ENDDO a1
#
            ENDDO a
#
            deallocate L2aibj(*,i,b,j)
#
      ENDPARDO i, j, b
#
#     Finish Dab_a
#     ------------
#
# ---------------------------------------------------------------------------
#
      ENDPROC DENSAB
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------  
#
# The two-electron integral deivative <mn|ls>^l is computed
# and transformed to the MO basis for use in constructing
# the Hessian. The transformation is performed in 4 steps as
# is usually done. Since there will always be one occupied index
# in the Hessian computation the 4-types of integrals are computed. 
#
# 1. DTpppi
#
# Note that the integrals are not antisymmetrized in the transformation. 
#
# --------------------------------------------------------------------------- 
#
      PROC DINT_TRAN 
#     --------------  
#
      create Qyai 
      create QAyy 
      create QByy 
      create QAByy 
      execute sip_barrier 
#
#     Compute integrals and perform first stage of the transformation. 
#     ---------------------------------------------------------------- 
#
      PARDO mu, nu, lambda
#
            allocate Dxxxi(mu,lambda,nu,*) 
#
            DO  sigma 
#
                execute                       der2_comp daoint(mu,lambda,nu,sigma) 
#
#               Update QAyy, QByy, and QAByy  
#               ----------------------------
#
                GET                     Dhfa(lambda,nu) 
                GET                     Dhfb(lambda,nu) 
                GET                     Dhfa(nu,sigma) 
                GET                     Dhfb(nu,sigma) 
#
                txx(nu,sigma)         = Dhfa(nu,sigma) 
                txx(nu,sigma)        += Dhfb(nu,sigma) 
#
                t1xx(mu,sigma)        = daoint(mu,lambda,nu,sigma)*Dhfa(lambda,nu)
                t1xx(mu,sigma)       *= -1.0  
                PUT QAyy(mu,sigma)   += t1xx(mu,sigma) 
#
                t1xx(mu,sigma)        = daoint(mu,lambda,nu,sigma)*Dhfb(lambda,nu)
                t1xx(mu,sigma)       *= -1.0  
                PUT QByy(mu,sigma)   += t1xx(mu,sigma) 
#
                t1xx(mu,lambda)       = daoint(mu,lambda,nu,sigma)*txx(nu,sigma)
                PUT QAByy(mu,lambda) += t1xx(mu,lambda) 
#
                DO i 
#
                   txxxi(mu,lambda,nu,i)  = daoint(mu,lambda,nu,sigma)*ca(sigma,i)
                   Dxxxi(mu,lambda,nu,i) += txxxi(mu,lambda,nu,i) 
#
                ENDDO i 
#
            ENDDO  sigma 
#
            DO i 
#
               txxxi(mu,lambda,nu,i)         = Dxxxi(mu,lambda,nu,i) 
               PREPARE Vxxxi(mu,lambda,nu,i) = txxxi(mu,lambda,nu,i) 
#
            ENDDO i 
#
            deallocate Dxxxi(mu,lambda,nu,*) 
#
      ENDPARDO mu, nu, lambda
#
      execute server_barrier 
#
#     Perform second stage of the transformation. 
#     ------------------------------------------- 
#
      PARDO mu, lambda, i 
#
            allocate Exxpi(mu,lambda,*,i) 
#
            DO nu 
#
               REQUEST Vxxxi(mu,lambda,nu,i) i  
#
               DO p 
#
                  txxpi(mu,lambda,p,i)  = Vxxxi(mu,lambda,nu,i)*ca(nu,p) 
                  Exxpi(mu,lambda,p,i) += txxpi(mu,lambda,p,i)  
#
               ENDDO p 
#
            ENDDO nu  
#
            DO p 
#
               txxpi(mu,lambda,p,i)          = Exxpi(mu,lambda,p,i) 
               PREPARE DTxxpi(mu,lambda,p,i) = txxpi(mu,lambda,p,i) 
#
            ENDDO p 
#
            deallocate Exxpi(mu,lambda,*,i) 
#
      ENDPARDO mu, lambda, i 
#
      execute server_barrier 
#
#     Perform third stage of the transformation. 
#     ------------------------------------------ 
#
      PARDO mu, p, i 
#
            allocate Fxppi(mu,*,p,i) 
#
            DO nu 
#
               REQUEST DTxxpi(mu,nu,p,i) i 
#
               DO p1 
#
                  txppi(mu,p1,p,i)  = DTxxpi(mu,nu,p,i)*ca(nu,p1) 
                  Fxppi(mu,p1,p,i) += txppi(mu,p1,p,i)
#
               ENDDO p1 
#
            ENDDO nu 
#
            DO p1 
#
               txppi(mu,p1,p,i)          = Fxppi(mu,p1,p,i) 
               PREPARE DTxppi(mu,p1,p,i) = txppi(mu,p1,p,i)  
#
            ENDDO p1 
#
            deallocate Fxppi(mu,*,p,i) 
#
      ENDPARDO mu, p, i 
#
      execute server_barrier 
#
#     Perform fourth stage of the transformation. 
#     ------------------------------------------- 
#
      PARDO p, p1, i 
#
            allocate Fpppi(*,p1,p,i) 
#
            DO mu 
#
               REQUEST DTxppi(mu,p1,p,i) i 
#
               DO p2 
#
                  tpppi(p2,p1,p,i)  = DTxppi(mu,p1,p,i)*ca(mu,p2) 
                  Fpppi(p2,p1,p,i) += tpppi(p2,p1,p,i) 
#
               ENDDO p2 
#
            ENDDO mu 
#
            DO p2 
#
               tpppi(p2,p1,p,i)          = Fpppi(p2,p1,p,i) 
               PREPARE DTpppi(p2,p1,p,i) = tpppi(p2,p1,p,i) 
#
            ENDDO p2 
#
            deallocate Fpppi(*,p1,p,i) 
#
      ENDPARDO p, p1, i 
#
      create Fya 
      execute sip_barrier 
      execute server_barrier 
#
#     Finish the contribution to Qyai and Qybj 
#     ---------------------------------------- 
#
      PARDO mu, sigma  
#
            GET               QAByy(mu,sigma) 
            GET               QAyy(mu,sigma) 
            GET               QByy(mu,sigma) 
#
            txx(mu,sigma)   = QAByy(mu,sigma)  
            txx(mu,sigma)  += QAyy(mu,sigma)  
#
            t1xx(mu,sigma)  = QAByy(mu,sigma)  
            t1xx(mu,sigma) += QByy(mu,sigma)  
#
            DO a  
#
               tax(a,sigma) = txx(mu,sigma)*ca(mu,a)  
#
               DO i 
#
                  tai(a,i)       = tax(a,sigma)*ca(sigma,i) 
                  PUT Qyai(a,i) += tai(a,i)  
#
               ENDDO i 
#
            ENDDO a  
#
            DO a
#
               tpx(a,sigma) = ca(mu,a)*txx(mu,sigma)
#
               DO a1 
#
                  tpp(a,a1)       = tpx(a,sigma)*ca(sigma,a1)
                  PUT Fya(a,a1) += tpp(a,a1)
#
               ENDDO a1 
#
            ENDDO a
#
            DO i
#
               tpx(i,sigma) = ca(mu,i)*txx(mu,sigma)
#
               DO i1 
#
                  tpp(i,i1)       = tpx(i,sigma)*ca(sigma,i1)
                  PUT Fya(i,i1) += tpp(i,i1)
#
               ENDDO i1 
#
            ENDDO i
#
      ENDPARDO mu, sigma  
#
      execute sip_barrier 
#
      ENDPROC DINT_TRAN 
#     -----------------  
#
# ---------------------------------------------------------------------- 
#
# ----------------------------------------------------------------------  
#
# The two-electron integral deivative <mn|ls>^l is computed
# and transformed to the MO basis for use in constructing
# the Hessian. The transformation is performed in 3 steps as
# as only the vovo integrals are needed. 
#
# 1. VXpipi  
#
# Note that the integrals are not antisymmetrized in the transformation. 
#
# ---------------------------------------------------------------------- 
#
      PROC TRAN_VX_XIXI  
#     ----------------- 
#
      create Qxai 
      create QAxx
      create QBxx
      create QABxx 
#
      PARDO mu, nu, i, i1 
            Txixi(mu,i,nu,i1)          = 0.0 
            prepare VXxixi(mu,i,nu,i1) = Txixi(mu,i,nu,i1)
      ENDPARDO mu, nu, i, i1 
#
      execute server_barrier 
      execute sip_barrier 
#
#     Compute integrals and perform first two stages of the transformation. 
#     --------------------------------------------------------------------- 
#
      PARDO mu, nu, lambda, sigma
#          
            IF mu     < nu
            IF lambda < sigma
#             
               execute der2_comp saoint(mu,nu,lambda,sigma)
#             
               DO i
#                
                  V0xxxi(mu,nu,lambda,i) = saoint(mu,nu,lambda,sigma)*ca(sigma,i)
                  V2xxxi(mu,nu,sigma,i)  = saoint(mu,nu,lambda,sigma)*ca(lambda,i)
#                
                  DO i1
#
                     Txixi(mu,i1,lambda,i)          = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                     prepare VXxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                     T1xixi(mu,i1,sigma,i)          = V2xxxi(mu,nu,sigma,i)*ca(nu,i1)
                     prepare VXxixi(mu,i1,sigma,i)  += T1xixi(mu,i1,sigma,i)
#
                  ENDDO i1 #
#
                  DO i1
#
                     Txixi(nu,i1,lambda,i)          = V0xxxi(mu,nu,lambda,i)*ca(mu,i1)
                     prepare VXxixi(nu,i1,lambda,i) += Txixi(nu,i1,lambda,i)
#
                     T1xixi(nu,i1,sigma,i)          = V2xxxi(mu,nu,sigma,i)*ca(mu,i1)
                     prepare VXxixi(nu,i1,sigma,i)  += T1xixi(nu,i1,sigma,i)
#
                  ENDDO i1
#
               ENDDO i
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
                GET                   Dhfa(lambda,sigma)
                GET                   Dhfb(lambda,sigma)
                GET                   Dhfa(lambda,nu)
                GET                   Dhfb(lambda,nu)
                GET                   Dhfa(sigma,nu)
                GET                   Dhfb(sigma,nu)
                GET                   Dhfa(lambda,mu)
                GET                   Dhfb(lambda,mu)
                GET                   Dhfa(sigma,mu)
                GET                   Dhfb(sigma,mu)
#
                txx(lambda,sigma)   = Dhfa(lambda,sigma)
                txx(lambda,sigma)  += Dhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfb(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*Dhfa(sigma,nu)
                t1xx(mu,lambda)     *= -1.0
                PUT QAxx(mu,lambda) += t1xx(mu,lambda)
#
                t1xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*Dhfb(sigma,nu)
                t1xx(mu,lambda)     *= -1.0
                PUT QBxx(mu,lambda) += t1xx(mu,lambda)
#
                t1xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfa(lambda,mu)
                t1xx(nu,sigma)     *= -1.0
                PUT QAxx(nu,sigma) += t1xx(nu,sigma)
#
                t1xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfb(lambda,mu)
                t1xx(nu,sigma)     *= -1.0
                PUT QBxx(nu,sigma) += t1xx(nu,sigma)
#
                t1xx(nu,lambda)      = saoint(mu,nu,lambda,sigma)*Dhfa(sigma,mu)
                t1xx(nu,lambda)     *= -1.0
                PUT QAxx(nu,lambda) += t1xx(nu,lambda)
#
                t1xx(nu,lambda)      = saoint(mu,nu,lambda,sigma)*Dhfb(sigma,mu)
                t1xx(nu,lambda)     *= -1.0
                PUT QBxx(nu,lambda) += t1xx(nu,lambda)
#
                t1xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                t1xx(mu,nu)        *= 2.0  
                PUT QABxx(mu,nu)   += t1xx(mu,nu)
#
                txx(nu,mu)          = t1xx(mu,nu)  
                txx(mu,nu)         *= 2.0  
                PUT QABxx(nu,mu)   += txx(nu,mu)
#
            ENDIF # lambda < sigma
            ENDIF # mu     < nu
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            IF mu     == nu
            IF lambda < sigma
#
               execute der2_comp saoint(mu,nu,lambda,sigma)
#
               DO i
#
                  V0xxxi(mu,nu,lambda,i) = saoint(mu,nu,lambda,sigma)*ca(sigma,i)
                  V2xxxi(mu,nu,sigma,i)  = saoint(mu,nu,lambda,sigma)*ca(lambda,i)
#
                  DO i1
#
                     Txixi(mu,i1,lambda,i)          = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                     prepare VXxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                     T1xixi(mu,i1,sigma,i)          = V2xxxi(mu,nu,sigma,i)*ca(nu,i1)
                     prepare VXxixi(mu,i1,sigma,i)  += T1xixi(mu,i1,sigma,i)
#
                  ENDDO i1
#
               ENDDO i
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
                GET                   Dhfa(lambda,sigma)
                GET                   Dhfb(lambda,sigma)
                GET                   Dhfa(lambda,nu)
                GET                   Dhfb(lambda,nu)
                GET                   Dhfa(sigma,nu)
                GET                   Dhfb(sigma,nu)
                GET                   Dhfa(lambda,mu)
                GET                   Dhfb(lambda,mu)
                GET                   Dhfa(sigma,mu)
                GET                   Dhfb(sigma,mu)
#
                txx(lambda,sigma)   = Dhfa(lambda,sigma)
                txx(lambda,sigma)  += Dhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfb(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*Dhfa(sigma,nu)
                t1xx(mu,lambda)     *= -1.0
                PUT QAxx(mu,lambda) += t1xx(mu,lambda)
#
                t1xx(mu,lambda)      = saoint(mu,nu,lambda,sigma)*Dhfb(sigma,nu)
                t1xx(mu,lambda)     *= -1.0
                PUT QBxx(mu,lambda) += t1xx(mu,lambda)
#
                t1xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                t1xx(mu,nu)        *= 2.0  
                PUT QABxx(mu,nu)   += t1xx(mu,nu)
#
            ENDIF # lambda < sigma
            ENDIF # mu     == nu #
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            IF mu     < nu
            IF lambda == sigma
#
               execute der2_comp saoint(mu,nu,lambda,sigma)
#
               DO i
#
                  V0xxxi(mu,nu,lambda,i) = saoint(mu,nu,lambda,sigma)*ca(sigma,i)
#
                  DO i1
#
                     Txixi(mu,i1,lambda,i)          = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                     prepare VXxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                     T1xixi(nu,i1,lambda,i)         = V0xxxi(mu,nu,lambda,i)*ca(mu,i1)
                     prepare VXxixi(nu,i1,lambda,i) += T1xixi(nu,i1,lambda,i)
#
                  ENDDO i1
#
               ENDDO i
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
                GET                   Dhfa(lambda,sigma)
                GET                   Dhfb(lambda,sigma)
                GET                   Dhfa(lambda,nu)
                GET                   Dhfb(lambda,nu)
                GET                   Dhfa(sigma,nu)
                GET                   Dhfb(sigma,nu)
                GET                   Dhfa(lambda,mu)
                GET                   Dhfb(lambda,mu)
                GET                   Dhfa(sigma,mu)
                GET                   Dhfb(sigma,mu)
#
                txx(lambda,sigma)   = Dhfa(lambda,sigma)
                txx(lambda,sigma)  += Dhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfb(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfa(lambda,mu)
                t1xx(nu,sigma)     *= -1.0
                PUT QAxx(nu,sigma) += t1xx(nu,sigma)
#
                t1xx(nu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfb(lambda,mu)
                t1xx(nu,sigma)     *= -1.0
                PUT QBxx(nu,sigma) += t1xx(nu,sigma)
#
                t1xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                PUT QABxx(mu,nu)   += t1xx(mu,nu)
#
                txx(nu,mu)          = t1xx(mu,nu)  
                PUT QABxx(nu,mu)   += txx(nu,mu)
#
            ENDIF # lambda == sigma
            ENDIF # mu     < nu
#
      ENDPARDO mu, nu, lambda, sigma
#
      PARDO mu, nu, lambda, sigma
#
            IF mu     == nu
            IF lambda == sigma
#
               execute der2_comp saoint(mu,nu,lambda,sigma)
#
               DO i
#
                  V0xxxi(mu,nu,lambda,i) = saoint(mu,nu,lambda,sigma)*ca(sigma,i)
#
                  DO i1
#
                     Txixi(mu,i1,lambda,i)          = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                     prepare VXxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                  ENDDO i1
#
               ENDDO i
#
#               Update QAxx, QBxx, and QABxx
#               ----------------------------
#
                GET                   Dhfa(lambda,sigma)
                GET                   Dhfb(lambda,sigma)
                GET                   Dhfa(lambda,nu)
                GET                   Dhfb(lambda,nu)
                GET                   Dhfa(sigma,nu)
                GET                   Dhfb(sigma,nu)
                GET                   Dhfa(lambda,mu)
                GET                   Dhfb(lambda,mu)
                GET                   Dhfa(sigma,mu)
                GET                   Dhfb(sigma,mu)
#
                txx(lambda,sigma)   = Dhfa(lambda,sigma)
                txx(lambda,sigma)  += Dhfb(lambda,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfa(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QAxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(mu,sigma)      = saoint(mu,nu,lambda,sigma)*Dhfb(lambda,nu)
                t1xx(mu,sigma)     *= -1.0
                PUT QBxx(mu,sigma) += t1xx(mu,sigma)
#
                t1xx(mu,nu)         = saoint(mu,nu,lambda,sigma)*txx(lambda,sigma)
                PUT QABxx(mu,nu)   += t1xx(mu,nu)
#
            ENDIF # lambda == sigma
            ENDIF # mu     == nu
#
      ENDPARDO mu, nu, lambda, sigma
#
      execute server_barrier 
#
#     Perform third stage of the transformation. 
#     ------------------------------------------ 
#
#     Alpha/Alpha sipn component. 
#     --------------------------- 
#
      PARDO mu, i, i1  
#
             allocate L2xixi(mu,i,*,i1) 
#
             DO nu 
#
                REQUEST              VXxixi(mu,i,nu,i1) i 
                L2xixi(mu,i,nu,i1) = VXxixi(mu,i,nu,i1) 
#
             ENDDO nu 
#
            DO a
#
               txiai(mu,i,a,i1) = 0.0 
#
               DO nu 
#
                  T1xiai(mu,i,a,i1) = L2xixi(mu,i,nu,i1)*ca(nu,a)
                  Txiai(mu,i,a,i1) += T1xiai(mu,i,a,i1)  
#
               ENDDO nu  
#
               PREPARE VXxipi(mu,i,a,i1) = Txiai(mu,i,a,i1)
#
            ENDDO a
#
            deallocate L2xixi(mu,i,*,i1) 
#
      ENDPARDO mu, i, i1  
#
      execute server_barrier 
#
#     Perform fourth stage of the transformation. 
#     ------------------------------------------ 
#
      PARDO a, i, i1  
#
            allocate L3xipi(*,i,a,i1) 
#
            DO mu  
#
               REQUEST             VXxipi(mu,i,a,i1) a 
               L3xipi(mu,i,a,i1) = VXxipi(mu,i,a,i1) 
#
            ENDDO mu  
#
            DO a1
#
               Taiai(a1,i,a,i1) = 0.0 
#
               DO mu  
#
                  Tpppp(a1,i,a,i1)  = L3xipi(mu,i,a,i1)*ca(mu,a1)
                  Taiai(a1,i,a,i1) += Tpppp(a1,i,a,i1)  
               ENDDO mu  
#
               PREPARE VXpipi(a1,i,a,i1) = Taiai(a1,i,a,i1)
#
            ENDDO a1
#
            deallocate L3xipi(*,i,a,i1) 
#
      ENDPARDO a, i, i1  
#
      create Fxa 
      create Hxa 
      execute sip_barrier 
      execute server_barrier 
#
#     Finish the contribution to Qxai and Qxbj
#     ----------------------------------------
#
      PARDO mu, sigma
#
            GET               QABxx(mu,sigma)
            GET               QAxx(mu,sigma)
            GET               QBxx(mu,sigma)
#
            txx(mu,sigma)   = QABxx(mu,sigma)
            txx(mu,sigma)  += QAxx(mu,sigma)
#
            t1xx(mu,sigma)  = QABxx(mu,sigma)
            t1xx(mu,sigma) += QBxx(mu,sigma)
#
            DO a
#
               tax(a,sigma) = ca(mu,a)*txx(mu,sigma)
#
               DO i
#
                  tai(a,i)       = tax(a,sigma)*ca(sigma,i)
                  PUT Qxai(a,i) += tai(a,i)
#
               ENDDO i
#
            ENDDO a
#
            DO p
#
               tpx(p,sigma) = ca(mu,p)*txx(mu,sigma)
#
               DO p1 
#
                  tpp(p,p1)      = tpx(p,sigma)*ca(sigma,p1)
                  PUT Hxa(p,p1) += tpp(p,p1)
#
               ENDDO p1 
#
            ENDDO p
#
            DO i
#
               tpx(i,sigma) = ca(mu,i)*txx(mu,sigma)
#
               DO i1 
#
                  tpp(i,i1)       = tpx(i,sigma)*ca(sigma,i1)
                  PUT Fxa(i,i1) += tpp(i,i1)
#
               ENDDO i1 
#
            ENDDO i
#
            DO a
#
               tpx(a,sigma) = ca(mu,a)*txx(mu,sigma)
#
               DO a1 
#
                  tpp(a,a1)       = tpx(a,sigma)*ca(sigma,a1)
                  PUT Fxa(a,a1) += tpp(a,a1)
#
               ENDDO a1 
#
            ENDDO a
#
      ENDPARDO mu, sigma
#
      execute sip_barrier
#
      ENDPROC TRAN_VX_XIXI  
#     --------------------  
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC QYAI_H 
#     ----------- 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Qxai and Qxbj  
#           ------------------------------ 
#
            DO a 
#
               tpx(a,nu) = ca(mu,a)*txx(mu,nu)   
#
               DO i 
#
                  tpp(a,i)       = tpx(a,nu)*ca(nu,i) 
                  PUT Qyai(a,i) += tpp(a,i) 
#
               ENDDO i  
#
            ENDDO a 
#
      ENDPARDO mu, nu 
#
      ENDPROC QYAI_H 
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC QXAI_H 
#     ----------- 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Qxai and Qxbj  
#           ------------------------------ 
#
            DO a 
#
               tpx(a,nu) = txx(mu,nu)*ca(mu,a)  
#
               DO i 
#
                  tpp(a,i)       = tpx(a,nu)*ca(nu,i) 
                  PUT Qxai(a,i) += tpp(a,i) 
#
               ENDDO i  
#
            ENDDO a 
#
      ENDPARDO mu, nu 
#
      ENDPROC QXAI_H 
#     -------------- 
#
# ---------------------------------------------------------------------------
#
      PROC FINTY_TRAN 
#     --------------- 
#
#     The transformed first-derivative fock matrix is computed. The 
#     perturbation is defined by jatom, jx and jcenter and the 
#     final arrays are Fya and Fyb. 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
#           Contributions to Fya and Fyb 
#           ---------------------------- 
#
            DO a 
#
               txp(mu,a) = txx(mu,nu)*ca(nu,a)  
#
               DO a1 
#
                  tpp(a1,a)      = txp(mu,a)*ca(mu,a1) 
                  PUT Fya(a1,a) += tpp(a1,a) 
#
               ENDDO a1  
#
            ENDDO a 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO i1 
#
                  tpp(i1,i)      = txp(mu,i)*ca(mu,i1) 
                  PUT Fya(i1,i) += tpp(i1,i) 
#
               ENDDO i1  
#
            ENDDO i 
#
      ENDPARDO mu, nu 
#
      execute sip_barrier 
#
#     Add contributions from overlap derivatives and two-electron integrals  
#     --------------------------------------------------------------------- 
#
#     alpha-alpha virtual-virtual block 
#     --------------------------------- 
#
      PARDO a, a1 
#
            taa(a,a1) = 0.0 
#
            DO a2 
#
               if a2 == a1 
#
               GET           Sya(a,a2) 
               t1aa(a,a1)  = Sya(a,a2)*Fock_a(a1,a2) 
               t1aa(a,a1) *= -0.5  
               taa(a,a1)  += t1aa(a,a1) 
#
               endif 
#
            ENDDO a2 
#
            DO a2 
#
               if a2 == a 
#
               GET           Sya(a2,a1) 
               t1aa(a,a1)  = Sya(a2,a1)*Fock_a(a2,a) 
               t1aa(a,a1) *= -0.5  
               taa(a,a1)  += t1aa(a,a1) 
#
               endif 
#
            ENDDO a2 
#
            DO i 
            DO i1 
#
               REQUEST             Vaaii(a,a1,i,i1) a
               REQUEST             Viaai(i,a1,a,i1) a
               GET                 Sya(i1,i) 
#
               tpppp(a,a1,i,i1)  = Vaaii(a,a1,i,i1) 
               t1pppp(a,a1,i,i1) = Viaai(i,a1,a,i1) 
               tpppp(a,a1,i,i1) -= t1pppp(a,a1,i,i1) 
#
               t1aa(a,a1)        = tpppp(a,a1,i,i1)*Sya(i1,i)  
               taa(a,a1)        -= t1aa(a,a1) 
#
            ENDDO i1 
            ENDDO i 
#
            DO j 
            DO j1 
#
               REQUEST      Vaaii(a,a1,j,j1) a
               GET          Sya(j1,j) 
#
               t1aa(a,a1) = Vaaii(a,a1,j,j1)*Sya(j1,j)  
               taa(a,a1) -= t1aa(a,a1) 
#
            ENDDO j1 
            ENDDO j 
#
            DO a2 
            DO i 
#
               REQUEST             VSaaai(a1,a,a2,i) a
               REQUEST             VSaaai(a,a1,a2,i) a 
               GET                 Uyaa(a2,i) 
#
               tpppp(a,a1,a2,i)  = VSaaai(a1,a,a2,i) 
               t1pppp(a,a1,a2,i) = VSaaai(a,a1,a2,i) 
               tpppp(a,a1,a2,i) += t1pppp(a,a1,a2,i) 
#
               t1aa(a,a1)        = tpppp(a,a1,a2,i)*Uyaa(a2,i) 
               taa(a,a1)        += t1aa(a,a1) 
#
            ENDDO i 
            ENDDO a2 
#
            DO b 
            DO j 
#
               REQUEST            Vaaai(a1,a,b,j) b 
               REQUEST            Vaaai(a,a1,b,j) b 
               GET                Uyaa(b,j) 
#
               tppqq(a,a1,b,j)  = Vaaai(a1,a,b,j) 
               t1ppqq(a,a1,b,j) = Vaaai(a,a1,b,j) 
               tppqq(a,a1,b,j) += t1ppqq(a,a1,b,j) 
#
               t1aa(a,a1)       = tppqq(a,a1,b,j)*Uyaa(b,j) 
               taa(a,a1)       += t1aa(a,a1) 
#
            ENDDO j 
            ENDDO b 
#
            PUT Fya(a,a1) += taa(a,a1)  
#
      ENDPARDO a, a1 
#
#     alpha-alpha occupied-occupied block 
#     ----------------------------------- 
#
      PARDO i, i1 
#
            tii(i,i1) = 0.0 
#
            DO i2 
#
               if i1 == i2 
#
               GET           Sya(i,i2) 
               t1ii(i,i1)  = Sya(i,i2)*Fock_a(i1,i2) 
               t1ii(i,i1) *= -0.5  
               tii(i,i1)  += t1ii(i,i1) 
#
               endif 
#
            ENDDO i2 
#
            DO i2 
#
               if i == i2 
#
               GET           Sya(i2,i1) 
               t1ii(i,i1)  = Sya(i2,i1)*Fock_a(i2,i) 
               t1ii(i,i1) *= -0.5  
               tii(i,i1)  += t1ii(i,i1) 
#
               endif 
#
            ENDDO i2 
#
            DO i2 
            DO i3 
#
               REQUEST      VSpipi(i,i1,i2,i3) i
               GET          Sya(i3,i2) 
#
               t1ii(i,i1) = VSpipi(i,i1,i2,i3)*Sya(i3,i2)  
               tii(i,i1) -= t1ii(i,i1) 
#
            ENDDO i3 
            ENDDO i2
#
            DO j 
            DO j1 
#
               REQUEST      Vpiqj(i,i1,j,j1) i
               GET          Sya(j1,j) 
#
               t1ii(i,i1) = Vpiqj(i,i1,j,j1)*Sya(j1,j)  
               tii(i,i1) -= t1ii(i,i1) 
#
            ENDDO j1 
            ENDDO j 
#
            DO a2 
            DO i2 
#
               REQUEST              VSpipi(i1,i,a2,i2) i 
               REQUEST              VSpipi(i,i1,a2,i2) i 
               GET                  Uyaa(a2,i2) 
#
               tpppp(i,i1,a2,i2)  = VSpipi(i1,i,a2,i2) 
               t1pppp(i,i1,a2,i2) = VSpipi(i,i1,a2,i2) 
               tpppp(i,i1,a2,i2) += t1pppp(i,i1,a2,i2) 
#
               t1ii(i,i1)         = tpppp(i,i1,a2,i2)*Uyaa(a2,i2) 
               tii(i,i1)         += t1ii(i,i1) 
#
            ENDDO i2 
            ENDDO a2 
#
            DO b 
            DO j 
#
               REQUEST            Vpiqj(i1,i,b,j) i
               REQUEST            Vpiqj(i,i1,b,j) i
               GET                Uyaa(b,j) 
#
               tppqq(i,i1,b,j)  = Vpiqj(i1,i,b,j) 
               t1ppqq(i,i1,b,j) = Vpiqj(i,i1,b,j) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j) 
#
               t1ii(i,i1)       = tppqq(i,i1,b,j)*Uyaa(b,j) 
               tii(i,i1)       += t1ii(i,i1) 
#
            ENDDO j 
            ENDDO b 
#
            PUT Fya(i,i1) += tii(i,i1)  
#
      ENDPARDO i, i1 
#
      ENDPROC FINTY_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC FINTX_TRAN 
#     --------------- 
#
#     The transformed first-derivative fock matrix is computed. The 
#     perturbation is defined by iatom, ix and icenter and the 
#     final arrays are Fxa and Fxb. 
#
      PARDO mu, nu 
#
            execute fock_der txx(mu,nu) 
#
            DO p 
#
               txp(mu,p) = txx(mu,nu)*ca(nu,p)  
#
               DO p1 
#
                  tpp(p1,p)      = txp(mu,p)*ca(mu,p1) 
                  PUT Hxa(p1,p) += tpp(p1,p) 
#
               ENDDO p1  
#
            ENDDO p 
#
            DO a 
#
               txp(mu,a) = txx(mu,nu)*ca(nu,a)  
#
               DO a1 
#
                  tpp(a1,a)      = txp(mu,a)*ca(mu,a1) 
                  PUT Fxa(a1,a) += tpp(a1,a) 
#
               ENDDO a1  
#
            ENDDO a 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO i1 
#
                  tpp(i1,i)      = txp(mu,i)*ca(mu,i1) 
                  PUT Fxa(i1,i) += tpp(i1,i) 
#
               ENDDO i1  
#
            ENDDO i 
#
#           Compute contributions to the HF hessian. 
#           ---------------------------------------- 
#
            GET            dhfya(mu,nu) 
#
            GET            QABxx(mu,nu) 
            GET            QAxx(mu,nu) 
            GET            QBxx(mu,nu) 

            t1xx(mu,nu)  = txx(mu,nu) 
            t1xx(mu,nu) += QABxx(mu,nu) 
            t1xx(mu,nu) += QAxx(mu,nu) 

           #etemp        = t1xx(mu,nu)*dhfya(mu,nu) 
           #etemp       *= 0.5 
           #hessxy      += etemp 
           #hessyx      += etemp 

            t1xx(mu,nu)  = txx(mu,nu) 
            t1xx(mu,nu) += QABxx(mu,nu) 
            t1xx(mu,nu) += QBxx(mu,nu) 

            etemp        = t1xx(mu,nu)*dhfya(mu,nu) 
           #etemp       *= 0.5 
            hessxy      += etemp 
            hessyx      += etemp 
#
      ENDPARDO mu, nu 
#
      execute sip_barrier 
#
#     Add contributions from overlap derivatives and two-electron integrals  
#     --------------------------------------------------------------------- 
#
#     alpha-alpha virtual-virtual block 
#     --------------------------------- 
#
      PARDO a, a1 
#
            taa(a,a1) = 0.0 
#
            DO a2 
#
               GET           Sxa(a,a2) 
               t1aa(a,a1)  = Sxa(a,a2)*Fock_a(a1,a2) 
               t1aa(a,a1) *= -0.5  
               taa(a,a1)  += t1aa(a,a1) 
#
            ENDDO a2 
#
            DO a2 
#
               GET           Sxa(a2,a1) 
               t1aa(a,a1)  = Sxa(a2,a1)*Fock_a(a2,a) 
               t1aa(a,a1) *= -0.5  
               taa(a,a1)  += t1aa(a,a1) 
#
            ENDDO a2 
#
            DO i 
            DO i1 
#
               REQUEST             Vaaii(a,a1,i,i1) a
               REQUEST             Viaai(i,a1,a,i1) a
               GET                 Sxa(i1,i) 
#
               tpppp(a,a1,i,i1)  = Vaaii(a,a1,i,i1) 
               t1pppp(a,a1,i,i1) = Viaai(i,a1,a,i1) 
               tpppp(a,a1,i,i1) -= t1pppp(a,a1,i,i1) 
#
               t1aa(a,a1)        = tpppp(a,a1,i,i1)*Sxa(i1,i)  
               taa(a,a1)        -= t1aa(a,a1) 
#
            ENDDO i1 
            ENDDO i 
#
            DO j 
            DO j1 
#
               REQUEST      Vaaii(a,a1,j,j1) a
               GET          Sxa(j1,j) 
#
               t1aa(a,a1) = Vaaii(a,a1,j,j1)*Sxa(j1,j)  
               taa(a,a1) -= t1aa(a,a1) 
#
            ENDDO j1 
            ENDDO j 
#
            DO a2 
            DO i 
#
               REQUEST             VSaaai(a1,a,a2,i) a
               REQUEST             VSaaai(a,a1,a2,i) a  
               GET                 Uxaa(a2,i) 
#
               tpppp(a,a1,a2,i)  = VSaaai(a1,a,a2,i) 
               t1pppp(a,a1,a2,i) = VSaaai(a,a1,a2,i) 
               tpppp(a,a1,a2,i) += t1pppp(a,a1,a2,i) 
#
               t1aa(a,a1)        = tpppp(a,a1,a2,i)*Uxaa(a2,i) 
               taa(a,a1)        += t1aa(a,a1) 
#
            ENDDO i 
            ENDDO a2 
#
            DO b 
            DO j 
#
               REQUEST Vaaai(a1,a,b,j) a 
               REQUEST Vaaai(a,a1,b,j) a 
               GET Uxaa(b,j) 
#
               tppqq(a,a1,b,j) = Vaaai(a1,a,b,j) 
               t1ppqq(a,a1,b,j) = Vaaai(a,a1,b,j) 
               tppqq(a,a1,b,j) += t1ppqq(a,a1,b,j) 
#
               t1aa(a,a1) = tppqq(a,a1,b,j)*Uxaa(b,j) 
               taa(a,a1) += t1aa(a,a1) 
#
            ENDDO j 
            ENDDO b 
#
            PUT Fxa(a,a1) += taa(a,a1)  
#
      ENDPARDO a, a1 
#
#     alpha-alpha occupied-occupied block 
#     ----------------------------------- 
#
      PARDO i, i1 
#
            tii(i,i1) = 0.0 
#
            DO i2 
#
               GET Sxa(i,i2) 
               t1ii(i,i1) = Sxa(i,i2)*Fock_a(i1,i2) 
               t1ii(i,i1) *= -0.5  
               tii(i,i1) += t1ii(i,i1) 
#
            ENDDO i2 
#
            DO i2 
#
               GET Sxa(i2,i1) 
               t1ii(i,i1) = Sxa(i2,i1)*Fock_a(i2,i) 
               t1ii(i,i1) *= -0.5  
               tii(i,i1) += t1ii(i,i1) 
#
            ENDDO i2 
#
            DO i2 
            DO i3 
#
               REQUEST VSpipi(i,i1,i2,i3) i 
               GET Sxa(i3,i2) 
#
               t1ii(i,i1) = VSpipi(i,i1,i2,i3)*Sxa(i3,i2)  
               tii(i,i1) -= t1ii(i,i1) 
#
            ENDDO i3 
            ENDDO i2
#
            DO j 
            DO j1 
#
               REQUEST Vpiqj(i,i1,j,j1) i
               GET Sxa(j1,j) 
#
               t1ii(i,i1) = Vpiqj(i,i1,j,j1)*Sxa(j1,j)  
               tii(i,i1) -= t1ii(i,i1) 
#
            ENDDO j1 
            ENDDO j 
#
            DO a2 
            DO i2 
#
               REQUEST VSpipi(i1,i,a2,i2) i
               REQUEST VSpipi(i,i1,a2,i2) i
               GET Uxaa(a2,i2) 
#
               tpppp(i,i1,a2,i2) = VSpipi(i1,i,a2,i2) 
               t1pppp(i,i1,a2,i2) = VSpipi(i,i1,a2,i2) 
               tpppp(i,i1,a2,i2) += t1pppp(i,i1,a2,i2) 
#
               t1ii(i,i1) = tpppp(i,i1,a2,i2)*Uxaa(a2,i2) 
               tii(i,i1) += t1ii(i,i1) 
#
            ENDDO i2 
            ENDDO a2 
#
            DO b 
            DO j 
#
               REQUEST Vpiqj(i1,i,b,j) b
               REQUEST Vpiqj(i,i1,b,j) b
               GET Uxaa(b,j) 
#
               tppqq(i,i1,b,j) = Vpiqj(i1,i,b,j) 
               t1ppqq(i,i1,b,j) = Vpiqj(i,i1,b,j) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j) 
#
               t1ii(i,i1) = tppqq(i,i1,b,j)*Uxaa(b,j) 
               tii(i,i1) += t1ii(i,i1) 
#
            ENDDO j 
            ENDDO b 
#
            PUT Fxa(i,i1) += tii(i,i1)  
#
      ENDPARDO i, i1 
#
      ENDPROC FINTX_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC SINTY_TRAN 
#     --------------- 
#
#     The transformed first-derivative overlap matrix is computed. The 
#     perturbation is defined by jatom, jx and jcenter and the 
#     final arrays are Sya and Syb. 
#
      create Sya 
#
      execute sip_barrier 
#
      PARDO mu, nu 
#
            txx(mu,nu)  = 0.0 
#
            execute overlap_der txx(mu,nu) 
#
            DO p 
#
               txp(mu,p) = txx(mu,nu)*ca(nu,p)  
#
               DO p1 
#
                  tpp(p1,p)       = txp(mu,p)*ca(mu,p1) 
                  PUT Sya(p1,p)  += tpp(p1,p) 
#
               ENDDO p1  
#
            ENDDO p 
#
      ENDPARDO mu, nu 

      execute sip_barrier 
#
      ENDPROC SINTY_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC SINTX_TRAN 
#     --------------- 
#
#     The transformed first-derivative overlap matrix is computed. The 
#     perturbation is defined by iatom, ix and icenter and the 
#     final arrays are Sxa and Sxb. 
#
      create Sxa 
#
      execute sip_barrier 
#
      PARDO mu, nu 
#
            execute overlap_der txx(mu,nu) 
#
#           Compute contributions to HF hessian. 
#           ------------------------------------ 
#
            GET            whfya(mu,nu) 
           #GET            whfya(mu,nu) 
            t1xx(mu,nu)  = whfya(mu,nu) 
           #t1xx(mu,nu) += whfya(mu,nu) 
            etemp        = txx(mu,nu)*t1xx(mu,nu) 
           #etemp       *= 0.5 
            hessxy      += etemp 
            hessyx      += etemp 
#
            DO p 
#
               txp(mu,p) = txx(mu,nu)*ca(nu,p)  
#
               DO p1 
#
                  tpp(p1,p)       = txp(mu,p)*ca(mu,p1) 
                  PUT Sxa(p1,p)  += tpp(p1,p) 
#
               ENDDO p1  
#
            ENDDO p 
#
      ENDPARDO mu, nu 
# 
      ENDPROC SINTX_TRAN 
#     ------------------ 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC Uy_XX  
#     ----------- 
#
      create Uyaa 
      execute sip_barrier 
#
      PARDO mu, nu 
#
            execute overlap_der txx(mu,nu) 
#
            DO a 
#
               txp(mu,a) = txx(mu,nu)*ca(nu,a)  
#
               DO a1 
#
                  tpp(a1,a)       = txp(mu,a)*ca(mu,a1) 
                  tpp(a1,a)      *= -0.5  
                  PUT Uyaa(a1,a) += tpp(a1,a) 
#
               ENDDO a1  
#
            ENDDO a 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO i1 
#
                  tpp(i1,i)       = txp(mu,i)*ca(mu,i1) 
                  tpp(i1,i)      *= -0.5  
                  PUT Uyaa(i1,i) += tpp(i1,i) 
#
               ENDDO i1  
#
            ENDDO i 
#
      ENDPARDO mu, nu 
#
#     Form the virtual-occupied block of the Q array --> Qyai, Qybj 
#     ------------------------------------------------------------- 
#
#     Qyai first 
#     ---------- 
#
      PARDO a, i 
#
            tai(a,i) = 0.0 # Fya(a,i) 
#
            DO i1 
#
               if i1 == i 
#
               GET         Sya(a,i) 
               t1ai(a,i) = Sya(a,i1)*Fock_a(i1,i) 
               tai(a,i) -= t1ai(a,i) 
#
               endif 
#
               DO i2 
#
                  REQUEST     VSpipi(a,i,i2,i1) i  
                  GET         Sya(i2,i1) 
                  t1ai(a,i) = VSpipi(a,i,i2,i1)*Sya(i2,i1) 
                  tai(a,i) -= t1ai(a,i) 
#
               ENDDO i2 
#
            ENDDO i1 
#
            DO j 
            DO j1 
#
               REQUEST     Vpiqj(a,i,j1,j) a  
               GET         Sya(j1,j) 
               t1ai(a,i) = Vpiqj(a,i,j1,j)*Sya(j1,j) 
               tai(a,i) -= t1ai(a,i) 
#
            ENDDO j1 
            ENDDO j 
#
            PUT Qyai(a,i) += tai(a,i) 
#
      ENDPARDO a, i 
#
      ENDPROC Uy_XX  
#     ------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC Ux_XX  
#     ----------- 
#
      create Uxaa 
#
      execute sip_barrier 
#
      PARDO mu, nu 
#
            txx(mu,nu)        = 0.0 
            execute overlap_der txx(mu,nu) 
#
            DO a 
#
               txp(mu,a) = txx(mu,nu)*ca(nu,a)  
#
               DO a1 
#
                  tpp(a1,a)       = txp(mu,a)*ca(mu,a1) 
                  tpp(a1,a)      *= -0.5  
                  PUT Uxaa(a1,a) += tpp(a1,a) 
#
               ENDDO a1  
#
            ENDDO a 
#
            DO i 
#
               txp(mu,i) = txx(mu,nu)*ca(nu,i)  
#
               DO i1 
#
                  tpp(i1,i)       = txp(mu,i)*ca(mu,i1) 
                  tpp(i1,i)      *= -0.5  
                  PUT Uxaa(i1,i) += tpp(i1,i) 
#
               ENDDO i1  
#
            ENDDO i 
#
      ENDPARDO mu, nu 
#
#     Form the virtual-occupied block of the Q array --> Qxai, Qxbj
#     -------------------------------------------------------------
#
#     Qxai first
#     ----------
#
      PARDO a, i
#
            tai(a,i) = 0.0 # Fxa(a,i)
#
            DO i1
#
               GET         Sxa(a,i1)
               t1ai(a,i) = Sxa(a,i1)*Fock_a(i,i1)
               tai(a,i) -= t1ai(a,i)
#
               DO i2
#
                  REQUEST     VSpipi(a,i,i2,i1) i 
                  GET         Sxa(i1,i2)
                  t1ai(a,i) = VSpipi(a,i,i2,i1)*Sxa(i1,i2)
                  tai(a,i) -= t1ai(a,i)
#
               ENDDO i2
#
            ENDDO i1
#
            DO j
            DO j1
#
               REQUEST     Vpiqj(a,i,j1,j) a 
               GET         Sxa(j,j1)
               t1ai(a,i) = Vpiqj(a,i,j1,j)*Sxa(j,j1)
               tai(a,i) -= t1ai(a,i)
#
            ENDDO j1
            ENDDO j
#
            PUT Qxai(a,i) += tai(a,i)
#
      ENDPARDO a, i
#
      ENDPROC Ux_XX  
#     ------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC I_TRANS
#     ------------
#
      create Ixx_a 
      create Ihf 
      execute sip_barrier 
#
#     1. Iij_a
#     --------
#
      PARDO i, i1
#
            GET Ipq_a(i,i1)
#
            DO mu
#
               Txi(mu,i1) = ca(mu,i)*Ipq_a(i,i1)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i1)*ca(nu,i1)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO i, i1
#
#     3. Iab_a
#     --------
#
      PARDO a, a1
#
            GET Ipq_a(a,a1)
#
            DO mu
#
               Txa(mu,a1) = ca(mu,a)*Ipq_a(a,a1)
#
               DO nu
#
                  Txx(mu,nu)        = Txa(mu,a1)*ca(nu,a1)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, a1
#
#     5. Iai_a
#     --------
#
      PARDO a, i
#
#           GET Ipq_a(a,i)
            GET Ipq_a(i,a)
#
            DO mu
#
               Txi(mu,i)  = ca(mu,a)*Ipq_a(i,a)
#              T1xi(mu,i) = ca(mu,a)*Ipq_a(i,a)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i)*ca(nu,i)
                  PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
                  T1xx(nu,mu)       = Txx(mu,nu) 
                  PUT Ixx_a(nu,mu) += T1xx(nu,mu)
#
#                 Txx(mu,nu)        = T1xi(mu,i)*ca(nu,i)
#                 PUT Ixx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, i
#
      ENDPROC I_TRANS
#     ---------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC D_TRANS
#     ------------
#
      create Dxx_a 
      execute sip_barrier 
#
#     1. Dij_a
#     --------
#
      PARDO i, i1
#
            GET Dij_a(i,i1)
#
            DO mu
#
               Txi(mu,i1) = ca(mu,i)*Dij_a(i,i1)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i1)*ca(nu,i1)
                  PUT Dxx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO i, i1
#
#     3. Dab_a
#     --------
#
      PARDO a, a1
#
            GET Dab_a(a,a1)
#
            DO mu
#
               Txa(mu,a1) = ca(mu,a)*Dab_a(a,a1)
#
               DO nu
#
                  Txx(mu,nu)        = Txa(mu,a1)*ca(nu,a1)
                  PUT Dxx_a(mu,nu) += Txx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, a1
#
#     5. Dai_a
#     --------
#
      PARDO a, i
#
            GET Dai_a(a,i)
#
            DO mu
#
               Txi(mu,i) = ca(mu,a)*Dai_a(a,i)
#
               DO nu
#
                  Txx(mu,nu)        = Txi(mu,i)*ca(nu,i)
                  PUT Dxx_a(mu,nu) += Txx(mu,nu)
#
                  T1xx(nu,mu)       = Txx(mu,nu)
                  PUT Dxx_a(nu,mu) += T1xx(nu,mu) 
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, i
#
      ENDPROC D_TRANS
#     ---------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC I_HF
#     --------
#
      execute sip_barrier 
#
      PARDO mu, nu, i
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               T1xi(nu,i) = ca(nu,i1)*fock_a(i,i1)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)      = ca(mu,i)*Txi(nu,i)
            PUT Ihf(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i
#
      execute sip_barrier 
#
      ENDPROC I_HF
#     ------------
#
# ---------------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
      create Dhfa 
      create Dhfb 
      execute sip_barrier 
#
      PARDO mu, nu, i
#
            Txi(nu,i)        = ca(nu,i)
            Txx(mu,nu)       = ca(mu,i)*Txi(nu,i)
            PUT Dhfa(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i
#
      PARDO mu, nu, j
#
            Txj(nu,j)        = ca(nu,j)
            Txx(mu,nu)       = ca(mu,j)*Txj(nu,j)
            PUT Dhfb(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, j
#
      ENDPROC HFDENS
#     --------------
#
# ---------------------------------------------------------------------------------- 
#
     PROC I11
#    --------
#
      PARDO a, i
#
            Tia(i,a) = 0.0
#
            DO i1
#
               IF i1 == i
#
                  GET         Dpq_a(a,i1)
                  T1ia(i,a) = Dpq_a(a,i1)*fock_a(i1,i)
                  Tia(i,a) -= T1ia(i,a)
#
               ENDIF # i1 == i
#
            ENDDO i1
#
            PUT Ipq_a(i,a) += Tia(i,a)
#
      ENDPARDO a, i 
#
# Compute contribution to Iij_a
# -----------------------------
#
#     Dab contribution
#     ----------------
#
      PARDO a, a1, i, i1
#
            REQUEST             Vaaii(a,a1,i,i1) a
            REQUEST             Viaai(i,a1,a,i1) a
            REQUEST             Vaaii(a,a1,i1,i) a
            REQUEST             Viaai(i1,a1,a,i) a  
            GET                 Dab_a(a,a1)
#
            Tpppp(i,i1,a,a1)  = Vaaii(a,a1,i,i1)
            T1pppp(i,i1,a,a1) = Viaai(i,a1,a,i1)
            T2pppp(i,i1,a,a1) = Vaaii(a,a1,i1,i)
            T3pppp(i,i1,a,a1) = Viaai(i1,a1,a,i)
#
            Tpppp(i,i1,a,a1) -= T1pppp(i,i1,a,a1)
            Tpppp(i,i1,a,a1) += T2pppp(i,i1,a,a1)
            Tpppp(i,i1,a,a1) -= T3pppp(i,i1,a,a1)
#
            Tii(i,i1)         = Tpppp(i,i1,a,a1)*Dab_a(a,a1)
            Tii(i,i1)        *= -0.5
            PUT Iij_a(i,i1)  += Tii(i,i1)
#
      ENDPARDO a, a1, i, i1
#
      PARDO b, b1, i, i1
#
            REQUEST             Vaaii(b,b1,i,i1) b
            REQUEST             Vaaii(b,b1,i1,i) b 
            GET                 Dab_a(b,b1)
#
            Tppqq(i,i1,b,b1)  = Vaaii(b,b1,i,i1)
            T2ppqq(i,i1,b,b1) = Vaaii(b,b1,i1,i)
            Tppqq(i,i1,b,b1) += T2ppqq(i,i1,b,b1)
#
            Tii(i,i1)         = Tppqq(i,i1,b,b1)*Dab_a(b,b1)
            Tii(i,i1)        *= -0.5
            PUT Iij_a(i,i1)  += Tii(i,i1)
#
      ENDPARDO b, b1, i, i1
#
#     Dij contribution
#     ----------------
#
      PARDO i2, i3, i, i1
#
            REQUEST              VSpipi(i2,i3,i,i1) i
            REQUEST              VSpipi(i2,i3,i1,i) i 
            GET                  Dij_a(i2,i3)
#
            Tpppp(i,i1,i2,i3)  = VSpipi(i2,i3,i,i1)
            T2pppp(i,i1,i2,i3) = VSpipi(i2,i3,i1,i)
            Tpppp(i,i1,i2,i3) += T2pppp(i,i1,i2,i3)
#
            Tii(i,i1)          = Tpppp(i,i1,i2,i3)*Dij_a(i2,i3)
            Tii(i,i1)         *= -0.5
            PUT Iij_a(i,i1)   += Tii(i,i1)
#
      ENDPARDO i2, i3, i, i1
#
      PARDO j, j1, i, i1
#
            REQUEST             Vpiqj(i,i1,j,j1) i
            REQUEST             Vpiqj(i1,i,j,j1) i  
            GET                 Dij_a(j,j1)
#
            Tppqq(i,i1,j,j1)  = Vpiqj(i,i1,j,j1)
            T2ppqq(i,i1,j,j1) = Vpiqj(i1,i,j,j1)
            Tppqq(i,i1,j,j1) += T2ppqq(i,i1,j,j1)
#
            Tii(i,i1)         = Tppqq(i,i1,j,j1)*Dij_a(j,j1)
            Tii(i,i1)        *= -0.5
            PUT Iij_a(i,i1)  += Tii(i,i1)
#
      ENDPARDO j, j1, i, i1
#
# DONE Compute contribution to Iij_a
# -----------------------------------
#
#      virtual-occupied contribution 
#      -----------------------------
#
       PARDO i, i1, a, i2
#
             REQUEST            VSpipi(i,i1,a,i2) a 
             GET                Dpq_a(a,i2)
#
             Tii(i,i1)        = VSpipi(i,i1,a,i2)*Dpq_a(a,i2)
             Tii(i,i1)       *= -1.0
             PUT Iij_a(i,i1) += Tii(i,i1)
             T1ii(i1,i)       = Tii(i,i1)
             PUT Iij_a(i1,i) += T1ii(i1,i)
#
       ENDPARDO i, i1, a, i2 
#
       PARDO i, i1, b, j
#
             REQUEST            Vpiqj(i,i1,b,j) b 
             GET                Dpq_a(b,j)
#
             Tii(i,i1)        = Vpiqj(i,i1,b,j)*Dpq_a(b,j)
             Tii(i,i1)       *= -1.0
             PUT Iij_a(i,i1) += Tii(i,i1)
             T1ii(i1,i)       = Tii(i,i1)
             PUT Iij_a(i1,i) += T1ii(i1,i)
#
       ENDPARDO i, i1, b, j
#
       execute sip_barrier 
#
#      Complete intermediate arrays to be used in construction of Hessian. 
#      ------------------------------------------------------------------- 
#
       PARDO i, i1
             GET               Iij_a(i,i1)
             PUT Ipq_a(i,i1) = Iij_a(i,i1)
       ENDPARDO i, i1
#
       PARDO a, a1
             GET               Iab_a(a,a1)
             PUT Ipq_a(a,a1) = Iab_a(a,a1)
       ENDPARDO a, a1
#
       PARDO a, i
             GET              Ipq_a(i,a)
             tai(a,i)       = Ipq_a(i,a)
             PUT Ipq_a(a,i) = tai(a,i)
       ENDPARDO a, i
#
       execute sip_barrier 
#
     ENDPROC I11
#    -----------
#
# ---------------------------------------------------------------------------------
#
      PROC SXY_CONT
#     -------------
#
# Contract with the second derivative integrals
# --------------------------------------
#
      PARDO mu, nu
#
            GET             Ihf(mu,nu) 
            GET             Ixx_a(mu,nu)

            Txx(mu,nu)    = Ixx_a(mu,nu)
            Txx(mu,nu)   += Ihf(mu,nu)
            Txx(mu,nu)   *= 2.0  

            EXECUTE SCONTXY Txx(mu,nu)
# 
      ENDPARDO mu, nu
#
      ENDPROC SXY_CONT
#     ----------------
#
# ---------------------------------------------------------------------------------
#
      PROC DXY_CONT
#     -------------
#
# Contract with the second derivative integrals
# --------------------------------------
#
      PARDO mu, nu
            GET             Dxx_a(mu,nu)
            GET             Dhfa(mu,nu)
#
            Txx(mu,nu)    = Dxx_a(mu,nu)
            Txx(mu,nu)   += Dhfa(mu,nu)
            Txx(mu,nu)   *= 2.0  
#
            EXECUTE HCONTXY Txx(mu,nu)
#
      ENDPARDO mu, nu
#
      ENDPROC DXY_CONT
#     ----------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC GIJAB_BT
#     --------------
#
#     First 'backtransform' G^{ab}_{ij} to G^{mu nu}_{ij}.
#     ----------------------------------------------------
#
#     alpha/alpha block.
#     ------------------
#
      PARDO mu, nu, i, i1
#
            Txixi(mu,i,nu,i1) = 0.0 
#
            DO a1
#
               Txiai(mu,i,a1,i1) = 0.0 
#
               DO a  
#
                  REQUEST              T1aiai_aa(a,i,a1,i1) a
                  T1xiai(mu,i,a1,i1) = T1aiai_aa(a,i,a1,i1)*ca(mu,a)
                  Txiai(mu,i,a1,i1) += T1xiai(mu,i,a1,i1)  
#
               ENDDO a 
#
               T1xixi(mu,i,nu,i1) = Txiai(mu,i,a1,i1)*ca(nu,a1)
               Txixi(mu,i,nu,i1) += T1xixi(mu,i,nu,i1) 
#
            ENDDO a1
#
            Txixi(mu,i,nu,i1)        *= 2.0 
            PREPARE Vxixi(mu,i,nu,i1) = Txixi(mu,i,nu,i1)
#
      ENDPARDO mu, nu, i, i1
#
#     alpha/beta block.
#     -----------------
#
      PARDO mu, nu, i, j
#
            Txixj(mu,i,nu,j) = 0.0 
#
            DO b
#
               Txibj(mu,i,b,j) = 0.0 
#
               DO a  
#
                  REQUEST            T1aibj_ab(a,i,b,j) a
                  T1xibj(mu,i,b,j) = T1aibj_ab(a,i,b,j)*ca(mu,a)
                  Txibj(mu,i,b,j) += T1xibj(mu,i,b,j)  
#
               ENDDO a 
#
               T1xixj(mu,i,nu,j) = Txibj(mu,i,b,j)*ca(nu,b)
               Txixj(mu,i,nu,j) += T1xixj(mu,i,nu,j) 
#
            ENDDO b
#
            PREPARE Vxixj(mu,i,nu,j) = Txixj(mu,i,nu,j)
#
      ENDPARDO mu, nu, i, j
#
      execute sip_barrier
      execute server_barrier
#
      ENDPROC GIJAB_BT
#     ---------------- 
#
# ---------------------------------------------------------------------------------
#
      PROC GIJAB_CONT
#     ---------------
#
#     Complete backtransformation and 'contract' with second derivative integral.
#     ---------------------------------------------------------------------------
#
        PARDO mu, nu, lambda, sigma   
#
#             Get 1-particle pieces
#             ---------------------
#
              GET DHFa(mu,lambda)
              GET DHFa(mu,sigma)
              GET DHFa(mu,nu)
              GET DHFa(nu,sigma)
              GET DHFa(nu,lambda)
              GET DHFa(sigma,lambda)
#
              GET DHFb(mu,lambda)
              GET DHFb(mu,sigma)
              GET DHFb(mu,nu)
              GET DHFb(nu,sigma)
              GET DHFb(nu,lambda)
              GET DHFb(sigma,lambda)
#
              GET Dxx_a(mu,lambda)
              GET Dxx_a(mu,sigma)
              GET Dxx_a(mu,nu)
              GET Dxx_a(nu,lambda)
              GET Dxx_a(nu,sigma)
              GET Dxx_a(sigma,lambda)
#
#             HF only
#             -------
              Txx(mu,lambda)             = DHFa(mu,lambda)
              Txxxx(mu,lambda,nu,sigma)  = Txx(mu,lambda)^DHFa(nu,sigma)
#
              Txx(mu,lambda)             = DHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^DHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = DHFa(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^DHFb(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,lambda)             = DHFb(mu,lambda)
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,lambda)^DHFa(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = DHFa(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^DHFa(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,sigma)              = DHFb(mu,sigma)
              Txx(mu,sigma)             *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,sigma)^DHFb(nu,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = DHFa(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^DHFa(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txx(mu,nu)                 = DHFb(mu,nu)
              Txx(mu,nu)                *= 0.5  
              T1xxxx(mu,lambda,nu,sigma) = Txx(mu,nu)^DHFb(sigma,lambda)
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#             Correlation
#             -----------
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,lambda)^DHFA(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,lambda)^DHFB(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,lambda)^DHFB(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,lambda)^DHFA(nu,sigma)
              Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFA(nu,lambda)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFA(sigma,lambda)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFA(mu,sigma)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFA(mu,nu)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,sigma)^DHFB(nu,lambda)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(mu,nu)^DHFB(sigma,lambda)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(nu,lambda)^DHFB(mu,sigma)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              T1xxxx(mu,lambda,nu,sigma) = Dxx_a(sigma,lambda)^DHFB(mu,nu)
              T1xxxx(mu,lambda,nu,sigma)*= 0.25
              Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
              TSxxxx(mu,lambda,nu,sigma) = Txxxx(mu,lambda,nu,sigma) 
#
              IF mu == lambda
              IF nu == sigma
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1) i
                       T1xxxi(mu,lambda,nu,i1)  = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j) i
                       T1xxxj(mu,lambda,nu,j)  = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j) += T1xxxj(mu,lambda,nu,j)
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    Txxxx(mu,lambda,nu,sigma)*= 2.0  
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)#
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 txxxx(mu,nu,lambda,sigma) = 0.0 
                 execute                     der4_comp txxxx(mu,lambda,nu,sigma) 
                 etemp                     = TSxxxx(mu,lambda,nu,sigma)*txxxx(mu,lambda,nu,sigma) 
                 hessxy                   += etemp 
#
              ENDIF # nu == sigma
              ENDIF # mu == lambda
#
              IF mu == lambda
              IF nu < sigma
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)     = 0.0
                    TBxxxi(mu,lambda,sigma,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)    i
                       REQUEST Vxixi(mu,i,sigma,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)    = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1)   += T1xxxi(mu,lambda,nu,i1)
                       T3xxxi(mu,lambda,sigma,i1) = Vxixi(mu,i,sigma,i1)*ca(lambda,i)
                       TBxxxi(mu,lambda,sigma,i1)+= T3xxxi(mu,lambda,sigma,i1) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxi(mu,lambda,sigma,i1)*ca(nu,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)    = 0.0
                    TBxxxj(mu,lambda,sigma,j) = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)    j
                       REQUEST Vxixj(mu,i,sigma,j) j
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       T3xxxj(mu,lambda,sigma,j) = Vxixj(mu,i,sigma,j)*ca(lambda,i)
                       TBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxj(mu,lambda,sigma,j)*ca(nu,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 txxxx(mu,nu,lambda,sigma) = 0.0 
                 execute                     der4_comp txxxx(mu,lambda,nu,sigma) 
                 etemp                     = TSxxxx(mu,lambda,nu,sigma)*txxxx(mu,lambda,nu,sigma) 
                 hessxy                   += etemp 
#
              ENDIF # nu < sigma
              ENDIF # mu == lambda
#
              IF mu < lambda
              IF nu == sigma
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)  = 0.0
                    TBxxxi(mu,lambda,nu,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)     i
                       REQUEST Vxixi(lambda,i,nu,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)  = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       TAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                       T2xxxi(mu,lambda,nu,i1)  = Vxixi(lambda,i,nu,i1)*ca(mu,i)
                       TBxxxi(mu,lambda,nu,i1) += T2xxxi(mu,lambda,nu,i1) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)  = 0.0
                    TBxxxj(mu,lambda,nu,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)     j
                       REQUEST Vxixj(lambda,i,nu,j) j
#
                       T1xxxj(mu,lambda,nu,j)  = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       TAxxxj(mu,lambda,nu,j) += T1xxxj(mu,lambda,nu,j)
                       T2xxxj(mu,lambda,nu,j)  = Vxixj(lambda,i,nu,j)*ca(mu,i)
                       TBxxxj(mu,lambda,nu,j) += T2xxxj(mu,lambda,nu,j) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma) = TBxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma) = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 txxxx(mu,nu,lambda,sigma) = 0.0 
                 execute                     der4_comp txxxx(mu,lambda,nu,sigma) 
                 etemp                     = TSxxxx(mu,lambda,nu,sigma)*txxxx(mu,lambda,nu,sigma) 
                 hessxy                   += etemp 
#
              ENDIF # nu == sigma
              ENDIF # mu < lambda
#
              IF mu < lambda
              IF nu < sigma
#
                 D2(mu,lambda,nu,sigma) = 0.0
#
                 DO i1
                    TAxxxi(mu,lambda,nu,i1)     = 0.0
                    TBxxxi(mu,lambda,sigma,i1)  = 0.0
                    DO i
                       REQUEST Vxixi(mu,i,nu,i1)        i
                       REQUEST Vxixi(lambda,i,nu,i1)    i
                       REQUEST Vxixi(mu,i,sigma,i1)     i
                       REQUEST Vxixi(lambda,i,sigma,i1) i
#
                       T1xxxi(mu,lambda,nu,i1)    = Vxixi(mu,i,nu,i1)*ca(lambda,i)
                       T2xxxi(mu,lambda,nu,i1)    = Vxixi(lambda,i,nu,i1)*ca(mu,i)
#
                       TAxxxi(mu,lambda,nu,i1)   += T1xxxi(mu,lambda,nu,i1)
                       TAxxxi(mu,lambda,nu,i1)   += T2xxxi(mu,lambda,nu,i1) # -
#
                       T3xxxi(mu,lambda,sigma,i1) = Vxixi(mu,i,sigma,i1)*ca(lambda,i)
                       T4xxxi(mu,lambda,sigma,i1) = Vxixi(lambda,i,sigma,i1)*ca(mu,i)
#
                       TBxxxi(mu,lambda,sigma,i1)+= T4xxxi(mu,lambda,sigma,i1)
                       TBxxxi(mu,lambda,sigma,i1)+= T3xxxi(mu,lambda,sigma,i1) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma)  = TBxxxi(mu,lambda,sigma,i1)*ca(nu,i1)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma)  = TAxxxi(mu,lambda,nu,i1)*ca(sigma,i1)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 DO j
                    TAxxxj(mu,lambda,nu,j)     = 0.0
                    TBxxxj(mu,lambda,sigma,j)  = 0.0
                    DO i
                       REQUEST Vxixj(mu,i,nu,j)        j
                       REQUEST Vxixj(lambda,i,nu,j)    j
                       REQUEST Vxixj(mu,i,sigma,j)     j
                       REQUEST Vxixj(lambda,i,sigma,j) j
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixj(mu,i,nu,j)*ca(lambda,i)
                       T2xxxj(mu,lambda,nu,j)    = Vxixj(lambda,i,nu,j)*ca(mu,i)
#
                       TAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       TAxxxj(mu,lambda,nu,j)   += T2xxxj(mu,lambda,nu,j) # -
#
                       T3xxxj(mu,lambda,sigma,j) = Vxixj(mu,i,sigma,j)*ca(lambda,i)
                       T4xxxj(mu,lambda,sigma,j) = Vxixj(lambda,i,sigma,j)*ca(mu,i)
#
                       TBxxxj(mu,lambda,sigma,j)+= T4xxxj(mu,lambda,sigma,j)
                       TBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # -
#
                    ENDDO i
                    Txxxx(mu,lambda,nu,sigma)  = TBxxxj(mu,lambda,sigma,j)*ca(nu,j)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    Txxxx(mu,lambda,nu,sigma)  = TAxxxj(mu,lambda,nu,j)*ca(sigma,j)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
#                Get the separable part
#                ----------------------
                 TSxxxx(mu,lambda,nu,sigma) *= 4.0
#
#                Add the the nonseparable part
#                -----------------------------
                 TSxxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 txxxx(mu,nu,lambda,sigma) = 0.0 
                 execute                     der4_comp txxxx(mu,lambda,nu,sigma) 
                 etemp                     = TSxxxx(mu,lambda,nu,sigma)*txxxx(mu,lambda,nu,sigma) 
                 hessxy                   += etemp 
#
              ENDIF # nu < sigma
              ENDIF # mu < lambda
#
        ENDPARDO mu, nu, lambda, sigma   
#
      ENDPROC GIJAB_CONT
#     ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC FSCF_HESS 
#     -------------- 
#
      create cya 
      create dhfya 
      create whfya 
      execute sip_barrier 
#
#     Compute derivatives of coefficients. 
#     ------------------------------------ 
#
      PARDO mu, i 
#
           txp(mu,i) = 0.0 
#
           DO p1 
#
              GET          Uyaa(p1,i) 
              t1xp(mu,i) = ca(mu,p1)*Uyaa(p1,i) 
              txp(mu,i) += t1xp(mu,i) 
#
           ENDDO p1 
#
           PUT cya(mu,i) = txp(mu,i) 
#
      ENDPARDO mu, i 
#
      execute sip_barrier 
#
#     Form derivatives of HF density. 
#     ------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component. 
#           ---------------- 
#
            txx(mu,nu) = 0.0 
#
            DO i 
#
               GET           cya(mu,i) 
               GET           cya(nu,i) 
#
               t1xx(mu,nu) = cya(mu,i)*ca(nu,i) 
               txx(mu,nu) += t1xx(mu,nu) 
#
               t1xx(mu,nu) = ca(mu,i)*cya(nu,i) 
               txx(mu,nu) += t1xx(mu,nu) 
#
            ENDDO i 
#
            PUT dhfya(mu,nu) = txx(mu,nu) 
#
      ENDPARDO mu, nu 
#
#     Compute derivatives of weighted HF density. 
#     ------------------------------------------- 
#
      PARDO mu, nu, i  
#
#           piece 1. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               GET          cya(nu,i1) 
               T1xi(nu,i) = cya(nu,i1)*fock_a(i1,i)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)        = ca(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      PARDO mu, nu, i  
#
#           piece 2. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               T1xi(nu,i) = ca(nu,i1)*fock_a(i1,i)
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            get                 cya(mu,i) 
            Txx(mu,nu)        = cya(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      PARDO mu, nu, i  
#
#           piece 3. 
#           -------- 
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               get          fya(i1,i) 
               T1xi(nu,i) = ca(nu,i1)*fya(i1,i) 
               Txi(nu,i) -= T1xi(nu,i)
#
            ENDDO i1
#
            Txx(mu,nu)        = ca(mu,i)*Txi(nu,i)
            PUT whfya(mu,nu) += Txx(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      execute sip_barrier 
#
      delete cya 
#
      ENDPROC FSCF_HESS 
#     ----------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
# --------------------------------------------------------------------------- 
#
# The derivatives of the virtual-virtual block of the denstity matrix
# are formed.  
#
# --------------------------------------------------------------------------- 
#
      PROC FORMDDAB 
#     ------------- 
#
#     alpha/alpha contribution 
#     ------------------------ 
#
      PARDO a, a1 
#
            tpp(a,a1) = 0.0  
#
#           Taa*Vaa contribution 
#           -------------------- 
#
            DO a2 
            DO i 
            DO i1 
#
               REQUEST       T1aiai_aa(a,i,a2,i1)  a
               REQUEST       T2yFullaa(a1,i,a2,i1) i  
#
               t1pp(a,a1)  = T1aiai_aa(a,i,a2,i1)*T2yFullaa(a1,i,a2,i1)
               t1pp(a,a1) *= 0.5 
               tpp(a,a1)  += t1pp(a,a1) 
#
            ENDDO i1 
            ENDDO i 
            ENDDO a2 
#
#           Tab*Vab contribution 
#           -------------------- 
#
            DO b 
            DO i 
            DO j 
#
               REQUEST      T1aibj_ab(a,i,b,j)  a  
               REQUEST      T2yFullab(a1,i,b,j) b  
#
               t1pp(a,a1) = T1aibj_ab(a,i,b,j)*T2yFullab(a1,i,b,j)
               tpp(a,a1) += t1pp(a,a1) 
#
            ENDDO j 
            ENDDO i 
            ENDDO b 
#
            t1pp(a1,a)      = tpp(a,a1) 
            PUT Dyaa(a,a1) += tpp(a,a1) 
            PUT Dyaa(a1,a) += t1pp(a1,a) 
#
      ENDPARDO a, a1 
#
      ENDPROC FORMDDAB 
#     ---------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivatives of the occupied-occupied block of the denstity matrix
# are formed.  
#
# ---------------------------------------------------------------------- 
#
      PROC FORMDDIJ 
#     ------------- 
#
#     alpha/alpha contribution 
#     ------------------------ 
#
      PARDO i, i1 
#
            tpp(i,i1) = 0.0 
#
#           Taa*Vaa contribution 
#           -------------------- 
#
            DO a 
            DO a1 
            DO i2 
#
               REQUEST       T1aiai_aa(a,i,a1,i2)  a
               REQUEST       T2yFullaa(a,i1,a1,i2) a  
#
               t1pp(i,i1)  = T1aiai_aa(a,i,a1,i2)*T2yFullaa(a,i1,a1,i2)
               t1pp(i,i1) *= 0.5 
               tpp(i,i1)  += t1pp(i,i1) 
#
            ENDDO i2 
            ENDDO a1 
            ENDDO a 
#
#           Tab*Vab contribution 
#           -------------------- 
#
            DO a 
            DO b 
            DO j 
#
               REQUEST      T1aibj_ab(a,i,b,j)  a  
               REQUEST      T2yFullab(a,i1,b,j) a  
#
               t1pp(i,i1) = T1aibj_ab(a,i,b,j)*T2yFullab(a,i1,b,j)
               tpp(i,i1) += t1pp(i,i1) 
#
            ENDDO j 
            ENDDO b 
            ENDDO a 
#
            tpp(i,i1)      *= -1.0 
            t1pp(i1,i)      = tpp(i,i1) 
            PUT Dyii(i,i1) += tpp(i,i1) 
            PUT Dyii(i1,i) += t1pp(i1,i) 
#
      ENDPARDO i, i1 
#
      ENDPROC FORMDDIJ 
#     ---------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The contributions to the Hessian from 'part1' are computed. 
#
#     hess(x,y) = 1/2 ( f^x_{ij}*dD_{ij}/dy 
#                     + f^x_{ab}*dD_{ab}/dy 
#                     + f^x_{ai}*dD_{ai}/dy 
#                     + f^x_{ia}*dD_{ia}/dy) + x<-->y  
#
# ---------------------------------------------------------------------- 
#
      PROC PART1  
#     ---------- 
#
      PARDO i, i1 
#
            GET       Hxa(i,i1) 
            GET       Dyii(i,i1) 
#
            etemp   = Hxa(i,i1)*Dyii(i,i1) 
            hessxy += etemp 
#
      ENDPARDO i, i1 
#
      PARDO j, j1 
#
            GET       Hxa(j,j1) 
            GET       Dyii(j,j1) 
#
            etemp   = Hxa(j,j1)*Dyii(j,j1) 
            hessxy += etemp 
#
      ENDPARDO j, j1 
#
      PARDO a, a1 
#
            GET       Hxa(a,a1) 
            GET       Dyaa(a,a1) 
#
            etemp   = Hxa(a,a1)*Dyaa(a,a1) 
            hessxy += etemp 
#
      ENDPARDO a, a1 
#
      PARDO b, b1 
#
            GET       Hxa(b,b1) 
            GET       Dyaa(b,b1) 
#
            etemp   = Hxa(b,b1)*Dyaa(b,b1) 
            hessxy += etemp 
#
      ENDPARDO b, b1 
#
      PARDO a, i 
#
            GET       Hxa(a,i) 
            GET       Dyai(a,i) 
#
            etemp   = Hxa(a,i)*Dyai(a,i) 
            etemp  *= 2.0 
            hessxy += etemp 
#
      ENDPARDO a, i 
#
      PARDO b, j 
#
            GET       Hxa(b,j) 
            GET       Dyai(b,j) 
#
            etemp   = Hxa(b,j)*Dyai(b,j) 
            etemp  *= 2.0 
            hessxy += etemp 
#
      ENDPARDO b, j 
#
#     Also included in Part1 should be the contribution from the derivative 
#     of the density(HF)-->Term 24 in CPL. 
#     ---------------------------------------------------------------------- 
#
#     Contributions from Uxpi.
#     -----------------------
#
      PARDO p, i
#
           GET        Uxaa(p,i)
           tpi(p,i) = 0.0
#
#          alpha/alpha contribution.
#          -------------------------
#
           DO p1
           DO p2
#
              REQUEST             DTpppi(p2,p1,p,i)  p
              REQUEST             DTpppi(p,p1,p2,i)  p
              GET                 Dpq_a(p1,p2)
#
              tpppi(p2,p1,p,i)  = DTpppi(p2,p1,p,i)
              t1pppi(p2,p1,p,i) = DTpppi(p,p1,p2,i)
              tpppi(p2,p1,p,i) -= t1pppi(p2,p1,p,i)
#
              t1pi(p,i)         = tpppi(p2,p1,p,i)*Dpq_a(p1,p2)
              t1pi(p,i)        *= 2.0
              tpi(p,i)         += t1pi(p,i)
#
           ENDDO p2
           ENDDO p1
#
#          alpha/beta contribution.
#          ------------------------
#
           DO q1
           DO q
#
              REQUEST      DTpppi(q,q1,p,i) p
              GET          Dpq_a(q1,q)
#
              t1pi(p,i)  = DTpppi(q,q1,p,i)*Dpq_a(q1,q)
              t1pi(p,i) *= 2.0
              tpi(p,i)  += t1pi(p,i)
#
           ENDDO q
           ENDDO q1
#
           etemp  = tpi(p,i)*Uxaa(p,i)
           hessyx += etemp
#
      ENDPARDO p, i
#
#     Contributions from Uxqj.
#     -----------------------
#
      PARDO q, j
#
           GET        Uxaa(q,j)
           tqj(q,j) = 0.0
#
#          alpha/alpha contribution.
#          -------------------------
#
           DO q1
           DO q2
#
              REQUEST             DTpppi(q2,q1,q,j) q
              REQUEST             DTpppi(q,q1,q2,j) q 
              GET                 Dpq_a(q1,q2)
#
              tqqqj(q2,q1,q,j)  = DTpppi(q2,q1,q,j)
              t1qqqj(q2,q1,q,j) = DTpppi(q,q1,q2,j)
              tqqqj(q2,q1,q,j) -= t1qqqj(q2,q1,q,j)
#
              t1qj(q,j)         = tqqqj(q2,q1,q,j)*Dpq_a(q1,q2)
              t1qj(q,j)        *= 2.0
              tqj(q,j)         += t1qj(q,j)
#
           ENDDO q2
           ENDDO q1
#
#          alpha/beta contribution.
#          ------------------------
#
           DO p1
           DO p
#
              REQUEST      DTpppi(p,p1,q,j) p
              GET          Dpq_a(p1,p)
#
              t1qj(q,j)  = DTpppi(p,p1,q,j)*Dpq_a(p1,p)
              t1qj(q,j) *= 2.0
              tqj(q,j)  += t1qj(q,j)
#
           ENDDO p
           ENDDO p1
#
           etemp   = tqj(q,j)*Uxaa(q,j)
           hessyx += etemp
#
      ENDPARDO q, j
#
      ENDPROC PART1  
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC PART2  
#     ---------- 
#
      PARDO p, p1 
#
            GET         Dpq_a(p,p1) 
            tpp(p,p1) = 0.0 
#
            DO p2 
#
               GET          Hxa(p2,p1) 
               GET          Uyaa(p2,p) 
               GET          Hxa(p,p2) 
               GET          Uyaa(p2,p1) 
#
               t1pp(p,p1) = Uyaa(p2,p)*Hxa(p2,p1)
               tpp(p,p1) += t1pp(p,p1) 
#
               t1pp(p,p1) = Uyaa(p2,p1)*Hxa(p,p2) 
               tpp(p,p1) += t1pp(p,p1) 
#
            ENDDO p2 
#
            etemp   = tpp(p,p1)*Dpq_a(p,p1) 
            hessxy += etemp 
#
      ENDPARDO p, p1 
#
      PARDO q, q1 
#
            GET         Dpq_a(q,q1) 
            tqq(q,q1) = 0.0 
#
            DO q2 
#
               GET          Hxa(q2,q1) 
               GET          Uyaa(q2,q) 
               GET          Hxa(q,q2) 
               GET          Uyaa(q2,q1) 
#
               t1qq(q,q1) = Uyaa(q2,q)*Hxa(q2,q1)
               tqq(q,q1) += t1qq(q,q1) 
#
               t1qq(q,q1) = Uyaa(q2,q1)*Hxa(q,q2) 
               tqq(q,q1) += t1qq(q,q1) 
#
            ENDDO q2 
#
            etemp   = tqq(q,q1)*Dpq_a(q,q1) 
            hessxy += etemp 
#
      ENDPARDO q, q1 
#
      ENDPROC PART2  
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC PART4 
#     ---------- 
#
      PARDO p, p1 
#
            GET         Ipq_a(p,p1) 
            tpp(p,p1) = 0.0 
#
            DO p2 
#
               GET          Uyaa(p2,p) 
               GET          Sxa(p2,p1) 
               GET          Uyaa(p2,p1) 
               GET          Sxa(p,p2) 
#
               t1pp(p,p1) = Uyaa(p2,p)*Sxa(p2,p1)
               tpp(p,p1) += t1pp(p,p1) 
#
               t1pp(p,p1) = Uyaa(p2,p1)*Sxa(p,p2) 
               tpp(p,p1) += t1pp(p,p1) 
#
            ENDDO p2 
#
            etemp   = tpp(p,p1)*Ipq_a(p,p1) 
            hessxy += etemp 
#
      ENDPARDO p, p1 
#
      PARDO q, q1 
#
            GET         Ipq_a(q,q1) 
            tqq(q,q1) = 0.0 
#
            DO q2 
#
               GET          Uyaa(q2,q) 
               GET          Sxa(q2,q1) 
               GET          Uyaa(q2,q1) 
               GET          Sxa(q,q2) 
#
               t1qq(q,q1) = Uyaa(q2,q)*Sxa(q2,q1)
               tqq(q,q1) += t1qq(q,q1) 
#
               t1qq(q,q1) = Uyaa(q2,q1)*Sxa(q,q2) 
               tqq(q,q1) += t1qq(q,q1) 
#
            ENDDO q2 
#
            etemp   = tqq(q,q1)*Ipq_a(q,q1) 
            hessxy += etemp 
#
      ENDPARDO q, q1 
#
      ENDPROC PART4 
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
# The contributions equivalent to T7-14 in CPL are computed. This 
# is a more efficient reformulation. 
#
# ---------------------------------------------------------------------- 
#
      PROC PART5 
#     ---------- 
#
#     Contribution from Taiai. 
#     ------------------------ 
#
      PARDO a, a1, i, i1 
#
            REQUEST            T1aiai_aa(a,i,a1,i1) a  
            tpppp(a,i,a1,i1) = 0.0 
# 
            DO p 
#
               REQUEST             DTpppi(p,i,a1,i1)  p
               REQUEST             DTpppi(p,i1,a1,i)  p  
               GET                 Uxaa(p,a) 
#
               t2pppp(p,i,a1,i1) = DTpppi(p,i,a1,i1) 
               t3pppp(p,i,a1,i1) = DTpppi(p,i1,a1,i) 
               t2pppp(p,i,a1,i1)-= t3pppp(p,i,a1,i1)  
#
               t1pppp(a,i,a1,i1) = t2pppp(p,i,a1,i1)*Uxaa(p,a)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1) 
# 
            ENDDO p 
# 
            DO a2 
#
               REQUEST              DTpppi(a,a2,a1,i1)  a
               REQUEST              DTpppi(a1,a2,a,i1)  a  
               GET                  Uxaa(a2,i) 
#
               t2pppp(a,a2,a1,i1) = DTpppi(a,a2,a1,i1) 
               t3pppp(a,a2,a1,i1) = DTpppi(a1,a2,a,i1) 
               t2pppp(a,a2,a1,i1)-= t3pppp(a,a2,a1,i1) 
#
               t1pppp(a,i,a1,i1)  = t2pppp(a,a2,a1,i1)*Uxaa(a2,i)  
               tpppp(a,i,a1,i1)  += t1pppp(a,i,a1,i1) 
# 
            ENDDO a2 
# 
            DO i2 
#
               REQUEST              DTpppi(a,i2,a1,i1)  a
               REQUEST              DTpppi(a,i1,a1,i2)  a 
               GET                  Uxaa(i2,i) 
#
               t2pppp(a,i2,a1,i1) = DTpppi(a,i2,a1,i1) 
               t3pppp(a,i2,a1,i1) = DTpppi(a,i1,a1,i2) 
               t2pppp(a,i2,a1,i1)-= t3pppp(a,i2,a1,i1) 
#
               t1pppp(a,i,a1,i1)  = t2pppp(a,i2,a1,i1)*Uxaa(i2,i)  
               tpppp(a,i,a1,i1)  += t1pppp(a,i,a1,i1) 
# 
            ENDDO i2 
# 
            etemp   = tpppp(a,i,a1,i1)*T1aiai_aa(a,i,a1,i1) 
            hessyx += etemp 
#
      ENDPARDO a, a1, i, i1 
#
#     Contribution from Tbjbj. 
#     ------------------------ 
#
      PARDO b, b1, j, j1 
#
            REQUEST            T1aiai_aa(b,j,b1,j1) b  
            tqqqq(b,j,b1,j1) = 0.0 
# 
            DO q 
#
               REQUEST             DTpppi(q,j,b1,j1)  q
               REQUEST             DTpppi(q,j1,b1,j)  q   
               GET                 Uxaa(q,b) 
#
               t2qqqq(q,j,b1,j1) = DTpppi(q,j,b1,j1) 
               t3qqqq(q,j,b1,j1) = DTpppi(q,j1,b1,j) 
               t2qqqq(q,j,b1,j1)-= t3qqqq(q,j,b1,j1)  
#
               t1qqqq(b,j,b1,j1) = t2qqqq(q,j,b1,j1)*Uxaa(q,b)
               tqqqq(b,j,b1,j1) += t1qqqq(b,j,b1,j1) 
# 
            ENDDO q 
# 
            DO b2 
#
               REQUEST              DTpppi(b,b2,b1,j1)  b
               REQUEST              DTpppi(b1,b2,b,j1)  b  
               GET                  Uxaa(b2,j) 
#
               t2qqqq(b,b2,b1,j1) = DTpppi(b,b2,b1,j1) 
               t3qqqq(b,b2,b1,j1) = DTpppi(b1,b2,b,j1) 
               t2qqqq(b,b2,b1,j1)-= t3qqqq(b,b2,b1,j1) 
#
               t1qqqq(b,j,b1,j1)  = t2qqqq(b,b2,b1,j1)*Uxaa(b2,j)  
               tqqqq(b,j,b1,j1)  += t1qqqq(b,j,b1,j1) 
# 
            ENDDO b2 
# 
            DO j2 
#
               REQUEST              DTpppi(b,j2,b1,j1)  b
               REQUEST              DTpppi(b,j1,b1,j2)  b 
               GET                  Uxaa(j2,j) 
#
               t2qqqq(b,j2,b1,j1) = DTpppi(b,j2,b1,j1) 
               t3qqqq(b,j2,b1,j1) = DTpppi(b,j1,b1,j2) 
               t2qqqq(b,j2,b1,j1)-= t3qqqq(b,j2,b1,j1) 
#
               t1qqqq(b,j,b1,j1)  = t2qqqq(b,j2,b1,j1)*Uxaa(j2,j)  
               tqqqq(b,j,b1,j1)  += t1qqqq(b,j,b1,j1) 
# 
            ENDDO j2 
# 
            etemp   = tqqqq(b,j,b1,j1)*T1aiai_aa(b,j,b1,j1) 
            hessyx += etemp 
#
      ENDPARDO b, b1, j, j1 
#
#     Contribution from Taibj. 
#     ------------------------ 
#
      PARDO a, b, i, j 
#
            REQUEST          T1aibj_ab(a,i,b,j) a  
            tppqq(a,i,b,j) = 0.0 
#
            DO p 
#
               REQUEST           DTpppi(p,i,b,j) p  
               REQUEST           DTpppi(a,p,b,j) p   
               GET               Uxaa(p,a) 
               GET               Uxaa(p,i) 
#
               t1ppqq(a,i,b,j) = DTpppi(p,i,b,j)*Uxaa(p,a)
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
               t1ppqq(a,i,b,j) = DTpppi(a,p,b,j)*Uxaa(p,i) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO p 
#
            DO q 
#
               REQUEST           DTpppi(a,i,q,j) a  
               REQUEST           DTpppi(b,q,a,i) a  
               GET               Uxaa(q,b) 
               GET               Uxaa(q,j) 
#
               t1ppqq(a,i,b,j) = DTpppi(a,i,q,j)*Uxaa(q,b)
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
               t1ppqq(a,i,b,j) = DTpppi(b,q,a,i)*Uxaa(q,j) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO q 
#
            etemp   = tppqq(a,i,b,j)*T1aibj_ab(a,i,b,j) 
            etemp  *= 2.0 
            hessyx += etemp 
# 
      ENDPARDO a, b, i, j 
#
      ENDPROC PART5 
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# Part6 corresponds to Term6 in the CPL BUT the derivative of V 
# does not contain U derivatives. It only contains derivatives of
# the integrals transformed to the unperturbed MO basis. 
#
# ---------------------------------------------------------------------- 
#
      PROC PART6 
#     ---------- 
#
      PARDO a, i, a1, i1 
#
            REQUEST             T2yFullaa(a,i,a1,i1) a 
            REQUEST             VXpipi(a,i,a1,i1)    a
            REQUEST             VXpipi(a,i1,a1,i)    a  
# 
            tpppp(a,i,a1,i1)  = VXpipi(a,i,a1,i1) 
            t1pppp(a,i,a1,i1) = VXpipi(a,i1,a1,i) 
            tpppp(a,i,a1,i1) -= t1pppp(a,i,a1,i1) 
#
            etemp             = T2yFullaa(a,i,a1,i1)*tpppp(a,i,a1,i1)
            etemp            *= 0.5 
            hessxy           += etemp 
#
      ENDPARDO a, i, a1, i1 
#
      PARDO b, j, b1, j1 
#
            REQUEST             T2yFullaa(b,j,b1,j1) b 
            REQUEST             VXpipi(b,j,b1,j1)    b
            REQUEST             VXpipi(b,j1,b1,j)    b  
# 
            tqqqq(b,j,b1,j1)  = VXpipi(b,j,b1,j1) 
            t1qqqq(b,j,b1,j1) = VXpipi(b,j1,b1,j) 
            tqqqq(b,j,b1,j1) -= t1qqqq(b,j,b1,j1) 
#
            etemp             = T2yFullaa(b,j,b1,j1)*tqqqq(b,j,b1,j1)
            etemp            *= 0.5 
            hessxy           += etemp 
#
      ENDPARDO b, j, b1, j1 
#
      PARDO a, i, b, j 
#
            REQUEST           T2yFullab(a,i,b,j) a 
            REQUEST           VXpipi(a,i,b,j)    a
#
            etemp           = T2yFullab(a,i,b,j)*VXpipi(a,i,b,j)
            etemp          *= 2.0 
            hessxy         += etemp 
#
      ENDPARDO a, i, b, j 
#
      ENDPROC PART6 
#     ------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivative of the occupied-occupied block of the intermediate 
# Ipq is determined. This is the most complicated procedure in this 
# program!  
#
# ---------------------------------------------------------------------- 
#
      PROC DERIIJ 
#     ----------- 
#
#     alpha/alpha block 
#     ----------------- 
#
      PARDO i, i1 
#
            tpp(i,i1)  = 0.0 
            t3pp(i1,i) = 0.0 
#
            DO i2 
#
               GET Dpq_a(i,i2) 
               GET Fya(i2,i1) 
#
               IF i2 == i1 
                  GET          Dyii(i,i2) 
                  t1pp(i,i1) = Dyii(i,i2)*Fock_a(i2,i1)  
                  tpp(i,i1) -= t1pp(i,i1) 
               ENDIF 
#
               t1pp(i,i1) = Dpq_a(i,i2)*Fya(i2,i1) 
               tpp(i,i1) -= t1pp(i,i1) 
#
               DO a 
               DO a1 
#
                  REQUEST             VSpipi(a,i,a1,i2)     a  
                  REQUEST             T2yFullaa(a,i1,a1,i2) a  
#
                  t1pp(i,i1)        = VSpipi(a,i,a1,i2)*T2yFullaa(a,i1,a1,i2) 
                  t1pp(i,i1)       *= 0.5 
                  tpp(i,i1)        -= t1pp(i,i1) 
#
               ENDDO a1 
               ENDDO a 
#
               DO i3 
#
                  REQUEST      VSpipi(i,i1,i2,i3) i
                  GET          Dyii(i2,i3) 
#
                  t1pp(i,i1) = VSpipi(i,i1,i2,i3)*Dyii(i2,i3)
                  tpp(i,i1) -= t1pp(i,i1) 
#
               ENDDO i3 
#
               DO a 
#
                  REQUEST       VSpipi(i,i1,a,i2) a
                  GET           Dyai(a,i2) 
#
                  t1pp(i,i1)  = VSpipi(i,i1,a,i2)*Dyai(a,i2)
                  tpp(i,i1)  -= t1pp(i,i1)
#
                  t2pp(i1,i)  = t1pp(i,i1) 
                  t3pp(i1,i) -= t2pp(i1,i) 
#
               ENDDO a
#
            ENDDO i2 
#
            DO a 
#
               DO b 
               DO j 
#
                  REQUEST      Vpiqj(a,i,b,j)      a  
                  REQUEST      T2yFullab(a,i1,b,j) a  
#
                  t1pp(i,i1) = Vpiqj(a,i,b,j)*T2yFullab(a,i1,b,j) 
                  tpp(i,i1) -= t1pp(i,i1) 
#
               ENDDO j 
               ENDDO b 
#
               DO a1 
#
                  REQUEST             Vaaii(a,a1,i,i1) a  
                  REQUEST             Viaai(i,a1,a,i1) a  
                  GET                 Dyaa(a,a1) 
#
                  tpppp(a,a1,i,i1)  = Vaaii(a,a1,i,i1)  
                  t1pppp(a,a1,i,i1) = Viaai(i,a1,a,i1)
                  tpppp(a,a1,i,i1) -= t1pppp(a,a1,i,i1)  
#
                  t1pp(i,i1)        = tpppp(a,a1,i,i1)*Dyaa(a,a1) 
                  tpp(i,i1)        -= t1pp(i,i1) 
#
               ENDDO a1 
#
            ENDDO a 
#
            DO b 
#
               DO b1 
#
                  REQUEST      Vaaii(b1,b,i,i1) b  
                  GET          Dyaa(b1,b) 
#
                  t1pp(i,i1) = Vaaii(b1,b,i,i1)*Dyaa(b1,b) 
                  tpp(i,i1) -= t1pp(i,i1) 
#
               ENDDO b1 
#
               DO j2 
#
                  REQUEST       Vpiqj(i,i1,b,j2) i
                  GET           Dyai(b,j2) 
#
                  t1pp(i,i1)  = Vpiqj(i,i1,b,j2)*Dyai(b,j2)
                  tpp(i,i1)  -= t1pp(i,i1)
#
                  t2pp(i1,i)  = t1pp(i,i1) 
                  t3pp(i1,i) -= t2pp(i1,i) 
#
               ENDDO j2
#
            ENDDO b
#
            DO j2 
            DO j3 
#
               REQUEST      Vpiqj(i,i1,j2,j3) i
               GET          Dyii(j2,j3) 
#
               t1pp(i,i1) = Vpiqj(i,i1,j2,j3)*Dyii(j2,j3)
               tpp(i,i1) -= t1pp(i,i1) 
#
            ENDDO j3 
            ENDDO j2 
#
            PUT DIii(i,i1) += tpp(i,i1) 
            PUT DIii(i1,i) += t3pp(i1,i) 
#
      ENDPARDO i, i1 
#
#     Done alpha/alpha block 
#     ---------------------- 
#
      ENDPROC DERIIJ 
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivative of the virtual-virtual block of the intermediate 
# Ipq is determined. 
#
# ---------------------------------------------------------------------- 
#
      PROC DERIAB  
#     ----------- 
#
#     alpha/alpha block 
#     ----------------- 
#
      PARDO a, a1 
#
            tpp(a,a1) = 0.0 
#
            DO a2 
#
               GET Dpq_a(a,a2) 
               GET Fya(a2,a1) 
#
               IF a2 == a1 
                  GET          Dyaa(a,a2) 
                  t1pp(a,a1) = Dyaa(a,a2)*Fock_a(a2,a1)  
                  tpp(a,a1) -= t1pp(a,a1) 
               ENDIF 
#
               t1pp(a,a1) = Dpq_a(a,a2)*Fya(a2,a1) 
               tpp(a,a1) -= t1pp(a,a1) 
#
               DO i 
               DO i1 
#
                  REQUEST       VSpipi(a,i,a2,i1)     a  
                  REQUEST       T2yFullaa(a1,i,a2,i1) i  
#
                  t1pp(a,a1)  = VSpipi(a,i,a2,i1)*T2yFullaa(a1,i,a2,i1) 
                  t1pp(a,a1) *= 0.5 
                  tpp(a,a1)  -= t1pp(a,a1) 
#
               ENDDO i1 
               ENDDO i 
#
            ENDDO a2 
#
            DO i 
            DO j1 
            DO b2 
#
               REQUEST       Vpiqj(a,i,b2,j1)      a  
               REQUEST       T2yFullab(a1,i,b2,j1) i  
#
               t1pp(a,a1)  = Vpiqj(a,i,b2,j1)*T2yFullab(a1,i,b2,j1) 
               tpp(a,a1)  -= t1pp(a,a1) 
#
            ENDDO b2 
            ENDDO j1 
            ENDDO i 
#
            tpp(a,a1)      *= 0.5 
            t1pp(a1,a)      = tpp(a,a1) 
            PUT DIaa(a,a1) += tpp(a,a1) 
            PUT DIaa(a1,a) += t1pp(a1,a) 
#
      ENDPARDO a, a1 
#
#     End alpha/alpha block 
#     --------------------- 
#
#     End beta/beta block 
#     ------------------- 
#
      ENDPROC DERIAB  
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
# The derivative of the virtual-occipied block of the intermediate 
# Ipq is determined. 
#
# ---------------------------------------------------------------------- 
#
      PROC DERIAI  
#     ----------- 
#
#     alpha/alpha block 
#     ----------------- 
#
      PARDO a, i 
#
            tpp(a,i)  = 0.0 
#
            DO i2 
#
               GET Dpq_a(a,i2) 
               GET Fya(i2,i) 
#
               IF i2 == i 
                  GET         Dyai(a,i2) 
                  t1pp(a,i) = Dyai(a,i2)*Fock_a(i2,i)  
                  tpp(a,i) -= t1pp(a,i) 
               ENDIF 
#
               t1pp(a,i) = Dpq_a(a,i2)*Fya(i2,i) 
               tpp(a,i) -= t1pp(a,i) 
#
               DO a1 
               DO i1 
#
                  REQUEST      VSpipi(a1,i2,i,i1)    i 
                  REQUEST      T2yFullaa(a,i1,a1,i2) a  
#
                  t1pp(a,i)  = T2yFullaa(a,i1,a1,i2)*VSpipi(a1,i2,i,i1) 
                  t1pp(a,i) *= 0.5  
                  tpp(a,i)  -= t1pp(a,i) 
#
               ENDDO i1 
               ENDDO a1 
#
               DO b1 
               DO j2 
#
                  REQUEST     Vpiqj(i,i2,b1,j2)     i 
                  REQUEST     T2yFullab(a,i2,b1,j2) a  
#
                  t1pp(a,i) = T2yFullab(a,i2,b1,j2)*Vpiqj(i,i2,b1,j2) 
                  tpp(a,i) -= t1pp(a,i) 
#
               ENDDO j2 
               ENDDO b1 
#
            ENDDO i2 
#
            PUT DIai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i 
#
#     Done alpha/alpha block 
#     ---------------------- 
#
#     Done beta/beta block 
#     -------------------- 
#
      ENDPROC DERIAI  
#     -------------- 
#
# ---------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------- 
#
      PROC PART3 
#     ---------- 
#
      PARDO i, i1 
#
            GET       Sxa(i,i1) 
            GET       DIii(i,i1) 
#
            etemp   = Sxa(i,i1)*DIii(i,i1)
            hessxy += etemp 
#
      ENDPARDO i, i1 
#
      PARDO a, a1 
#
            GET       Sxa(a,a1) 
            GET       DIaa(a,a1) 
#
            etemp   = Sxa(a,a1)*DIaa(a,a1)
            hessxy += etemp 
#
      ENDPARDO a, a1 
#
      PARDO a, i1 
#
            GET       Sxa(a,i1) 
            GET       DIai(a,i1) 
#
            etemp   = Sxa(a,i1)*DIai(a,i1)
            etemp  *= 2.0 
            hessxy += etemp 
#
      ENDPARDO a, i1 
#
      PARDO j, j1 
#
            GET       Sxa(j,j1) 
            GET       DIii(j,j1) 
#
            etemp   = Sxa(j,j1)*DIii(j,j1)
            hessxy += etemp 
#
      ENDPARDO j, j1 
#
      PARDO b, b1 
#
            GET       Sxa(b,b1) 
            GET       DIaa(b,b1) 
#
            etemp   = Sxa(b,b1)*DIaa(b,b1)
            hessxy += etemp 
#
      ENDPARDO b, b1 
#
      PARDO b, j1 
#
            GET       Sxa(b,j1) 
            GET       DIai(b,j1) 
#
            etemp   = Sxa(b,j1)*DIai(b,j1)
            etemp  *= 2.0 
            hessxy += etemp 
#
      ENDPARDO b, j1 
#
      ENDPROC PART3 
#     ------------- 
#
# --------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------
#
      PROC DERVYFULLAB  
#     ----------------  
#
#     dV^{ab}_{ij}/dy first 
#     --------------------- 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO a, b, i, j 
#
            REQUEST          DTpppi(a,i,b,j) a  
            tppqq(a,i,b,j) = DTpppi(a,i,b,j) 
#
#           alpha virtual contraction. 
#           -------------------------- 
#
            DO a1 
#
               REQUEST           Vpiqj(a1,i,b,j) b  
               REQUEST           Vaaai(a,a1,b,j) b  
               GET               Uyaa(a1,a) 
               GET               Uyaa(a1,i) 
#
               t1ppqq(a,i,b,j) = Vpiqj(a1,i,b,j)*Uyaa(a1,a) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
               t1ppqq(a,i,b,j) = Vaaai(a,a1,b,j)*Uyaa(a1,i) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO a1 
#
#           alpha occupied contraction. 
#           -------------------------- 
#
            DO i1 
#
               REQUEST           Vpiqj(i1,i,b,j) b  
               REQUEST           Vpiqj(a,i1,b,j) b  
               GET               Uyaa(i1,a) 
               GET               Uyaa(i1,i) 
#
               t1ppqq(a,i,b,j) = Vpiqj(i1,i,b,j)*Uyaa(i1,a) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
               t1ppqq(a,i,b,j) = Vpiqj(a,i1,b,j)*Uyaa(i1,i) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO i1 
#
#           beta virtual contraction. 
#           ------------------------- 
#
            DO b1 
#
               REQUEST           Vpiqj(a,i,b1,j) a  
               REQUEST           Vaaai(b,b1,a,i) a  
               GET               Uyaa(b1,b) 
               GET               Uyaa(b1,j) 
#
               t1ppqq(a,i,b,j) = Vpiqj(a,i,b1,j)*Uyaa(b1,b) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
               t1ppqq(a,i,b,j) = Vaaai(b,b1,a,i)*Uyaa(b1,j) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO b1 
#
#           beta occupied contraction. 
#           ------------------------- 
#
            DO j1 
#
               REQUEST           Vpiqj(a,i,j1,j) a  
               REQUEST           Vpiqj(a,i,b,j1) a  
               GET               Uyaa(j1,b) 
               GET               Uyaa(j1,j) 
#
               t1ppqq(a,i,b,j) = Vpiqj(a,i,j1,j)*Uyaa(j1,b) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
               t1ppqq(a,i,b,j) = Vpiqj(a,i,b,j1)*Uyaa(j1,j) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO j1 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           Compute contribution to Dyaa. 
#           ----------------------------- 
#
            DO a2 
#
               REQUEST           T1aibj_ab(a2,i,b,j) b  
               tpp(a,a2)       = tppqq(a,i,b,j)*T1aibj_ab(a2,i,b,j) 
               tpp(a,a2)      *= -0.5 
               t1pp(a2,a)      = tpp(a,a2) 
               PUT DIaa(a,a2) += tpp(a,a2) 
               PUT DIaa(a2,a) += t1pp(a2,a) 
#
            ENDDO a2 
#
#           Compute contribution to DIii. 
#           ----------------------------- 
#
            DO i1  
#
               REQUEST           T1aibj_ab(a,i1,b,j) a  
               tpp(i,i1)       = tppqq(a,i,b,j)*T1aibj_ab(a,i1,b,j) 
               tpp(i,i1)      *= -1.0 
               PUT DIii(i,i1) += tpp(i,i1)  
#
            ENDDO i1  
#
#           Compute contribution to DXai. 
#           ----------------------------- 
#
            GET              Dpq_a(b,j) 
            tpp(a,i)       = tppqq(a,i,b,j)*Dpq_a(b,j)
            PUT DXai(a,i) += tpp(a,i) 
#
#           Form complete amplitude derivative. 
#           ---------------------------------- 
#
            DO i1 
#
               REQUEST           T1aibj_ab(a,i1,b,j) a  
               GET               Fya(i1,i) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a,i1,b,j)*Fya(i1,i)  
               tppqq(a,i,b,j) -= t1ppqq(a,i,b,j) 
#
            ENDDO i1 
#
            DO j1 
#
               REQUEST           T1aibj_ab(a,i,b,j1) a  
               GET               Fya(j1,j) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a,i,b,j1)*Fya(j1,j)  
               tppqq(a,i,b,j) -= t1ppqq(a,i,b,j) 
#
            ENDDO j1 
#
            DO a1 
#
               REQUEST           T1aibj_ab(a1,i,b,j) b  
               GET               Fya(a,a1) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a1,i,b,j)*Fya(a,a1) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO a1 
#
            DO b1 
#
               REQUEST           T1aibj_ab(a,i,b1,j) a  
               GET               Fya(b,b1) 
#
               t1ppqq(a,i,b,j) = T1aibj_ab(a,i,b1,j)*Fya(b,b1) 
               tppqq(a,i,b,j) += t1ppqq(a,i,b,j) 
#
            ENDDO b1 
#
            execute                      energy_denominator tppqq(a,i,b,j) 
            PREPARE T2yFullab(a,i,b,j) = tppqq(a,i,b,j)
#
      ENDPARDO a, b, i, j 
#
#     dV^{ai}_{bj}/dy next  
#     -------------------- 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO b, b1, i1, i 
#
            REQUEST            DTpppi(b,b1,i1,i) b  
            tqqpp(b,b1,i1,i) = DTpppi(b,b1,i1,i) 
#
#           beta virtual contractions. 
#           -------------------------- 
#
            DO b2 
#
               REQUEST             Vaaii(b2,b1,i1,i) i  
               REQUEST             Vaaii(b,b2,i1,i)  i  
               GET                 Uyaa(b2,b) 
               GET                 Uyaa(b2,b1) 
#
               t1qqpp(b,b1,i1,i) = Vaaii(b2,b1,i1,i)*Uyaa(b2,b) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
               t1qqpp(b,b1,i1,i) = Vaaii(b,b2,i1,i)*Uyaa(b2,b1) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
            ENDDO b2 
#
#           beta occupied contractions. 
#           --------------------------- 
#
            DO j2 
#
               REQUEST             Vpiqj(i,i1,b1,j2) i
               REQUEST             Vpiqj(i1,i,b,j2)  i  
               GET                 Uyaa(j2,b) 
               GET                 Uyaa(j2,b1) 
#
               t1qqpp(b,b1,i1,i) = Vpiqj(i,i1,b1,j2)*Uyaa(j2,b) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
               t1qqpp(b,b1,i1,i) = Vpiqj(i1,i,b,j2)*Uyaa(j2,b1) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
            ENDDO j2 
#
#           alpha virtual contractions. 
#           --------------------------- 
#
            DO a 
#
               REQUEST             Vaaai(b,b1,a,i)  a 
               REQUEST             Vaaai(b1,b,a,i1) a 
               GET                 Uyaa(a,i1) 
               GET                 Uyaa(a,i) 
#
               t1qqpp(b,b1,i1,i) = Vaaai(b,b1,a,i)*Uyaa(a,i1) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
               t1qqpp(b,b1,i1,i) = Vaaai(b1,b,a,i1)*Uyaa(a,i) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
            ENDDO a 
#
#           alpha occupied contractions. 
#           ---------------------------- 
#
            DO i2 
#
               REQUEST             Vaaii(b,b1,i2,i)  b  
               REQUEST             Vaaii(b,b1,i1,i2) b  
               GET                 Uyaa(i2,i1) 
               GET                 Uyaa(i2,i) 
#
               t1qqpp(b,b1,i1,i) = Vaaii(b,b1,i2,i)*Uyaa(i2,i1) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
               t1qqpp(b,b1,i1,i) = Vaaii(b,b1,i1,i2)*Uyaa(i2,i) 
               tqqpp(b,b1,i1,i) += t1qqpp(b,b1,i1,i)  
#
            ENDDO i2 
#
#           Compute contributions to intermediates. 
#           --------------------------------------- 
#
            GET               Dpq_a(b,b1)  
            tpp(i1,i)       = tqqpp(b,b1,i1,i)*Dpq_a(b,b1) 
            tpp(i1,i)      *= -1.0  
            PUT DIii(i1,i) += tpp(i1,i) 
#
      ENDPARDO b, b1, i1, i 
#
#     dV^{ia}_{bj}/dy next  
#     -------------------- 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO a, b, i, j 
#
            REQUEST          DTpppi(i,a,b,j) a  
            tppqq(i,a,b,j) = DTpppi(i,a,b,j) 
#
#           alpha virtual contractions. 
#           --------------------------- 
#
            DO a1 
#
               REQUEST           Vaaai(a1,a,b,j) a  
               REQUEST           Viaai(i,a1,b,j) i  
               GET               Uyaa(a1,i) 
               GET               Uyaa(a1,a) 
#
               t1ppqq(i,a,b,j) = Vaaai(a1,a,b,j)*Uyaa(a1,i) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
               t1ppqq(i,a,b,j) = Viaai(i,a1,b,j)*Uyaa(a1,a) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
            ENDDO a1 
#
#           alpha occupied contractions. 
#           ---------------------------- 
#
            DO i1 
#
               REQUEST           Viaai(i1,a,b,j) b  
               REQUEST           Vpiqj(i,i1,b,j) b  
               GET               Uyaa(i1,i) 
               GET               Uyaa(i1,a) 
#
               t1ppqq(i,a,b,j) = Viaai(i1,a,b,j)*Uyaa(i1,i) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
               t1ppqq(i,a,b,j) = Vpiqj(i,i1,b,j)*Uyaa(i1,a) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
            ENDDO i1 
#
#           beta virtual contractions. 
#           -------------------------- 
#
            DO b1 
#
               REQUEST           Viaai(i,a,b1,j) a  
               REQUEST           Vaaai(b1,b,a,i) a 
               GET               Uyaa(b1,b) 
               GET               Uyaa(b1,j) 
#
               t1ppqq(i,a,b,j) = Viaai(i,a,b1,j)*Uyaa(b1,b) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
               t1ppqq(i,a,b,j) = Vaaai(b1,b,a,i)*Uyaa(b1,j) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
            ENDDO b1 
#
#           beta occupied contractions. 
#           --------------------------- 
#
            DO j1 
#
               REQUEST           Vpiqj(a,i,j,j1) a
               REQUEST           Viaai(i,a,b,j1) a  
               GET               Uyaa(j1,b) 
               GET               Uyaa(j1,j) 
#
               t1ppqq(i,a,b,j) = Vpiqj(a,i,j,j1)*Uyaa(j1,b) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
               t1ppqq(i,a,b,j) = Viaai(i,a,b,j1)*Uyaa(j1,j) 
               tppqq(i,a,b,j) += t1ppqq(i,a,b,j) 
#
            ENDDO j1 
#
#           Compute contribution to DXai. 
#           ---------------------------- 
#
            GET              Dpq_a(b,j) 
            tpp(a,i)       = tppqq(i,a,b,j)*Dpq_a(b,j)
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO a, b, i, j 
#
#     dV^{ia}_{bc}/dy next  
#     -------------------- 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO a, i, b, b1 
#
            REQUEST           DTpppi(b1,b,a,i) a  
            tqqpp(b1,b,a,i) = DTpppi(b1,b,a,i) 
#
#           alpha virtual contraction. 
#           -------------------------- 
#
            DO a1 
#
               REQUEST            Vaaai(b1,b,a1,i) b
               GET                Uyaa(a1,i) 
               GET                Uyaa(a1,a) 
#
               t1qqpp(b1,b,a,i) = Vaaai(b1,b,a1,i)*Uyaa(a1,a) 
               tqqpp(b1,b,a,i) += t1qqpp(b1,b,a,i)  
#
            ENDDO a1 
#
#           alpha occupied contractions. 
#           ---------------------------- 
#
            DO i1 
#
               REQUEST            Vaaai(b1,b,a,i1) b 
               REQUEST            Vaaii(b1,b,i1,i) b  
               GET                Uyaa(i1,i) 
               GET                Uyaa(i1,a)
#
               t1qqpp(b1,b,a,i) = Vaaai(b1,b,a,i1)*Uyaa(i1,i) 
               tqqpp(b1,b,a,i) += t1qqpp(b1,b,a,i)  
#
               t1qqpp(b1,b,a,i) = Vaaii(b1,b,i1,i)*Uyaa(i1,a) 
               tqqpp(b1,b,a,i) += t1qqpp(b1,b,a,i)  
#
            ENDDO i1 
#
#           beta virtual contractions. 
#           -------------------------- 
#
            DO b2 
#
               REQUEST            Vaaai(b2,b,a,i)  a 
               REQUEST            Vaaai(b1,b2,a,i) a  
               GET                Uyaa(b2,b1) 
               GET                Uyaa(b2,b) 
#
               t1qqpp(b1,b,a,i) = Vaaai(b2,b,a,i)*Uyaa(b2,b1) 
               tqqpp(b1,b,a,i) += t1qqpp(b1,b,a,i)  
#
               t1qqpp(b1,b,a,i) = Vaaai(b1,b2,a,i)*Uyaa(b2,b) 
               tqqpp(b1,b,a,i) += t1qqpp(b1,b,a,i)  
#
            ENDDO b2 
#
#           beta occupied contractions. 
#           --------------------------- 
#
            DO j2 
#
               REQUEST            Viaai(i,a,b,j2)  a 
               REQUEST            Vpiqj(a,i,b1,j2) a  
               GET                Uyaa(j2,b1) 
               GET                Uyaa(j2,b) 
#
               t1qqpp(b1,b,a,i) = Viaai(i,a,b,j2)*Uyaa(j2,b1) 
               tqqpp(b1,b,a,i) += t1qqpp(b1,b,a,i)  
#
               t1qqpp(b1,b,a,i) = Vpiqj(a,i,b1,j2)*Uyaa(j2,b) 
               tqqpp(b1,b,a,i) += t1qqpp(b1,b,a,i)  
#
            ENDDO j2 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            GET                        Dpq_a(b1,b)  
            tpp(a,i)                 = tqqpp(b1,b,a,i)*Dpq_a(b1,b) 
            PUT DXai(a,i)           += tpp(a,i) 
#
      ENDPARDO a, i, b, b1 
#
#     Add contributions to DXai from 'direct' intermediates. 
#     ------------------------------------------------------ 
#
      PARDO a, a1 
#
           GET VXX_aa(a,a1)
#
           DO i 
#
              GET              Uyaa(a1,i) 
              tpp(a,i)       = VXX_aa(a,a1)*Uyaa(a1,i) 
              PUT DXai(a,i) += tpp(a,i)  
#
           ENDDO i 
#
      ENDPARDO a, a1 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO b, j, a, a1 
#
            REQUEST           DTpppi(a1,a,b,j) a  
            tppqq(a1,a,b,j) = DTpppi(a1,a,b,j) 
#
#           beta virtual contractions. 
#           -------------------------- 
#
            DO b1 
#
               REQUEST            Vaaai(a1,a,b1,j) a 
               GET                Uyaa(b1,j) 
               GET                Uyaa(b1,b) 
#
               t1ppqq(a1,a,b,j) = Vaaai(a1,a,b1,j)*Uyaa(b1,b) 
               tppqq(a1,a,b,j) += t1ppqq(a1,a,b,j)  
#
            ENDDO b1 
#
#           beta occupied contractions. 
#           --------------------------- 
#
            DO j1 
#
               REQUEST            Vaaai(a1,a,b,j1) a 
               REQUEST            Vaaii(a1,a,j1,j) a  
               GET                Uyaa(j1,j) 
               GET                Uyaa(j1,b)
#
               t1ppqq(a1,a,b,j) = Vaaai(a1,a,b,j1)*Uyaa(j1,j) 
               tppqq(a1,a,b,j) += t1ppqq(a1,a,b,j)  
#
               t1ppqq(a1,a,b,j) = Vaaii(a1,a,j1,j)*Uyaa(j1,b) 
               tppqq(a1,a,b,j) += t1ppqq(a1,a,b,j)  
#
            ENDDO j1 
#
#           alpha virtual contractions. 
#           --------------------------- 
#
            DO a2 
#
               REQUEST            Vaaai(a2,a,b,j)  b 
               REQUEST            Vaaai(a1,a2,b,j) b  
               GET                Uyaa(a2,a1) 
               GET                Uyaa(a2,a) 
#
               t1ppqq(a1,a,b,j) = Vaaai(a2,a,b,j)*Uyaa(a2,a1) 
               tppqq(a1,a,b,j) += t1ppqq(a1,a,b,j)  
#
               t1ppqq(a1,a,b,j) = Vaaai(a1,a2,b,j)*Uyaa(a2,a) 
               tppqq(a1,a,b,j) += t1ppqq(a1,a,b,j)  
#
            ENDDO a2 
#
#           alpha occupied contractions. 
#           ---------------------------- 
#
            DO i2 
#
               REQUEST            Viaai(i2,a,b,j)  b 
               REQUEST            Vpiqj(a1,i2,b,j) b  
               GET                Uyaa(i2,a1) 
               GET                Uyaa(i2,a) 
#
               t1ppqq(a1,a,b,j) = Viaai(i2,a,b,j)*Uyaa(i2,a1) 
               tppqq(a1,a,b,j) += t1ppqq(a1,a,b,j)  
#
               t1ppqq(a1,a,b,j) = Vpiqj(a1,i2,b,j)*Uyaa(i2,a) 
               tppqq(a1,a,b,j) += t1ppqq(a1,a,b,j)  
#
            ENDDO i2 
#
#           Contributions to DXai. 
#           ---------------------- 
#
            DO i 
#
               REQUEST          T1aibj_ab(a1,i,b,j) b  
               tpp(a,i)       = tppqq(a1,a,b,j)*T1aibj_ab(a1,i,b,j)  
               PUT DXai(a,i) += tpp(a,i) 
# 
            ENDDO i 
#
      ENDPARDO b, j, a, a1 
#
#     Add contributions to DXai from 'direct' intermediates. 
#     ------------------------------------------------------ 
#
      PARDO a, i, b, j 
#
           REQUEST          VT_ab(a,i,b,j) a 
           GET              Uyaa(b,j) 
#
           tpp(a,i)       = VT_ab(a,i,b,j)*Uyaa(b,j) 
           PUT DXai(a,i) += tpp(a,i)  
#
      ENDPARDO a, i, b, j 
#
#     dV^{ik}_{jl}/dy next  
#     -------------------- 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO i, i1, j, j1 
#
            REQUEST            DTpppi(i,i1,j,j1) i  
            tppqq(i,i1,j,j1) = DTpppi(i,i1,j,j1)
#
#           alpha virtual contractions. 
#           --------------------------- 
#
            DO a 
#
               REQUEST             Vpiqj(a,i1,j,j1) a  
               REQUEST             Vpiqj(a,i,j1,j)  a 
               GET                 Uyaa(a,i) 
               GET                 Uyaa(a,i1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(a,i1,j,j1)*Uyaa(a,i) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(a,i,j1,j)*Uyaa(a,i1) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
            ENDDO a 
#
#           alpha occupied contractions. 
#           --------------------------- 
#
            DO i2 
#
               REQUEST             Vpiqj(i2,i1,j,j1) j  
               REQUEST             Vpiqj(i,i2,j,j1)  j  
               GET                 Uyaa(i2,i) 
               GET                 Uyaa(i2,i1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(i2,i1,j,j1)*Uyaa(i2,i) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(i,i2,j,j1)*Uyaa(i2,i1) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
            ENDDO i2 
#
#           beta virtual contractions. 
#           -------------------------- 
#
            DO b 
#
               REQUEST             Vpiqj(i,i1,b,j1) b  
               REQUEST             Vpiqj(i1,i,b,j)  b  
               GET                 Uyaa(b,j) 
               GET                 Uyaa(b,j1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(i,i1,b,j1)*Uyaa(b,j) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(i1,i,b,j)*Uyaa(b,j1) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
            ENDDO b 
#
#           beta occupied contractions. 
#           -------------------------- 
#
            DO j2 
#
               REQUEST             Vpiqj(i,i1,j2,j1) i  
               REQUEST             Vpiqj(i,i1,j,j2)  i  
               GET                 Uyaa(j2,j) 
               GET                 Uyaa(j2,j1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(i,i1,j2,j1)*Uyaa(j2,j) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
               t1ppqq(i,i1,j,j1) = Vpiqj(i,i1,j,j2)*Uyaa(j2,j1) 
               tppqq(i,i1,j,j1) += t1ppqq(i,i1,j,j1) 
#
            ENDDO j2 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           DIii contribution. 
#           ------------------ 
#
            GET               Dpq_a(j,j1) 
            tpp(i,i1)       = tppqq(i,i1,j,j1)*Dpq_a(j,j1)
            tpp(i,i1)      *= -1.0  
            PUT DIii(i,i1) += tpp(i,i1) 
#
      ENDPARDO i, i1, j, j1 
#
#     dV^{ij}_{aj}/dy next  
#     -------------------- 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO i, i1, b, j 
#
            REQUEST           DTpppi(i,i1,b,j) b  
            tppqq(i,i1,b,j) = DTpppi(i,i1,b,j) 
#
#           alpha virtual contributions. 
#           ---------------------------- 
#
            DO a2 
#
               REQUEST            Vpiqj(a2,i1,b,j) b  
               REQUEST            Viaai(i,a2,b,j)  b  
               GET                Uyaa(a2,i) 
               GET                Uyaa(a2,i1) 
#
               t1ppqq(i,i1,b,j) = Vpiqj(a2,i1,b,j)*Uyaa(a2,i) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
               t1ppqq(i,i1,b,j) = Viaai(i,a2,b,j)*Uyaa(a2,i1) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
            ENDDO a2 
#
#           alpha occupied contributions. 
#           ---------------------------- 
#
            DO i2 
#
               REQUEST            Vpiqj(i2,i1,b,j) b  
               REQUEST            Vpiqj(i,i2,b,j)  b  
               GET                Uyaa(i2,i) 
               GET                Uyaa(i2,i1) 
#
               t1ppqq(i,i1,b,j) = Vpiqj(i2,i1,b,j)*Uyaa(i2,i) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
               t1ppqq(i,i1,b,j) = Vpiqj(i,i2,b,j)*Uyaa(i2,i1) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
            ENDDO i2 
#
#           beta virtual contributions. 
#           --------------------------- 
#
            DO b2 
#
               REQUEST            Vpiqj(i,i1,b2,j) i  
               REQUEST            Vaaii(b,b2,i,i1) b
               GET                Uyaa(b2,b) 
               GET                Uyaa(b2,j) 
#
               t1ppqq(i,i1,b,j) = Vpiqj(i,i1,b2,j)*Uyaa(b2,b) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
               t1ppqq(i,i1,b,j) = Vaaii(b,b2,i,i1)*Uyaa(b2,j) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
            ENDDO b2 
#
#           beta occupied contributions. 
#           --------------------------- 
#
            DO j2 
#
               REQUEST            Vpiqj(i,i1,j2,j) i  
               REQUEST            Vpiqj(i,i1,b,j2) i  
               GET                Uyaa(j2,b) 
               GET                Uyaa(j2,j) 
#
               t1ppqq(i,i1,b,j) = Vpiqj(i,i1,j2,j)*Uyaa(j2,b) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
               t1ppqq(i,i1,b,j) = Vpiqj(i,i1,b,j2)*Uyaa(j2,j) 
               tppqq(i,i1,b,j) += t1ppqq(i,i1,b,j)  
#
            ENDDO j2 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
            DO a 
#
               REQUEST          T1aibj_ab(a,i1,b,j) a 
               tpp(a,i )      = T1aibj_ab(a,i1,b,j)*tppqq(i,i1,b,j)
               tpp(a,i)      *= -1.0  
               PUT DIai(a,i) += tpp(a,i) 
#
            ENDDO a 
#
#          DIii. 
#          ----- 
#
           GET               Dpq_a(b,j) 
           tpp(i,i1)       = tppqq(i,i1,b,j)*Dpq_a(b,j)
           tpp(i,i1)      *= -1.0  
           t2pp(i1,i)      = tpp(i,i1) 
           PUT DIii(i,i1) += tpp(i,i1) 
           PUT DIii(i1,i) += t2pp(i1,i) 
#
#          Compute contributions to DXai. 
#          ----------------------------- 
#
           DO a 
#
               REQUEST          T1aibj_ab(a,i1,b,j) a  
               tpp(a,i)       = T1aibj_ab(a,i1,b,j)*tppqq(i,i1,b,j)
               tpp(a,i)      *= -1.0 
               PUT DXai(a,i) += tpp(a,i)  
#
           ENDDO a 
#
      ENDPARDO i, i1, b, j 
#
#     alpha-beta component 
#     -------------------- 
#
      PARDO j, j1, a, i 
#
            REQUEST           DTpppi(j,j1,a,i) a  
            tqqpp(j,j1,a,i) = DTpppi(j,j1,a,i) 
#
#           beta virtual contractions. 
#           -------------------------- 
#
            DO b2 
#
               REQUEST            Vpiqj(a,i,b2,j1) a  
               REQUEST            Viaai(i,a,b2,j)  a 
               GET                Uyaa(b2,j) 
               GET                Uyaa(b2,j1) 
#
               t1qqpp(j,j1,a,i) = Vpiqj(a,i,b2,j1)*Uyaa(b2,j) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
               t1qqpp(j,j1,a,i) = Viaai(i,a,b2,j)*Uyaa(b2,j1) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
            ENDDO b2 
#
#           beta occupied contractions. 
#           -------------------------- 
#
            DO j2 
#
               REQUEST            Vpiqj(a,i,j2,j1) a  
               REQUEST            Vpiqj(a,i,j,j2)  a  
               GET                Uyaa(j2,j) 
               GET                Uyaa(j2,j1) 
#
               t1qqpp(j,j1,a,i) = Vpiqj(a,i,j2,j1)*Uyaa(j2,j) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
               t1qqpp(j,j1,a,i) = Vpiqj(a,i,j,j2)*Uyaa(j2,j1) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
            ENDDO j2 
#
#           alpha virtual contractions. 
#           --------------------------- 
#
            DO a2 
#
               REQUEST            Vpiqj(a2,i,j,j1) j  
               REQUEST            Vaaii(a,a2,j,j1) a 
               GET                Uyaa(a2,a) 
               GET                Uyaa(a2,i) 
#
               t1qqpp(j,j1,a,i) = Vpiqj(a2,i,j,j1)*Uyaa(a2,a) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
               t1qqpp(j,j1,a,i) = Vaaii(a,a2,j,j1)*Uyaa(a2,i) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
            ENDDO a2 
#
#           alpha occupied contractions. 
#           ---------------------------- 
#
            DO i2 
#
               REQUEST            Vpiqj(i2,i,j,j1) j  
               REQUEST            Vpiqj(a,i2,j,j1) j  
               GET                Uyaa(i2,a) 
               GET                Uyaa(i2,i) 
#
               t1qqpp(j,j1,a,i) = Vpiqj(i2,i,j,j1)*Uyaa(i2,a) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
               t1qqpp(j,j1,a,i) = Vpiqj(a,i2,j,j1)*Uyaa(i2,i) 
               tqqpp(j,j1,a,i) += t1qqpp(j,j1,a,i)  
#
            ENDDO i2 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
# 
            GET              Dpq_a(j,j1) 
            tpp(a,i)       = tqqpp(j,j1,a,i)*Dpq_a(j,j1)
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO j, j1, a, i 
#
      ENDPROC DERVYFULLAB  
#     -------------------  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC DERVYFULLAA  
#     ----------------  
#
#     dV^{ab}_{ij}/dy first 
#     --------------------- 
#
      PARDO i, i1, a, a1  
#
            REQUEST             DTpppi(a,i,a1,i1) a  
            REQUEST             DTpppi(a,i1,a1,i) a  
            tpppp(a,i,a1,i1)  = DTpppi(a,i,a1,i1) 
            t1pppp(a,i,a1,i1) = DTpppi(a,i1,a1,i) 
            tpppp(a,i,a1,i1) -= t1pppp(a,i,a1,i1) 
#
#           Virtual contractions. 
#           --------------------- 
#
            DO a2
#
               REQUEST             VSpipi(a2,i,a1,i1) i 
               REQUEST             VSpipi(a,i,a2,i1)  i 
               REQUEST             VSaaai(a,a2,a1,i1) a 
               REQUEST             VSaaai(a1,a2,a,i)  a 
               GET                 Uyaa(a2,a)
               GET                 Uyaa(a2,a1)
               GET                 Uyaa(a2,i)
               GET                 Uyaa(a2,i1)
#
               t1pppp(a,i,a1,i1) = VSpipi(a2,i,a1,i1)*Uyaa(a2,a)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
               t1pppp(a,i,a1,i1) = VSpipi(a,i,a2,i1)*Uyaa(a2,a1)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
               t1pppp(a,i,a1,i1) = VSaaai(a,a2,a1,i1)*Uyaa(a2,i)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
               t1pppp(a,i,a1,i1) = VSaaai(a1,a2,a,i)*Uyaa(a2,i1)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
            ENDDO a2
#
#           Occupied contractions. 
#           ---------------------- 
#
            DO i2
#
               REQUEST             VSpipi(i2,i,a1,i1) a1 
               REQUEST             VSpipi(a,i,i2,i1)  a
               REQUEST             VSpipi(a,i2,a1,i1) a
               REQUEST             VSpipi(a,i,a1,i2)  a 
               GET                 Uyaa(i2,a)
               GET                 Uyaa(i2,a1)
               GET                 Uyaa(i2,i)
               GET                 Uyaa(i2,i1)
#
               t1pppp(a,i,a1,i1) = VSpipi(i2,i,a1,i1)*Uyaa(i2,a)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
               t1pppp(a,i,a1,i1) = VSpipi(a,i,i2,i1)*Uyaa(i2,a1)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
               t1pppp(a,i,a1,i1) = VSpipi(a,i2,a1,i1)*Uyaa(i2,i)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
               t1pppp(a,i,a1,i1) = VSpipi(a,i,a1,i2)*Uyaa(i2,i1)
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1)
#
            ENDDO i2
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           Compute contribution to Dyaa. 
#           ----------------------------- 
#
            DO a2 
#
               REQUEST           T1aiai_aa(a2,i,a1,i1) i  
               tpp(a,a2)       = tpppp(a,i,a1,i1)*T1aiai_aa(a2,i,a1,i1) 
               tpp(a,a2)      *= -0.25 
               t1pp(a2,a)      = tpp(a,a2) 
               PUT DIaa(a,a2) += tpp(a,a2) 
               PUT DIaa(a2,a) += t1pp(a2,a) 
#
            ENDDO a2 
#
#           Compute contribution to Dyii. 
#           ----------------------------- 
#
            DO i2 
#
               REQUEST            T1aiai_aa(a,i2,a1,i1) a 
               tpp(i,i2)        = tpppp(a,i,a1,i1)*T1aiai_aa(a,i2,a1,i1) 
               tpp(i,i2)       *= -0.5 
               PUT DIii(i,i2)  += tpp(i,i2) 
#
            ENDDO i2 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            GET              Dpq_a(a1,i1) 
            tpp(a,i)       = tpppp(a,i,a1,i1)*Dpq_a(a1,i1)
            PUT Dxai(a,i) += tpp(a,i) 
#
#           Compute complete amplitude derivative. 
#           -------------------------------------- 
#
            DO i2 
#
               REQUEST             T1aiai_aa(a,i2,a1,i1) a  
               REQUEST             T1aiai_aa(a,i,a1,i2)  a  
               GET                 Fya(i2,i) 
               GET                 Fya(i2,i1) 
#
               t1pppp(a,i,a1,i1) = T1aiai_aa(a,i2,a1,i1)*Fya(i2,i) 
               tpppp(a,i,a1,i1) -= t1pppp(a,i,a1,i1) 
#
               t1pppp(a,i,a1,i1) = T1aiai_aa(a,i,a1,i2)*Fya(i2,i1) 
               tpppp(a,i,a1,i1) -= t1pppp(a,i,a1,i1) 
#
            ENDDO i2 
#
            DO a2 
#
               REQUEST             T1aiai_aa(a2,i,a1,i1) i  
               REQUEST             T1aiai_aa(a,i,a2,i1)  i  
               GET                 Fya(a2,a) 
               GET                 Fya(a2,a1) 
#
               t1pppp(a,i,a1,i1) = T1aiai_aa(a2,i,a1,i1)*Fya(a2,a) 
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1) 
#
               t1pppp(a,i,a1,i1) = T1aiai_aa(a,i,a2,i1)*Fya(a2,a1) 
               tpppp(a,i,a1,i1) += t1pppp(a,i,a1,i1) 
#
            ENDDO a2 
#
            execute                        energy_denominator tpppp(a,i,a1,i1) 
            PREPARE T2yFullaa(a,i,a1,i1) = tpppp(a,i,a1,i1)
#
      ENDPARDO i, i1, a, a1  
#
#     dV^{ai}_{bj}/dy next  
#     -------------------- 
#
      PARDO i, i1, a, a1 
#
            REQUEST             DTpppi(a,a1,i,i1) a  
            REQUEST             DTpppi(i,a1,a,i1) a  
            tpppp(a,a1,i,i1)  = DTpppi(a,a1,i,i1) 
            t1pppp(a,a1,i,i1) = DTpppi(i,a1,a,i1) 
            tpppp(a,a1,i,i1) -= t1pppp(a,a1,i,i1) 
#
#           Virtual contractions. 
#           --------------------- 
#
            DO a2 
#
               REQUEST               Vaaii(a2,a1,i,i1)  i
               REQUEST               Viaai(i,a1,a2,i1)  i
               REQUEST               Vaaii(a,a2,i,i1)   a  
               REQUEST               Viaai(i,a2,a,i1)   a  
               REQUEST               VSaaai(a,a1,a2,i1) a  
               REQUEST               VSaaai(a1,a,a2,i)  a 
               GET                   Uyaa(a2,a) 
               GET                   Uyaa(a2,a1) 
               GET                   Uyaa(a2,i) 
               GET                   Uyaa(a2,i1) 
#
               t2pppp(i,a1,a2,i1)  = Vaaii(a2,a1,i,i1) # +  
               t2pppp(i,a1,a2,i1) -= Viaai(i,a1,a2,i1) # -  
#
               t1pppp(a,a1,i,i1)   = t2pppp(i,a1,a2,i1)*Uyaa(a2,a) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
               t2pppp(i,a2,a,i1)   = Vaaii(a,a2,i,i1) # +  
               t2pppp(i,a2,a,i1)  -= Viaai(i,a2,a,i1) # -  
#
               t1pppp(a,a1,i,i1)   = t2pppp(i,a2,a,i1)*Uyaa(a2,a1) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
               t1pppp(a,a1,i,i1)   = VSaaai(a,a1,a2,i1)*Uyaa(a2,i) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
               t1pppp(a,a1,i,i1)   = VSaaai(a1,a,a2,i)*Uyaa(a2,i1) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
            ENDDO a2 
#
#           Occupied contractions. 
#           ---------------------- 
#
            DO i2 
#
               REQUEST               VSpipi(a1,i2,i1,i) i
               REQUEST               VSpipi(a,i2,i,i1)  i  
               REQUEST               Vaaii(a,a1,i2,i1)  a  
               REQUEST               Viaai(i2,a1,a,i1)  a  
               REQUEST               Vaaii(a,a1,i,i2)   a  
               REQUEST               Viaai(i,a1,a,i2)   a  
               GET                   Uyaa(i2,a) 
               GET                   Uyaa(i2,a1) 
               GET                   Uyaa(i2,i) 
               GET                   Uyaa(i2,i1) 
#
               t1pppp(a,a1,i,i1)   = VSpipi(a1,i2,i1,i)*Uyaa(i2,a) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
               t1pppp(a,a1,i,i1)   = VSpipi(a,i2,i,i1)*Uyaa(i2,a1) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
               t2pppp(i2,a1,a,i1)  = Vaaii(a,a1,i2,i1) # +  
               t2pppp(i2,a1,a,i1) -= Viaai(i2,a1,a,i1) # -  
#
               t1pppp(a,a1,i,i1)   = t2pppp(i2,a1,a,i1)*Uyaa(i2,i) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
               t2pppp(i,a1,a,i2)   = Vaaii(a,a1,i,i2) # +  
               t2pppp(i,a1,a,i2)  -= Viaai(i,a1,a,i2) # -  
#
               t1pppp(a,a1,i,i1)   = t2pppp(i,a1,a,i2)*Uyaa(i2,i1) 
               tpppp(a,a1,i,i1)   += t1pppp(a,a1,i,i1) 
#
            ENDDO i2 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           DIii. 
#           ----- 
#
            GET               Dpq_a(a,a1) 
            tpp(i,i1)       = tpppp(a,a1,i,i1)*Dpq_a(a,a1) 
            tpp(i,i1)      *= -1.0  
            PUT DIii(i,i1) += tpp(i,i1) 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            GET               Dpq_a(a1,i) 
            tpp(a,i1)       = tpppp(a,a1,i,i1)*Dpq_a(a1,i)
            tpp(a,i1)      *= -1.0 
            PUT DXai(a,i1) += tpp(a,i1)  
#
      ENDPARDO i, i1, a, a1 
#
#     dV^{ia}_{bc}/dy next  
#     -------------------- 
#
      PARDO a, a1, a2, i 
#
            REQUEST             DTpppi(a2,a,a1,i) a
            REQUEST             DTpppi(a1,a,a2,i) a  
            tpppp(a2,a,a1,i)  = DTpppi(a2,a,a1,i) 
            t1pppp(a2,a,a1,i) = DTpppi(a1,a,a2,i) 
            tpppp(a2,a,a1,i) -= t1pppp(a2,a,a1,i)
#
#           Virtual contractions. 
#           --------------------- 
#
            DO a3 
#
               REQUEST             VSaaai(a2,a,a3,i)  a  
               REQUEST             VSaaai(a2,a3,a1,i) i  
               REQUEST             VSaaai(a3,a,a1,i)  i  
               GET                 Uyaa(a3,i) 
               GET                 Uyaa(a3,a1) 
               GET                 Uyaa(a3,a) 
               GET                 Uyaa(a3,a2) 
#
               t1pppp(a2,a,a1,i) = VSaaai(a2,a,a3,i)*Uyaa(a3,a1) 
               tpppp(a2,a,a1,i) += t1pppp(a2,a,a1,i) 
#
               t1pppp(a2,a,a1,i) = VSaaai(a2,a3,a1,i)*Uyaa(a3,a) 
               tpppp(a2,a,a1,i) += t1pppp(a2,a,a1,i) 
#
               t1pppp(a2,a,a1,i) = VSaaai(a3,a,a1,i)*Uyaa(a3,a2) 
               tpppp(a2,a,a1,i) += t1pppp(a2,a,a1,i) 
#
            ENDDO a3 
#
#           Occupied contractions. 
#           ---------------------- 
#
            DO i3 
#
               REQUEST              VSaaai(a2,a,a1,i3) a 
               REQUEST              Vaaii(a2,a,i3,i)   i  
               REQUEST              Viaai(i3,a,a2,i)   i  
               REQUEST              VSpipi(a2,i3,a1,i) i  
               REQUEST              Viaai(i3,a,a1,i)   i  
               REQUEST              Vaaii(a1,a,i3,i)   i  
               GET                  Uyaa(i3,i) 
               GET                  Uyaa(i3,a1) 
               GET                  Uyaa(i3,a) 
               GET                  Uyaa(i3,a2) 
#
               t1pppp(a2,a,a1,i)  = VSaaai(a2,a,a1,i3)*Uyaa(i3,i) 
               tpppp(a2,a,a1,i)  += t1pppp(a2,a,a1,i) 
#
               t2pppp(i3,a,a2,i)  = Vaaii(a2,a,i3,i) # +   
               t2pppp(i3,a,a2,i) -= Viaai(i3,a,a2,i) # -   
#
               t1pppp(a2,a,a1,i)  = t2pppp(i3,a,a2,i)*Uyaa(i3,a1) 
               tpppp(a2,a,a1,i)  += t1pppp(a2,a,a1,i) 
#
               t1pppp(a2,a,a1,i)  = VSpipi(a2,i3,a1,i)*Uyaa(i3,a) 
               tpppp(a2,a,a1,i)  += t1pppp(a2,a,a1,i) 
#
               t2pppp(a1,a,i3,i)  = Viaai(i3,a,a1,i) # +  
               t2pppp(a1,a,i3,i) -= Vaaii(a1,a,i3,i) # -  
#
               t1pppp(a2,a,a1,i)  = t2pppp(a1,a,i3,i)*Uyaa(i3,a2) 
               tpppp(a2,a,a1,i)  += t1pppp(a2,a,a1,i) 
#
            ENDDO i3 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            DO i1 
#
               REQUEST           T1aiai_aa(a2,i1,a1,i) i  
               tpp(a,i1)       = tpppp(a2,a,a1,i)*T1aiai_aa(a2,i1,a1,i)  
               tpp(a,i1)      *= 0.5 
               PUT DXai(a,i1) += tpp(a,i1) 
#
            ENDDO i1 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            GET               Dpq_a(a2,a) 
            tpp(a1,i)       = tpppp(a2,a,a1,i)*Dpq_a(a2,a) 
            PUT DXai(a1,i) += tpp(a1,i) 
#
      ENDPARDO a, a1, a2, i 
#
#     Add contributions to DXai from 'direct' intermediates. 
#     ------------------------------------------------------ 
#
      PARDO a, a1 
#
           GET VDD_aa(a,a1)
#
           DO i 
#
              GET              Uyaa(a1,i) 
              tpp(a,i)       = VDD_aa(a,a1)*Uyaa(a1,i) 
              PUT DXai(a,i) += tpp(a,i)  
#
           ENDDO i 
#
      ENDPARDO a, a1 
#
      PARDO a, i, a1, i1 
#
           REQUEST          VT_aa(a,i,a1,i1) a 
           GET              Uyaa(a1,i1) 
#
           tpp(a,i)       = VT_aa(a,i,a1,i1)*Uyaa(a1,i1) 
           tpp(a,i)      *= 0.5  
           PUT DXai(a,i) += tpp(a,i)  
#
      ENDPARDO a, i, a1, i1 
#
#     dV^{ik}_{jl}/dy next  
#     -------------------- 
#
      PARDO i, i1, i2, i3 
#
            REQUEST              DTpppi(i,i2,i1,i3) i
            REQUEST              DTpppi(i1,i2,i,i3) i  
            tpppp(i,i2,i1,i3)  = DTpppi(i,i2,i1,i3) # + 
            t1pppp(i,i2,i1,i3) = DTpppi(i1,i2,i,i3) # - 
            tpppp(i,i2,i1,i3) -= t1pppp(i,i2,i1,i3) 
#
#           Occupied contractions. 
#           ---------------------- 
#
            DO i4 
#
               REQUEST              VSpipi(i4,i2,i1,i3) i1  
               REQUEST              VSpipi(i,i4,i1,i3)  i  
               REQUEST              VSpipi(i,i2,i4,i3)  i  
               REQUEST              VSpipi(i,i2,i1,i4)  i  
               GET                  Uyaa(i4,i) 
               GET                  Uyaa(i4,i2) 
               GET                  Uyaa(i4,i1) 
               GET                  Uyaa(i4,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(i4,i2,i1,i3)*Uyaa(i4,i) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(i,i4,i1,i3)*Uyaa(i4,i2) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(i,i2,i4,i3)*Uyaa(i4,i1) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(i,i2,i1,i4)*Uyaa(i4,i3) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
            ENDDO i4 
#
#           Virtual contractions. 
#           --------------------- 
#
            DO a4 
#
               REQUEST              VSpipi(a4,i2,i1,i3) i1  
               REQUEST              VSpipi(a4,i,i3,i1)  i 
               REQUEST              VSpipi(i,i2,a4,i3)  i  
               REQUEST              VSpipi(i2,i,a4,i1)  i 
               GET                  Uyaa(a4,i) 
               GET                  Uyaa(a4,i2) 
               GET                  Uyaa(a4,i1) 
               GET                  Uyaa(a4,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(a4,i2,i1,i3)*Uyaa(a4,i) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(a4,i,i3,i1)*Uyaa(a4,i2) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(i,i2,a4,i3)*Uyaa(a4,i1) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
               t1pppp(i,i2,i1,i3) = VSpipi(i2,i,a4,i1)*Uyaa(a4,i3) 
               tpppp(i,i2,i1,i3) += t1pppp(i,i2,i1,i3) 
#
            ENDDO a4 
#
#           Compute contribution to density derivatives. 
#           -------------------------------------------- 
#
            GET               Dpq_a(i1,i3) 
            tpp(i,i2)       = tpppp(i,i2,i1,i3)*Dpq_a(i1,i3)
            tpp(i,i2)      *= -1.0 
            PUT DIii(i,i2) += tpp(i,i2)  
#
      ENDPARDO i, i1, i2, i3 
#
#     dV^{ij}_{ak}/dy next  
#     -------------------- 
#
      PARDO i, i1, a, i2 
#
            REQUEST             DTpppi(a,i2,i,i1) a  
            REQUEST             DTpppi(a,i1,i,i2) a  
            tpppp(a,i2,i,i1)  = DTpppi(a,i2,i,i1) # + 
            t1pppp(a,i2,i,i1) = DTpppi(a,i1,i,i2) # - 
            tpppp(a,i2,i,i1) -= t1pppp(a,i2,i,i1)
#
#           Occupied contractions. 
#           ---------------------- 
#
            DO i3 
#
               REQUEST             VSpipi(i3,i1,a,i2) a  
               REQUEST             VSpipi(i,i3,a,i2)  a  
               REQUEST             VSpipi(i,i1,i3,i2) i  
               REQUEST             VSpipi(i,i1,a,i3)  a  
               GET                 Uyaa(i3,i) 
               GET                 Uyaa(i3,i1) 
               GET                 Uyaa(i3,a) 
               GET                 Uyaa(i3,i2) 
#
               t1pppp(a,i2,i,i1) = VSpipi(i3,i1,a,i2)*Uyaa(i3,i) 
               tpppp(a,i2,i,i1) += t1pppp(a,i2,i,i1) 
#
               t1pppp(a,i2,i,i1) = VSpipi(i,i3,a,i2)*Uyaa(i3,i1) 
               tpppp(a,i2,i,i1) += t1pppp(a,i2,i,i1) 
#
               t1pppp(a,i2,i,i1) = VSpipi(i,i1,i3,i2)*Uyaa(i3,a) 
               tpppp(a,i2,i,i1) += t1pppp(a,i2,i,i1) 
#
               t1pppp(a,i2,i,i1) = VSpipi(i,i1,a,i3)*Uyaa(i3,i2) 
               tpppp(a,i2,i,i1) += t1pppp(a,i2,i,i1) 
#
            ENDDO i3 
#
#           Virtual contractions. 
#           --------------------- 
#
            DO a3 
#
               REQUEST              VSpipi(a3,i1,a,i2) a  
               REQUEST              Viaai(i,a3,a,i2)   a  
               REQUEST              Vaaii(a,a3,i,i2)   a  
               REQUEST              VSpipi(i,i1,a3,i2) i  
               REQUEST              Vaaii(a,a3,i,i1)   i  
               REQUEST              Viaai(i,a3,a,i1)   i  
               GET                  Uyaa(a3,i) 
               GET                  Uyaa(a3,i1) 
               GET                  Uyaa(a3,a) 
               GET                  Uyaa(a3,i2) 
#
               t1pppp(a,i2,i,i1)  = VSpipi(a3,i1,a,i2)*Uyaa(a3,i) 
               tpppp(a,i2,i,i1)  += t1pppp(a,i2,i,i1) 
#
               t2pppp(a,a3,i,i2)  = Viaai(i,a3,a,i2) # +  
               t2pppp(a,a3,i,i2) -= Vaaii(a,a3,i,i2) # -  
#
               t1pppp(a,i2,i,i1)  = t2pppp(a,a3,i,i2)*Uyaa(a3,i1) 
               tpppp(a,i2,i,i1)  += t1pppp(a,i2,i,i1) 
#
               t1pppp(a,i2,i,i1)  = VSpipi(i,i1,a3,i2)*Uyaa(a3,a) 
               tpppp(a,i2,i,i1)  += t1pppp(a,i2,i,i1) 
#
               t2pppp(i,a3,a,i1)  = Vaaii(a,a3,i,i1) # +  
               t2pppp(i,a3,a,i1) -= Viaai(i,a3,a,i1) # -  
#
               t1pppp(a,i2,i,i1)  = t2pppp(i,a3,a,i1)*Uyaa(a3,i2) 
               tpppp(a,i2,i,i1)  += t1pppp(a,i2,i,i1) 
#
            ENDDO a3 
#
#           Compute contributions to density derivatives. 
#           --------------------------------------------- 
#
#           Dai. 
#           ---- 
#
            DO a1 
#
               REQUEST           T1aiai_aa(a1,i1,a,i2) a  
               tpp(a1,i)       = T1aiai_aa(a1,i1,a,i2)*tpppp(a,i2,i,i1)
               tpp(a1,i)      *= -0.5 
               PUT DIai(a1,i) += tpp(a1,i)  
#
            ENDDO a1 
#
#           DIii. 
#           ----- 
#
            GET               Dpq_a(a,i2) 
            tpp(i,i1)       = tpppp(a,i2,i,i1)*Dpq_a(a,i2)
            tpp(i,i1)      *= -1.0  
            t2pp(i1,i)      = tpp(i,i1) 
            PUT DIii(i,i1) += tpp(i,i1) 
            PUT DIii(i1,i) += t2pp(i1,i) 
#
#           Compute contributions to DXai. 
#           ------------------------------ 
#
            DO a1 
#
               REQUEST           T1aiai_aa(a1,i1,a,i2) a  
               tpp(a1,i)       = T1aiai_aa(a1,i1,a,i2)*tpppp(a,i2,i,i1)
               tpp(a1,i)      *= -0.5 
               PUT DXai(a1,i) += tpp(a1,i) 
#
            ENDDO a1 
#
            GET               Dpq_a(i1,i) 
            tpp(a,i2)       = tpppp(a,i2,i,i1)*Dpq_a(i1,i)
            PUT DXai(a,i2) += tpp(a,i2) 
#
      ENDPARDO i, i1, a, i2 
#
      ENDPROC DERVYFULLAA  
#     -------------------  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC FORMDXAI   
#     -------------  
#
#     Contributions of the y-derivative of the intermediate Xai used 
#     in the Z-vector equations is computed. Note that the individual 
#     terms have been rearranged from the original version to scale 
#     better. A description of the contributions can be found in that 
#     version, but it is noted that contributions coming from 
#     complete integral derivatives are done 'directly' in the routines
#     where they are computed.  
#     ----------------------------------------------------------------- 
#
#     Alpha-alpha block. 
#     ------------------ 
#
      PARDO a, i 
#
#           Initialize DXai to zero. 
#           ------------------------ 
#
            tpp(a,i) = 0.0 
#
            DO i1
            DO i2 
#
#              Contribution from Dyii. 
#              ----------------------- 
#
               REQUEST     VSpipi(a,i,i2,i1) a  
               GET         Dyii(i1,i2) 
#
               t1pp(a,i) = VSpipi(a,i,i2,i1)*Dyii(i1,i2) 
               tpp(a,i) += t1pp(a,i) 
#
               DO a1 
#
                  REQUEST     VSpipi(a1,i2,i,i1)    i  
                  REQUEST     T2yFullaa(a,i1,a1,i2) a  
#
                  t1pp(a,i) = T2yFullaa(a,i1,a1,i2)*VSpipi(a1,i2,i,i1)
                  t1pp(a,i)*= -0.5 
                  tpp(a,i) += t1pp(a,i) 
#
               ENDDO a1 
#
            ENDDO i2 
            ENDDO i1
#
            DO j 
            DO b 
#
               DO a1 
#
                  REQUEST     Vaaai(a1,a,b,j)     b  
                  REQUEST     T2yFullab(a1,i,b,j) b  
#
                  t1pp(a,i) = Vaaai(a1,a,b,j)*T2yFullab(a1,i,b,j) 
                  tpp(a,i) += t1pp(a,i) 
#
               ENDDO a1 
#
               DO i1 
#
                  REQUEST     Vpiqj(i,i1,b,j)     b  
                  REQUEST     T2yFullab(a,i1,b,j) b  
#
                  t1pp(a,i) = T2yFullab(a,i1,b,j)*Vpiqj(i,i1,b,j) 
                  tpp(a,i) -= t1pp(a,i) 
#
               ENDDO i1 
#
            ENDDO b 
            ENDDO j 
#
#           Contributions from Daa*V. 
#           ------------------------- 
#
            DO a1 
            DO a2 
#
               REQUEST     VSaaai(a2,a1,a,i) a  
               GET         Dyaa(a2,a1) 
#
               t1pp(a,i) = VSaaai(a2,a1,a,i)*Dyaa(a2,a1) 
               tpp(a,i) += t1pp(a,i) 
#
#              Compute contributions from V^ab_ci*T. 
#              ------------------------------------- 
#
               DO i1 
#
                  REQUEST     VSaaai(a2,a,a1,i1)    a  
                  REQUEST     T2yFullaa(a2,i,a1,i1) i  
#
                  t1pp(a,i) = VSaaai(a2,a,a1,i1)*T2yFullaa(a2,i,a1,i1) 
                  t1pp(a,i)*= 0.5 
                  tpp(a,i) += t1pp(a,i) 
#
               ENDDO i1 
#
            ENDDO a2 
            ENDDO a1 
#
#           Contributions from Dbb*V. 
#           ------------------------- 
#
            DO b 
            DO b1 
#
               REQUEST Vaaai(b1,b,a,i) a  
               GET Dyaa(b1,b)  
# 
               t1pp(a,i) = Vaaai(b1,b,a,i)*Dyaa(b1,b) 
               tpp(a,i) += t1pp(a,i) 
#
            ENDDO b1 
            ENDDO b 
#
#           Contributions from Djj*V. 
#           ------------------------- 
#
            DO j 
            DO j1 
#
               REQUEST Vpiqj(a,i,j1,j) a 
               GET Dyii(j1,j) 
#
               t1pp(a,i) = Vpiqj(a,i,j1,j)*Dyii(j1,j) 
               tpp(a,i) += t1pp(a,i) 
#
            ENDDO j1 
            ENDDO j 
#
#           Contributions to Dxai/Dy involving unperturbed integrals 
#           are complete. 
#           --------------------------------------------------------- 
#
#           Add contribution from derivative of fock-matrix. 
#           ------------------------------------------------ 
#
            DO i1 
               GET         Dpq_a(a,i1) 
               GET         Fya(i,i1) 
               t3ai(a,i) = Dpq_a(a,i1)*Fya(i,i1) 
               tpp(a,i) -= t3ai(a,i)                
            ENDDO i1 
# 
            DO a1 
               GET         Dpq_a(a1,i) 
               GET         Fya(a,a1) 
               t3ai(a,i) = Dpq_a(a1,i)*Fya(a,a1) 
               tpp(a,i) += t3ai(a,i)                
            ENDDO a1 
#
            PUT DXai(a,i) += tpp(a,i) 
#
      ENDPARDO a, i 
#
      ENDPROC FORMDXAI   
#     ----------------  
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
         PROC UPDATE_DAI 
#        --------------- 
#
         PARDO a, i 
#
               GET        Dainew_a(a,i) 
               GET        Daiold_a(a,i) 
               Tai(a,i) = Dainew_a(a,i) 
#              execute energy_denominator Tai(a,i) 
               Tai(a,i) -= Daiold_a(a,i) 
#
               if kiter == 1 
                  PUT e1ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 2 
                  PUT e2ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 3 
                  PUT e3ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 4 
                  PUT e4ai(a,i) = tai(a,i) 
               endif 
#
               if kiter >= 5 
                  PUT e5ai(a,i) = tai(a,i) 
               endif 
#
         ENDPARDO a, i 
#
         ENDPROC UPDATE_DAI 
#        ------------------ 
#
# ----------------------------------------------------------------------------------------
# 
# ----------------------------------------------------------------------------------------
#
      PROC MOVE_DAI 
#     ------------- 
#
      PARDO a, i
#
            GET        Daiold_a(a,i)
            tai(a,i) = Daiold_a(a,i)
#
            if kiter == 1
               PUT d1ai(a,i) = tai(a,i)
            endif
#
            if kiter == 2
               PUT d2ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 3
               PUT d3ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 4
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
            if kiter >= 5
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
      ENDPARDO a, i
#
      ENDPROC MOVE_DAI 
#     ---------------- 
# 
# ----------------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR
#    -----------------
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS
#    expansion are zero'd out.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR
#    --------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS
#    ---------------
#
#    Put the matrix elements of B into the sip 'B' matrix.
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS
#    ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to Dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-1 amplitudes
           GET e2ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb22 += b22
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------
#
     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-2 amplitudes
           GET D1ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-1 amplitudes
           GET e2ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS1
#    -------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute server_barrier
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-2 amplitudes
           GET e2ai(a,i)    # kiter-1 amplitudes
           GET e3ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
     ENDPARDO a, i
#
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb33 += b33
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-3 amplitudes
           GET D1ai(a,i)     # kiter-2 amplitudes
           GET D2ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-2 amplitudes
           GET e2ai(a,i)     # kiter-1 amplitudes
           GET e3ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS2
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-3 amplitudes
           GET e2ai(a,i)    # kiter-2 amplitudes
           GET e3ai(a,i)    # kiter-1 amplitudes
           GET e4ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb44 += b44
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-4 amplitudes
           GET D1ai(a,i)     # kiter-3 amplitudes
           GET D2ai(a,i)     # kiter-2 amplitudes
           GET D3ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-3 amplitudes
           GET e2ai(a,i)     # kiter-2 amplitudes
           GET e3ai(a,i)     # kiter-1 amplitudes
           GET e4ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS3
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-4 amplitudes
           GET e2ai(a,i)    # kiter-3 amplitudes
           GET e3ai(a,i)    # kiter-2 amplitudes
           GET e4ai(a,i)    # kiter-1 amplitudes
           GET e5ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
              etemp = e1ai(a,i)*e5ai(a,i)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
              etemp = e2ai(a,i)*e5ai(a,i)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
              etemp = e3ai(a,i)*e5ai(a,i)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
              etemp = e4ai(a,i)*e5ai(a,i)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5ai(a,i)*e5ai(a,i)
              b55  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb15 += b15
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb25 += b25
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb35 += b35
     collective Tb44 += b44
     collective Tb45 += b45
     collective Tb55 += b55
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     c5 = Tb55
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-5 amplitudes
           GET D1ai(a,i)     # kiter-4 amplitudes
           GET D2ai(a,i)     # kiter-3 amplitudes
           GET D3ai(a,i)     # kiter-2 amplitudes
           GET D4ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-4 amplitudes
           GET e2ai(a,i)     # kiter-3 amplitudes
           GET e3ai(a,i)     # kiter-2 amplitudes
           GET e4ai(a,i)     # kiter-1 amplitudes
           GET e5ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d4ai(a,i)
           t1ai(a,i)    += e5ai(a,i)
           t1ai(a,i)    *= c5
           tai(a,i)     += t1ai(a,i)
#
           PUT Daiold_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
#
#    0 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET d1ai(a,i)
           PUT d0ai(a,i) = d1ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier 
#
#    2 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET e2ai(a,i)
           PUT e1ai(a,i) = e2ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d2ai(a,i)
           PUT d1ai(a,i) = d2ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     PARDO a, i
           GET e3ai(a,i)
           PUT e2ai(a,i) = e3ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d3ai(a,i)
           PUT d2ai(a,i) = d3ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    4 --> 3
#    ---------------------------------------------------
#
     PARDO a, i
           GET e4ai(a,i)
           PUT e3ai(a,i) = e4ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d4ai(a,i)
           PUT d3ai(a,i) = d4ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     PARDO a, i
           GET e5ai(a,i)
           PUT e4ai(a,i) = e5ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET daiold_a(a,i)
           PUT d4ai(a,i) = daiold_a(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC MOVE4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC DENSAI
#     -----------
#
#     Create distributed denisty arrays. 
#     --------------------------------- 
#
      create Dai_a 
      create Dainew_a 
      create Daiold_a 
      CREATE D0ai
      CREATE D1ai
      CREATE D2ai
      CREATE D3ai
      CREATE D4ai
#
      CREATE e1ai
      CREATE e2ai
      CREATE e3ai
      CREATE e4ai
      CREATE e5ai
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.000000001
      execute sip_barrier
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i 
#
            GET                 Xai_a(a,i)
            tai(a,i)          = Xai_a(a,i) 
            execute             energy_denominator tai(a,i) 
            PUT Daiold_a(a,i) = tai(a,i) 
            PUT D0ai(a,i)     = tai(a,i) 
#
      ENDPARDO a, i 
#
      execute sip_barrier 
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
#
         PARDO a, i
#
               GET        Xai_a(a,i)
               tai(a,i) = Xai_a(a,i)
#
               DO a1
               DO i1
#
                  REQUEST             VSpipi(a,i,a1,i1) a
                  REQUEST             Vaaii(a,a1,i1,i)  a 
                  REQUEST             Viaai(i,a,a1,i1)  a 
#
                  GET                 Daiold_a(a1,i1)
#
                  Taiai(a,i,a1,i1)  = VSpipi(a,i,a1,i1)
                  T3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)
                  T4aiai(a,i,a1,i1) = Viaai(i,a,a1,i1)
#
                  Taiai(a,i,a1,i1) -= T3aiai(a,i,a1,i1)
                  Taiai(a,i,a1,i1) += T4aiai(a,i,a1,i1)
#
                  t1ai(a,i)         = Taiai(a,i,a1,i1)*Daiold_a(a1,i1)
                  tai(a,i)         += t1ai(a,i)
#
               ENDDO i1
               ENDDO a1
#
               DO b
               DO j
#
                  REQUEST           Vpiqj(a,i,b,j) a 
                  REQUEST           Viaai(i,a,b,j) a 
                  GET               Daiold_a(b,j)
#
                  Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
                  T1aibj(a,i,b,j) = Viaai(i,a,b,j)
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
                  t1ai(a,i)       = Taibj(a,i,b,j)*Daiold_a(b,j)
                  tai(a,i)       += t1ai(a,i)
#
               ENDDO j
               ENDDO b
#
               execute energy_denominator tai(a,i)
               PUT Dainew_a(a,i)        = tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI
         execute server_barrier 
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one. 
#        ------------------------------------- 
#
         PARDO a, i 
               GET                 Dainew_a(a,i) 
               PUT Daiold_a(a,i) = Dainew_a(a,i) 
         ENDPARDO a, i 
#
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI
#
      ENDDO kiter
#
      execute sip_barrier
#
#     Put results into the proper arrays. 
#     ----------------------------------- 
#
      PARDO a, i
            GET               Dainew_a(a,i)
            tpp(i,a)        = Dainew_a(a,i)
            PUT Dai_a(a,i)  = Dainew_a(a,i)
            PUT Dpq_a(a,i) += Dainew_a(a,i)
            PUT Dpq_a(i,a) += tpp(i,a)
      ENDPARDO a, i
#
       PARDO a, i, i1
#
             GET                Dainew_a(a,i1)
             Tai(a,i)         = Dainew_a(a,i1)*Fock_a(i1,i)
             Tai(a,i)        *= -1.0
             PUT Iai_a(a,i) += Tai(a,i) 
#
       ENDPARDO a, i, i1 
#
      ENDPROC DENSAI
#     --------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
      PROC FORMDDAI  
#     -------------
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.00000001
      execute sip_barrier
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i 
#
            GET                 DXai(a,i)
            tai(a,i)          = DXai(a,i) 
            execute             energy_denominator tai(a,i) 
            PUT Daiold_a(a,i) = tai(a,i) 
            PUT D0ai(a,i)     = tai(a,i) 
#
      ENDPARDO a, i 
#
      execute sip_barrier
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
#
         PARDO a, i
#
               GET        DXai(a,i)
               tai(a,i) = DXai(a,i)   
#
               DO a1
               DO i1
#
                  REQUEST             VSpipi(a,i,a1,i1) a 
                  REQUEST             Vaaii(a,a1,i1,i)  a 
                  REQUEST             Viaai(i,a,a1,i1)  a 
#
                  GET                 Daiold_a(a1,i1)
#
                  Taiai(a,i,a1,i1)  = VSpipi(a,i,a1,i1)
                  T3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)
                  T4aiai(a,i,a1,i1) = Viaai(i,a,a1,i1)
#
                  Taiai(a,i,a1,i1) -= T3aiai(a,i,a1,i1)
                  Taiai(a,i,a1,i1) += T4aiai(a,i,a1,i1)
#
                  t1ai(a,i)         = Taiai(a,i,a1,i1)*Daiold_a(a1,i1)
                  tai(a,i)         += t1ai(a,i)
#
               ENDDO i1
               ENDDO a1
#
               DO b
               DO j
#
                  REQUEST           Vpiqj(a,i,b,j) a 
                  REQUEST           Viaai(i,a,b,j) a 
                  GET               Daiold_a(b,j)
#
                  Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
                  T1aibj(a,i,b,j) = Viaai(i,a,b,j)
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
                  t1ai(a,i)       = Taibj(a,i,b,j)*Daiold_a(b,j)
                  tai(a,i)       += t1ai(a,i)
#
               ENDDO j
               ENDDO b
#
               execute energy_denominator    tai(a,i)
               PUT Dainew_a(a,i)           = tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI
         execute server_barrier 
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one.
#        -------------------------------------
#
         PARDO a, i
               GET                 Dainew_a(a,i)
               PUT Daiold_a(a,i) = Dainew_a(a,i)
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI
#
      ENDDO kiter
#
      execute sip_barrier
#
#     Put results into proper arrays Dyai and Dybj. 
#     --------------------------------------------- 
#
      PARDO a, i 
            GET Dainew_a(a,i) 
            PUT Dyai(a,i) = Dainew_a(a,i) 
      ENDPARDO a, i 
#
      ENDPROC FORMDDAI
#     ----------------
#
# ---------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC FORM_UYAI  
#     --------------
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.00000001
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i 
#
            GET                 Qyai(a,i)
            tai(a,i)          = Qyai(a,i) 
            execute             energy_denominator tai(a,i) 
            PUT Daiold_a(a,i) = tai(a,i) 
            PUT D0ai(a,i)     = tai(a,i) 
#
      ENDPARDO a, i 
#
      execute sip_barrier 
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
#
         PARDO a, i
#
               GET        Qyai(a,i)
               tai(a,i) = Qyai(a,i)
#
               DO a1
               DO i1
#
                  REQUEST             VSpipi(a,i,a1,i1) a
                  REQUEST             Vaaii(a,a1,i1,i)  a
                  REQUEST             Viaai(i,a,a1,i1)  a 
                  GET                 Daiold_a(a1,i1)
#
                  Taiai(a,i,a1,i1)  = VSpipi(a,i,a1,i1)
                  T3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)
                  T4aiai(a,i,a1,i1) = Viaai(i,a,a1,i1)
#
                  Taiai(a,i,a1,i1) -= T3aiai(a,i,a1,i1)
                  Taiai(a,i,a1,i1) += T4aiai(a,i,a1,i1)
#
                  t1ai(a,i)         = Taiai(a,i,a1,i1)*Daiold_a(a1,i1)
                  tai(a,i)         += t1ai(a,i)
#
               ENDDO i1
               ENDDO a1
#
               DO b
               DO j
#
                  REQUEST           Vpiqj(a,i,b,j) a 
                  REQUEST           Viaai(i,a,b,j) a 
                  GET               Daiold_a(b,j)
#
                  Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
                  T1aibj(a,i,b,j) = Viaai(i,a,b,j)
                  Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
                  t1ai(a,i)       = Taibj(a,i,b,j)*Daiold_a(b,j)
                  tai(a,i)       += t1ai(a,i)
#
               ENDDO j
               ENDDO b
#
               execute energy_denominator    tai(a,i)
               PUT Dainew_a(a,i)           = tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI
         execute server_barrier 
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one.
#        -------------------------------------
#
         PARDO a, i
               GET                 Dainew_a(a,i)
               PUT Daiold_a(a,i) = Dainew_a(a,i)
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI
#
      ENDDO kiter
#
      execute sip_barrier 
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            GET              Dainew_a(a,i)
            GET              Sya(a,i)
#
            PUT Uyaa(a,i)  = Dainew_a(a,i) 
#
            tai(a,i)       = Dainew_a(a,i) 
            tai(a,i)      += Sya(a,i) 
            tia(i,a)       = tai(a,i) 
            tia(i,a)      *= -1.0  
#
            PUT Uyaa(i,a)  = tia(i,a) 

      ENDPARDO a, i 
#
      execute sip_barrier 
#
      ENDPROC FORM_UYAI  
#     -----------------
#
# ---------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------
#
      PROC FORM_UXAI  
#     --------------
#
#     Initialize the sum of the squares to 0
#     --------------------------------------
#
      eold  = 0.0
      ecrit = 0.00000001
#
#     Form initial guess --> DX/eps. 
#     ------------------------------ 
#
      PARDO a, i 
#
            GET                 Qxai(a,i)
            tai(a,i)          = Qxai(a,i) 
            execute             energy_denominator tai(a,i) 
            PUT Daiold_a(a,i) = tai(a,i) 
            PUT D0ai(a,i)     = tai(a,i) 
#
      ENDPARDO a, i 
#
      execute sip_barrier 
#
      DO kiter
#
         esum = 0.0
         enew = 0.0
#
         PARDO a, i
#
               GET                           Qxai(a,i)
               tai(a,i)                    = Qxai(a,i)
#
               execute energy_denominator    tai(a,i)
               PUT Dainew_a(a,i)           = tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i
#
         execute sip_barrier 
#
         PARDO a, i, a1, i1 
#
               REQUEST             VSpipi(a,i,a1,i1) a
               REQUEST             Vaaii(a,a1,i1,i)  a
               REQUEST             Viaai(i,a,a1,i1)  a 
               GET                 Daiold_a(a1,i1)
#
               Taiai(a,i,a1,i1)  = VSpipi(a,i,a1,i1)
               T3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)
               T4aiai(a,i,a1,i1) = Viaai(i,a,a1,i1)
#
               Taiai(a,i,a1,i1) -= T3aiai(a,i,a1,i1)
               Taiai(a,i,a1,i1) += T4aiai(a,i,a1,i1)
#
               tai(a,i)          = Taiai(a,i,a1,i1)*Daiold_a(a1,i1)
#
               execute energy_denominator    tai(a,i)
               PUT Dainew_a(a,i)          += tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i, a1, i1 
#
         PARDO a, i, b, j 
#
               REQUEST           Vpiqj(a,i,b,j) a 
               REQUEST           Viaai(i,a,b,j) a 
               GET               Daiold_a(b,j)
#
               Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
               T1aibj(a,i,b,j) = Viaai(i,a,b,j)
               Taibj(a,i,b,j) += T1aibj(a,i,b,j)
#
               tai(a,i)        = Taibj(a,i,b,j)*Daiold_a(b,j)
#
               execute energy_denominator    tai(a,i)
               PUT Dainew_a(a,i)          += tai(a,i)
#
#              Add new contribution to the sum of the squares
#              ----------------------------------------------
#
               etemp = tai(a,i)*tai(a,i)
               esum += etemp
#
         ENDPARDO a, i, b, j 
#
         execute sip_barrier
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI
         execute server_barrier 
#
         collective enew   += esum
#
#        Reset 'old' density to 'current' one.
#        -------------------------------------
#
         PARDO a, i
               GET                 Dainew_a(a,i)
               PUT Daiold_a(a,i) = Dainew_a(a,i)
         ENDPARDO a, i
#
         execute sip_barrier
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI
#
      ENDDO kiter
#
      execute sip_barrier 
#
#     Put arrays into proper places and apply orthonormality condition. 
#     ----------------------------------------------------------------- 
#
      PARDO a, i 
            GET              Dainew_a(a,i)
            GET              Sxa(a,i)
#
            PUT Uxaa(a,i)  = Dainew_a(a,i) 
#
            tai(a,i)       = Dainew_a(a,i) 
            tai(a,i)      += Sxa(a,i) 
            tia(i,a)       = tai(a,i) 
            tia(i,a)      *= -1.0  
#
            PUT Uxaa(i,a)  = tia(i,a) 

      ENDPARDO a, i 
#
      execute sip_barrier 
#
      ENDPROC FORM_UXAI  
#     -----------------
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
      PROC VT_XAI 
#     ----------- 
#
#     The intermediates used to remove the 4-virtual arrays are constructed. 
#
#     Create one-particle intermediates used in this routine and used
#     later in the 'direct' computation. 
#     ----------------------------------------------------------------------- 
#
      create VD_aa
      create VDX_aa
      create D_aa 
      create VDD_aa  
      create VXX_aa  
      execute sip_barrier
#
#     Form backtransformed virtual-virtual block of the density matrix. 
#     ----------------------------------------------------------------- 
#
#     alpha-alpha block. 
#     ------------------ 
#
      PARDO a, a1 
#
           GET Dpq_a(a,a1) 
#
           DO mu 
#
              txp(mu,a1) = Dpq_a(a,a1)*ca(mu,a)  
#
              DO nu 
#
                 txx(mu,nu)       = txp(mu,a1)*ca(nu,a1) 
                 PUT D_aa(mu,nu) += txx(mu,nu)
#
              ENDDO nu 
#
           ENDDO mu 
#
      ENDPARDO a, a1 
#
#     Form Half back transformed cluster arrays
#     -----------------------------------------
#
      PARDO a1, i1, i
#
           allocate LLaiai(*,i,a1,i1)
#
           DO a
#
              REQUEST              T1aiai_aa(a,i,a1,i1) i1
              REQUEST              T1aiai_aa(a,i1,a1,i) i1
              LLaiai(a,i,a1,i1)  = T1aiai_aa(a,i,a1,i1)
              Taiai(a,i,a1,i1)   = T1aiai_aa(a,i1,a1,i)
              LLaiai(a,i,a1,i1) -= Taiai(a,i,a1,i1)
#
           ENDDO a
#
           DO lambda
#
              Txipi(lambda,i,a1,i1) = 0.0
#
              DO a
#
                 Txiai(lambda,i,a1,i1)   = LLaiai(a,i,a1,i1)*ca(lambda,a)
                 Txipi(lambda,i,a1,i1)  += Txiai(lambda,i,a1,i1)
#
              ENDDO a
#
              PREPARE T1AO_aa(lambda,i,a1,i1) = Txipi(lambda,i,a1,i1)
#
           ENDDO lambda
#
           deallocate LLaiai(*,i,a1,i1)
#
      ENDPARDO a1, i1, i
#
      PARDO b, j, i
#
           allocate LLaibj(*,i,b,j)
#
           DO a
#
              REQUEST            T1aibj_ab(a,i,b,j) i
              LLaibj(a,i,b,j)  = T1aibj_ab(a,i,b,j)
#
           ENDDO a
#
           DO lambda
#
              Txiqj(lambda,i,b,j) = 0.0
#
              DO a
#
                 Txibj(lambda,i,b,j)   = LLaibj(a,i,b,j)*ca(lambda,a)
                 Txiqj(lambda,i,b,j)  += Txibj(lambda,i,b,j)
#
              ENDDO a
#
              PREPARE T1AO_ab(lambda,i,b,j) = Txiqj(lambda,i,b,j)
#
           ENDDO lambda
#
           deallocate LLaibj(*,i,b,j)
#
      ENDPARDO b, j, i
#
      execute server_barrier 
#
      PARDO lambda, i, i1
#
           allocate Lxiai(lambda,i,*,i1)
#
           DO a1
#
              REQUEST                 T1AO_aa(lambda,i,a1,i1) i1
              Lxiai(lambda,i,a1,i1) = T1AO_aa(lambda,i,a1,i1)
#
           ENDDO a1
#
           DO sigma
#
              Txixi(lambda,i,sigma,i1)  = 0.0
#
              DO a1
#
                 T1xixi(lambda,i,sigma,i1) = Lxiai(lambda,i,a1,i1)*ca(sigma,a1)
                 Txixi(lambda,i,sigma,i1)  += T1xixi(lambda,i,sigma,i1)
#
              ENDDO a1
#
              PREPARE TAO_aa(lambda,i,sigma,i1) = Txixi(lambda,i,sigma,i1)
#
           ENDDO sigma
#
           deallocate Lxiai(lambda,i,*,i1)
#
      ENDPARDO lambda, i, i1
#
      PARDO lambda, i, j
#
           allocate Lxibj(lambda,i,*,j)
#
           DO b
#
              REQUEST               T1AO_ab(lambda,i,b,j) j
              Lxibj(lambda,i,b,j) = T1AO_ab(lambda,i,b,j)
#
           ENDDO b 
#
           DO sigma
#
              Txixj(lambda,i,sigma,j) = 0.0
#
              DO b
#
                 T1xixj(lambda,i,sigma,j) = Lxibj(lambda,i,b,j)*ca(sigma,b)
                 Txixj(lambda,i,sigma,j) += T1xixj(lambda,i,sigma,j)
#
              ENDDO b
#
              PREPARE TAO_ab(lambda,i,sigma,j) = Txixj(lambda,i,sigma,j)
#
           ENDDO sigma
#
           deallocate Lxibj(lambda,i,*,j)
#
      ENDPARDO lambda, i, j
#
      execute server_barrier
      execute sip_barrier
#
#     Contract AOINT with half back transformed Amplitudes
#     ----------------------------------------------------
#
      PARDO mu, nu
#
           allocate L1xixi(mu,*,nu,*)
           allocate L1xixj(mu,*,nu,*)
#
           DO lambda
           DO sigma
#
              compute_integrals aoint(lambda,mu,sigma,nu)
#
              GET                      D_aa(sigma,nu) 
              GET                      D_aa(mu,sigma) 
#
              txx(lambda,mu)         = aoint(lambda,mu,sigma,nu)*D_aa(sigma,nu)  
              PUT VD_aa(lambda,mu)  += txx(lambda,mu) 
#
              txx(lambda,nu)         = aoint(lambda,mu,sigma,nu)*D_aa(mu,sigma) 
              PUT VDX_aa(lambda,nu) += txx(lambda,nu) 
#
              DO i
              DO i1
#
                 REQUEST               TAO_aa(lambda,i,sigma,i1) i1
                 Txixi(mu,i,nu,i1)   = aoint(lambda,mu,sigma,nu)*TAO_aa(lambda,i,sigma,i1)
                 L1xixi(mu,i,nu,i1) += Txixi(mu,i,nu,i1)
#
              ENDDO i1
              ENDDO i
#
              DO i
              DO j
#
                 REQUEST              TAO_ab(lambda,i,sigma,j) j
                 Txixj(mu,i,nu,j)   = aoint(lambda,mu,sigma,nu)*TAO_ab(lambda,i,sigma,j)
                 L1xixj(mu,i,nu,j) += Txixj(mu,i,nu,j)
#
              ENDDO j
              ENDDO i
#
           ENDDO sigma
           ENDDO lambda
#
           DO i
           DO i1
#
              PREPARE T2AO_aa(mu,i,nu,i1) = L1xixi(mu,i,nu,i1)
#
           ENDDO i1
           ENDDO i
#
           DO i
           DO j
#
              PREPARE T2AO_ab(mu,i,nu,j) = L1xixj(mu,i,nu,j)
#
           ENDDO j
           ENDDO i
#
           deallocate L1xixi(mu,*,nu,*)
           deallocate L1xixj(mu,*,nu,*)
#
      ENDPARDO  mu, nu
      execute sip_barrier 
      execute server_barrier 
#
#     Perform final transformation
#     ----------------------------
#
      PARDO a, a1, i, i1
#
           T1aiai(a,i,a1,i1) = 0.0
#
           DO nu
#
              Taixi(a,i,nu,i1) = 0.0
#
              DO mu
#
                 REQUEST             T2AO_aa(mu,i,nu,i1) i1
                 T1aixi(a,i,nu,i1) = T2AO_aa(mu,i,nu,i1)*ca(mu,a)
                 Taixi(a,i,nu,i1) += T1aixi(a,i,nu,i1)
#
              ENDDO mu
#
              T2aiai(a,i,a1,i1)  = Taixi(a,i,nu,i1)*ca(nu,a1)
              T1aiai(a,i,a1,i1) += T2aiai(a,i,a1,i1)
#
           ENDDO nu
#
           PREPARE VT_aa(a,i,a1,i1) = T1aiai(a,i,a1,i1)
#
      ENDPARDO a, a1, i, i1
#
      PARDO a, b, i, j
#
           T1aibj(a,i,b,j) = 0.0
#
           DO nu
#
              Taixj(a,i,nu,j) = 0.0
#
              DO mu
#
                 REQUEST            T2AO_ab(mu,i,nu,j) j
                 T1aixj(a,i,nu,j) = T2AO_ab(mu,i,nu,j)*ca(mu,a)
                 Taixj(a,i,nu,j) += T1aixj(a,i,nu,j)
#
              ENDDO mu
#
              T2aibj(a,i,b,j)  = Taixj(a,i,nu,j)*ca(nu,b)
              T1aibj(a,i,b,j) += T2aibj(a,i,b,j)
#
           ENDDO nu
#
           PREPARE VT_ab(a,i,b,j) = T1aibj(a,i,b,j)
#
      ENDPARDO a, b, i, j
#
      execute server_barrier 
#
      PARDO a, a1 
#
            tpp(a,a1) = 0.0 
#
            DO mu 
#
               txp(mu,a1) = 0.0 
#
               DO nu 
#
                  GET           VD_aa(mu,nu) 
                  GET           VDX_aa(mu,nu) 
                  txx(mu,nu)  = VD_aa(mu,nu) 
                  txx(mu,nu) -= VDX_aa(mu,nu) 
#
                  t1xp(mu,a1) = txx(mu,nu)*ca(nu,a1) 
                  txp(mu,a1) += t1xp(mu,a1) 
#
               ENDDO nu 
#
               t1pp(a,a1) = txp(mu,a1)*ca(mu,a) 
               tpp(a,a1) += t1pp(a,a1) 
#
            ENDDO mu 
#
            PUT VDD_aa(a,a1) = tpp(a,a1) 
#
            tpp(a,a1) = 0.0 
#
            DO mu 
#
               txp(mu,a1) = 0.0 
#
               DO nu 
#
                  GET           VD_aa(mu,nu) 
                  t1xp(mu,a1) = VD_aa(mu,nu)*ca(nu,a1) 
                  txp(mu,a1) += t1xp(mu,a1) 
#
               ENDDO nu 
#
               t1pp(a,a1) = txp(mu,a1)*ca(mu,a) 
               tpp(a,a1) += t1pp(a,a1) 
#
            ENDDO mu 
#
            PUT VXX_aa(a,a1) = tpp(a,a1) 
#
      ENDPARDO a, a1 
#
      execute sip_barrier
#
#     Remove one-particle arrays never used again. 
#     -------------------------------------------- 
#
      delete VD_aa
      delete VDX_aa
      delete D_aa 
#
      ENDPROC VT_XAI 
#     -------------- 
#
# ---------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------
#
#                  BEGIN  MAIN PROGRAM 
#
# ---------------------------------------------------------------------------
#
# First compute unperturbed quantities
# ------------------------------------
#
#     1. 2-electron integral transformation 
#     2. First order amplitudes T2aiai, T2bjbj, T2aibj   
#     3. Intermediate Ipq/Xai  
#     4. Density Dpq  
#
# 1. Two-electron integral transformation. 
# ---------------------------------------- 
#
      CALL TRAN_UHF
      execute server_barrier
      execute sip_barrier
#
# 2. First order amplitudes T2aiai, T2bjbj, T2aibj, t1ai, t2bj. 
# -------------------------------------------------------------  
#
      ecrit = 0.00000001 
#
      CALL T2AA_REFERANCE #--> compute the uhf referance amplitudes T2aa  
      CALL T2AB_REFERANCE #--> compute the uhf referance amplitudes T2ab  
      execute sip_barrier 
      execute server_barrier 
#
# 3. Occupied-occupied and virtual-virtual blocks of the density.
# ---------------------------------------------------------------
#
      CALL DENSIJ
      CALL DENSAB
      CALL HFDENS
      execute sip_barrier 
#
# 4. One-particle intermediates Ipq and Xai and virtual-occupied block of the density.
# ------------------------------------------------------------------------------------
#
      CALL PINTER
      execute sip_barrier 
      CALL DENSAI
      execute sip_barrier 
      CALL I11 
      execute sip_barrier 
#
# 5. Compute 'directly' computed intermediates. 
# --------------------------------------------- 
#
      CALL VT_XAI 
#
# Done compute unperturbed quantities.
# ------------------------------------
#
#     Now consider the contributions from second-derivative integrals.
#     ----------------------------------------------------------------
#
#     Transform the intermediates I to the AO basis.
#     ----------------------------------------------
#
      CALL I_TRANS
      CALL I_HF
#
#     Transform the one-particle density to the AO basis.
#     ---------------------------------------------------
#
      CALL D_TRANS
      execute sip_barrier 
#
#     'Contract' the backtransformed intermediates with S''.
#     ------------------------------------------------------
#
      CALL SXY_CONT   # Passed 
#
#     'Contract' the backtransformed density with H''.
#     ------------------------------------------------
#
      CALL DXY_CONT # Passed  
#
#     Half backtransform gamma array.
#     -------------------------------
#
      CALL GIJAB_BT # Passed 
#
# Loop over unique Hessian elements. The Hessian will be viewed as a two
# dimensional array HESS(x,y). The first loop will be over y the second
# over x. Contributions from products of first derivatives will be
# considered first.
# ----------------------------------------------------------------------
#
      DO jatom 
#
      DO jx 
#
         create Dyaa 
         create Dyii  
         create Dyai 
         create DIii  
         create DIaa  
         create DIai 
         create DXai 
         execute sip_barrier 
#
#        Set flags --> perturbation. 
#        --------------------------- 
#
         execute set_flags2 dflagsj2(jatom,jx)   
#
#        Compute the perturbed quantities DTpppi, DTqqqj, DTppqi
#        and DTqqpi.
#        --> Transformed first-derivative two-electron integrals.
#        ------------------------------------------------------------
#
         CALL DINT_TRAN 
#
#        Compute the perturbed quantities Fya and Fyb, Sya and Syb.
#        --> Transformed first-derivative one-electron integrals.
#        ------------------------------------------------------------
#
         CALL SINTY_TRAN 
#
#        Compute CHF coefficients. 
#        ------------------------- 
#
         CALL QYAI_H 
         execute sip_barrier 
         CALL Uy_XX  
         execute sip_barrier 
#
         CALL FORM_UYAI  
         execute sip_barrier 
         CALL FINTY_TRAN 
         execute sip_barrier 
#
#        Prepare perturbed arrays used to complete the HF hessian. 
#        --------------------------------------------------------- 
#
         CALL FSCF_HESS 
         execute sip_barrier 

#        Compute complete two-electron integral derivatives AND 
#        complete derivatives of T-amplitudes. 
#        --------------------------------------------------- 
#
         CALL DERVYFULLAA  
         CALL DERVYFULLAB  
         execute sip_barrier 
         execute server_barrier 
#
#        Compute derivatives of T-amplitudes. Obsolete! Contributions 
#        computed directly.  
#        ------------------------------------------------------------ 
#
        #CALL DT2AMP 
#
#        Compute complete derivative of the density. 
#        ------------------------------------------- 
#
         CALL FORMDDIJ 
         CALL FORMDDAB 
         execute sip_barrier 
#
         CALL FORMDXAI   
         execute sip_barrier 
         CALL FORMDDAI 
         execute sip_barrier 
#
#        Compute complete derivatives of the one-particle intermediates Ipq. 
#        -------------------------------------------------------------------
#
         CALL DERIIJ 
         CALL DERIAB  
         CALL DERIAI 
         execute sip_barrier 
#
         DO iatom 
#
         DO ix 
#
#           Zero out the hessian element. 
#           ----------------------------- 
#
            hessxy                   = 0.0 
            phessxy                  = 0.0 
            thess(jatom,jx,iatom,ix) = 1.0 
#
            hessyx                   = 0.0 
            phessyx                  = 0.0 
            xhess(iatom,ix,jatom,jx) = 1.0 
#
           #execute eval_hess xhess doit 
           #IF doit > 0.0   
#
#           Set flags --> perturbation. 
#           --------------------------- 
#
            execute set_flags2 dflagsi2(iatom,ix)   
#
#           Set flags --> perturbation. 
#           --------------------------- 
#
            execute set_flags4 dflags4(jatom,jx,iatom,ix)   
            CALL GIJAB_CONT  
#
#           Form transformed perturbed two-electron integrals. 
#           -------------------------------------------------- 
#
            CALL TRAN_VX_XIXI 
            execute sip_barrier 
#
#           Compute the perturbed quantities Fxa and Fxb, Sxa and Sxb.
#           --> Transformed first-derivative one-electron integrals.
#           ----------------------------------------------------------
#
            CALL SINTX_TRAN 
            execute sip_barrier 
#
#           Compute CHF coefficients. 
#           ------------------------- 
#
            CALL QXAI_H 
            execute sip_barrier 
#
            CALL Ux_XX  
            execute sip_barrier 
#
            CALL FORM_UXAI  
            execute sip_barrier 
#
            CALL FINTX_TRAN 
            execute sip_barrier 
#
#           Compute contributions to the Hessian 
#           ------------------------------------ 
#
            CALL PART1 # CHECKED  
            CALL PART2 # CHECKED 
            CALL PART3 # CHECKED  
            CALL PART4 # CHECKED  
            CALL PART5 # CHECKED  
            CALL PART6 # CHECKED  
#
#           Remove x-perturbed distributed arrays. 
#           -------------------------------------- 
#
            execute sip_barrier
#
            delete Hxa 
#
            delete Fxa 
            delete Sxa 
            delete Uxaa  
            delete Qxai 
#
            delete QAxx
            delete QBxx
            delete QABxx
#
            execute sip_barrier
#
            collective phessxy       += hessxy  
            thess(jatom,jx,iatom,ix) *= phessxy  
            execute                     read_hess thess(jatom,jx,iatom,ix) 
#
            collective phessyx       += hessyx  
            xhess(iatom,ix,jatom,jx) *= phessyx  
            execute                     read_hess xhess(iatom,ix,jatom,jx) 
           #ENDIF # doit > 0.0   
#
         ENDDO ix 
#
         ENDDO iatom 
#
#        Remove distributed arrays not used anymore. 
#        ------------------------------------------- 
#
         execute sip_barrier 
#
         delete Dyaa 
         delete Dyii 
         delete Dyai 
         delete DIii 
         delete DIaa 
         delete DIai 
         delete DXai 
#
         delete Fya 
         delete Sya 
         delete Uyaa  
         delete Qyai 
         delete dhfya 
         delete whfya 
#
         delete QAyy 
         delete QByy 
         delete QAByy 
#
      ENDDO jx 
#
      ENDDO jatom 
#
#     Print out the final hessian without the nuclear-nuclear contribution. 
#     --------------------------------------------------------------------- 
#
                   ENDSIAL UHF_HESS_SV1_OPT2  
#
# ---------------------------------------------------------------------------
#
