#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL CCSD_RHF_SV1
#
#-------------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index kiter    = 1, cc_iter   
      index kptr1    = 1, 2
#
      aoindex mu     = 1, norb 
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
# 
# Declare static arrays 
# --------------------- 
#
# Arrays used in transformation for AO2 algorithm
# -----------------------------------------------
#
      temp Txixi(mu,i1,lambda,i)
      temp Txxii(mu,nu,i1,i)
      temp Tixxi(i1,nu,lambda,i)
      temp Txipi(mu,i,p,i1)
      temp T1xipi(mu,i,p,i1)
      temp Tpipi(p1,i,p,i1)
      temp T1pipi(p1,i,p,i1)
      temp Tixai(i,mu,a,i1)
      temp Txaii(mu,a,i,i1)
      temp Tiaai(i,a1,a,i1)
      temp Taaii(a,a1,i,i1)
      temp Txaai(mu,a1,a,i)
      temp Taaai(a2,a,a1,i)
      temp Txxai(mu,nu,a,i)
      temp T1xaai(mu,a1,a,i) 
#
      served Viaai(i,a1,a,i1) 
      served Vaaii(a,a1,i,i1)
      served Vpiqj(p1,i,p,i1) 
#
# End Arrays used in transformation for AO2 algorithm
# --------------------------------------------------- 
#
# Declare temporary arrays 
# ------------------------ 
#
      local Lxxxi(mu,nu,lambda,i)
      local Lxxai(mu,nu,a,i) 
      local Lxaai(mu,a1,a,i) 
      temp T1xxxi(mu,nu,lambda,i)  
      temp T1xixi(mu,i,nu,i1)
      temp Txiix(mu,i,i1,nu)
      temp Txpii(mu,p,i,i1)
      temp Tppii(p,p1,i,i1)
      temp Tixpi(i,mu,p,i1)
      temp Tippi(i,p,p1,i1)
#
      temp Taiai(p,i,p1,i1)
      temp T1aiai(p,i,p1,i1)
      temp T2aiai(p,i,p1,i1)
      temp T3aiai(p,i,p1,i1)
      temp Taibj(p,i,q,j)
      temp T1aibj(p,i,q,j)
      temp T2aibj(p,i,q,j)
      temp T3aibj(p,i,q,j)
      temp T4aibj(p,i,q,j)
      temp T5aibj(p,i,q,j)
#
      temp Txxxp(mu,nu,lambda,i)
      temp Txxpp(mu,nu,p1,i)
      temp Txppp(mu,p2,p1,i)
      temp Tpppp(p3,p2,p1,p)
      temp Tixxx(i,mu,nu,sigma) 
      temp Tipxx(i,p,nu,sigma) 
      temp Txiai(lambda,i,a1,i1) 
#
      temp tmp1_aiai(a,i,a1,i1) 
      temp tmp2_aiai(a,i,a1,i1) 
      temp tmp3_aiai(a,i,a1,i1) 
      temp tmp1_aibj(a,i,b,j) 
      temp tmp2_aibj(a,i,b,j) 
#
      temp Taiii(a,i,i1,i2) 
      temp T1aiii(a,i,i1,i2) 
#
      temp  Tiiii(i,i1,i2,i3) 
      temp T1iiii(i,i1,i2,i3) 
#
      temp  Tiiai(i,i1,a,i2) 
      temp T1iiai(i,i1,a,i2) 
#
      temp T1aaai(a,a1,a2,i)  
      temp T2aaai(a,a1,a2,i)  
      temp Taaaa(a,a1,a2,a3)  
      temp T1aaaa(a,a1,a2,a3)  
#
      temp Taabb(a,a1,b,b1)  
      temp T1aabb(a,a1,b,b1)  
#
      temp R1aiai(a,i,a1,i1) 
      temp R2aiai(a,i,a1,i1) 
      temp R3aiai(a,i,a1,i1) 
      temp R4aiai(a,i,a1,i1) 
      temp R1aibj(a,i,b,j) 
      temp R2aibj(a,i,b,j) 
      temp R3aibj(a,i,b,j) 
      temp R4aibj(a,i,b,j) 
#
      temp T1iaai(i,a,a1,i1) 
      temp T2iaai(i,a,a1,i1) 
      temp T1jbbj(j,b,b1,j1) 
      temp T2jbbj(j,b,b1,j1) 
      temp T1iabj(i,a,b,j) 
      temp T2iabj(i,a,b,j) 
      temp Tjjpp(j,j1,p,p1) 
      temp T1jjpp(j,j1,p,p1) 
      temp T2jjpp(j,j1,p,p1) 
      temp  Tiiqq(i,i1,q,q1) 
      temp T1iiqq(i,i1,q,q1) 
      temp T2iiqq(i,i1,q,q1) 
      temp  Tjjai(j,j1,a,i) 
      temp T1jjai(j,j1,a,i) 
      temp T2jjai(j,j1,a,i) 
      temp  Tiibj(i,i1,b,j) 
      temp T1iibj(i,i1,b,j) 
      temp T2iibj(i,i1,b,j) 
      temp  Tjbai(j,b,a,i)  
      temp T1jbai(j,b,a,i)  
      temp T2jbai(j,b,a,i)  
      temp  Taijj(a,i,j,j1) 
      temp T1aijj(a,i,j,j1) 
      temp Tqqip(a,i,b,b1)  
#
# Declare distributed arrays 
# -------------------------- 
#
      served T2new_ab(a,i,b,j)
      served T2old_aa(a,i,a1,i1)
      served T2old_ab(a,i,b,j)
#
      served Tau_ab(a,i,b,j)
      served Taup_aa(a,i,a1,i1)
      served Taup_ab(a,i,b,j)
#
      served Wiibb(i1,i,b,b1)    
      served Wjjaa(j1,j,a,a1)      
#
# Declare served arrays 
# --------------------- 
#
      temp AOINT(mu,nu,lambda,sigma) 
      static pinf(kiter,kptr1)
      temp tpinf(kiter,kptr1)
      scalar one
      scalar two
      scalar ncount1
      scalar ncount2
#
# Arrays needed for AOLADDER contribution
# ---------------------------------------
#
     temp Zab(lambda,i,b,j)
     temp ZZab(lambda,i,sigma,j)
#
     temp Yab(lambda,i,mu,j)
     temp Y1ab(lambda,i,mu,j)
#
     temp TXaiai(a,i,nu,i1)
     temp Taixi(a,i,nu,i1)   
     temp TYaiai(a,i,a1,i1)
     temp TY1aiai(a,i,a1,i1)
     temp TXbjbj(b,j,nu,j1)
     temp Tbjxj(b,j,nu,j1)
     temp TYbjbj(b,j,b1,j1)
     temp TY1bjbj(b,j,b1,j1)
     temp TXaibj(a,i,nu,j)
     temp TZaibj(a,i,nu,j)
     temp Taixj(a,i,nu,j)
     temp TYaibj(a,i,b,j)
#
     served TAO_ab(lambda,i,sigma,j)
     served T2AO_ab(lambda,i,sigma,j)
     served TDaixj(a,i,nu,j)
     local LDaixj(a,i,nu,j) 
#
# local arrays used for data storage
# ---------------------------------- 
#
     local Liiai(i2,i,a,i1) 
     local L1iiai(i,i1,a2,i2) 
     local L2iiai(i2,i1,a2,i)  
     local L3iiai(i,i1,a,i2)  
     local L4iiai(i2,i1,a,i)  
     local Laiai(a,i,a2,i1) 
     local L1aiai(a,i,a1,i2) 
     local L2aiai(a1,i1,a2,i) 
     local L3aiai(a2,i1,a,i2) 
     local L4aiai(a1,i,a2,i1) 
     local Laaai(a,a2,a1,i) 
#
     local Laijj(a,i,j1,j) 
     local Laibj(a,i,b1,j) 
     local L1aibj(a1,i,b,j) 
     local L2aibj(a,i,b,j2) 
     local L3aibj(a,i1,b,j) 
     local L4aibj(a,i,b1,j) 
     local Liibj(i1,i,b,j) 
     local L1iibj(i,i1,b,j) 
     local Lbbai(b,b1,a,i) 
     local Laabj(a,a1,b,j) 
     local LLaiai(a,i,a1,i1) 
     local Lxiai(lambda,i,a1,i1) 
     local LLbjbj(b,j,b1,j1) 
     local Lxjbj(lambda,j,b1,j1) 
     local LLaibj(a,i,b,j) 
     local Lxibj(lambda,i,b,j) 
     local L1xixi(mu,i,nu,i1)  
     local L2xixi(nu,i1,mu,i)  
     local L1xjxj(mu,j,nu,j1)  
     local L2xjxj(nu,j1,mu,j)  
     local L1xixj(mu,i,nu,j)  
     local Laiii(a,i,i2,i1) 
     local L1aiii(a1,i2,i,i1) 
     local Lbjjj(b,j,j2,j1) 
     local L1bjjj(b1,j2,j,j1) 
     local Ljjai(a,i,j,j1) 
#
     local LXbbai(b1,b,a1,i1) 
     local LXaabj(a1,a,b1,j1) 
#
# Distributed two-particle arrays 
# ------------------------------- 
#
      served Vxxxi(mu,nu,lambda,i)
      served Vxixi(mu,i1,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
      served Vxipi(mu,i,p,i1)
      served Vixai(i,mu,a,i1)
      served Vxaii(mu,a,i,i1)
      served Vxaai(mu,a1,a,i)
      served Vxxai(mu,nu,a,i)
#
# Declare scalars 
# --------------- 
#
      scalar etemp
      scalar esum
      scalar esuma
      scalar esumb
      scalar esumab
      scalar ecorraa
      scalar ecorrbb
      scalar ecorrab
      scalar ecorrT
      scalar enew 
      scalar eold 
      scalar ecrit 
      scalar ediff 
      scalar mp2_energy
      scalar restart
#
# Arrays/Scalars used exclusively in DIIS procedure. 
# -------------------------------------------------- 
#
       served D0aibj(a,i,b,j)  
       served D1aibj(a,i,b,j)  
       served D2aibj(a,i,b,j)  
       served D3aibj(a,i,b,j)  
       served D4aibj(a,i,b,j)  
       served D5aibj(a,i,b,j)  
#
       distributed D0ai(a,i)  
       distributed D1ai(a,i)  
       distributed D2ai(a,i)  
       distributed D3ai(a,i)  
       distributed D4ai(a,i)  
       distributed D5ai(a,i)  
#
       distributed e1ai(a,i)  
       distributed e2ai(a,i)  
       distributed e3ai(a,i)  
       distributed e4ai(a,i)  
       distributed e5ai(a,i)  
#
       served e1aibj(a,i,b,j)  
       served e2aibj(a,i,b,j)  
       served e3aibj(a,i,b,j)  
       served e4aibj(a,i,b,j)  
       served e5aibj(a,i,b,j)  
       served e6aibj(a,i,b,j)  
#
       served e5aiai(a,i,b,j) 
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510
#
       scalar b66
       scalar b67
       scalar b68
       scalar b69
       scalar b610
#
       scalar b77
       scalar b78
       scalar b79
       scalar b710
#
       scalar b88
       scalar b89
       scalar b810
#
       scalar b99
       scalar b910
#
       scalar b1010
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510
#
       scalar Tb66
       scalar Tb67
       scalar Tb68
       scalar Tb69
       scalar Tb610
#
       scalar Tb77
       scalar Tb78
       scalar Tb79
       scalar Tb710
#
       scalar Tb88
       scalar Tb89
       scalar Tb810
#
       scalar Tb99
       scalar Tb910
#
       scalar Tb1010
#
       scalar c1 
       scalar c2 
       scalar c3 
       scalar c4 
       scalar c5 
       scalar c6 
       scalar c7 
       scalar c8 
       scalar c9 
       scalar c10  
#
#    ------------------------------------------------------------------------
#
#    Perform the first two stages of the transformation in two N5 steps.
#
     PROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
#
          allocate Lxxxi(mu,nu,lambda,*)
#     
          DO sigma
#
             compute_integrals            aoint(mu,nu,lambda,sigma)
#
             DO i   
#
                 T1xxxi(mu,nu,lambda,i)  = aoint(mu,nu,lambda,sigma)*ca(sigma,i)
                 Lxxxi(mu,nu,lambda,i)  += T1xxxi(mu,nu,lambda,i)
#    
             ENDDO i
#    
          ENDDO sigma

          DO i
             T1xxxi(mu,nu,lambda,i)         = Lxxxi(mu,nu,lambda,i)
             PREPARE Vxxxi(mu,nu,lambda,i)  = T1xxxi(mu,nu,lambda,i)
              
           DO i1
#
              Txxii(mu,nu,i1,i)          = Lxxxi(mu,nu,lambda,i)*ca(lambda,i1)
              PREPARE Vxxii(mu,nu,i1,i) += Txxii(mu,nu,i1,i)
              Txixi(mu,i1,lambda,i)      = Lxxxi(mu,nu,lambda,i)*ca(nu,i1)
              PREPARE Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
              Tixxi(i1,nu,lambda,i)      = Lxxxi(mu,nu,lambda,i)*ca(mu,i1)
              PREPARE Vixxi(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i)
#
           ENDDO i1
           ENDDO i
#    
          deallocate Lxxxi(mu,nu,lambda,*)
#
     ENDPARDO mu, nu, lambda
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i
#
        ALLOCATE Lxxai(mu,nu,*,i)
#
        DO lambda
           REQUEST Vxxxi(mu,nu,lambda,i) i

           DO a
              Txxai(mu,nu,a,i) = Vxxxi(mu,nu,lambda,i)*ca(lambda,a)
              Lxxai(mu,nu,a,i) += Txxai(mu,nu,a,i)
           ENDDO a

        ENDDO lambda
#
        DO a
           PREPARE Vxxai(mu,nu,a,i) = Lxxai(mu,nu,a,i)
        ENDDO a

        DEALLOCATE Lxxai(mu,nu,*,i)
#
     ENDPARDO mu, nu, i
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
     destroy Vxxxi
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.
#
     PROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxixi(mu,i,nu,i1) i1
           REQUEST Vxxii(mu,nu,i,i1) i1
           REQUEST Vixxi(i,mu,nu,i1) i1
#
           DO p
#
              Txipi(mu,i,p,i1)          = Vxixi(mu,i,nu,i1)*ca(nu,p)
              PREPARE Vxipi(mu,i,p,i1) += Txipi(mu,i,p,i1)
#
           ENDDO p
#
           DO a
#
              Txaii(mu,a,i,i1)          = Vxxii(mu,nu,i,i1)*ca(nu,a)
              Tixai(i,mu,a,i1)          = Vixxi(i,mu,nu,i1)*ca(nu,a)
#
              PREPARE Vxaii(mu,a,i,i1) += Txaii(mu,a,i,i1)
              PREPARE Vixai(i,mu,a,i1) += Tixai(i,mu,a,i1)
#
           ENDDO a
#
     ENDPARDO mu, nu, i, i1
#
#    ------------------------------------------------------------------------
#
     PARDO mu, a, i
#
        ALLOCATE Lxaai(mu,*,a,i)

        DO nu
           REQUEST Vxxai(mu,nu,a,i) i
#
           DO a1
#
              T1xaai(mu,a1,a,i) = Vxxai(mu,nu,a,i)*ca(nu,a1)
              Lxaai(mu,a1,a,i) += T1xaai(mu,a1,a,i)
#
           ENDDO a1
        ENDDO nu
#
        DO a1
           PREPARE Vxaai(mu,a1,a,i) = Lxaai(mu,a1,a,i)
        ENDDO a1

        DEALLOCATE Lxaai(mu,*,a,i)
     ENDPARDO mu, a, i
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
     destroy Vxxai
#
     ENDPROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PARDO mu, p, i, i1
#
           REQUEST             Vxipi(mu,i,p,i1) i1
#
           DO p1
#
              Tpipi(p1,i,p,i1)          = Vxipi(mu,i,p,i1)*ca(mu,p1)
              PREPARE Vpiqj(p1,i,p,i1) += Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
     ENDPARDO mu, p, i, i1
#
     PARDO mu, a, i, i1
#
           REQUEST Vxaii(mu,a,i,i1) i1
           REQUEST Vixai(i,mu,a,i1) i1
#
           DO a1
#
              Taaii(a1,a,i,i1)          = Vxaii(mu,a,i,i1)*ca(mu,a1)
              PREPARE Vaaii(a1,a,i,i1) += Taaii(a1,a,i,i1)
#
           ENDDO a1
#
           DO a1
#
              Tiaai(i,a1,a,i1)          = Vixai(i,mu,a,i1)*ca(mu,a1)
              PREPARE Viaai(i,a1,a,i1) += Tiaai(i,a1,a,i1)
#
           ENDDO a1
#
     ENDPARDO mu, a, i, i1
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF
#
#        CALL COMP_INTEGRALS # --> compute integrals and put into served array
         CALL TRAN_TRAN2     # --> performs the first two stages of the
                             #     two-electron integral transformation.
         CALL TRAN_TRAN3     # --> performs the third stage
                             #     two-electron integral transformation.
         CALL TRAN_TRAN4     # --> performs the fourth stage of the
                             #     two-electron integral transformation.
#
     ENDPROC TRAN_UHF
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------ 
#
     PROC IGUESS_UHF  
# 
#    ------------------------------------------------------------------------ 
#
     PARDO a, b, i, j 
#
           REQUEST                     Vpiqj(a,i,b,j) j  
           REQUEST                     Vpiqj(b,j,a,i) j  
           Taibj(a,i,b,j)            = Vpiqj(b,j,a,i)
           Taibj(a,i,b,j)           += Vpiqj(a,i,b,j)
           execute energy_denominator  Taibj 
           Taibj(a,i,b,j)           *= 0.5  
           PREPARE T2old_ab(a,i,b,j) = Taibj(a,i,b,j)  
           PREPARE D0aibj(a,i,b,j)   = Taibj(a,i,b,j)  
#
     ENDPARDO a, b, i, j 
#
#    ------------------------------------------------------------------------ 
# 
     ENDPROC IGUESS_UHF 
# 
#    ------------------------------------------------------------------------ 
#
# ---------------------------------------------------------------------------- 
#
      PROC WminjAB
#     ------------
#
      PARDO a, b, i1, j1 
#
            REQUEST T2old_ab(a,i1,b,j1) j1
#
            DO i
            DO j
#
               REQUEST                      Vpiqj(i1,i,j1,j) j
               T1aibj(a,i,b,j)            = T2old_ab(a,i1,b,j1)*Vpiqj(i1,i,j1,j)
               PREPARE T2new_ab(a,i,b,j) += T1aibj(a,i,b,j)
#
            ENDDO j
            ENDDO i
#
      ENDPARDO a, b, i1, j1
#
      ENDPROC WminjAB
#     --------------- 
# 
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMINJ 
#
           CALL WminjAB 
#
      ENDPROC WMINJ 
# 
# ----------------------------------------------------------------------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# In PROCEDURE T2NEWAB the new amplitudes T2new_ab are computed. Contributions 
# involving large two-particle intermediates are computed in the corresponding  
# procedures where these intermediates(temp) are computed. Thus the 
# intermediate Wminj is stored and its contribution computed here.  
#
# Contributions coming from P_(ij)P_(ab)t^e_i t^a_m <mb||ej> are computed 
# elsewhere. 
#
      PROC T2NEWAB    
#     ------------
#
      PARDO a, i, b, j 
#
               REQUEST          Vpiqj(a,i,b,j) j 
               Taibj(a,i,b,j) = Vpiqj(a,i,b,j)   
               Taibj(a,i,b,j)*= 0.5  
#
               T1aibj(b,j,a,i)            = Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(a,i,b,j) += Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(b,j,a,i) += T1aibj(b,j,a,i)  
#
      ENDPARDO a, i, b, j 
#
      ENDPROC T2NEWAB    
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
#    ------------------------------------------------------------------------ 
#
     PROC AOLADDER  
#
#    ------------------------------------------------------------------------ 
#
#    Form Half back transformed cluster arrays  
#    -----------------------------------------
#
#    AB spin combination
#     -------------------
#
     PARDO b, a, j, i
#
           REQUEST T2old_ab(a,i,b,j) a
#
           DO mu
#
              Taixj(a,i,mu,j) = T2old_ab(a,i,b,j)*ca(mu,b)
#
              DO nu
#
                 Txixi(nu,i,mu,j)           = Taixj(a,i,mu,j)*ca(nu,a)
                 PREPARE TAO_ab(nu,i,mu,j) += Txixi(nu,i,mu,j)
#
              ENDDO nu
#
           ENDDO mu
#
      ENDPARDO b, a, j, i
#
     execute server_barrier   
#
#    Contract AOINT with half back transformed Amplitudes 
#    ----------------------------------------------------    
#
     PARDO mu, nu, lambda, sigma
        WHERE mu < nu 
#
           compute_integrals aoint(lambda,mu,sigma,nu)
#
           DO i
           DO j
#
              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(lambda,mu,sigma,nu)*TAO_ab(lambda,i,sigma,j)
              Y1ab(nu,j,mu,i)             = Yab(mu,i,nu,j)
#
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)
              PREPARE T2AO_ab(nu,j,mu,i) += Y1ab(nu,j,mu,i)
#
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     PARDO mu, nu, lambda, sigma
        WHERE mu == nu 
#
           compute_integrals aoint(mu,lambda,nu,sigma)
#
           DO i
           DO j
#
              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(mu,lambda,nu,sigma)*TAO_ab(lambda,i,sigma,j)
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)
#
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     execute server_barrier  
#
#    Perform final transformation
#    ----------------------------
#
        PARDO nu, i, j
#
              allocate LDaixj(*,i,nu,j)
#
              DO mu
#
                 REQUEST T2AO_ab(mu,i,nu,j) j
#
                 DO a
                    Taixj(a,i,nu,j)   = T2AO_ab(mu,i,nu,j)*ca(mu,a)
                    LDaixj(a,i,nu,j) += Taixj(a,i,nu,j)
                 ENDDO a
#
              ENDDO mu
#
              DO a
                 PREPARE TDaixj(a,i,nu,j) = LDaixj(a,i,nu,j)
              ENDDO a
#
              deallocate LDaixj(*,i,nu,j)
#
        ENDPARDO nu, i, j
        execute server_barrier
#
        PARDO a, i, j, nu
#
              REQUEST TDaixj(a,i,nu,j) a
#
              DO b
#
                 Taibj(a,i,b,j)             = TDaixj(a,i,nu,j)*ca(nu,b)
                 PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
#
              ENDDO b
#
        ENDPARDO a, i, j, nu
#
#    ------------------------------------------------------------------------ 
#
     ENDPROC AOLADDER  
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
# In the procedures WMEBJAA, WMEBJBB, WMEBJAB, and WMEBJBA these  
# intermediates are formed as temporary arrarys. The contribution to the 
# outout arrays is computed directly from these temporary arrays so 
# that the array is never stored.   
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMEBJAA 
#     ------------
#
      PARDO a, a1, i, i1  
#
               REQUEST              Viaai(i1,a1,a,i) i  
               REQUEST              Vaaii(a,a1,i1,i) i  

               TYaiai(a1,i1,a,i)          = 0.0  
#
               Taiai(a1,i1,a,i)           = Vaaii(a,a1,i1,i)
               TYaiai(a1,i1,a,i)         -= Taiai(a1,i1,a,i)
               Taiai(a1,i1,a,i)           = Viaai(i1,a1,a,i)
               TYaiai(a1,i1,a,i)         += Taiai(a1,i1,a,i)
               PREPARE TAUP_aa(a1,i1,a,i) = TYaiai(a1,i1,a,i) 
#
      ENDPARDO a, a1, i, i1  
      execute server_barrier 
#
# Contributions to T2new_ab 
# ------------------------- 
#
      PARDO a, i, a1, i1 
#
            REQUEST TAUP_aa(a,i,a1,i1)  i 
#
            DO j  
            DO b
#
               REQUEST                      T2old_ab(a1,i1,b,j) j  
               R1aibj(a,i,b,j)            = TAUP_aa(a,i,a1,i1)*T2old_ab(a1,i1,b,j) 
               Taibj(b,j,a,i)             = R1aibj(a,i,b,j) 
               PREPARE T2new_ab(a,i,b,j) += R1aibj(a,i,b,j)
               PREPARE T2new_ab(b,j,a,i) += Taibj(b,j,a,i)
#
            ENDDO b  
            ENDDO j  
#
      ENDPARDO a, i, a1, i1 
#
      ENDPROC WMEBJAA 
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMEBJAB 
#     ------------
#
# Contribution to T2new_ab 
# ------------------------ 
#
      PARDO i1, a1, a, i
#
            REQUEST T2old_aa(a1,i1,a,i) i 
            tpppp(a1,i1,i,a) = T2old_aa(a1,i1,a,i) 
#
            DO j 
            DO b 
#
               REQUEST                        Viaai(i,a,b,j) j  
               R1aibj(a1,i1,b,j)            = tpppp(a1,i1,i,a)*Viaai(i,a,b,j)  
               Taibj(b,j,a1,i1)             = R1aibj(a1,i1,b,j) 
               PREPARE T2new_ab(a1,i1,b,j) += R1aibj(a1,i1,b,j) 
               PREPARE T2new_ab(b,j,a1,i1) += Taibj(b,j,a1,i1) 
#
            ENDDO b 
            ENDDO j 
#
      ENDPARDO i1, a1, a, i
      execute server_barrier 
#
      ENDPROC WMEBJAB 
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# -------------------------------------------------------------------------------  
#
# Compute contributions from 'Wmjbe'. 
#
      PROC WMJBEab
#     -------------
#
#  Calculate contribution to the amplitudes
#  ----------------------------------------
#
      PARDO a, j, i1, b1
#
            REQUEST T2old_ab(a,i1,b1,j) j
#
            DO i
            DO b
#
               REQUEST                      Vaaii(b,b1,i1,i) i
#
               Taibj(a,i,b,j)             = T2old_ab(a,i1,b1,j)*Vaaii(b,b1,i1,i)
               Taibj(a,i,b,j)            *= -1.0  
#
               T2aibj(b,j,a,i)            = Taibj(a,i,b,j) 
               PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
               PREPARE T2new_ab(b,j,a,i) += T2aibj(b,j,a,i)
#
            ENDDO b
            ENDDO i
#
      ENDPARDO a, j, i1, b1
#
      ENDPROC WMJBEab
#     ---------------
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
      PROC WMEBJ 
# 
           CALL WMEBJAA
           CALL WMEBJAB
           CALL WMJBEab
#
      ENDPROC WMEBJ 
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
#    ------------------------------------------------------------------------ 
#
     PROC ENERGY_NEW 
# 
#    ------------------------------------------------------------------------ 
#
     one = 1.0
     two = 2.0
#
     ecorrab = 0.0 
     esumab  = 0.0 
     execute sip_barrier 
     PARDO a, b, i, j 
#
           REQUEST Vpiqj(a,i,b,j) j  
           REQUEST Vpiqj(a,j,b,i) j  
#
           REQUEST T2old_ab(a,i,b,j) j  
#
           T1aibj(a,i,b,j) = Vpiqj(a,i,b,j)  
           T2aibj(a,i,b,j) = Vpiqj(a,j,b,i)  
           T1aibj(a,i,b,j)*= 2.0  
           T1aibj(a,i,b,j)-= T2aibj(a,i,b,j)  
#
           etemp = T2old_ab(a,i,b,j)*T1aibj(a,i,b,j) 
           esumab += etemp 
#
     ENDPARDO a, b, i, j 

     execute sip_barrier 
#
     collective ecorrab += esumab
     execute print_scalar ecorrab 
#
    #ecorrT  = ecorraa + ecorrbb
     ecorrT = ecorrab 
     execute print_scalar ecorrT  
     if kiter > 0
            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == one
               tpinf(kiter,kptr1) = ecorrab
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == two
               etemp = ecorrab
               etemp+= scfeneg
               tpinf(kiter,kptr1) = etemp
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

         etemp = 32
         execute print_rel_info etemp pinf
      endif
# 
#    ------------------------------------------------------------------------ 
# 
     ENDPROC ENERGY_NEW 
# 
#    ------------------------------------------------------------------------ 
# 
     PROC T2NEW_ZERO
#    --------------- 
#
#     Zero out new 2-particle amplitude arrays 
#     ---------------------------------------- 
#
          PARDO a, b, i, j 
                Taibj(a,i,b,j) = 0.0
                PREPARE T2new_ab(a,i,b,j) = Taibj(a,i,b,j) 
          ENDPARDO a, b, i, j 
#
#    Zero-out intermediate arrays
#    ---------------------------------------------
#
          PARDO mu, nu, i, j
                Txixi(mu,i,nu,j)           = 0.0
                PREPARE TAO_ab(mu,i,nu,j)  = Txixi(mu,i,nu,j)
                PREPARE T2AO_ab(mu,i,nu,j) = Txixi(mu,i,nu,j)
          ENDPARDO mu, nu, i, j
#
     ENDPROC T2NEW_ZERO
# 
#    ------------------------------------------------------------------------ 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC UPDATET2 
#     ------------- 
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab(b,j,a,i) b 
            REQUEST                    T2new_ab(b,j,a,i) b 
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            T1aibj(a,i,b,j)          = T2old_ab(b,j,a,i)
#
            REQUEST                    T2old_ab(a,i,b,j) b 
            REQUEST                    T2new_ab(a,i,b,j) b 
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            T1aibj(a,i,b,j)         += T2old_ab(a,i,b,j)

            execute energy_denominator Taibj
            T1aibj(a,i,b,j) -= Taibj(a,i,b,j)
            T1aibj(a,i,b,j) *= -0.5
#
            if kiter == 1
               PREPARE e1aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 2
               PREPARE e2aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 3
               PREPARE e3aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 4
               PREPARE e4aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter >= 5
               PREPARE e5aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
      ENDPARDO b, a, j, i
      execute server_barrier 
#
      PARDO b, a, j, i
#
            REQUEST                    T2new_ab(a,i,b,j) a
            REQUEST                    T2new_ab(b,j,a,i) a
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            Taibj(a,i,b,j)          *= 0.5  
            execute energy_denominator Taibj
            PREPARE T2old_ab(a,i,b,j)    = Taibj(a,i,b,j)
#
      ENDPARDO b, a, j, i
#
      ENDPROC UPDATET2 
#     ----------------  
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC MOVET2
#     ------------
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab(a,i,b,j) a 
            Taibj(a,i,b,j)           = T2old_ab(a,i,b,j)
#
            if kiter == 1
               PREPARE d1aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 2
               PREPARE d2aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 3
               PREPARE d3aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 4
               PREPARE d4aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter >= 5
               PREPARE d4aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
      ENDPARDO b, a, j, i
#
      ENDPROC MOVET2
#     ----------------
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR  
#    ----------------- 
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS 
#    expansion are zero'd out. 
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR  
#    -------------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS   
#    --------------- 
#
#    Put the matrix elements of B into the sip 'B' matrix. 
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS   
#    ------------------ 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
#             b1x x=1,2
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb22 += b22 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     execute server_barrier 
     execute print_scalar c1 
     execute print_scalar c2 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS1  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
#             b1x x=1,3
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb33 += b33 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     execute server_barrier 
     execute print_scalar c1 
     execute print_scalar c2 
     execute print_scalar c3 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS2  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-3 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e4aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e4aibj(a,j,b,i) 
           t4aibj(a,i,b,j) = e4aibj(a,i,b,j) 
           t4aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
              etemp = e1aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
              etemp = e2aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
              etemp = e3aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b44  += etemp
#
#             b1x x=1,4
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
              etemp = t1aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
              etemp = t2aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
              etemp = t3aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = t4aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b44  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb14 += b14 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb24 += b24 
     collective Tb33 += b33 
     collective Tb34 += b34 
     collective Tb44 += b44 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     c4 = Tb44 
     execute print_scalar c1 
     execute print_scalar c2 
     execute print_scalar c3 
     execute print_scalar c4 
     execute server_barrier 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D3aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c4
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS3  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 5 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e5aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-4 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-3 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e4aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e5aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e4aibj(a,j,b,i) 
           t4aibj(a,i,b,j) = e4aibj(a,i,b,j) 
           t4aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e5aibj(a,j,b,i) 
           t5aibj(a,i,b,j) = e5aibj(a,i,b,j) 
           t5aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
              etemp = e1aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b14  += etemp
#
              etemp = e1aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
              etemp = e2aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b24  += etemp
#
              etemp = e2aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
              etemp = e3aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b34  += etemp
#
              etemp = e3aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b44  += etemp
#
              etemp = e4aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b55  += etemp
#
#
#             b1x x=1,5
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
              etemp = t1aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b14  += etemp
#
              etemp = t1aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
              etemp = t2aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b24  += etemp
#
              etemp = t2aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
              etemp = t3aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b34  += etemp
#
              etemp = t3aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = t4aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b44  += etemp
#
              etemp = t4aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = t5aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b55  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb14 += b14 
     collective Tb15 += b15 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb24 += b24 
     collective Tb25 += b25 
     collective Tb33 += b33 
     collective Tb34 += b34 
     collective Tb35 += b35 
     collective Tb44 += b44 
     collective Tb45 += b45 
     collective Tb55 += b55 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     c4 = Tb44 
     c5 = Tb55 
     execute print_scalar c1 
     execute print_scalar c2 
     execute print_scalar c3 
     execute print_scalar c4 
     execute print_scalar c5 
     execute server_barrier 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 5 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-5 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D4aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e5aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c4
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e5aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c5
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS4  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
     execute server_barrier
     execute sip_barrier
#
#    0 --> 1
#    ---------------------------------------------------
#
     execute array_copy d1aibj d0aibj
     execute server_barrier
#
#    2 --> 1
#    ---------------------------------------------------
#
     execute array_copy e2aibj e1aibj
     execute array_copy d2aibj d1aibj
     execute server_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     execute array_copy e3aibj e2aibj
     execute array_copy d3aibj d2aibj
     execute server_barrier
#
#
#    4 --> 3
#    ---------------------------------------------------
#
     execute array_copy e4aibj e3aibj
     execute array_copy d4aibj d3aibj
     execute server_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     execute array_copy e5aibj e4aibj
#
     execute server_barrier
#
     ENDPROC MOVE4
#    -------------
#
#    proc do_checkpoint

#    execute checkpoint t2old_aa
#    execute checkpoint t2old_ab
#    execute checkpoint t1a_old
#    execute checkpoint E1aibj
#    execute checkpoint E2aibj
#    execute checkpoint E3aibj
#    execute checkpoint E4aibj
#    execute checkpoint E5aibj
#    execute checkpoint E1ai
#    execute checkpoint E2ai
#    execute checkpoint E3ai
#    execute checkpoint E4ai
#    execute checkpoint E5ai
#    execute checkpoint D0aibj
#    execute checkpoint D1aibj
#    execute checkpoint D2aibj
#    execute checkpoint D3aibj
#    execute checkpoint D4aibj
#    execute checkpoint D0ai
#    execute checkpoint D1ai
#    execute checkpoint D2ai
#    execute checkpoint D3ai
#    execute checkpoint D4ai
#    execute commit_checkpoint

#    execute get_restart_status restart
#    if restart == 1.0
#       CALL READ_2EL   # Restore data saved as BLOCKDATA 
#    endif

#    endproc do_checkpoint

# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
# 
# BEGIN MAIN PROGRAM 
# ------------------ 
#
      ecrit = cc_conv  
#
# Read transformed integrals from lists 
# ------------------------------------- 
#
     #CALL READ_2EL 
#
# Perform two-electron integral transformation 
# -------------------------------------------- 
#
      CALL TRAN_UHF 
#
      EXECUTE SERVER_BARRIER  
#
# Get initial second-order guess 
# ------------------------------ 
      CALL IGUESS_UHF
      EXECUTE SIP_BARRIER  
      EXECUTE SERVER_BARRIER  
#
      PARDO a, i, b, j 
            REQUEST                     T2old_ab(a,i,b,j) a 
            REQUEST                     T2old_ab(a,j,b,i) a 
            taiai(a,i,b,j)            = T2old_ab(a,i,b,j) 
            t1aiai(a,i,b,j)           = T2old_ab(a,j,b,i) 
            taiai(a,i,b,j)           -= t1aiai(a,i,b,j) 
            PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j) 
      ENDPARDO a, i, b, j 
#
      EXECUTE SERVER_BARRIER  
#
# Calculate the second-order energy 
# --------------------------------- 
      CALL ENERGY_NEW 
#
# Start iterations
# ---------------- 
      DO KITER 

      EXECUTE SERVER_BARRIER  
#
      PARDO a, i, b, j 
            REQUEST                     T2old_ab(a,i,b,j) a 
            REQUEST                     T2old_ab(a,j,b,i) a 
            taiai(a,i,b,j)            = T2old_ab(a,i,b,j) 
            t1aiai(a,i,b,j)           = T2old_ab(a,j,b,i) 
            taiai(a,i,b,j)           -= t1aiai(a,i,b,j) 
            PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j) 
      ENDPARDO a, i, b, j 
#
      EXECUTE SERVER_BARRIER  
#
#        Zero-out the new two-particle amplitude arrays
#        ---------------------------------------------- 
#
         CALL T2NEW_ZERO
#
#        Form one-particle intermediates 
#        ------------------------------- 
         EXECUTE SERVER_BARRIER  
# 
#        Calculate new two-particle amplitudes 
#        ------------------------------------- 
#
         CALL T2NEWAB  
#
         CALL WMINJ 
         CALL AOLADDER 
         CALL WMEBJ 
#
#        Wait for all to finish 
#        ---------------------- 
         EXECUTE SERVER_BARRIER   
#
         CALL UPDATET2 
#
         EXECUTE SERVER_BARRIER   
         CALL ENERGY_NEW 
         EXECUTE SERVER_BARRIER   
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
         EXECUTE SERVER_BARRIER  
#
         CALL MOVET2
#
         EXECUTE SERVER_BARRIER  
         PARDO a, i, b, j 
               REQUEST                     T2old_ab(a,i,b,j) a 
               REQUEST                     T2old_ab(a,j,b,i) a 
               taiai(a,i,b,j)            = T2old_ab(a,i,b,j) 
               t1aiai(a,i,b,j)           = T2old_ab(a,j,b,i) 
               taiai(a,i,b,j)           -= t1aiai(a,i,b,j) 
               PREPARE T2old_aa(a,i,b,j) = taiai(a,i,b,j) 
         ENDPARDO a, i, b, j 
         EXECUTE SERVER_BARRIER  
#
#        Check on convergence 
#        -------------------- 
#
         IF ecorrT < eold 
            ediff = eold - ecorrT 
            IF ediff < ecrit 
               exit # kiter 
            ENDIF
         ENDIF   
#
         IF ecorrT > eold 
            ediff = ecorrT - eold  
            IF ediff < ecrit 
               exit # kiter 
            ENDIF
         ENDIF   
#
#        Reset eold --> enew 
#        ------------------- 
#
         eold = ecorrT 

         #if kiter >= 5 
         #   call do_checkpoint
         #endif
#
      ENDDO KITER 
#
      execute sip_barrier 
      totenerg  = ecorrT  
      totenerg += scfeneg  
      execute print_scalar totenerg  
      etemp = 33
      execute print_rel_info etemp pinf 
#
# Write amplitudes to file
# ------------------------
#
######CALL WRITE_2EL   
#
      execute blocks_to_list                T2old_ab
      execute write_blocks_to_list
      execute sip_barrier
#
                           ENDSIAL CCSD_RHF_SV1    
#
# EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE 
#
#
