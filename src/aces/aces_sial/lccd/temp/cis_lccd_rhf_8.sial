#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL CCSD_RHF_SV1
#
#-------------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index kiter    = 1, cc_iter   
      index kptr0    = 1, 1
      index kptr1    = 1, 2
      index kstate   = 1, 12
      index jstate   = 1, 12
#
      aoindex mu     = 1, norb 
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
# 
# Declare static arrays 
# --------------------- 
#
# Arrays used in transformation for AO2 algorithm
# -----------------------------------------------
#
      temp Txixi(mu,i1,lambda,i)
      temp Txxii(mu,nu,i1,i)
      temp Tixxi(i1,nu,lambda,i)
      temp Txipi(mu,i,p,i1)
      temp T1xipi(mu,i,p,i1)
      temp Tpipi(p1,i,p,i1)
      temp T1pipi(p1,i,p,i1)
      temp Tixai(i,mu,a,i1)
      temp Txaii(mu,a,i,i1)
      temp Tiaai(i,a1,a,i1)
      temp Taaii(a,a1,i,i1)
      temp Txaai(mu,a1,a,i)
      temp Taaai(a2,a,a1,i)
      temp Txxai(mu,nu,a,i)
      temp T1xaai(mu,a1,a,i) 
#
      served Viaai(i,a1,a,i1) 
      served Vaaii(a,a1,i,i1)
      served Vaaai(a,a1,a2,i1)
      served Vpiqj(p1,i,p,i1) 
      served VSpiqj(p1,i,p,i1) 
      served VSaaai(a,a1,a2,i1)
#
# End Arrays used in transformation for AO2 algorithm
# --------------------------------------------------- 
#
# Declare temporary arrays 
# ------------------------ 
#
      local Lxxxi(mu,nu,lambda,i)
      local Lxxai(mu,nu,a,i) 
      local Lxaai(mu,a1,a,i) 
      temp T1xxxi(mu,nu,lambda,i)  
      temp T1xixi(mu,i,nu,i1)
      temp Txiix(mu,i,i1,nu)
      temp Txpii(mu,p,i,i1)
      temp Tppii(p,p1,i,i1)
      temp Tixpi(i,mu,p,i1)
      temp Tippi(i,p,p1,i1)
#
      temp Taiai(p,i,p1,i1)
      temp T1aiai(p,i,p1,i1)
      temp T2aiai(p,i,p1,i1)
      temp T3aiai(p,i,p1,i1)
      temp Taibj(p,i,q,j)
      temp T1aibj(p,i,q,j)
      temp T2aibj(p,i,q,j)
      temp T3aibj(p,i,q,j)
      temp T4aibj(p,i,q,j)
      temp T5aibj(p,i,q,j)
#
      temp Txxxp(mu,nu,lambda,i)
      temp Txxpp(mu,nu,p1,i)
      temp Txppp(mu,p2,p1,i)
      temp Tpppp(p3,p2,p1,p)
      temp Tixxx(i,mu,nu,sigma) 
      temp Tipxx(i,p,nu,sigma) 
      temp Txiai(lambda,i,a1,i1) 
#
      temp tmp1_aiai(a,i,a1,i1) 
      temp tmp2_aiai(a,i,a1,i1) 
      temp tmp3_aiai(a,i,a1,i1) 
      temp tmp1_aibj(a,i,b,j) 
      temp tmp2_aibj(a,i,b,j) 
#
      temp Taiii(a,i,i1,i2) 
      temp T1aiii(a,i,i1,i2) 
#
      temp  Tiiii(i,i1,i2,i3) 
      temp T1iiii(i,i1,i2,i3) 
#
      temp  Tiiai(i,i1,a,i2) 
      temp T1iiai(i,i1,a,i2) 
#
      temp T1aaai(a,a1,a2,i)  
      temp T2aaai(a,a1,a2,i)  
      temp Taaaa(a,a1,a2,a3)  
      temp T1aaaa(a,a1,a2,a3)  
#
      temp Taabb(a,a1,b,b1)  
      temp T1aabb(a,a1,b,b1)  
#
      temp R1aiai(a,i,a1,i1) 
      temp R2aiai(a,i,a1,i1) 
      temp R3aiai(a,i,a1,i1) 
      temp R4aiai(a,i,a1,i1) 
      temp R1aibj(a,i,b,j) 
      temp R2aibj(a,i,b,j) 
      temp R3aibj(a,i,b,j) 
      temp R4aibj(a,i,b,j) 
#
      temp T1iaai(i,a,a1,i1) 
      temp T2iaai(i,a,a1,i1) 
      temp T1jbbj(j,b,b1,j1) 
      temp T2jbbj(j,b,b1,j1) 
      temp T1iabj(i,a,b,j) 
      temp T2iabj(i,a,b,j) 
      temp Tjjpp(j,j1,p,p1) 
      temp T1jjpp(j,j1,p,p1) 
      temp T2jjpp(j,j1,p,p1) 
      temp  Tiiqq(i,i1,q,q1) 
      temp T1iiqq(i,i1,q,q1) 
      temp T2iiqq(i,i1,q,q1) 
      temp  Tjjai(j,j1,a,i) 
      temp T1jjai(j,j1,a,i) 
      temp T2jjai(j,j1,a,i) 
      temp  Tiibj(i,i1,b,j) 
      temp T1iibj(i,i1,b,j) 
      temp T2iibj(i,i1,b,j) 
      temp  Tjbai(j,b,a,i)  
      temp T1jbai(j,b,a,i)  
      temp T2jbai(j,b,a,i)  
      temp  Taijj(a,i,j,j1) 
      temp T1aijj(a,i,j,j1) 
      temp Tqqip(a,i,b,b1)  
#
      temp Tpp(p,q)
      temp T1pp(p,q)
      temp T2pp(p,q)
#
# Declare distributed arrays 
# -------------------------- 
#
      served T2new_ab(a,i,b,j)
      served T2old_ab(a,i,b,j)
#
      served T2old_aa(a,i,b,j)
      served cai(a,i)
      served Ctau(a,i,b,j)
      served CT_ab(a,i,b,j)
      served CT_aa(a,i,b,j)
      served Fii(i,j)
      served Faa(a,b)
      served Fai(a,i)
      distributed LSFai(a,i)
#
      served Tau_ab(a,i,b,j)
      served Taup_aa(a,i,a1,i1)
      served Taup_ab(a,i,b,j)
#
      served Wiibb(i1,i,b,b1)    
      served Wjjaa(j1,j,a,a1)      
#
# Declare served arrays 
# --------------------- 
#
      temp AOINT(mu,nu,lambda,sigma) 
#
# Arrays needed for AOLADDER contribution
# ---------------------------------------
#
     temp Zab(lambda,i,b,j)
     temp ZZab(lambda,i,sigma,j)
#
     temp Yab(lambda,i,mu,j)
     temp Y1ab(lambda,i,mu,j)
#
     temp TXaiai(a,i,nu,i1)
     temp Taixi(a,i,nu,i1)   
     temp TYaiai(a,i,a1,i1)
     temp TY1aiai(a,i,a1,i1)
     temp TXbjbj(b,j,nu,j1)
     temp Tbjxj(b,j,nu,j1)
     temp TYbjbj(b,j,b1,j1)
     temp TY1bjbj(b,j,b1,j1)
     temp TXaibj(a,i,nu,j)
     temp TZaibj(a,i,nu,j)
     temp Taixj(a,i,nu,j)
     temp T1aixj(a,i,nu,j)
     temp TYaibj(a,i,b,j)
#
     served TAO_ab(lambda,i,sigma,j)
     served T2AO_ab(lambda,i,sigma,j)
     served TDaixj(a,i,nu,j)
     local LDaixj(a,i,nu,j) 
#
# local arrays used for data storage
# ---------------------------------- 
#
     local Liiai(i2,i,a,i1) 
     local L1iiai(i,i1,a2,i2) 
     local L2iiai(i2,i1,a2,i)  
     local L3iiai(i,i1,a,i2)  
     local L4iiai(i2,i1,a,i)  
     local Laiai(a,i,a2,i1) 
     local L1aiai(a,i,a1,i2) 
     local L2aiai(a1,i1,a2,i) 
     local L3aiai(a2,i1,a,i2) 
     local L4aiai(a1,i,a2,i1) 
     local Laaai(a,a2,a1,i) 
#
     local Laijj(a,i,j1,j) 
     local Laibj(a,i,b1,j) 
     local L1aibj(a1,i,b,j) 
     local L2aibj(a,i,b,j2) 
     local L3aibj(a,i1,b,j) 
     local L4aibj(a,i,b1,j) 
     local Liibj(i1,i,b,j) 
     local L1iibj(i,i1,b,j) 
     local Lbbai(b,b1,a,i) 
     local Laabj(a,a1,b,j) 
     local LLaiai(a,i,a1,i1) 
     local Lxiai(lambda,i,a1,i1) 
     local LLbjbj(b,j,b1,j1) 
     local Lxjbj(lambda,j,b1,j1) 
     local LLaibj(a,i,b,j) 
     local Lxibj(lambda,i,b,j) 
     local L1xixi(mu,i,nu,i1)  
     local L2xixi(nu,i1,mu,i)  
     local L1xjxj(mu,j,nu,j1)  
     local L2xjxj(nu,j1,mu,j)  
     local L1xixj(mu,i,nu,j)  
     local Laiii(a,i,i2,i1) 
     local L1aiii(a1,i2,i,i1) 
     local Lbjjj(b,j,j2,j1) 
     local L1bjjj(b1,j2,j,j1) 
     local Ljjai(a,i,j,j1) 
#
     local LXbbai(b1,b,a1,i1) 
     local LXaabj(a1,a,b1,j1) 
#
# Distributed two-particle arrays 
# ------------------------------- 
#
      served Vxixi(mu,i1,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
      served Vxxai(mu,nu,a,i)
      served Vxipi(mu,i,p,i1)
      served Vixai(i,mu,a,i1)
      served Vxaii(mu,a,i,i1)
      served Vxaai(mu,a1,a,i)
#
# Declare scalars 
# --------------- 
#
      scalar etemp
      scalar etemp1
      scalar exponent  
      scalar esum
      scalar esuma
      scalar esumb
      scalar esumab
      scalar ecorraa
      scalar ecorrbb
      scalar ecorrab
      scalar ecorrT
      scalar enew 
      scalar eold 
      scalar ecrit 
      scalar ediff 
      scalar mp2_energy
      scalar restart
      scalar esum2
      scalar esum3
      scalar ecorr2
      scalar edoubles
      scalar etriples
      scalar ecisd
      scalar ecisdev
      scalar toev
      scalar fev
      scalar iroot
      scalar cismp2flag
#
# needed for formatted printing
#
      static pinf(kiter,kptr1)
      temp tpinf(kiter,kptr1)
      scalar one
      scalar two
      scalar ncount1
      scalar ncount2
#
# Arrays/Scalars used exclusively in DIIS procedure. 
# -------------------------------------------------- 
#
       served D0aibj(a,i,b,j)  
       served D1aibj(a,i,b,j)  
       served D2aibj(a,i,b,j)  
       served D3aibj(a,i,b,j)  
       served D4aibj(a,i,b,j)  
       served D5aibj(a,i,b,j)  
#
       distributed D0ai(a,i)  
       distributed D1ai(a,i)  
       distributed D2ai(a,i)  
       distributed D3ai(a,i)  
       distributed D4ai(a,i)  
       distributed D5ai(a,i)  
#
       distributed e1ai(a,i)  
       distributed e2ai(a,i)  
       distributed e3ai(a,i)  
       distributed e4ai(a,i)  
       distributed e5ai(a,i)  
#
       served e1aibj(a,i,b,j)  
       served e2aibj(a,i,b,j)  
       served e3aibj(a,i,b,j)  
       served e4aibj(a,i,b,j)  
       served e5aibj(a,i,b,j)  
       served e6aibj(a,i,b,j)  
#
       served e5aiai(a,i,b,j) 
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510
#
       scalar b66
       scalar b67
       scalar b68
       scalar b69
       scalar b610
#
       scalar b77
       scalar b78
       scalar b79
       scalar b710
#
       scalar b88
       scalar b89
       scalar b810
#
       scalar b99
       scalar b910
#
       scalar b1010
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510
#
       scalar Tb66
       scalar Tb67
       scalar Tb68
       scalar Tb69
       scalar Tb610
#
       scalar Tb77
       scalar Tb78
       scalar Tb79
       scalar Tb710
#
       scalar Tb88
       scalar Tb89
       scalar Tb810
#
       scalar Tb99
       scalar Tb910
#
       scalar Tb1010
#
       scalar c1 
       scalar c2 
       scalar c3 
       scalar c4 
       scalar c5 
       scalar c6 
       scalar c7 
       scalar c8 
       scalar c9 
       scalar c10  
#
# CIS vectors
# -----------
#
      distributed VSTART1A1(a,i)
      distributed VSTART1A2(a,i)
      distributed VSTART1A3(a,i)
      distributed VSTART1A4(a,i)
      distributed VSTART1A5(a,i)
      distributed VSTART1A6(a,i)
      distributed VSTART1A7(a,i)
      distributed VSTART1A8(a,i)
      distributed VSTART1A9(a,i)
      distributed VSTART1A10(a,i)
      distributed VSTART1A11(a,i)
      distributed VSTART1A12(a,i)
#
      distributed VSTART1B1(b,j)
      distributed VSTART1B2(b,j)
      distributed VSTART1B3(b,j)
      distributed VSTART1B4(b,j)
      distributed VSTART1B5(b,j)
      distributed VSTART1B6(b,j)
      distributed VSTART1B7(b,j)
      distributed VSTART1B8(b,j)
      distributed VSTART1B9(b,j)
      distributed VSTART1B10(b,j)
      distributed VSTART1B11(b,j)
      distributed VSTART1B12(b,j)
#
      static cpinf(kstate,kptr1)
      temp ctpinf(kstate,kptr1)
      distributed omegacis(kstate,kptr0)
      temp tomegacis(kstate,kptr0)
      temp t1omegacis(kstate,kptr0)
      scalar eomegacis
      scalar shift
      scalar rank
      scalar maxstate
      scalar oldcorrT
#
#    ------------------------------------------------------------------------
     PROC read_data
#
      create VSTART1A1
      create VSTART1A2
      create VSTART1A3
      create VSTART1A4
      create VSTART1A5
      create VSTART1A6
      create VSTART1A7
      create VSTART1A8
      create VSTART1A9
      create VSTART1A10
      create VSTART1A11
      create VSTART1A12
      create VSTART1B1
      create VSTART1B2
      create VSTART1B3
      create VSTART1B4
      create VSTART1B5
      create VSTART1B6
      create VSTART1B7
      create VSTART1B8
      create VSTART1B9
      create VSTART1B10
      create VSTART1B11
      create VSTART1B12
      create omegacis
      execute server_barrier

      execute list_to_blocks T2old_ab
      execute list_to_blocks VSTART1A1
      execute list_to_blocks VSTART1B1
      execute list_to_blocks VSTART1A2
      execute list_to_blocks VSTART1B2
      execute list_to_blocks VSTART1A3
      execute list_to_blocks VSTART1B3
      execute list_to_blocks VSTART1A4
      execute list_to_blocks VSTART1B4
      execute list_to_blocks VSTART1A5
      execute list_to_blocks VSTART1B5
      execute list_to_blocks VSTART1A6
      execute list_to_blocks VSTART1B6
      execute list_to_blocks VSTART1A7
      execute list_to_blocks VSTART1B7
      execute list_to_blocks VSTART1A8
      execute list_to_blocks VSTART1B8
      execute list_to_blocks VSTART1A9
      execute list_to_blocks VSTART1B9
      execute list_to_blocks VSTART1A10
      execute list_to_blocks VSTART1B10
      execute list_to_blocks VSTART1A11
      execute list_to_blocks VSTART1B11
      execute list_to_blocks VSTART1A12
      execute list_to_blocks VSTART1B12
      execute list_to_blocks omegacis
      execute server_barrier
      execute read_list_to_blocks
      execute server_barrier
#
    ENDPROC read_data
     proc write_data
      execute server_barrier
      execute blocks_to_list T2old_ab
      execute blocks_to_list VSTART1A1
      execute blocks_to_list VSTART1B1
      execute blocks_to_list VSTART1A2
      execute blocks_to_list VSTART1B2
      execute blocks_to_list VSTART1A3
      execute blocks_to_list VSTART1B3
      execute blocks_to_list VSTART1A4
      execute blocks_to_list VSTART1B4
      execute blocks_to_list VSTART1A5
      execute blocks_to_list VSTART1B5
      execute blocks_to_list VSTART1A6
      execute blocks_to_list VSTART1B6
      execute blocks_to_list VSTART1A7
      execute blocks_to_list VSTART1B7
      execute blocks_to_list VSTART1A8
      execute blocks_to_list VSTART1B8
      execute blocks_to_list VSTART1A9
      execute blocks_to_list VSTART1B9
      execute blocks_to_list VSTART1A10
      execute blocks_to_list VSTART1B10
      execute blocks_to_list VSTART1A11
      execute blocks_to_list VSTART1B11
      execute blocks_to_list VSTART1A12
      execute blocks_to_list VSTART1B12
      execute blocks_to_list omegacis
      execute server_barrier
      execute write_blocks_to_list
      execute server_barrier
     ENDPROC write_data
#
     PROC putvec
     ncount1 = 1.0
     execute sip_barrier
     execute print_scalar iroot
     do jstate
     do kptr0
         if ncount1 == iroot
         get omegacis(jstate,kptr0)
         tomegacis(jstate,kptr0) = omegacis(jstate,kptr0)
         t1omegacis(jstate,kptr0) = 1.0
         eomegacis = tomegacis(jstate,kptr0)*t1omegacis(jstate,kptr0)
         eomegacis *= fev
#
         shift = eomegacis
         shift*= -1.0
         execute print_scalar eomegacis
         endif
         ncount1 += 1.0
     enddo kptr0
     enddo jstate
      execute server_barrier
      PARDO a, i
            if iroot == 1.0
               get VSTART1A1(a,i)
               prepare cai(a,i)=VSTART1A1(a,i)
            endif
            if iroot == 2.0
               get VSTART1A2(a,i)
               prepare cai(a,i)=VSTART1A2(a,i)
            endif
            if iroot == 3.0
               get VSTART1A3(a,i)
               prepare cai(a,i)=VSTART1A3(a,i)
            endif
            if iroot == 4.0
               get VSTART1A4(a,i)
               prepare cai(a,i)=VSTART1A4(a,i)
            endif
            if iroot == 5.0
               get VSTART1A5(a,i)
               prepare cai(a,i)=VSTART1A5(a,i)
            endif
            if iroot == 6.0
               get VSTART1A6(a,i)
               prepare cai(a,i)=VSTART1A6(a,i)
            endif
            if iroot == 7.0
               get VSTART1A7(a,i)
               prepare cai(a,i)=VSTART1A7(a,i)
            endif
            if iroot == 8.0
               get VSTART1A8(a,i)
               prepare cai(a,i)=VSTART1A8(a,i)
            endif
            if iroot == 9.0
               get VSTART1A9(a,i)
               prepare cai(a,i)=VSTART1A9(a,i)
            endif
            if iroot == 10.0
               get VSTART1A10(a,i)
               prepare cai(a,i)=VSTART1A10(a,i)
            endif
            if iroot == 11.0
               get VSTART1A11(a,i)
               prepare cai(a,i)=VSTART1A11(a,i)
            endif
            if iroot == 12.0
               get VSTART1A12(a,i)
               prepare cai(a,i)=VSTART1A12(a,i)
            endif
      ENDPARDO a,i
      execute server_barrier
     ENDPROC putvec
#
#    Perform the first two stages of the transformation in two N5 steps.
#
     PROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
#
          allocate Lxxxi(mu,nu,lambda,*)
#     
          DO sigma
#
             compute_integrals            aoint(mu,nu,lambda,sigma)
#
             DO i   
#
                 T1xxxi(mu,nu,lambda,i)  = aoint(mu,nu,lambda,sigma)*ca(sigma,i)
                 Lxxxi(mu,nu,lambda,i)  += T1xxxi(mu,nu,lambda,i)
#    
             ENDDO i
#    
          ENDDO sigma

          DO i
           DO i1
              Txxii(mu,nu,i1,i)          = Lxxxi(mu,nu,lambda,i)*ca(lambda,i1)
              PREPARE Vxxii(mu,nu,i1,i) += Txxii(mu,nu,i1,i)
           ENDDO i1
           ENDDO i

          DO i
           DO i1
              Txixi(mu,i1,lambda,i)      = Lxxxi(mu,nu,lambda,i)*ca(nu,i1)
              PREPARE Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
           ENDDO i1
           ENDDO i

          DO i
           DO i1
              Tixxi(i1,nu,lambda,i)      = Lxxxi(mu,nu,lambda,i)*ca(mu,i1)
              PREPARE Vixxi(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i)
           ENDDO i1
           ENDDO i
#    
          DO i
           DO a
              Txxai(mu,nu,a,i)          = Lxxxi(mu,nu,lambda,i)*ca(lambda,a)
              PREPARE Vxxai(mu,nu,a,i) += Txxai(mu,nu,a,i)
           ENDDO a
           ENDDO i
#
          deallocate Lxxxi(mu,nu,lambda,*)
#
     ENDPARDO mu, nu, lambda
     execute server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.
#
     PROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxixi(mu,i,nu,i1) i1
#
           DO p
#
              Txipi(mu,i,p,i1)          = Vxixi(mu,i,nu,i1)*ca(nu,p)
              PREPARE Vxipi(mu,i,p,i1) += Txipi(mu,i,p,i1)
#
           ENDDO p
#
     ENDPARDO mu, nu, i, i1
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxxii(mu,nu,i,i1) i1
#
           DO a
#
              Txaii(mu,a,i,i1)          = Vxxii(mu,nu,i,i1)*ca(nu,a)
              PREPARE Vxaii(mu,a,i,i1) += Txaii(mu,a,i,i1)
#
           ENDDO a
#
     ENDPARDO mu, nu, i, i1
#
     PARDO mu, nu, i, i1
#
           REQUEST Vixxi(i,mu,nu,i1) i1
#
           DO a
#
              Tixai(i,mu,a,i1)          = Vixxi(i,mu,nu,i1)*ca(nu,a)
              PREPARE Vixai(i,mu,a,i1) += Tixai(i,mu,a,i1)
#
           ENDDO a
#
     ENDPARDO mu, nu, i, i1
#
     pardo mu,nu,a,i
         request Vxxai(mu,nu,a,i) i
         do a1
             Txaai(mu,a1,a,i) = Vxxai(mu,nu,a,i)*Ca(nu,a1)
             prepare Vxaai(mu,a1,a,i) += Txaai(mu,a1,a,i)
         enddo a1
     endpardo mu,nu,a,i
#
#    ------------------------------------------------------------------------
#
     execute server_barrier
#
     ENDPROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PARDO mu, p, i, i1
#
           REQUEST             Vxipi(mu,i,p,i1) i1
           REQUEST             Vxipi(mu,i1,p,i) i
           Txipi(mu,i,p,i1)  = Vxipi(mu,i,p,i1)
           T1xipi(mu,i,p,i1) = Vxipi(mu,i1,p,i)
           Txipi(mu,i,p,i1) -= T1xipi(mu,i,p,i1)
#
           DO p1
#
              Tpipi(p1,i,p,i1)          = Vxipi(mu,i,p,i1)*ca(mu,p1)
              PREPARE Vpiqj(p1,i,p,i1) += Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
           DO p1
#
              Tpipi(p1,i,p,i1)          = Txipi(mu,i,p,i1)*ca(mu,p1)
              PREPARE VSpiqj(p1,i,p,i1) += Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
     ENDPARDO mu, p, i, i1
#
     PARDO mu, a, i, i1
#
           REQUEST Vxaii(mu,a,i,i1) i1
           REQUEST Vixai(i,mu,a,i1) i1
#
           DO a1
#
              Taaii(a1,a,i,i1)          = Vxaii(mu,a,i,i1)*ca(mu,a1)
              PREPARE Vaaii(a1,a,i,i1) += Taaii(a1,a,i,i1)
#
           ENDDO a1
#
           DO a1
#
              Tiaai(i,a1,a,i1)          = Vixai(i,mu,a,i1)*ca(mu,a1)
              PREPARE Viaai(i,a1,a,i1) += Tiaai(i,a1,a,i1)
#
           ENDDO a1
#
     ENDPARDO mu, a, i, i1
#
         pardo mu, a, a1, i
             request Vxaai(mu,a,a1,i) i
             do a2
                 Taaai(a2,a,a1,i) = Vxaai(mu,a,a1,i)*Ca(mu,a2)
                 prepare Vaaai(a2,a,a1,i) += Taaai(a2,a,a1,i)
             enddo a2
         endpardo mu, a, a1, i

         execute server_barrier
         pardo a,a1,a2,i
             request Vaaai(a,a1,a2,i) i
             request Vaaai(a2,a1,a,i) i
             Taaai(a,a1,a2,i)  = Vaaai(a,a1,a2,i)
             T1aaai(a,a1,a2,i) = Vaaai(a2,a1,a,i)
             Taaai(a,a1,a2,i) -= T1aaai(a,a1,a2,i)
             prepare VSaaai(a,a1,a2,i) = Taaai(a,a1,a2,i)
         endpardo a,a1,a2,i
         execute server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF
#
#        CALL COMP_INTEGRALS # --> compute integrals and put into served array
         CALL TRAN_TRAN2     # --> performs the first two stages of the
                             #     two-electron integral transformation.
         CALL TRAN_TRAN3     # --> performs the third stage
                             #     two-electron integral transformation.
         CALL TRAN_TRAN4     # --> performs the fourth stage of the
                             #     two-electron integral transformation.
#
     ENDPROC TRAN_UHF
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------ 
#
     PROC IGUESS_UHF  
# 
#    ------------------------------------------------------------------------ 
#
     PARDO a, b, i, j 
#
           REQUEST                     Vpiqj(a,i,b,j) j  
           REQUEST                     Vpiqj(b,j,a,i) j  
           Taibj(a,i,b,j)            = Vpiqj(b,j,a,i)
           Taibj(a,i,b,j)           += Vpiqj(a,i,b,j)
           execute energy_denominator  Taibj 
           #execute energy_ty_denominator Taibj shift
           Taibj(a,i,b,j)           *= 0.5  
           PREPARE T2old_ab(a,i,b,j) = Taibj(a,i,b,j)  
           PREPARE D0aibj(a,i,b,j)   = Taibj(a,i,b,j)  
#
     ENDPARDO a, b, i, j 
#
#    ------------------------------------------------------------------------ 
# 
     ENDPROC IGUESS_UHF 
# 
#    ------------------------------------------------------------------------ 
#
# ---------------------------------------------------------------------------- 
#
      PROC WminjAB
#     ------------
#
      PARDO a, b, i1, j1 
#
            REQUEST T2old_ab(a,i1,b,j1) j1
#
            DO i
            DO j
#
               REQUEST                      Vpiqj(i1,i,j1,j) j
               T1aibj(a,i,b,j)            = T2old_ab(a,i1,b,j1)*Vpiqj(i1,i,j1,j)
               PREPARE T2new_ab(a,i,b,j) += T1aibj(a,i,b,j)
#
            ENDDO j
            ENDDO i
#
      ENDPARDO a, b, i1, j1
#
      ENDPROC WminjAB
#     --------------- 
# 
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMINJ 
#
           CALL WminjAB 
#
      ENDPROC WMINJ 
# 
# ----------------------------------------------------------------------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# In PROCEDURE T2NEWAB the new amplitudes T2new_ab are computed. Contributions 
# involving large two-particle intermediates are computed in the corresponding  
# procedures where these intermediates(temp) are computed. Thus the 
# intermediate Wminj is stored and its contribution computed here.  
#
# Contributions coming from P_(ij)P_(ab)t^e_i t^a_m <mb||ej> are computed 
# elsewhere. 
#
      PROC T2NEWAB    
#     ------------
#
      PARDO a, i, b, j 
#
               REQUEST          Vpiqj(a,i,b,j) j 
               Taibj(a,i,b,j) = Vpiqj(a,i,b,j)   
               Taibj(a,i,b,j)*= 0.5  
#
               T1aibj(b,j,a,i)            = Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(a,i,b,j) += Taibj(a,i,b,j)  
               PREPARE T2NEW_AB(b,j,a,i) += T1aibj(b,j,a,i)  
#
      ENDPARDO a, i, b, j 
      pardo a,i,b,j
          request CT_ab(a,i,b,j) j
          Taibj(a,i,b,j) = CT_ab(a,i,b,j)
          PREPARE T2NEW_AB(a,i,b,j) += Taibj(a,i,b,j)  
      endpardo a,i,b,j
#
      ENDPROC T2NEWAB    
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
#    ------------------------------------------------------------------------ 
#
     PROC AOLADDER  
#
#    ------------------------------------------------------------------------ 
#
#    Contract AOINT with half back transformed Amplitudes 
#    ----------------------------------------------------    
#
     PARDO mu, nu, lambda, sigma
        WHERE mu < nu 
#
           compute_integrals aoint(lambda,mu,sigma,nu)
          #execute temp_x    aoint etemp 

          #if etemp > 0.00000001 
#
           DO i
           DO j
#
              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(lambda,mu,sigma,nu)*TAO_ab(lambda,i,sigma,j)
              Y1ab(nu,j,mu,i)             = Yab(mu,i,nu,j)
#
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)
              PREPARE T2AO_ab(nu,j,mu,i) += Y1ab(nu,j,mu,i)
#
           ENDDO j
           ENDDO i

          #endif 
#
     ENDPARDO mu, nu, lambda, sigma
#
     PARDO mu, nu, lambda, sigma
        WHERE mu == nu 
#
           compute_integrals aoint(mu,lambda,nu,sigma)
#
           DO i
           DO j
#
              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(mu,lambda,nu,sigma)*TAO_ab(lambda,i,sigma,j)
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)
#
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     execute server_barrier  
#
#    ------------------------------------------------------------------------ 
#
     ENDPROC AOLADDER  
#
#    ------------------------------------------------------------------------ 
#
#    ------------------------------------------------------------------------ 
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
# In the procedures WMEBJAA, WMEBJBB, WMEBJAB, and WMEBJBA these  
# intermediates are formed as temporary arrarys. The contribution to the 
# outout arrays is computed directly from these temporary arrays so 
# that the array is never stored.   
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMEBJAA 
#     ------------
#
# Contributions to T2new_ab 
# ------------------------- 
#
      PARDO j, b, a, i  
            Taibj(a,i,b,j) = 0.0  
#
            DO i1   
            DO a1  
#
               REQUEST              Viaai(i,a,a1,i1) i  
               REQUEST              Vaaii(a1,a,i,i1) i  
               REQUEST              T2old_ab(a1,i1,b,j) j  

               TYaiai(a,i,a1,i1)   = 0.0  
#
               Taiai(a,i,a1,i1)    = Vaaii(a1,a,i,i1)
               TYaiai(a,i,a1,i1)  -= Taiai(a,i,a1,i1)
               Taiai(a,i,a1,i1)    = Viaai(i,a,a1,i1)
               TYaiai(a,i,a1,i1)  += Taiai(a,i,a1,i1)
#
               R1aibj(a,i,b,j)     = TYaiai(a,i,a1,i1)*T2old_ab(a1,i1,b,j) 
               Taibj(a,i,b,j)     += R1aibj(a,i,b,j) 
#
            ENDDO a1   
            ENDDO i1   

            R1aibj(b,j,a,i)            = taibj(a,i,b,j) 
            PREPARE T2new_ab(a,i,b,j) += taibj(a,i,b,j)
            PREPARE T2new_ab(b,j,a,i) += R1aibj(b,j,a,i)
#
      ENDPARDO j, b, a, i 
#
      ENDPROC WMEBJAA 
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC WMEBJAB 
#     ------------
#
# Contribution to T2new_ab 
# ------------------------ 
#
      PARDO i1, a1, a, i
            REQUEST                     T2old_ab(a1,i1,a,i) a 
            REQUEST                     T2old_ab(a1,i,a,i1) a 
            taiai(a1,i1,a,i)          = T2old_ab(a1,i1,a,i) 
            t1aiai(a1,i1,a,i)         = T2old_ab(a1,i,a,i1) 
            taiai(a1,i1,a,i)         -= t1aiai(a1,i1,a,i) 
            tpppp(a1,i1,i,a)          = taiai(a1,i1,a,i) 
#
            DO j 
            DO b 
#
               REQUEST                        Viaai(i,a,b,j) j  
               R1aibj(a1,i1,b,j)            = tpppp(a1,i1,i,a)*Viaai(i,a,b,j)  
               Taibj(b,j,a1,i1)             = R1aibj(a1,i1,b,j) 
               PREPARE T2new_ab(a1,i1,b,j) += R1aibj(a1,i1,b,j) 
               PREPARE T2new_ab(b,j,a1,i1) += Taibj(b,j,a1,i1) 
#
            ENDDO b 
            ENDDO j 
#
      ENDPARDO i1, a1, a, i
#
      ENDPROC WMEBJAB 
#     ---------------
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
# -------------------------------------------------------------------------------  
#
# Compute contributions from 'Wmjbe'. 
#
      PROC WMJBEab
#     -------------
#
#  Calculate contribution to the amplitudes
#  ----------------------------------------
#
      PARDO a, j, i1, b1
#
            REQUEST T2old_ab(a,i1,b1,j) j
#
            DO i
            DO b
#
               REQUEST                      Vaaii(b,b1,i1,i) i
#
               Taibj(a,i,b,j)             = T2old_ab(a,i1,b1,j)*Vaaii(b,b1,i1,i)
               Taibj(a,i,b,j)            *= -1.0  
#
               T2aibj(b,j,a,i)            = Taibj(a,i,b,j) 
               PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
               PREPARE T2new_ab(b,j,a,i) += T2aibj(b,j,a,i)
#
            ENDDO b
            ENDDO i
#
      ENDPARDO a, j, i1, b1

#    Perform final transformation of LADDER contribution 
#    ---------------------------------------------------
#
        PARDO nu, i, j
#
              allocate LDaixj(*,i,nu,j)
#
              DO mu
#
                 REQUEST T2AO_ab(mu,i,nu,j) j
#
                 DO a
                    Taixj(a,i,nu,j)   = T2AO_ab(mu,i,nu,j)*ca(mu,a)
                    LDaixj(a,i,nu,j) += Taixj(a,i,nu,j)
                 ENDDO a
#
              ENDDO mu

              DO a 
              DO b 
                 Taibj(a,i,b,j)             = LDaixj(a,i,nu,j)*ca(nu,b) 
                 PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
              ENDDO b 
              ENDDO a
#
              deallocate LDaixj(*,i,nu,j)
#
        ENDPARDO nu, i, j
#
      ENDPROC WMJBEab
#     ---------------
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
      PROC WMEBJ 
# 
           CALL WMEBJAA
           CALL WMEBJAB
           CALL WMJBEab
#
      ENDPROC WMEBJ 
#
# SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 

#    ------------------------------------------------------------------------ 
#
     PROC ENERGY_NEW 
# 
#    ------------------------------------------------------------------------ 
#
     ecorrab = 0.0 
     esumab  = 0.0 
     execute sip_barrier 
     PARDO a, b, i, j 
#
           REQUEST Vpiqj(a,i,b,j) j  
           REQUEST Vpiqj(a,j,b,i) j  
#
           REQUEST T2old_ab(a,i,b,j) j  
#
           T1aibj(a,i,b,j) = Vpiqj(a,i,b,j)  
           T2aibj(a,i,b,j) = Vpiqj(a,j,b,i)  
           T1aibj(a,i,b,j)*= 2.0  
           T1aibj(a,i,b,j)-= T2aibj(a,i,b,j)  
#
           etemp = T2old_ab(a,i,b,j)*T1aibj(a,i,b,j) 
           esumab += etemp 
#
     ENDPARDO a, b, i, j 

     execute sip_barrier 
#
     collective ecorrab += esumab
     execute print_scalar ecorrab 
     ecorrab += ecisd
#
    #ecorrT  = ecorraa + ecorrbb
     ecorrT = ecorrab 
     execute print_scalar ecorrT  
     if kiter > 0
            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == one
               tpinf(kiter,kptr1) = ecorrab
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == two
               etemp = ecorrab
               etemp+= scfeneg
               etemp+= eomegacis
               tpinf(kiter,kptr1) = etemp
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

         etemp = 32
         execute print_rel_info etemp pinf

         ncount1 = 1.0
         do kstate
         do kptr1
             etemp = 0.0
             ctpinf(kstate,kptr1) = etemp
             cpinf(kstate,kptr1)  = ctpinf(kstate,kptr1)
         enddo kptr1
         enddo kstate
         do kstate
         if ncount1 == iroot
             ncount2 = 0.0
             do kptr1
                 ncount2 += 1.0
                 if ncount2 == one
                     etemp  = ecorrT
                     etemp -= oldcorrT
                     ctpinf(kstate,kptr1) = etemp
                     cpinf(kstate,kptr1)  = ctpinf(kstate,kptr1)
                 endif
             enddo kptr1
             ncount2 = 0.0
             do kptr1
                 ncount2 += 1.0
                 if ncount2 == two
                     etemp  = ecorrT
                     etemp += eomegacis
                     etemp -= oldcorrT
                     ctpinf(kstate,kptr1) = etemp
                     cpinf(kstate,kptr1)  = ctpinf(kstate,kptr1)
                 endif
             enddo kptr1
             etemp = 37
             execute print_rel_info etemp cpinf
         endif
         ncount1 += 1.0
         enddo kstate
     endif
# 
#    ------------------------------------------------------------------------ 
# 
     ENDPROC ENERGY_NEW 
# 
     proc Caibj
#
     execute server_barrier
     pardo a,i,b,j
         Taiai(a,i,b,j) = 0.0
         prepare Ctau(a,i,b,j)  = Taiai(a,i,b,j)
         prepare CT_ab(a,i,b,j) = Taiai(a,i,b,j)
     endpardo a,i,b,j
     execute server_barrier
     pardo a,i,b,j
         Taiai(a,i,b,j) = 0.0
         do i1
             request Vpiqj(i1,i,b,j) j
             request cai(a,i1) a
             T1aiai(a,i,b,j) = Vpiqj(i1,i,b,j)*cai(a,i1)
             Taiai(a,i,b,j) += T1aiai(a,i,b,j)
         enddo i1
         Taiai(a,i,b,j) *= -1.0
         prepare Ctau(a,i,b,j) += Taiai(a,i,b,j)
     endpardo a,i,b,j
     pardo a,i,b,j
         Taiai(a,i,b,j) = 0.0
         do a1
             request Vaaai(a,a1,b,j) j
             request cai(a1,i) i
             T1aiai(a,i,b,j) = Vaaai(a,a1,b,j)*cai(a1,i)
             Taiai(a,i,b,j) += T1aiai(a,i,b,j)
         enddo a1
         prepare Ctau(a,i,b,j) += Taiai(a,i,b,j)
     endpardo a,i,b,j
     execute server_barrier
     pardo a,i,b,j
         request Ctau(a,i,b,j) j
         request Ctau(b,j,a,i) i
         Taiai(a,i,b,j)  = Ctau(a,i,b,j)
         T1aiai(a,i,b,j) = Ctau(b,j,a,i)
         Taiai(a,i,b,j) += T1aiai(a,i,b,j)
         prepare CT_ab(a,i,b,j) = Taiai(a,i,b,j)
     endpardo a,i,b,j
     execute server_barrier
      pardo a,i,b,j
          request CT_ab(a,i,b,j) j
          Taibj(a,i,b,j) = CT_ab(a,i,b,j)
          PREPARE T2old_ab(a,i,b,j) += Taibj(a,i,b,j)  
          PREPARE D0aibj(a,i,b,j) += Taibj(a,i,b,j)  
      endpardo a,i,b,j
     execute server_barrier
     destroy Ctau
#
     endproc Caibj
#
#
     proc hbar_ab
     pardo a,i,b,j
#
         Tpp(a,b) = 0.0
         do a1
             request VSpiqj(b,i,a1,j) j
             request T2old_aa(a,i,a1,j) j
             T1pp(a,b) = VSpiqj(b,i,a1,j)*T2old_aa(a,i,a1,j)
             Tpp(a,b) += T1pp(a,b)
         enddo a1
         Tpp(a,b) *= -0.5
         prepare Faa(a,b) += Tpp(a,b)
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp(a,b) = 0.0
         do a1
             request Vpiqj(b,i,a1,j) j
             request T2old_ab(a,i,a1,j) j
             T1pp(a,b) = Vpiqj(b,i,a1,j)*T2old_ab(a,i,a1,j)
             Tpp(a,b) += T1pp(a,b)
         enddo a1
         Tpp(a,b) *= -1.0
         prepare Faa(a,b) += Tpp(a,b)
#
     endpardo a,i,b,j
#
     endproc hbar_ab
#
     proc hbar_ij
#
     pardo a,i,b,j
#
         Tpp(i,j) = 0.0
         do i1
             request VSpiqj(a,j,b,i1) i1
             request T2old_aa(a,i,b,i1) i1
             T1pp(i,j) = VSpiqj(a,j,b,i1)*T2old_aa(a,i,b,i1)
             Tpp(i,j) += T1pp(i,j)
         enddo i1
         Tpp(i,j) *= -0.5
         prepare Fii(i,j) += Tpp(i,j)
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp(i,j) = 0.0
         do i1
             request Vpiqj(a,j,b,i1) i1
             request T2old_ab(a,i,b,i1) i1
             T1pp(i,j) = Vpiqj(a,j,b,i1)*T2old_ab(a,i,b,i1)
             Tpp(i,j) += T1pp(i,j)
         enddo i1
         Tpp(i,j) *= -1.0
         prepare Fii(i,j) += Tpp(i,j)
#
     endpardo a,i,b,j
#
     endproc hbar_ij
#
     proc hbar_ai
#
#
     pardo a,i
#
         do a1
         do i1
         request VSpiqj(a,i,a1,i1) i1
         request Vpiqj(a,i,a1,i1) i1
         request cai(a1,i1) i1
         T1pp(a,i) = VSpiqj(a,i,a1,i1)*cai(a1,i1)
         T2pp(a,i) = Vpiqj(a,i,a1,i1)*cai(a1,i1)
         T1pp(a,i)+= T2pp(a,i)
#
         put LSFai(a,i) += T1pp(a,i)

         enddo i1
         enddo a1
#
     endpardo a,i
     execute server_barrier
     pardo a,i,a1,i1
#
         request T2old_aa(a,i,a1,i1) i1
         get LSFai(a1,i1)
#
         Tpp(a,i) = T2old_aa(a,i,a1,i1)*LSFai(a1,i1)
#
         prepare Fai(a,i) += Tpp(a,i)
#
     endpardo a,i,a1,i1
     pardo a,i,a1,i1
#
         request T2old_ab(a,i,a1,i1) i1
         get LSFai(a1,i1)
#
         Tpp(a,i) = T2old_ab(a,i,a1,i1)*LSFai(a1,i1)
#
         prepare Fai(a,i) += Tpp(a,i)
#
     endpardo a,i,a1,i1
     execute server_barrier
#
     endproc hbar_ai
#
     proc hbar_prep
         execute server_barrier
         pardo a,i,b,j
             request T2old_ab(a,i,b,j) j
             request T2old_ab(a,j,b,i) i
             Taibj(a,i,b,j)  = T2old_ab(a,i,b,j)
             T1aibj(a,i,b,j) = T2old_ab(a,j,b,i)
             Taibj(a,i,b,j) -= T1aibj(a,i,b,j)
             prepare T2old_aa(a,i,b,j) = Taibj(a,i,b,j)
         endpardo a,i,b,j
         pardo a,b
             Tpp(a,b) = 0.0
             prepare Faa(a,b) = Tpp(a,b)
         endpardo a,b
         pardo i,j
             Tpp(i,j) = 0.0
             prepare Fii(i,j) = Tpp(i,j)
         endpardo i,j
         pardo a,i
             Tpp(a,i) = 0.0
             put LSFai(a,i) = Tpp(a,i)
             prepare Fai(a,i) = Tpp(a,i)
         endpardo a,i
         execute server_barrier
     endproc hbar_prep
#
     proc make_hbar
#
     call hbar_prep
     call hbar_ab
     call hbar_ij
     call hbar_ai
     execute server_barrier
#
     endproc make_hbar
#
     proc cispt2_energy
#
     execute server_barrier
     esum2 = 0.0
     esum3 = 0.0
     ecorr2 = 0.0
     edoubles = 0.0
     etriples = 0.0
     ecisd = 0.0
     execute server_barrier
     pardo a,i,b,j
#
         request T2old_ab(a,i,b,j) j
         REQUEST CT_ab(a,i,b,j) j  
         REQUEST CT_ab(b,i,a,j) j  
         Taibj(a,i,b,j)  = CT_ab(a,i,b,j)
         T1aibj(a,i,b,j) = CT_ab(b,i,a,j)
         Taibj(a,i,b,j) *= 2.0
         Taibj(a,i,b,j) -= T1aibj(a,i,b,j)
##
         etemp  = T2old_ab(a,i,b,j)*Taibj(a,i,b,j)
         etemp *= 0.5
         esum2 += etemp
#
     endpardo a,i,b,j
#
     pardo a,i
         request cai(a,i) i
         request Fai(a,i) i
         Tpp(a,i) = Fai(a,i)
#
         do b
             request Faa(a,b) a
             request cai(b,i) i
             T1pp(a,i) = Faa(a,b)*cai(b,i)
             Tpp(a,i) += T1pp(a,i)
         enddo b
##
         do j
             request Fii(i,j) i
             request cai(a,j) a
             T1pp(a,i) = Fii(i,j)*cai(a,j)
             Tpp(a,i) += T1pp(a,i)
         enddo j
#
         etemp = cai(a,i)*tpp(a,i)
         esum3+= etemp
#
     endpardo a,i
     execute server_barrier
#
     collective edoubles += esum2
     collective etriples += esum3
     execute server_barrier
#
     ecisd = edoubles
     ecisd+= etriples
     execute print_scalar edoubles
     execute print_scalar etriples
     execute print_scalar ecisd
     execute server_barrier
#
#     ecisd+= eomegacis
     execute print_scalar ecisd
#
     endproc cispt2_energy
#    ------------------------------------------------------------------------ 
# 
     PROC T2NEW_ZERO
#    --------------- 
#
#     Zero out new 2-particle amplitude arrays 
#     ---------------------------------------- 
#
          PARDO a, b, i, j 
                Taibj(a,i,b,j) = 0.0
                PREPARE T2new_ab(a,i,b,j) = Taibj(a,i,b,j) 
          ENDPARDO a, b, i, j 
#
#    Zero-out intermediate arrays
#    ---------------------------------------------
#
          PARDO mu, nu, i, j
                Txixi(mu,i,nu,j)           = 0.0
                PREPARE T2AO_ab(mu,i,nu,j) = Txixi(mu,i,nu,j)
          ENDPARDO mu, nu, i, j
#
          PARDO mu, nu, i, j
                Txixi(mu,i,nu,j)           = 0.0
                PREPARE TAO_ab(mu,i,nu,j) = Txixi(mu,i,nu,j)
          ENDPARDO mu, nu, i, j

          execute server_barrier 
#
#    Form Half back transformed cluster arrays  
#    -----------------------------------------
#
#    AB spin combination
#     -------------------
#
     PARDO mu, a, j, i
#
           taixj(a,i,mu,j) = 0.0 
#
           DO b
#
              REQUEST            T2old_ab(a,i,b,j) a
              T1aixj(a,i,mu,j) = T2old_ab(a,i,b,j)*ca(mu,b)
              Taixj(a,i,mu,j) += T1aixj(a,i,mu,j) 
#
           ENDDO b
#
            DO nu
#
               Txixi(nu,i,mu,j)           = Taixj(a,i,mu,j)*ca(nu,a)
               PREPARE TAO_ab(nu,i,mu,j) += Txixi(nu,i,mu,j)
#
            ENDDO nu
#
      ENDPARDO mu, a, j, i

          execute server_barrier 
#
     ENDPROC T2NEW_ZERO
# 
#    ------------------------------------------------------------------------ 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC UPDATET2 
#     ------------- 
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab(b,j,a,i) b 
            REQUEST                    T2new_ab(b,j,a,i) b 
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            T1aibj(a,i,b,j)          = T2old_ab(b,j,a,i)
#
            REQUEST                    T2old_ab(a,i,b,j) b 
            REQUEST                    T2new_ab(a,i,b,j) b 
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            T1aibj(a,i,b,j)         += T2old_ab(a,i,b,j)

            execute energy_denominator Taibj
            #execute energy_ty_denominator Taibj shift
            T1aibj(a,i,b,j) -= Taibj(a,i,b,j)
            T1aibj(a,i,b,j) *= -0.5
#
            if kiter == 1
               PREPARE e1aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 2
               PREPARE e2aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 3
               PREPARE e3aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter == 4
               PREPARE e4aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
            if kiter >= 5
               PREPARE e5aibj(a,i,b,j) = T1aibj(a,i,b,j)
            endif
#
      ENDPARDO b, a, j, i
      execute server_barrier 
#
      PARDO b, a, j, i
#
            REQUEST                    T2new_ab(a,i,b,j) a
            REQUEST                    T2new_ab(b,j,a,i) a
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            Taibj(a,i,b,j)          *= 0.5  
            execute energy_denominator Taibj
            #execute energy_ty_denominator Taibj shift
            PREPARE T2old_ab(a,i,b,j)    = Taibj(a,i,b,j)
#
      ENDPARDO b, a, j, i
#
      ENDPROC UPDATET2 
#     ----------------  
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
      PROC MOVET2
#     ------------
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab(a,i,b,j) a 
            Taibj(a,i,b,j)           = T2old_ab(a,i,b,j)
#
            if kiter == 1
               PREPARE d1aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 2
               PREPARE d2aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 3
               PREPARE d3aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter == 4
               PREPARE d4aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
            if kiter >= 5
               PREPARE d4aibj(a,i,b,j) = Taibj(a,i,b,j)
            endif
#
      ENDPARDO b, a, j, i
#
      ENDPROC MOVET2
#     ----------------
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR  
#    ----------------- 
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS 
#    expansion are zero'd out. 
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR  
#    -------------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS   
#    --------------- 
#
#    Put the matrix elements of B into the sip 'B' matrix. 
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS   
#    ------------------ 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
#             b1x x=1,2
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb22 += b22 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     execute server_barrier 
     execute print_scalar c1 
     execute print_scalar c2 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS1  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
#             b1x x=1,3
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb33 += b33 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     execute server_barrier 
     execute print_scalar c1 
     execute print_scalar c2 
     execute print_scalar c3 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS2  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-3 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e4aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e4aibj(a,j,b,i) 
           t4aibj(a,i,b,j) = e4aibj(a,i,b,j) 
           t4aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
              etemp = e1aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
              etemp = e2aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
              etemp = e3aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b44  += etemp
#
#             b1x x=1,4
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
              etemp = t1aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
              etemp = t2aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
              etemp = t3aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = t4aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b44  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb14 += b14 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb24 += b24 
     collective Tb33 += b33 
     collective Tb34 += b34 
     collective Tb44 += b44 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     c4 = Tb44 
     execute print_scalar c1 
     execute print_scalar c2 
     execute print_scalar c3 
     execute print_scalar c4 
     execute server_barrier 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D3aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c4
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS3  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4  
#    ---------- 
#
#    Zero out scalars.
#    ----------------- 
#
     CALL ZERO_DSCALAR 
#
#    Determine the 'B-matrix'. 
#    ------------------------- 
#
#    Compute contributions due to T2aibj amplitudes.
#    -----------------------------------------------
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 5 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST e1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e5aibj(a,i,b,j) a # kiter-0 amplitudes
#
           REQUEST e1aibj(a,j,b,i) a # kiter-4 amplitudes
           REQUEST e2aibj(a,j,b,i) a # kiter-3 amplitudes
           REQUEST e3aibj(a,j,b,i) a # kiter-2 amplitudes
           REQUEST e4aibj(a,j,b,i) a # kiter-1 amplitudes
           REQUEST e5aibj(a,j,b,i) a # kiter-0 amplitudes
#
           taibj(a,i,b,j)  = e1aibj(a,j,b,i) 
           t1aibj(a,i,b,j) = e1aibj(a,i,b,j) 
           t1aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e2aibj(a,j,b,i) 
           t2aibj(a,i,b,j) = e2aibj(a,i,b,j) 
           t2aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e3aibj(a,j,b,i) 
           t3aibj(a,i,b,j) = e3aibj(a,i,b,j) 
           t3aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e4aibj(a,j,b,i) 
           t4aibj(a,i,b,j) = e4aibj(a,i,b,j) 
           t4aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
           taibj(a,i,b,j)  = e5aibj(a,j,b,i) 
           t5aibj(a,i,b,j) = e5aibj(a,i,b,j) 
           t5aibj(a,i,b,j)-= taibj(a,i,b,j) 
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1aibj(a,i,b,j)*e1aibj(a,i,b,j)
              etemp *= 2.0
              b11  += etemp
#
              etemp = e1aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b12  += etemp
#
              etemp = e1aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b13  += etemp
#
              etemp = e1aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b14  += etemp
#
              etemp = e1aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2aibj(a,i,b,j)*e2aibj(a,i,b,j)
              etemp *= 2.0
              b22  += etemp
#
              etemp = e2aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b23  += etemp
#
              etemp = e2aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b24  += etemp
#
              etemp = e2aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3aibj(a,i,b,j)*e3aibj(a,i,b,j)
              etemp *= 2.0
              b33  += etemp
#
              etemp = e3aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b34  += etemp
#
              etemp = e3aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4aibj(a,i,b,j)*e4aibj(a,i,b,j)
              etemp *= 2.0
              b44  += etemp
#
              etemp = e4aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5aibj(a,i,b,j)*e5aibj(a,i,b,j)
              etemp *= 2.0
              b55  += etemp
#
#
#             b1x x=1,5
#             ---------
#
              etemp = t1aibj(a,i,b,j)*t1aibj(a,i,b,j)
              b11  += etemp
#
              etemp = t1aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b12  += etemp
#
              etemp = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b13  += etemp
#
              etemp = t1aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b14  += etemp
#
              etemp = t1aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = t2aibj(a,i,b,j)*t2aibj(a,i,b,j)
              b22  += etemp
#
              etemp = t2aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b23  += etemp
#
              etemp = t2aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b24  += etemp
#
              etemp = t2aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = t3aibj(a,i,b,j)*t3aibj(a,i,b,j)
              b33  += etemp
#
              etemp = t3aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b34  += etemp
#
              etemp = t3aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = t4aibj(a,i,b,j)*t4aibj(a,i,b,j)
              b44  += etemp
#
              etemp = t4aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = t5aibj(a,i,b,j)*t5aibj(a,i,b,j)
              b55  += etemp
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
#    Collectively sum B-matrix elements. 
#    -----------------------------------
#
     collective Tb11 += b11 
     collective Tb12 += b12 
     collective Tb13 += b13 
     collective Tb14 += b14 
     collective Tb15 += b15 
     collective Tb22 += b22 
     collective Tb23 += b23 
     collective Tb24 += b24 
     collective Tb25 += b25 
     collective Tb33 += b33 
     collective Tb34 += b34 
     collective Tb35 += b35 
     collective Tb44 += b44 
     collective Tb45 += b45 
     collective Tb55 += b55 
     execute server_barrier 
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out. 
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the  
#    R-matrix. 
#    -------------------------------------------------------------------------------- 
#
     CALL SETUP_DIIS 
     execute server_barrier 
#
     execute compute_diis # --> New instruction  
     execute server_barrier 
#
     c1 = Tb11 
     c2 = Tb22 
     c3 = Tb33 
     c4 = Tb44 
     c5 = Tb55 
     execute print_scalar c1 
     execute print_scalar c2 
     execute print_scalar c3 
     execute print_scalar c4 
     execute print_scalar c5 
     execute server_barrier 
#
#    Done computing the c-vector. 
#    ---------------------------- 
#
#    Form the updated amplitudes using the c-vector. 
#    -----------------------------------------------  
#
#    Form T2old_ab. 
#    -------------- 
#
     PARDO a, i, b, j
#
#          REQUEST/GET amplitude data from all 5 previous iterations.
#          ----------------------------------------------------------
#
           REQUEST D0aibj(a,i,b,j) a # kiter-5 amplitudes
           REQUEST D1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST D2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST D3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST D4aibj(a,i,b,j) a # kiter-1 amplitudes
#
           REQUEST e1aibj(a,i,b,j) a # kiter-4 amplitudes
           REQUEST e2aibj(a,i,b,j) a # kiter-3 amplitudes
           REQUEST e3aibj(a,i,b,j) a # kiter-2 amplitudes
           REQUEST e4aibj(a,i,b,j) a # kiter-1 amplitudes
           REQUEST e5aibj(a,i,b,j) a # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> T2old_ab.
#          ---------------------------------------------------------
#
           t2aibj(a,i,b,j)            = d0aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c1
           taibj(a,i,b,j)             = t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d1aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c2
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d2aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c3
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d3aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c4
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           t2aibj(a,i,b,j)            = d4aibj(a,i,b,j)
           t2aibj(a,i,b,j)           += e5aibj(a,i,b,j)
           t2aibj(a,i,b,j)           *= c5
           taibj(a,i,b,j)            += t2aibj(a,i,b,j)
#
           PREPARE T2old_ab(a,i,b,j)      = taibj(a,i,b,j)
#
     ENDPARDO a, i, b, j
#
     execute server_barrier 
#
     ENDPROC DIIS4  
#    ------------- 
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
     execute server_barrier
     execute sip_barrier
#
#    0 --> 1
#    ---------------------------------------------------
#
     execute array_copy d1aibj d0aibj
     execute server_barrier
#
#    2 --> 1
#    ---------------------------------------------------
#
     execute array_copy e2aibj e1aibj
     execute array_copy d2aibj d1aibj
     execute server_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     execute array_copy e3aibj e2aibj
     execute array_copy d3aibj d2aibj
     execute server_barrier
#
#
#    4 --> 3
#    ---------------------------------------------------
#
     execute array_copy e4aibj e3aibj
     execute array_copy d4aibj d3aibj
     execute server_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     execute array_copy e5aibj e4aibj
#
     execute server_barrier
#
     ENDPROC MOVE4
#    -------------
#
# ---------------------------------------------------------------------------------
# 
# BEGIN MAIN PROGRAM 
# ------------------ 
#
      ecrit = cc_conv  
      one = 1.0
      two = 2.0
      oldcorrT  = totenerg
      oldcorrT -= scfeneg
#
# Read transformed integrals from lists 
# ------------------------------------- 
#
      call read_data
#
# Perform two-electron integral transformation 
# -------------------------------------------- 
#
      CALL TRAN_UHF 
      execute server_barrier
      call iguess_uhf
#
      EXECUTE SERVER_BARRIER  
#
     create LSFai
     execute print_scalar eom_roots
     execute print_scalar eom_tol
     maxstate = eom_roots
     fev = 0.0367493089
#
     iroot = 8.0
     call putvec
# construct W[+1]*C_1 going into the T2 wavefunction
     call Caibj
#
# Start iterations
# ---------------- 
      DO KITER 

      EXECUTE SERVER_BARRIER  
#
#        Zero-out the new two-particle amplitude arrays
#        ---------------------------------------------- 
#
         CALL T2NEW_ZERO
#
#        Calculate new two-particle amplitudes 
#        ------------------------------------- 
#
         CALL T2NEWAB  
#
         CALL WMINJ 
         CALL AOLADDER 
         CALL WMEBJ 
#
#        Wait for all to finish 
#        ---------------------- 
         EXECUTE SERVER_BARRIER   
#
         CALL UPDATET2 
#
         EXECUTE SERVER_BARRIER   
         call make_hbar
         execute server_barrier
         call cispt2_energy
         execute server_barrier
         CALL ENERGY_NEW 
         EXECUTE SERVER_BARRIER   
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
         EXECUTE SERVER_BARRIER  
#
         CALL MOVET2
#
         EXECUTE SERVER_BARRIER  
#
#        Check on convergence 
#        -------------------- 
#
         IF ecorrT < eold 
            ediff = eold - ecorrT 
            IF ediff < ecrit 
               exit # kiter 
            ENDIF
         ENDIF   
#
         IF ecorrT > eold 
            ediff = ecorrT - eold  
            IF ediff < ecrit 
               exit # kiter 
            ENDIF
         ENDIF   
#
#        Reset eold --> enew 
#        ------------------- 
#
         eold = ecorrT 

         #if kiter >= 5 
         #   call do_checkpoint
         #endif
#
      ENDDO KITER 
#
      execute sip_barrier 
#      totenerg  = ecorrT  
#      totenerg += scfeneg  
#      execute print_scalar totenerg  
#      execute print_scalar ecisd
#      etemp = 33
#      execute print_rel_info etemp pinf
     etemp = 38
     execute print_rel_info etemp cpinf
     execute server_barrier
     call write_data
     execute print_scalar oldcorrT
# Write amplitudes to file
# ------------------------
#
                           ENDSIAL CCSD_RHF_SV1    
#
# EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE 
#
#
