#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                    SIAL ONE_HERM_GRAD_CO       
#
# This SIAL program computes the two particle density 
# matrice but only stores one piece at a time similar to dens6.sial. 
# The one-particle intermediates are computed and stored.  
# The two-particle density matrices have been tested and are CORRECT.  
# The one-particle intermediates have been tested and are CORRECT. 
# Contributions coming from Vabcd --> Iab are computed in AO basis and CHECKED. 
# Contributions coming from Vabcd --> Iai are computed in AO basis and CHECKED. 
#
# This version also computes Dai iteratively in the final step --> Tested and Working 
#
# Iij_aa --> matches aces 
#
# Iab_aa --> matches aces 
#
# Iai_aa --> matches aces 
#
# Iia_aa --> matches aces
#
# The integral files are split --> IN PROGRESS 
# and 
# antisymmetrized --> IN PROGRESS 
#
# ---------------------------------------
# PROCEDURE                  OPTIMIZATION 
# ---------------------------------------
# DIJKL                      COMPLETE  
# DABCD                      COMPLETE  
# DIBJA                      IN PROGRESS  
# DIJAB                      COMPLETE   
# DIJKA                      PARTIAL  
# DABCI                      PARTIAL  
#
# I11                        COMPLETE 
# IABDIRECT                  COMPLETE 
# IFOCK                      COMPLETE 
# DAI                        COMPLETE 
#
# DAB                        COMPLETE  
# DIJ                        COMPLETE  
# GAE                        COMPLETE --> REDO????   
# GMI                        COMPLETE  
# TAU                        COMPLETE  
# ---------------------------------------
#
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
#
# Declare indeces
# ---------------
#
      index kiter    = 1, cc_iter  
      aoindex mu     = 1, norb
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
      moaindex i4= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
      moaindex a4= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
      moaindex j4= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
      moaindex b4= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
#
# Arrays used in transformation for AO2 algorithm
# -----------------------------------------------
#
      temp Txixi(mu,i1,lambda,i)
      temp Txxii(mu,nu,i1,i)
      temp Tixxi(i1,nu,lambda,i)
      temp Txipi(mu,i,p,i1)
      temp Tpipi(p1,i,p,i1)
      temp T1pipi(p1,i,p,i1)
      temp Tixai(i,mu,a,i1)
      temp Txaii(mu,a,i,i1)
      temp Taiia(a,i1,i,a1)
      temp Taaii(a,a1,i,i1)
      temp Txaai(mu,a1,a,i)
      temp Taaai(a2,a,a1,i)
      temp Txxai(mu,nu,a,i)
      temp Txxxi(mu,nu,lambda,i)
#
      served VSpipi(p1,i,p,i1)
      served Viaai(i,a1,a,i1)
      served Vaaii(a,a1,i,i1)
      served VSaaai(a2,a,a1,i)
#
      temp Txjxj(mu,j1,lambda,j)
      temp Txxjj(mu,nu,j1,j)
      temp Tjjxx(j1,nu,lambda,j)
      temp Tjxxj(j1,nu,lambda,j)
      temp Txjqj(mu,j,q,j1)
      temp Tqjqj(q1,j,q,j1)
      temp T1qjqj(q1,j,q,j1)
      temp Tjxbj(j,mu,b,j1)
      temp Txbjj(mu,b,j,j1)
      temp Tjbbj(j,b1,b,j1)
      temp Tbbjj(b,b1,j,j1)
      temp Txbbj(mu,b1,b,j)
      temp Tbbbj(b2,b,b1,j)
      temp Txxbj(mu,nu,b,j)
      temp Txxxj(mu,nu,lambda,j)
#
      temp Txiqj(mu,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp Tiixx(i,i1,mu,nu)
      temp Tiixb(i,i1,mu,b)
      temp Tiibb(i,i1,b1,b)
      temp Txajj(mu,a,j,j1)
      temp Taajj(a,a1,j,j1)
      temp Txabj(mu,a,b,j)
      temp Tixxj(i,mu,nu,j)
      temp Tixbj(i,mu,b,j)
      temp Tiabj(i,a,b,j)
      temp Taabj(a,a1,b,j)
      temp T1xibj(lambda,i,b,j)  
#
      served Vpiqj(p,i,q,j)
      served Vaabj(a,a1,b,j)
#
      temp Txbii(mu,b,i,i1)
      temp Tbbii(b,b1,i,i1)
      temp Tjbii(j,b,i,i1)
      temp Txbai(mu,b,a,i)
      temp Tbbai(b,b1,a,i)
#
# End Arrays used in transformation for AO2 algorithm
# ---------------------------------------------------
#
# Declare temporary arrays
# ------------------------
#
      temp Txxxx(mu,nu,lambda,sigma)
      temp T1xxxx(mu,nu,lambda,sigma)
      temp Txxxp(mu,nu,lambda,p)
      temp Txxpp(mu,nu,p1,p)
      temp Txppp(mu,p2,p1,p)
      temp Tpppp(p3,p2,p1,p)
      temp T1pppp(p3,p2,p1,p)
      temp T2pppp(p3,p2,p1,p)
      temp T3pppp(p3,p2,p1,p)
      temp Txxxq(mu,nu,lambda,q)
      temp Txxqq(mu,nu,q1,q)
      temp Txqqq(mu,q2,q1,q)
      temp Tqqqq(q3,q2,q1,q)
      temp T1qqqq(q3,q2,q1,q)
      temp T2qqqq(q3,q2,q1,q)
      temp T3qqqq(q3,q2,q1,q)
      temp Txpqq(mu,p,q1,q)
      temp Tppqq(p1,p,q1,q)
      temp T1ppqq(p1,p,q1,q)
      temp T2ppqq(p1,p,q1,q)
      temp Tqpqp(q1,p2,q,p)
      temp Tpqpq(p1,q1,p,q)
      temp Tqqpp(q,q1,p,p1)
      temp T2qqpp(q,q1,p,p1)
      temp Txqpp(mu,q,p1,i)
#
# Declare local arrays
# --------------------------
#
      temp Tixxx(i,mu,nu,sigma)
      temp Tipxx(i,p,nu,sigma)
      temp Tipqx(i,p,q,sigma)
      temp Tipqq(i,p,q,q1)
#
# Declare served arrays
# ---------------------
#
      temp AOINT(mu,nu,lambda,sigma)
      temp AOINT1(mu,nu,lambda,sigma)
#
# Declare static arrays
# ---------------------
#
      served T2old_aa(a,i,a1,i1)
      served T2old_ab(a,i,b,j)
#
      served Dijab_aa(i,i1,a,a1)
      served Dijab_ab(i,j,a,b)
      served Dijkl_aa(i2,i,i3,i1)
      served Dijkl_ab(i,j,i1,j1)
      served Dibja_aaaa(i,a,i1,a1)
      served Dibja_abab(i,b,i1,b1)
      served Dibja_baba(j,a,j1,a1)
      served Dibja_baab(j,a,i,b)
      served Dibja_abba(i,b,j,a)
      served Dabci_aaaa(a,a2,a1,i)
      served Dabci_abab(a,b,a1,j)
      served Dabci_baba(b,a,b1,i)
      served Dijka_aaaa(i,i2,i1,a)
      served Dijka_abab(i,j,i1,b)
      served Dijka_baba(j,i,j1,a)
#
      distributed I3AA(i,a,i1,i2) 
      distributed I3AB(i,a,j,j1) 
      distributed I3BA(j,b,i,i1) 
      distributed I3BB(j,b,j1,j2) 
#
      served TAO_aa(mu,i,nu,i1)  
      served TAO_ab(mu,i,nu,j)  
# 
      distributed Dij_a(i,i1) 
      distributed Dab_a(a,a1) 
      distributed Dii(i,i1)
      distributed Daa(a1,a)
      distributed Djj(j,j1)
#
      distributed DOR_ii(i,i1) 
      distributed DOR_aa(a,a1) 
      distributed Dpp(p,p1)
      temp  Dabcd_aa(a,a1,a2,a3)
      temp  Dabcd_ab(a,b,a1,b1)
      temp DXabcd_ab(a1,b1,a,b)
      distributed Dpq(mu,nu)
      distributed DHF(mu,nu)
      distributed DHFa(mu,nu)
      distributed DHFb(mu,nu)
      distributed Ipq(mu,nu)
#
# Define Local arrays 
# ------------------- 
#
      local Laa(a,a1) 
      local L1aa(a1,a) 
      local Lbb(b,b1) 
      local L1bb(b1,b) 
      local Lai(a,i) 
      local L1ai(a1,i) 
      local Lbj(b,j) 
      local L1bj(b1,j) 
      local Lia(i,a) 
      Local Ljb(j,b) 
      local Lxaai(mu,a2,a,i) 
      local Lxabi(mu,a,b1,i)
#
#    ------------------------------------------------------------------------
#
# Declare temporary arrays
# ------------------------
#
      temp Taiai(p,i,p1,i1)
      temp T1aiai(p,i,p1,i1)
      temp T2aiai(p,i,p1,i1)
      temp T3aiai(p,i,p1,i1)
      temp Laiai(p,i,p1,i1)
#
      temp  Tiaia(i,a,i1,a1)
      temp T1iaia(i,a,i1,a1)
      temp T2iaia(i,a,i1,a1)
      temp T3iaia(i,a,i1,a1)
      temp TAiaia(i,a,i1,a1)
      temp  Tiaai(i,a,a1,i1)
      temp Tiiai(i1,i2,a2,i)  
      temp  Tjbjb(j,b,j1,b1)
      temp T1jbjb(j,b,j1,b1)
      temp T2jbjb(j,b,j1,b1)
      temp T3jbjb(j,b,j1,b1)
      temp TAjbjb(j,b,j1,b1)
      temp  Tiajb(i,a,j,b)
      temp T1iajb(i,a,j,b)
      temp T2iajb(i,a,j,b)
      temp TAiajb(i,a,j,b)
      temp  Tibib(i,b,i1,b1)
      temp T1ibib(i,b,i1,b1)
      temp T2ibib(i,b,i1,b1)
      temp TAibib(i,b,i1,b1)
      temp  Tjaja(j,a,j1,a1)
      temp T1jaja(j,a,j1,a1)
      temp T2jaja(j,a,j1,a1)
      temp TAjaja(j,a,j1,a1)
      temp  Taijb(a,i,j,b)   
      temp  Tbjjb(b,j,j1,b1)
      temp T1bjjb(b,j,j1,b1)
      temp Tjjbj(j1,j2,b2,j)  
#
      temp Tbjbj(q,j,q1,j1)
      temp T1bjbj(q,j,q1,j1)
      temp T2bjbj(q,j,q1,j1)
      temp T3bjbj(q,j,q1,j1)
      temp Lbjbj(q,j,q1,j1)
      temp Taibj(p,i,q,j)
      temp T1aibj(p,i,q,j)
#
      temp tmp1_aiai(a,i,a1,i1)
      temp tmp2_aiai(a,i,a1,i1)
      temp tmp1_bjbj(b,j,b1,j1)
      temp tmp2_bjbj(b,j,b1,j1)
      temp tmp1_aibj(a,i,b,j)
#
      temp Tai(a,i)
      temp T1ai(a,i)
      temp Tbj(b,j)
      temp T1bj(b,j)
      temp Tpq(mu,nu)
      temp T1pq(mu,nu)
      temp tpp(p,p1) 
      temp tqq(q,q1) 
#
      temp Taa(a,a1)
      temp T1aa(a,a1)
      temp Tbb(b,b1)
      temp T1bb(b,b1)
      temp Tae_a(a,a1)
      temp Tia(i,a)
      temp T1ia(i,a)
      temp T2ia(i,a)
      temp T3ia(i,a)
      temp T4ia(i,a)
      temp Tjb(j,b)
      temp T1jb(j,b)
      temp T2jb(j,b)
      temp T3jb(j,b)
      temp T4jb(j,b)
      temp Tme_a(i,a)
#
      temp Tii(i,i1)
      temp T1ii(i,i1)
      temp Tjj(j,j1)
      temp T1jj(j,j1)
      temp Tmi_a(i,i1)
#
      served Liaai(i,a,a1,i1) 
      temp T1iaai(i,a,a1,i1) 
      served Ljbbj(j,b,b1,j1) 
      served Liabj(i,a,b,j) 
      temp Lbjai(b,j,a,i) 
      temp Tbjai(b,j,a,i) 
      served Ljbai(j,b,a,i) 
      temp Tjbai(j,b,a,i) 
      temp Taaaa(a,a1,a2,a3) 
      temp T1aaaa(a,a1,a2,a3) 
      temp Taabb(a,a1,b,b1) 
      temp T1aabb(a,a1,b,b1) 
      temp Tbbbb(b,b1,b2,b3) 
      temp T1bbbb(b,b1,b2,b3) 
      temp Tiiii(i,i1,i2,i3) 
      temp T1iiii(i,i1,i2,i3) 
      temp Tiijj(i,i1,j,j1) 
      temp T1iijj(i,i1,j,j1) 
      temp Tjjjj(j,j1,j2,j3) 
      temp T1jjjj(j,j1,j2,j3) 
      temp Tiiaa(i,i1,a,a1) 
      temp TAiiaa(i,i1,a,a1) 
      temp T1iiaa(i,i1,a,a1) 
      temp T2iiaa(i,i1,a,a1) 
      temp T1iibb(i,i1,b,b1) 
      temp T2iibb(i,i1,b,b1) 
      temp TAiibb(i,i1,b,b1) 
      temp Tjjaa(j,j1,a,a1) 
      temp T1jjaa(j,j1,a,a1) 
      temp T2jjaa(j,j1,a,a1) 
      temp TAjjaa(j,j1,a,a1) 
      temp Tjjbb(j,j1,b,b1) 
      temp TAjjbb(j,j1,b,b1) 
      temp T1jjbb(j,j1,b,b1) 
      temp T2jjbb(j,j1,b,b1) 
      temp T1iabj(i,a,b,j) 
      temp T1jbai(j,b,a,i) 
      temp T1bjia(b,j,i,a) 
      temp Tiaii(i,a,i1,i2) 
      temp Tjbjj(j,b,j1,j2) 
      temp Tiajj(i,a,j,j1) 
      temp T1aaai(a,a1,a2,i) 
      temp T1aabj(a,a1,b,j) 
      temp T1bbai(b,b1,a,i) 
      temp T1bbbj(b,b1,b2,j) 
      temp Tiiia(i,i1,i2,a) 
      temp T1iiia(i,i1,i2,a) 
      temp  Tiijb(i,i1,j,b) 
      temp T1iijb(i,i1,j,b) 
      temp  Tjjia(j,j1,i,a) 
      temp T1jjia(j,j1,i,a) 
      temp  Tjjjb(j,j1,j2,b) 
      temp T1jjjb(j,j1,j2,b) 
      temp  Tijab(i,j,a,b) 
      temp T1ijab(i,j,a,b) 
      temp T2ijab(i,j,a,b) 
      temp  Tijaj(i,j,a,j1) 
      temp  Tabab(a,b,a1,b1) 
      temp T1abab(a,b,a1,b1) 
      temp  Tijij(i,j,i1,j1) 
      temp T1ijij(i,j,i1,j1) 
      temp  Tjbia(j,b,i,a) 
      temp T1jbia(j,b,i,a) 
      temp  Tabaj(a,b,a1,j) 
      temp  Tabij(a,b,i,j) 
      temp T1abaj(a,b,a1,j) 
      temp  Tbabi(b,a,b1,i) 
      temp T1babi(b,a,b1,i) 
      temp  Tijib(i,j,i1,b) 
      temp T1ijib(i,j,i1,b) 
      temp  Tjija(j,i,j1,a) 
      temp T1jija(j,i,j1,a) 
      temp  Tjaib(j,a,i,b) 
      temp  Tibja(i,b,j,a) 
      temp  Tibaj(i,b,a,j) 
      temp  Tjaaj(j,a,a1,j1) 
      temp  Tbibi(b,i1,b1,i) 
      temp  Lbibi(b,i1,b1,i) 
      temp  Tajaj(a,j1,a1,j)  
      temp  Lajaj(a,j1,a1,j) 
      temp  Tbaji(b1,a,j,i1)  
      temp  Tjibi(j,i1,b,i)   
#
      temp Zaa(lambda,i,a1,i1) 
      temp ZZaa(lambda,i,sigma,i1)  
      temp Zbb(lambda,j,b1,j1) 
      temp ZZbb(lambda,j,sigma,j1)  
      temp Zab(lambda,i,b1,j1) 
      temp ZZab(lambda,i,sigma,j1)  
#
      temp Qaa(i,lambda,i1,a1) 
      temp QQaa(i,lambda,i1,sigma) 
      temp Qbb(j,lambda,j1,b1)
      temp QQbb(j,lambda,j1,sigma) 
      temp  Qab(i,lambda,j,b) 
      temp QQab(i,lambda,j,sigma) 
#
# Intermediate arrays
# -------------------
#
      distributed Iij_aa(i,i1)
      distributed Iab_aa(a,a1)
      distributed Iai_aa(a,i)
      distributed Iia_aa(i,a)
      distributed Xai_aa(a,i)
#
# Arrays used in 'direct' computations 
# ------------------------------------ 
#
      temp T1xixi(mu,i,nu,i1) 
      served Ixixi(mu,i,nu,i1) 
      served I1xixi(mu,i,nu,i1) 
      temp T1xjxj(mu,j,nu,j1) 
      served Ixjxj(mu,j,nu,j1) 
      served I1xjxj(mu,j,nu,j1) 
      temp Txixj(mu,i,nu,j) 
      served Ixixj(mu,i,nu,j) 
      served I1xixj(mu,i,nu,j) 
#
      temp  Txiai(lambda,i,a1,i1)  
      temp T1xiai(lambda,i,a1,i1)  
      temp  Txjbj(lambda,j,b1,j1)  
      temp T1xjbj(lambda,j,b1,j1)  
      temp  Txibj(lambda,i,b1,j1)  
      temp Txabi(mu,a,b,i) 
      temp Txbaj(mu,b,a1,j) 
      temp Txxbi(mu,nu,b,i) 
      temp Txxaj(mu,nu,a,j) 
      temp  Txi(mu,i) 
      temp T1xi(mu,i) 
      temp  Txj(mu,j) 
      temp T1xj(mu,j) 
      temp Jxi(mu,i) 
      temp Jxj(mu,j) 
      temp Jxa(mu,a) 
      temp Jxb(mu,b) 
      temp Ixa(mu,a) 
      temp Ixb(mu,b) 
      temp Ixx(mu,nu) 
      temp I1xx(mu,nu) 
#
      served  Iaiai(a,i,a1,i1) 
      served I1aiai(a,i,a1,i1) 
      served  Ibjbj(b,j,b1,j1) 
      served I1bjbj(b,j,b1,j1) 
      served  Iaibj(a,i,b,j) 
      served I1aibj(a,i,b,j) 
      served  Ixxai(mu,nu,a,i) 
      served  Ixxbj(mu,nu,b,j) 
      served Ixabi(mu,a,b,i) 
      served Ixxbi(mu,nu,b,i) 
      served Ixxaj(mu,nu,a,j) 
      served Ixxxi(mu,nu,lambda,i)
      served Jxxxi(mu,nu,lambda,i)
      
      distributed IIxi(mu,i)
      distributed JJxi(mu,i)
#
      distributed  Ixi(mu,i) 
      distributed I1xi(mu,i) 
      distributed  Ixj(mu,j) 
      distributed I1xj(mu,j) 
#
# Arrays and scalars  used in iterative computation of Dai 
# -------------------------------------------------------- 
#
      distributed Doldai_a(a,i) 
      distributed Dnewai_a(a,i) 
#
      distributed D0ai(a,i)
      distributed D1ai(a,i)
      distributed D2ai(a,i)
      distributed D3ai(a,i)
      distributed D4ai(a,i)
#
      distributed e1ai(a,i)
      distributed e2ai(a,i)
      distributed e3ai(a,i)
      distributed e4ai(a,i)
      distributed e5ai(a,i)
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410
#
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510
#
       scalar b66
       scalar b67
       scalar b68
       scalar b69
       scalar b610
#
       scalar b77
       scalar b78
       scalar b79
       scalar b710
#
       scalar b88
       scalar b89
       scalar b810
#
       scalar b99
       scalar b910
#
       scalar b1010
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510
#
       scalar Tb66
       scalar Tb67
       scalar Tb68
       scalar Tb69
       scalar Tb610
#
       scalar Tb77
       scalar Tb78
       scalar Tb79
       scalar Tb710
#
       scalar Tb88
       scalar Tb89
       scalar Tb810
#
       scalar Tb99
       scalar Tb910
#
       scalar Tb1010
#
       scalar c1
       scalar c2
       scalar c3
       scalar c4
       scalar c5
       scalar c6
       scalar c7
       scalar c8
       scalar c9
       scalar c10
#

#
# Define scalar quantities 
# ------------------------ 
#
      scalar etemp 
      scalar esum 
      scalar eacbd 
      scalar eold
      scalar enew 
      scalar ecrit 
      scalar ediff
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC READ_2EL
#
#    ------------------------------------------------------------------------
#
      execute server_barrier
      execute list_to_blocks                VSpipi
      execute list_to_blocks                Vaaii
      execute list_to_blocks                Viaai
      execute list_to_blocks                Vaabj
      execute list_to_blocks                Vpiqj
      execute server_barrier 
#
#    ------------------------------------------------------------------------
#
     ENDPROC READ_2EL
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------ 
# 
         PROC CREATE1ARRAY 
# 

              CREATE Dij_a
              CREATE Dab_a
#
              CREATE DOR_ii 
              CREATE DOR_aa 
#
              CREATE Iij_aa
              CREATE Iab_aa
              CREATE Xai_aa
              CREATE Iai_aa
              CREATE Iia_aa
# 
         ENDPROC CREATE1ARRAY 
#
# PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
#
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
#
# --------------------------------------------------------------------------- 
#
# In this PROCEDURE the D^{ij}_{ab} block of the two-particle 
# density matrix is formed. Only the AA spin case is considered.  
#
# --------------------------------------------------------------------------- 
#
#
      PROC DIJABAA 
#     ------------- 
#
# Terms 1-5 in Eq. 33 
# ------------------- 
#
      PARDO a, a1, i, i1 
#
            REQUEST T2old_aa(a,i,a1,i1)   a1  
#
            Tiiaa(i,i1,a,a1)  = T2old_aa(a,i,a1,i1) 
            Tiiaa(i,i1,a,a1) *= 0.25
#            
            PREPARE Dijab_aa(i,i1,a,a1) += Tiiaa(i,i1,a,a1) 
#
      ENDPARDO a, a1, i, i1
      execute server_barrier 
#
# Compute contributions to one-particle intermediates 
# ---------------------------------------------------
#
# First-term of Iij_aa 
# --------------------
#
      PARDO i2, a1, a, i
#
           REQUEST VSpipi(a,i2,a1,i) i
           Tpppp(i2,a1,a,i)  = VSpipi(a,i2,a1,i)
#
           DO i1
#
              REQUEST Dijab_aa(i1,i2,a1,a) a 
#
              Tpp(i1,i)         = Dijab_aa(i1,i2,a1,a)*Tpppp(i2,a1,a,i)
              Tii(i,i1)         = Tpp(i1,i)   
              Tii(i,i1)        *= -2.0  
              PUT Iij_aa(i,i1) += Tii(i,i1)
#
           ENDDO i1
#
      ENDPARDO i2, a1, a, i
#
# First-term of Iab_aa
# --------------------
#
      PARDO a, a2, i, i1
#
            REQUEST VSpipi(a,i,a2,i1) i1  
#
            DO a1
#
               REQUEST Dijab_aa(i,i1,a1,a2) a2 
               tpppp(i,a2,i1,a1) = Dijab_aa(i,i1,a1,a2) 
#
              #Taa(a,a1)         = VSpipi(a,i,a2,i1)*Dijab_aa(i,i1,a1,a2)
               Taa(a,a1)         = VSpipi(a,i,a2,i1)*tpppp(i,a2,i1,a1)
               Taa(a,a1)        *= -2.0  
               PUT Iab_aa(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
      ENDPARDO a, a2, i, i1
#
# First-term of Iai_aa
# --------------------
#
      PARDO a, a1, a2, i1
#
            REQUEST VSaaai(a1,a,a2,i1) i1  
            Tpppp(i1,a1,a2,a)  = VSaaai(a1,a,a2,i1)
#
            DO i
#
               REQUEST Dijab_aa(i,i1,a1,a2) a2 
#
               Tpp(i,a)         = Dijab_aa(i,i1,a1,a2)*Tpppp(i1,a1,a2,a)
               Tai(a,i)         = Tpp(i,a)   
               Tai(a,i)        *= 2.0  
               PUT Iai_aa(a,i) += Tai(a,i)
#
            ENDDO i
#
      ENDPARDO a, a1, a2, i1
#
# First-term of Iia_aa
# --------------------
# 
      PARDO a, a1, i2, i1
#
            REQUEST Dijab_aa(i2,i1,a,a1) a1 
            tpppp(i2,a1,i1,a) = Dijab_aa(i2,i1,a,a1) 
#
            DO i
#
              #REQUEST VSpipi(a1,i1,i,i2) i2  
               REQUEST VSpipi(i,i2,a1,i1) i2  
#
              #Tia(i,a)           = VSpipi(a1,i1,i,i2)*Dijab_aa(i2,i1,a,a1)
               Tia(i,a)           = VSpipi(i,i2,a1,i1)*tpppp(i2,a1,i1,a)
               Tia(i,a)          *= -2.0  
               PUT Iia_aa(i,a)   += Tia(i,a)
#
            ENDDO i
#
      ENDPARDO a, a1, i2, i1
#
# Done contributions to one-particle intermediates 
# ------------------------------------------------ 
      execute sip_barrier 
#
# --------------------------------------------------------------------------- 
#
      ENDPROC DIJABAA 
#
# --------------------------------------------------------------------------- 
#
#
# --------------------------------------------------------------------------- 
#
# In this PROCEDURE the D^{ij}_{ab} clock of the two-particle 
# density matrix is formed.  
#
# --------------------------------------------------------------------------- 
#
# First form one-particle intermediates 
#
# --------------------------------------------------------------------------- 
#
# Dim(i,m) = Gmi_a(i,m) + l1a_old(m,e)*t1a_old(e,i)  
#
# Dea(e,a) = Gae_a(e,a) - l1a_old(m,e)*t1a_old(a,m) 
#
# --------------------------------------------------------------------------- 
#
      PROC DIJABAB 
#     ------------- 
#
# One-particle intermediates computed in AA/BB blocks  
# ---------------------------------------------------  
#
# Terms 1-5 in Eq. 33 
# ------------------- 
#
      PARDO a, b, i, j 
#
            REQUEST T2old_ab(a,i,b,j)   b  
#
            Tijab(i,j,a,b)  = T2old_ab(a,i,b,j) 
            Tijab(i,j,a,b) *= 0.25
#            
            PREPARE Dijab_ab(i,j,a,b) += Tijab(i,j,a,b) 
#
      ENDPARDO a, b, i, j 
      
      execute server_barrier
#
#
# Compute contributions to one-particle intermediates 
# --------------------------------------------------- 
#
# First-term of Iij_aa 
# --------------------
#
      PARDO j, a, b, i
#
           REQUEST Vpiqj(a,i,b,j) j
           Tpppp(j,a,b,i) = Vpiqj(a,i,b,j) 
#
           DO i1
#
              REQUEST Dijab_ab(i1,j,a,b) b 
#
             #Tii(i,i1)         = Dijab_ab(i1,j,a,b)*Vpiqj(a,i,b,j)
              Tpp(i1,i)         = Dijab_ab(i1,j,a,b)*Tpppp(j,a,b,i)
              Tii(i,i1)         = Tpp(i1,i)   
              Tii(i,i1)        *= -4.0  
              PUT Iij_aa(i,i1) += Tii(i,i1)
#
           ENDDO i1
#
      ENDPARDO j, a, b, i
#
# First-term of Iab_aa
# --------------------
#
      PARDO a, b, i, j
#
            REQUEST Vpiqj(a,i,b,j) j
#
            DO a1
#
               REQUEST Dijab_ab(i,j,a1,b) b 
               Tpppp(i,b,j,a1) = Dijab_ab(i,j,a1,b) 
#
              #Taa(a,a1)         = Vpiqj(a,i,b,j)*Dijab_ab(i,j,a1,b)
               Taa(a,a1)         = Vpiqj(a,i,b,j)*Tpppp(i,b,j,a1)
               Taa(a,a1)        *= -4.0  
               PUT Iab_aa(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
      ENDPARDO a, b, i, j
#
# First-term of Iai_aa 
# -------------------- 
#
      PARDO a, a1, b, j
#
            REQUEST Vaabj(a1,a,b,j) j
            Tqpqp(j,a1,b,a)  = Vaabj(a1,a,b,j)
#
            DO i
#
               REQUEST Dijab_ab(i,j,a1,b) b 
#
               Tpp(i,a)         = Dijab_ab(i,j,a1,b)*Tqpqp(j,a1,b,a)
               Tai(a,i)         = Tpp(i,a)   
               Tai(a,i)        *= 4.0  
               PUT Iai_aa(a,i) += Tai(a,i)
#
            ENDDO i
#
      ENDPARDO a, a1, b, j
#
# First-term of Iia_aa 
# -------------------- 
#
      PARDO a, b, i1, j
#
            REQUEST Dijab_ab(i1,j,a,b) b 
            Tpppp(i1,b,j,a) = Dijab_ab(i1,j,a,b) 
#
            DO i
#
               REQUEST Vpiqj(i,i1,b,j) j
#
              #Tia(i,a)         = Vpiqj(i,i1,b,j)*Dijab_ab(i1,j,a,b)
               Tia(i,a)         = Vpiqj(i,i1,b,j)*tpppp(i1,b,j,a)
               Tia(i,a)        *= -4.0 
               PUT Iia_aa(i,a) += Tia(i,a)
#
            ENDDO i
#
      ENDPARDO a, b, i1, j
#
# Done contributions to one-particle intermediates 
# ------------------------------------------------ 
      execute sip_barrier 
#
# --------------------------------------------------------------------------- 
#
      ENDPROC DIJABAB 
#
# --------------------------------------------------------------------------- 
#
# --------------------------------------------------------------------------- 
#
      PROC DIJAB 
#     ----------- 
#
# Create gamma arrays and one-particle intermediates 
# Note that Dii and Daa are computed in DIJABAA and 
# Djj and Dbb are computed in DIJABBB. 
# -------------------------------------------------- 
#
#
           CALL DIJABAA 
           CALL DIJABAB 
           execute sip_barrier 
           execute server_barrier 
#
      ENDPROC DIJAB 
#     ------------- 
#
# --------------------------------------------------------------------------- 
#
#
# -----------------------------------------------------------------------------
#
# Expression programmed: Equivalent to gamma2.  
#
# D^{ab}_{cd} = 1/16 P_+(ab,cd) \T2old^{ab}_{ij} \lambda^{ij}_{cd} 
# 4* D is stored to be consistent with acess 
#
# -----------------------------------------------------------------------------
#
      PROC DABCDAA 
#     ------------- 
# 
      PARDO a, a1, a2, a3 
#
            Dabcd_aa(a,a1,a2,a3)  = 0.0   
#
            DO i 
            DO i1 
#
               REQUEST T2old_aa(a,i,a1,i1)    i1
               Taaii(a,a1,i,i1)  = T2old_aa(a,i,a1,i1)  
               REQUEST T2old_aa(a2,i,a3,i1) a3  
               Tiiaa(i,i1,a2,a3) = T2old_aa(a2,i,a3,i1)
#
               Taaaa(a,a1,a2,a3)      = Taaii(a,a1,i,i1)*Tiiaa(i,i1,a2,a3)
               Taaaa(a,a1,a2,a3)	 *= 0.5
               
               Dabcd_aa(a,a1,a2,a3) += Taaaa(a,a1,a2,a3)
#
            ENDDO i1 
            ENDDO i 
#
# Compute contributions to one-particle intermediates 
# --------------------------------------------------- 
#
#           Second-term of Iia_aa 
#           --------------------- 
#
            tpppp(a,a3,a1,a2) = Dabcd_aa(a,a1,a2,a3) 
            DO i
#
               REQUEST VSaaai(a3,a1,a2,i) i
#
              #Tia(i,a)           = Dabcd_aa(a,a1,a2,a3)*Tpppp(a1,a2,a3,i)
               tpp(a,i)           = tpppp(a,a3,a1,a2)*VSaaai(a3,a1,a2,i)  
               Tia(i,a)           = tpp(a,i)   
               Tia(i,a)          *= -0.5  
               PUT Iia_aa(i,a)   += Tia(i,a)
#
            ENDDO i
#
# Done contributions to one-particle intermediates 
# ------------------------------------------------ 
#
      ENDPARDO a, a1, a2, a3 
#
      ENDPROC DABCDAA 
#     ---------------- 
# 
# -----------------------------------------------------------------------------
#
# Expression programmed: 
#
# D^{aB}_{cD} = 1/8 P_+(aB,cD) \T2old^{aB}_{iJ} \lambda^{iJ}_{cD} 
# 4* D is stored to be consistent with acess 
#
# -----------------------------------------------------------------------------
#
      PROC DABCDAB 
#     ------------- 
# 
      PARDO a, b, a1, b1 
#
            Dabcd_ab(a,b,a1,b1)  = 0.0  
#
            DO i 
            DO j 
#
               REQUEST T2old_ab(a,i,b,j)     j 
               Tabij(a,b,i,j)        = T2old_ab(a,i,b,j)  
               REQUEST T2old_ab(a1,i,b1,j) b1  
               Tijab(i,j,a1,b1)      = T2old_ab(a1,i,b1,j) 
# 
               Tabab(a,b,a1,b1)      = Tabij(a,b,i,j)*Tijab(i,j,a1,b1) 
#
               Tabab(a,b,a1,b1)     *= 1.0 
#               T1abab(a1,b1,a,b)     = Tabab(a,b,a1,b1)  
#
                Dabcd_ab(a,b,a1,b1) += Tabab(a,b,a1,b1)   
#
            ENDDO j 
            ENDDO i 
#
# Compute contributions to one-particle intermediates 
# --------------------------------------------------- 
#
#           Second-term of Iia_aa 
#           --------------------- 
#
            tpppp(a,b1,b,a1) = Dabcd_ab(a,b,a1,b1) 
            DO i
#
               REQUEST Vaabj(b1,b,a1,i) i 
#
              #Tia(i,a)          = Dabcd_ab(a,b,a1,b1)*Vaabj(b1,b,a1,i) 
               Tpp(a,i)          = tpppp(a,b1,b,a1)*Vaabj(b1,b,a1,i) 
               Tia(i,a)          = tpp(a,i)  
               Tia(i,a)         *= -1.0
               PUT Iia_aa(i,a)  += Tia(i,a)
#               
            ENDDO i
#
# Done contributions to one-particle intermediates 
# ------------------------------------------------ 
#
      ENDPARDO a, b, a1, b1 
#
      ENDPROC DABCDAB 
#     ---------------- 
# 
      PROC DABCD 
#     ---------- 
#
# Create gamma arrays 
# ------------------- 
#
           CALL DABCDAA 
           CALL DABCDAB 
# 
      ENDPROC DABCD 
#     -------------  
#
# ---------------------------------------------------------------------------- 
#
# Expression programmed: 
#
# D^{ij}_{kl} = 1/16 P_+(ij,kl) \lambda^{ij}_{ef} \T2old^{ef}_{kl} 
# Note that 4* result is kept to be consistent with aces. 
#
# Equivalent to gamma3 
#
# ---------------------------------------------------------------------------- 
#
      PROC DIJKLAAAA 
#     -------------- 
#
      PARDO a, a1, i, i1  
#
            REQUEST T2old_aa(a,i,a1,i1) a1  
            Tiiaa(i,i1,a,a1) = T2old_aa(a,i,a1,i1)  
#
            DO i2 
            DO i3 
#
               REQUEST T2old_aa(a,i2,a1,i3) i3  
               Taaii(a,a1,i2,i3) = T2old_aa(a,i2,a1,i3) 
#
               Tiiii(i,i1,i2,i3)           = Tiiaa(i,i1,a,a1)*Taaii(a,a1,i2,i3)  
#
               Tiiii(i,i1,i2,i3)          *= 0.5  
               PREPARE Dijkl_aa(i,i1,i2,i3)   += Tiiii(i,i1,i2,i3) 
            ENDDO i3 
            ENDDO i2 
#
      ENDPARDO a, a1, i, i1  
      execute sip_barrier 
      execute server_barrier 
#
# Compute contributions to intermediates 
# -------------------------------------- 
#
#     Part of the Second-term of Iij_aa
#     ---------------------------------
#
      PARDO i2, i3, i4, i
#
            REQUEST VSpipi(i3,i,i4,i2) i2  
            Tpppp(i2,i3,i4,i)  = VSpipi(i3,i,i4,i2)
#
            DO i1
#
               REQUEST Dijkl_aa(i1,i2,i3,i4) i4 
#
               Tpp(i1,i)         = Dijkl_aa(i1,i2,i3,i4)*Tpppp(i2,i3,i4,i)
               Tii(i,i1)         = Tpp(i1,i)  
               Tii(i,i1)        *= -0.5
               PUT Iij_aa(i,i1) += Tii(i,i1)
#
            ENDDO i1
#
      ENDPARDO i2, i3, i4, i
#
#     Part of the Second-term of Iai_aa
#     ---------------------------------
#
      PARDO a, i2, i3, i1
#
            REQUEST VSpipi(i3,i2,a,i1) i1  
            Tpppp(i3,i1,i2,a)  = VSpipi(i3,i2,a,i1)
#
            DO i
#
               REQUEST Dijkl_aa(i,i3,i1,i2) i2 
#
               Tpp(i,a)         = Dijkl_aa(i,i3,i1,i2)*Tpppp(i3,i1,i2,a)
               Tai(a,i)         = Tpp(i,a)  
               Tai(a,i)        *= 0.5
               PUT Iai_aa(a,i) += Tai(a,i)
#
            ENDDO i
#
      ENDPARDO a, i2, i3, i1
#
# Done one-particle contributions 
# ------------------------------- 
#
# Remove density component
# ------------------------ 
      execute sip_barrier 
#
      ENDPROC DIJKLAAAA 
#     ----------------- 
#
# ---------------------------------------------------------------------------- 
#
# Expression programmed: 
#
# D^{iJ}_{kL} = 1/8 P_+(iJ,kL) \lambda^{iJ}_{eF} \T2old^{eF}_{kL} 
#
# ---------------------------------------------------------------------------- 
#
      PROC DIJKLABAB 
#     -------------- 
#
      PARDO a, b, i, j  
#
            REQUEST T2old_ab(a,i,b,j) b
            Tijab(i,j,a,b) = T2old_ab(a,i,b,j) 
#
            DO i1 
            DO j1 
#
               REQUEST T2old_ab(a,i1,b,j1) j1  
               Tabij(a,b,i1,j1) = T2old_ab(a,i1,b,j1) 
#
               Tijij(i,j,i1,j1)           = Tijab(i,j,a,b)*Tabij(a,b,i1,j1)   
#
               PREPARE Dijkl_ab(i,j,i1,j1)   += Tijij(i,j,i1,j1) 
            ENDDO j1 
            ENDDO i1 
#
      ENDPARDO a, b, i, j  
      execute sip_barrier 
      execute server_barrier 
#
# Compute contributions to intermediates 
# -------------------------------------- 
#
# Part of the second-term of Iij_aa
# ---------------------------------
#
      PARDO j1, i2, j, i
#
            REQUEST            Vpiqj(i2,i,j,j1) j
            tpppp(j1,i2,j,i) = Vpiqj(i2,i,j,j1) 
#
            DO i1
#
               REQUEST Dijkl_ab(i1,j1,i2,j) j 
#
              #Tii(i,i1)         = Dijkl_ab(i1,j1,i2,j)*Vpiqj(i2,i,j,j1) 
               Tpp(i1,i)         = Dijkl_ab(i1,j1,i2,j)*tpppp(j1,i2,j,i) 
               Tii(i,i1)         =Tpp(i1,i)  
               Tii(i,i1)        *= -1.0
               PUT Iij_aa(i,i1) += Tii(i,i1)
#
            ENDDO i1
#
      ENDPARDO j1, i2, j, i
#
# Part of the Second-term of Iai_aa
# ---------------------------------
#
      PARDO a, j1, j, i1
#
            REQUEST Vpiqj(a,i1,j,j1) j1 
            Tqpqp(j,i1,j1,a)  = Vpiqj(a,i1,j,j1)
#
            DO i
#
               REQUEST Dijkl_ab(i,j,i1,j1) j1 
#
               Tpp(i,a)         = Dijkl_ab(i,j,i1,j1)*Tqpqp(j,i1,j1,a)
               Tai(a,i)         = Tpp(i,a) 
               PUT Iai_aa(a,i) += Tai(a,i)
#
            ENDDO i
#
      ENDPARDO a, j1, j, i1
#
# Done one-particle contributions 
# ------------------------------- 
#
# Remove density component
# ------------------------ 
      execute sip_barrier 
#
      ENDPROC DIJKLABAB 
#     ----------------- 
#
# ---------------------------------------------------------------------------- 
#
      PROC DIJKL 
#     ---------- 
#
      CALL DIJKLAAAA 
      CALL DIJKLABAB 
#
      ENDPROC DIJKL 
#     ------------- 
#
# ---------------------------------------------------------------------------- 
#
# Equivalent to gamma4*4 --> factor of 4 to match aces  
#
# ----------------------------------------------------------------------------
#
      PROC DIBJAAAAA 
#     -------------- 
#
      PARDO a, i, a2, i2  
#
            REQUEST     T2old_aa(a,i,a2,i2) i2  
            Tiaai(i2,a2,a,i)               = T2old_aa(a,i,a2,i2)
#
            DO i1  
#
               DO a1 
#
                  REQUEST                          T2old_aa(a1,i1,a2,i2) i2
#
                  T1iaai(i1,a1,a,i)              = T2old_aa(a1,i1,a2,i2)*Tiaai(i2,a2,a,i)  
                  Tiaia(i,a1,i1,a)               = T1iaai(i1,a1,a,i)  
                  PREPARE Dibja_aaaa(i,a1,i1,a) += Tiaia(i,a1,i1,a)  
#
               ENDDO a1 
            ENDDO i1 
#
      ENDPARDO a, i, a2, i2  
#
      PARDO a, i, b, j  
#
            REQUEST T2old_ab(a,i,b,j)j  
            Tjbia(j,b,i,a)                 = T2old_ab(a,i,b,j)
            
#
            DO i1 
            DO a1 
#
               REQUEST                          T2old_ab(a1,i1,b,j) a1  
# 
               T2iaia(i1,a1,i,a)              = T2old_ab(a1,i1,b,j)*Tjbia(j,b,i,a)  
               Tiaia(i,a1,i1,a)               = T2iaia(i1,a1,i,a)  
#
               PREPARE Dibja_aaaa(i,a1,i1,a) += Tiaia(i,a1,i1,a)   
#
            ENDDO a1  
            ENDDO i1 
#
      ENDPARDO a, i, b, j  
      execute server_barrier 
#
# Compute contributions to one-particle intermediates 
# --------------------------------------------------- 
#
#     Third-term of Iij_ii
#     --------------------
#
      PARDO i, a, i2, a1
#
            REQUEST Vaaii(a1,a,i2,i) i
            REQUEST Viaai(i2,a,a1,i) i
#
            Tpppp(a,i2,a1,i)  = Vaaii(a1,a,i2,i)
            T1pppp(a,i2,a1,i) = Viaai(i2,a,a1,i)
            Tpppp(a,i2,a1,i) -= T1pppp(a,i2,a1,i)
#
            DO i1
#
               REQUEST Dibja_aaaa(i1,a,i2,a1) a1 
#
               Tpp(i1,i)         = Dibja_aaaa(i1,a,i2,a1)*Tpppp(a,i2,a1,i)
               Tii(i,i1)         = Tpp(i1,i) 
               PUT Iij_aa(i,i1) += Tii(i,i1)
#
            ENDDO i1
#
      ENDPARDO i, a, i2, a1
#
#     Third-term of Iab_aa
#     --------------------
#
      PARDO a, a2, i, i1
#
            REQUEST             Vaaii(a2,a,i1,i) i
            REQUEST             Viaai(i1,a,a2,i) i
            Tpppp(a,a2,i1,i)  = Vaaii(a2,a,i1,i)
            T1pppp(a,a2,i1,i) = Viaai(i1,a,a2,i)
            Tpppp(a,a2,i1,i) -= T1pppp(a,a2,i1,i)
#
            DO a1
#
               REQUEST              Dibja_aaaa(i,a1,i1,a2) a2 
               t1pppp(a2,i1,i,a1) = Dibja_aaaa(i,a1,i1,a2)  
#
              #Taa(a,a1)         = Tpppp(a,a2,i1,i)*Dibja_aaaa(i,a1,i1,a2)
               Taa(a,a1)         = Tpppp(a,a2,i1,i)*t1pppp(a2,i1,i,a1)
               PUT Iab_aa(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
      ENDPARDO a, a2, i, i1
#
#     Fifth-term of Iai_aa
#     --------------------
#
      PARDO a, a1, i1, a2
#
            REQUEST VSaaai(a1,a2,a,i1) i1  
            Tpppp(a1,i1,a2,a)  = VSaaai(a1,a2,a,i1)
#
            DO i
#
               REQUEST Dibja_aaaa(i,a1,i1,a2) a2 
#
               Tpp(i,a)         = Dibja_aaaa(i,a1,i1,a2)*Tpppp(a1,i1,a2,a)
               Tai(a,i)         = Tpp(i,a) 
               Tai(a,i)        *= -1.0  
               PUT Iai_aa(a,i) += Tai(a,i)
#
            ENDDO i
#
      ENDPARDO a, a1, i1, a2
#
#     Third-term of Iia_aa
#     --------------------
#
      PARDO a, a1, i1, i2
#
            REQUEST             Dibja_aaaa(i1,a,i2,a1) a1 
            tpppp(a,i2,i1,a1) = Dibja_aaaa(i1,a,i2,a1) 
            DO i
#
               REQUEST            VSpipi(i2,i1,a1,i) i
              #Tia(i,a)         = Dibja_aaaa(i1,a,i2,a1)*VSpipi(i2,i1,a1,i)
               Tpp(a,i)         = tpppp(a,i2,i1,a1)*VSpipi(i2,i1,a1,i)
               Tia(i,a)         = Tpp(a,i) 
               PUT Iia_aa(i,a) += Tia(i,a)
#
            ENDDO i
#
      ENDPARDO a, a1, i1, i2
#
# Done one-particle intermediate contributions 
# -------------------------------------------- 
      execute sip_barrier 
#
      ENDPROC DIBJAAAAA 
#     ------------------ 
#
# The D(iB,jA) block of the two-particle density matrix is calculated. 
#
      PROC DIBJAABAB 
#     -------------- 
#
      PARDO i, b1, j, a  
#
            REQUEST T2old_ab(a,i,b1,j) j  
            Taibj(a,i,b1,j) = T2old_ab(a,i,b1,j)
#
            DO i1 
            DO b 
#
               REQUEST                          T2old_ab(a,i1,b,j) j 
#
               Tibib(i1,b1,i,b)               = T2old_ab(a,i1,b,j)*Taibj(a,i,b1,j) 
               PREPARE Dibja_abab(i1,b1,i,b) += Tibib(i1,b1,i,b) 
#
            ENDDO b 
            ENDDO i1 
#
      ENDPARDO i, b1, j, a  
#
      execute sip_barrier 
      execute server_barrier 
#
# Compute contributions to one-particle intermediates 
# ---------------------------------------------------
#
# Third-term of Iij_aa 
# --------------------
#
      PARDO i1, b, i2, b1
#
            REQUEST Dibja_abab(i1,b,i2,b1) b1 
            tpppp(i1,b1,b,i2) = Dibja_abab(i1,b,i2,b1) 
#
            DO i
#
               REQUEST Vaaii(b1,b,i2,i) b  
#
              #Tii(i,i1)         = Dibja_abab(i1,b,i2,b1)*Vaaii(b1,b,i2,i)
               Tpp(i1,i)         = tpppp(i1,b1,b,i2)*Vaaii(b1,b,i2,i)
               Tii(i,i1)         = Tpp(i1,i) 
               PUT Iij_aa(i,i1) += Tii(i,i1)
#
            ENDDO i
#
      ENDPARDO i1, b, i2, b1
#
# Fifth-term of Iai_aa 
# -------------------- 
#
      PARDO a, b, i1, b1
#
            REQUEST Vaabj(b,b1,a,i1) i1 
            Tqpqp(b,i1,b1,a)  = Vaabj(b,b1,a,i1)
#
            DO i
#
               REQUEST Dibja_abab(i,b,i1,b1) b1 
#
               Tpp(i,a)         = Dibja_abab(i,b,i1,b1)*Tqpqp(b,i1,b1,a)
               Tai(a,i)         = Tpp(i,a)   
               Tai(a,i)        *= -1.0  
               PUT Iai_aa(a,i) += Tai(a,i)
#
            ENDDO i
#
      ENDPARDO a, b, i1, b1 
#
# Done contribution to intermediates 
# ---------------------------------- 
      execute sip_barrier 
#
      ENDPROC DIBJAABAB 
#     ------------------ 
#
# The D(Ib,Ja) block of the two-particle density matrix is calculated. 
#
      PROC DIBJABABA 
#     --------------  
#
      PARDO a, j1, b, i  
#
            REQUEST T2old_ab(a,i,b,j1) j1  
            Tibaj(i,b,a,j1)                = T2old_ab(a,i,b,j1) 
#
            DO j  
            DO a1 
#
               REQUEST                          T2old_ab(a1,i,b,j) b   
#
               Tjaib(j,a1,i,b)                = T2old_ab(a1,i,b,j) 
               Tjaaj(j,a1,a,j1)               = Tjaib(j,a1,i,b)*Tibaj(i,b,a,j1) 
               Tjaja(j,a,j1,a1)               = Tjaaj(j,a1,a,j1) 
               PREPARE Dibja_baba(j,a,j1,a1) += Tjaja(j,a,j1,a1) 
#
            ENDDO a1  
            ENDDO j  
#
      ENDPARDO a, j1, b, i  
#
      execute sip_barrier 
      execute server_barrier 
#
# Compute contributions to one-particle intermediates 
# ---------------------------------------------------
#
#
# Third-term of Iab_aa 
# -------------------- 
#
      PARDO a, a2, j, j1
#
            REQUEST Vaaii(a2,a,j1,j) j1  
            t1pppp(a,a2,j1,j) = Vaaii(a2,a,j1,j) 
#
            DO a1
#
               REQUEST Dibja_baba(j,a1,j1,a2) a2 
               tpppp(a2,j1,j,a1) = Dibja_baba(j,a1,j1,a2) 
#
              #Taa(a,a1)         = Vaaii(a2,a,j1,j)*Dibja_baba(j,a1,j1,a2)
               Taa(a,a1)         = t1pppp(a,a2,j1,j)*tpppp(a2,j1,j,a1)  
               PUT Iab_aa(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
      ENDPARDO a, a2, j, j1
#
# Third-term of Iia_aa 
# -------------------- 
#
      PARDO a, a1, j, j1
#
            REQUEST             Dibja_baba(j,a,j1,a1) a1 
            t1pppp(a1,j1,j,a) = Dibja_baba(j,a,j1,a1) 
#
            DO i
#
               REQUEST Vpiqj(a1,i,j1,j) j 
               tpppp(i,a1,j1,j) = Vpiqj(a1,i,j1,j) 
#
              #Tia(i,a)         = Dibja_baba(j,a,j1,a1)*Vpiqj(a1,i,j1,j)
               Tia(i,a)         = tpppp(i,a1,j1,j)*t1pppp(a1,j1,j,a)  
               PUT Iia_aa(i,a) += Tia(i,a)
#
            ENDDO i
#
      ENDPARDO a, a1, j, j1
#
# Done one-particle intermediates 
# -------------------------------
#
      execute sip_barrier 
#
      ENDPROC DIBJABABA 
#     ------------------ 
#
#
      PROC DIBJAABBA 
#     --------------- 
#
      PARDO a, i, a1, i1  
#
            REQUEST T2old_aa(a,i,a1,i1) i1  
#
            DO j 
            DO b 
#
               REQUEST                        T2old_ab(a1,i1,b,j) i1  
               Taibj(a,i,b,j)               = T2old_aa(a,i,a1,i1)*T2old_ab(a1,i1,b,j)  
               Tibja(i,b,j,a)               = Taibj(a,i,b,j) 
               PREPARE Dibja_abba(i,b,j,a) += Tibja(i,b,j,a)  
#
            ENDDO b 
            ENDDO j 
#
      ENDPARDO a, i, a1, i1  
#
      PARDO a, i, b1, j1  
#
            REQUEST T2old_ab(a,i,b1,j1) j1  
#
            DO j 
            DO b 
#
               REQUEST                        T2old_aa(b1,j1,b,j) j1  
#
               Taibj(a,i,b,j)               = T2old_ab(a,i,b1,j1)*T2old_aa(b1,j1,b,j)
#
               Tibja(i,b,j,a)               = Taibj(a,i,b,j)  
               PREPARE Dibja_abba(i,b,j,a) += Tibja(i,b,j,a)  
#
            ENDDO b 
            ENDDO j  
#
      ENDPARDO a, i, b1, j1   
#
      execute sip_barrier 
      execute server_barrier 
#
# Compute contributions to one-particle intermediates 
# --------------------------------------------------- 
#
# Third-term of Iij_aa 
# -------------------- 
#
      PARDO i1, b, j, a
#
            REQUEST           Dibja_abba(i1,b,j,a) a 
            tpppp(a,b,j,i1) = Dibja_abba(i1,b,j,a) 
#
            DO i
#
               REQUEST Viaai(i,a,b,j) j 
#
              #Tii(i,i1)         = Dibja_abba(i1,b,j,a)*Viaai(i,a,b,j)
               Tii(i,i1)         = Viaai(i,a,b,j)*tpppp(a,b,j,i1)  
               Tii(i,i1)        *= -1.0  
               PUT Iij_aa(i,i1) += Tii(i,i1)
#
            ENDDO i
#
      ENDPARDO i1, b, j, a
#
# Fifth-term of Iai_aa
# -------------------- 
#
      PARDO a, b, j, a1
#
            REQUEST Vaabj(a,a1,b,j) j
            Tqqpp(b,j,a1,a) = Vaabj(a,a1,b,j)
#
            DO i
#
               REQUEST Dibja_abba(i,b,j,a1) a1 
#
              #Tai(a,i)         = Dibja_abba(i,b,j,a1)*Tqqpp(b,j,a1,a)
               Tpp(i,a)         = Dibja_abba(i,b,j,a1)*Tqqpp(b,j,a1,a)
               Tai(a,i)         = Tpp(i,a) 
               PUT Iai_aa(a,i) += Tai(a,i)
#
            ENDDO i
#
      ENDPARDO a, b, j, a1
#
# Done one-particle intermediates 
# -------------------------------
      execute sip_barrier 
#
      ENDPROC DIBJAABBA 
#     ------------------ 
# 
      PROC DIBJABAAB 
#     --------------- 
#
      PARDO j, b, i1, a1   
#
            REQUEST T2old_ab(a1,i1,b,j) i1 
#
            DO i
            DO a
#
               REQUEST                        T2old_aa(a1,i1,a,i) i1
#
               Tbjai(b,j,a,i)               = T2old_ab(a1,i1,b,j)*T2old_aa(a1,i1,a,i)
               Tjaib(j,a,i,b)               = Tbjai(b,j,a,i)
#
               PREPARE Dibja_baab(j,a,i,b) += Tjaib(j,a,i,b)
#
            ENDDO a
            ENDDO i
#
      ENDPARDO j, b, i1, a1  
#
      PARDO j, b, j1, b1   
#
            REQUEST T2old_aa(b,j,b1,j1) j1 
#
            DO i
            DO a
#
               REQUEST                        T2old_ab(a,i,b1,j1) j1
               Tbjai(b,j,a,i)                = T2old_aa(b,j,b1,j1)*T2old_ab(a,i,b1,j1)
               Tjaib(j,a,i,b)               = Tbjai(b,j,a,i)
               PREPARE Dibja_baab(j,a,i,b) += Tjaib(j,a,i,b)
#
            ENDDO a
            ENDDO i
#
      ENDPARDO j, b, j1, b1  
#
      execute server_barrier  
#
# Compute contributions to one-particle intermediates 
# --------------------------------------------------- 
#
# Third-term of Iab_aa 
# --------------------
#
      PARDO a, b, j, i
#
            REQUEST           Viaai(i,a,b,j) j
            t1pppp(j,i,b,a) = Viaai(i,a,b,j) 
#
            DO a1
#
               REQUEST             Dibja_baab(j,a1,i,b) b 
               tpppp(a1,j,i,b)   = Dibja_baab(j,a1,i,b) 
#
              #Taa(a,a1)         = Viaai(i,a,b,j)*Dibja_baab(j,a1,i,b)
               Tpp(a1,a)         = tpppp(a1,j,i,b)*t1pppp(j,i,b,a)  
               Taa(a,a1)         = Tpp(a1,a)   
               Taa(a,a1)        *= -1.0  
               PUT Iab_aa(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
      ENDPARDO a, b, j, i
#
# Third-term of Iia_aa
# --------------------
#
      PARDO a, b, j, i1
#
            REQUEST           Dibja_baab(j,a,i1,b) b 
            tpppp(i1,b,j,a) = Dibja_baab(j,a,i1,b) 
#
            DO i
#
               REQUEST            Vpiqj(i1,i,b,j) j 
               t1pppp(i,i1,b,j) = Vpiqj(i1,i,b,j) 
#
              #Tia(i,a)         = Dibja_baab(j,a,i1,b)*Vpiqj(i1,i,b,j)
               Tia(i,a)         = t1pppp(i,i1,b,j)*tpppp(i1,b,j,a) 
               Tia(i,a)        *= -1.0  
               PUT Iia_aa(i,a) += Tia(i,a)
#
            ENDDO i
#
      ENDPARDO a, b, j, i1
#
# Done one-particle intermediate contributions 
# -------------------------------------------- 
      execute sip_barrier 
#
      ENDPROC DIBJABAAB
#     ------------------ 
#
# ----------------------------------------------------------------------------
#
      PROC DIBJA  
#
# Create gamma arrays and V intermediates 
# --------------------------------------- 
#
           CALL DIBJAAAAA
           CALL DIBJAABAB
           CALL DIBJABABA
           CALL DIBJABAAB 
           CALL DIBJAABBA 
#
      ENDPROC DIBJA 
#
#
# ----------------------------------------------------------------------------
# ------------------------------------------------------------------------- 
#
# Start the calculation of the D^{ab}_{ci} type contributions to the
# density. Equivalent to Gamma5   
#
# ------------------------------------------------------------------------- 
#
# ----------------------------------------------------------------------------
#
# In this superprocedure the particle-particle block of the relaxed density 
# matrix is computed. The expressions programmed are: 
# 
# D_{ab} = 1/4 P_+(ab) t^{ae}_{mn} \lambda^{mn}_{be}  
#        + 1/4 P_+(ab) t^{aE}_{mN} \lambda^{mN}_{bE}  
#        + 1/2 P_+(ab) t^{a}_{m} \lambda^{m}_{b} 
#
# D_{AB} = D_{ab} [a<-->A, b<-->B, i<-->I, j<-->J, m<-->M, n<-->N] 
#
      PROC DABA 
#     --------- 
#
      PARDO a, a1, i  
#
            DO a2 
            DO i1 
#
               REQUEST T2old_aa(a,i,a2,i1) i1  
               Taiai(a,i,a2,i1) = T2old_aa(a,i,a2,i1)
               REQUEST T2old_aa(a1,i,a2,i1) i1
               T1aiai(a1,i,a2,i1) = T2old_aa(a1,i,a2,i1)
#
               Taa(a,a1)        = Taiai(a,i,a2,i1)*T1aiai(a1,i,a2,i1)
               
               Taa(a,a1)       *= 0.5
               PUT Dab_a(a,a1) += Taa(a,a1)
#
            ENDDO i1 
            ENDDO a2 
#
            DO b 
            DO j 
#
               REQUEST T2old_ab(a,i,b,j) j  
               Taibj(a,i,b,j) = T2old_ab(a,i,b,j)
               REQUEST T2old_ab(a1,i,b,j) j
               T1aibj(a1,i,b,j) = T2old_ab(a1,i,b,j)
#
               Taa(a,a1)        = Taibj(a,i,b,j)*T1aibj(a1,i,b,j)

               PUT Dab_a(a,a1) += Taa(a,a1)
#
            ENDDO j 
            ENDDO b 
#
      ENDPARDO a, a1, i
#
      ENDPROC DABA 
#     ------------ 
#
# ----------------------------------------------------------------------------
#
      PROC DAB 
           CALL DABA 
      ENDPROC DAB 
#
# --------------------------------------------------------------------------- 
#
# In this superprocedure the occupied-occupied block of the relaxed
# density matrix is computed. The expressions programmed are:
#
# D_{ij} = -1/4 P_+(ij) t^{ef}_{im} \lambda^{jm}_{ef} 
#          -1/4 P_+(ij) t^{eF}_{iM} \lambda^{jM}_{eF}   
#          -1/2 P_+(ij) t^{e}_{i} \lambda^{j}_{e}   
#
# D_{IJ} = D_{ij} [i<-->I, j<-->J, e<-->E, f<-->F] 
#
# --------------------------------------------------------------------------- 
#
      PROC DIJA 
#     --------- 
#
      PARDO a, a1, i2 
#
            DO i 
#
               REQUEST T2old_aa(a,i,a1,i2) i2
               Taiai(a,i,a1,i2) = T2old_aa(a,i,a1,i2)  
#
               DO i1 
#
                  REQUEST T2old_aa(a,i1,a1,i2) i2  
#
                  Tii(i,i1)        = Taiai(a,i,a1,i2)*T2old_aa(a,i1,a1,i2) 
                  Tii(i,i1)       *= -0.5
                  PUT Dij_a(i,i1) += Tii(i,i1) 
#
               ENDDO i1 
               
            ENDDO i 
#
      ENDPARDO a, a1, i2 
#
      PARDO a, b, j 
#
            DO i 
#
               REQUEST T2old_ab(a,i,b,j) j
               Taibj(a,i,b,j) = T2old_ab(a,i,b,j) 
               
#
               DO i1 
#
                  REQUEST T2old_ab(a,i1,b,j) j  
#
                  Tii(i,i1)        = Taibj(a,i,b,j)*T2old_ab(a,i1,b,j) 
                  Tii(i,i1)       *= -1.0  
                  PUT Dij_a(i,i1) += Tii(i,i1) 
#
               ENDDO i1 
               
            ENDDO i 
#
      ENDPARDO a, b, j 
#
      ENDPROC DIJA 
#     ------------ 
#
      PROC DIJ 
#     ----------- 
           CALL DIJA 
      ENDPROC DIJ 
#     ----------- 
# 
     PROC I11 
#    -------- 
#
# Calculate contribution to Iai_aa 
# -------------------------------- 
#
     PARDO a, i, i1, i2  
#
           REQUEST VSpipi(a,i2,i1,i) i
           GET Dij_a(i1,i2) 
#
           Tpppp(a,i,i1,i2)  = VSpipi(a,i2,i1,i) 
           Tai(a,i)          = Tpppp(a,i,i1,i2)*Dij_a(i1,i2) 
           Tai(a,i)         *= -1.0  
           PUT Iai_aa(a,i)  += Tai(a,i) 
#
     ENDPARDO a, i, i1, i2  
#
     PARDO a, j, j1, i 
#
           REQUEST Vpiqj(a,i,j,j1) j1  
           GET Dij_a(j,j1) 
#
           Tai(a,i)         = Vpiqj(a,i,j,j1)*Dij_a(j,j1) 
           PUT Iai_aa(a,i) += Tai(a,i) 
#
     ENDPARDO a, j, j1, i 
#
     PARDO a, a1, a2, i 
#
           REQUEST VSaaai(a,a1,a2,i) i
           GET Dab_a(a2,a1) 
#
           Tpppp(a,i,a2,a1)  = VSaaai(a,a1,a2,i) 
           Tai(a,i)          = Tpppp(a,i,a2,a1)*Dab_a(a2,a1) 
           Tai(a,i)         *= -1.0   
           PUT Iai_aa(a,i)  += Tai(a,i) 
#
     ENDPARDO a, a1, a2, i 
#
     PARDO a, b, b1, i 
#
           REQUEST Vaabj(b1,b,a,i) i
           GET Dab_a(b1,b) 
#
           Tai(a,i)         = Vaabj(b1,b,a,i)*Dab_a(b1,b) 
           PUT Iai_aa(a,i) += Tai(a,i) 
#
     ENDPARDO a, b, b1, i 
#
# Compute contribution to Iij_aa 
# ------------------------------ 
#
#     Dab contribution 
#     ---------------- 
#
      PARDO a, a1, i, i1 
#
            REQUEST Vaaii(a,a1,i,i1) i1  
            REQUEST Viaai(i,a1,a,i1) i1  
            REQUEST Vaaii(a,a1,i1,i) i1  
            REQUEST Viaai(i1,a1,a,i) i
            GET Dab_a(a,a1) 
#
            Tpppp(i,i1,a,a1)  = Vaaii(a,a1,i,i1)  
            T1pppp(i,i1,a,a1) = Viaai(i,a1,a,i1)  
            T2pppp(i,i1,a,a1) = Vaaii(a,a1,i1,i)  
            T3pppp(i,i1,a,a1) = Viaai(i1,a1,a,i) 
#
            Tpppp(i,i1,a,a1) -= T1pppp(i,i1,a,a1)  
            Tpppp(i,i1,a,a1) += T2pppp(i,i1,a,a1)  
            Tpppp(i,i1,a,a1) -= T3pppp(i,i1,a,a1)  
#
            Tii(i,i1)         = Tpppp(i,i1,a,a1)*Dab_a(a,a1) 
            Tii(i,i1)        *= -0.5  
            PUT Iij_aa(i,i1) += Tii(i,i1) 
#
      ENDPARDO a, a1, i, i1 
#
      PARDO b, b1, i, i1 
#
            REQUEST Vaaii(b,b1,i,i1) b1  
            REQUEST Vaaii(b,b1,i1,i) b1  
            GET Dab_a(b,b1) 
#
            Tppqq(i,i1,b,b1)  = Vaaii(b,b1,i,i1)  
            T2ppqq(i,i1,b,b1) = Vaaii(b,b1,i1,i)  
            Tppqq(i,i1,b,b1) += T2ppqq(i,i1,b,b1)  
#
            Tii(i,i1)         = Tppqq(i,i1,b,b1)*Dab_a(b,b1) 
            Tii(i,i1)        *= -0.5  
            PUT Iij_aa(i,i1) += Tii(i,i1) 
#
      ENDPARDO b, b1, i, i1 
#
#     Dij contribution 
#     ---------------- 
#
      PARDO i2, i3, i, i1 
#
            REQUEST VSpipi(i2,i3,i,i1) i1  
            REQUEST VSpipi(i2,i3,i1,i) i
            GET Dij_a(i2,i3) 
#
            Tpppp(i,i1,i2,i3)  = VSpipi(i2,i3,i,i1)  
            T2pppp(i,i1,i2,i3) = VSpipi(i2,i3,i1,i)  
            Tpppp(i,i1,i2,i3) += T2pppp(i,i1,i2,i3)  
#
            Tii(i,i1)          = Tpppp(i,i1,i2,i3)*Dij_a(i2,i3) 
            Tii(i,i1)         *= -0.5  
            PUT Iij_aa(i,i1)  += Tii(i,i1) 
#
      ENDPARDO i2, i3, i, i1 
#
      PARDO j, j1, i, i1 
#
            REQUEST Vpiqj(i,i1,j,j1) j1  
            REQUEST Vpiqj(i1,i,j,j1) j1  
            GET Dij_a(j,j1) 
#
            Tppqq(i,i1,j,j1)  = Vpiqj(i,i1,j,j1)  
            T2ppqq(i,i1,j,j1) = Vpiqj(i1,i,j,j1)  
            Tppqq(i,i1,j,j1) += T2ppqq(i,i1,j,j1)  
#
            Tii(i,i1)         = Tppqq(i,i1,j,j1)*Dij_a(j,j1) 
            Tii(i,i1)        *= -0.5  
            PUT Iij_aa(i,i1) += Tii(i,i1) 
#
      ENDPARDO j, j1, i, i1 
# 
# DONE Compute contribution to Iij_aa 
# ----------------------------------- 
# 
     ENDPROC I11 
#    ----------- 
#
# This procedure computes the contributions to the intermediate
# Iij_a which contain the Fock matrix. First-term of equation 43
# and computed in dfini.f.
#
# Equation programmed:
#
#     I(i,j) = - f(i,m) D(j,m)
#
      PROC FOCKIIJA
#     -------------
#
      PARDO i, i1 
#
            Tii(i,i1) = Fock_a(i,i1)
#
            DO i2 
#
            IF i2 == i 
#
               GET DOR_ii(i1,i2)
#
               T1ii(i,i1)        = DOR_ii(i1,i2)*Fock_a(i2,i)
               Tii(i,i1)        += T1ii(i,i1)  
#
            ENDIF # i2 == i 
#
            ENDDO i2 
#
            Tii(i,i1)        *= -1.0 
            PUT Iij_aa(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1 
#
# Also subtract out Dai contribution Eq. 56 
# ----------------------------------------- 
#
      PARDO i, i1, a, i2 
#
            REQUEST VSpipi(a,i2,i,i1) i1  
            REQUEST VSpipi(i1,i,a,i2) i2  
            GET Doldai_a(a,i2) 
#
            Tpppp(i,i1,a,i2)  = VSpipi(a,i2,i,i1) 
            T2pppp(i,i1,a,i2) = VSpipi(i1,i,a,i2)  
            Tpppp(i,i1,a,i2) += T2pppp(i,i1,a,i2)  
#
            Tii(i,i1)         = Tpppp(i,i1,a,i2)*Doldai_a(a,i2)
            Tii(i,i1)        *= -1.0 
            PUT Iij_aa(i,i1) += Tii(i,i1)
# 
      ENDPARDO i, i1, a, i2 
#
      PARDO i, i1, b, j 
#
            REQUEST Vpiqj(i,i1,b,j) j 
            REQUEST Vpiqj(i1,i,b,j) j   
            GET Doldai_a(b,j) 
#
            Tppqq(i,i1,b,j)   = Vpiqj(i,i1,b,j)  
            T2ppqq(i,i1,b,j)  = Vpiqj(i1,i,b,j)  
            Tppqq(i,i1,b,j)  += T2ppqq(i,i1,b,j)  
#
            Tii(i,i1)         = Tppqq(i,i1,b,j)*Doldai_a(b,j)
            Tii(i,i1)        *= -1.0 
#
            PUT Iij_aa(i,i1) += Tii(i,i1)
# 
      ENDPARDO i, i1, b, j 
#
# Add contributions from o-o and v-v orbital response. 
# ---------------------------------------------------- 
#
      PARDO i, i1, i2, i3 
#
            REQUEST             VSpipi(i,i1,i2,i3) i 
            GET                 DOR_ii(i2,i3) 
            Tii(i,i1)         = VSpipi(i,i1,i2,i3)*DOR_ii(i2,i3) 
            Tii(i,i1)        *= -1.0  
            PUT Iij_aa(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1, i2, i3 
#
      PARDO i, i1, j2, j3 
#
            REQUEST             Vpiqj(i,i1,j2,j3) i 
            GET                 DOR_ii(j2,j3) 
            Tii(i,i1)         = Vpiqj(i,i1,j2,j3)*DOR_ii(j2,j3) 
            Tii(i,i1)        *= -1.0  
            PUT Iij_aa(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1, j2, j3 
#
      PARDO i, i1, a2, a3 
#
            REQUEST             Vaaii(a2,a3,i,i1) i 
            REQUEST             Viaai(i,a3,a2,i1) i 
            GET                 DOR_aa(a2,a3) 
            tpppp(i,i1,a2,a3) = Vaaii(a2,a3,i,i1)  
            t1pppp(i,i1,a2,a3)= Viaai(i,a3,a2,i1)   
            tpppp(i,i1,a2,a3)-= t1pppp(i,i1,a2,a3) 
            Tii(i,i1)         = tpppp(i,i1,a2,a3)*DOR_aa(a2,a3) 
            Tii(i,i1)        *= -1.0  
            PUT Iij_aa(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1, a2, a3 
#
      PARDO i, i1, b2, b3 
#
            REQUEST             Vaaii(b2,b3,i,i1) i 
            GET                 DOR_aa(b2,b3) 
            Tii(i,i1)         = Vaaii(b2,b3,i,i1)*DOR_aa(b2,b3) 
            Tii(i,i1)        *= -1.0  
            PUT Iij_aa(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1, b2, b3       
#
      ENDPROC FOCKIIJA
#     ----------------
#
# This procedure computes the contributions to the intermediate
# Iab_a which contain the Fock matrix. First-term of equation 43
# and computed in dfini.f.
#
# Equation programmed:
#
#     I(a,b) = - f(a,e) D(b,e)
#
      PROC FOCKIABA
#     -------------
#
      PARDO a, a1
#
            DO a2
#
               IF a2 == a 
#
                  GET DOR_aa(a2,a1)
                  Taa(a,a1)         = Fock_a(a,a2)*DOR_aa(a2,a1)
                  Taa(a,a1)        *= -1.0
                  PUT Iab_aa(a,a1) += Taa(a,a1)
#
               ENDIF # a2 == a 
#
            ENDDO a2
#
      ENDPARDO a, a1          
#
      ENDPROC FOCKIABA
#     ----------------
#
# This procedure computes the contributions to the intermediate
# Iab_b which contain the Fock matrix. First-term of equarion 43
# and computed in dfini.f.
#
# Equation programmed:
#
#     I(A,B) = - f(A,E) D(B,E)
#
      PROC FOCKIABB
#     -------------

#
      PARDO a, i 
#
            Tia(i,a) = 0.0 
#
            DO i1 
#
               IF i1 == i 
#
               GET Doldai_a(a,i1) 
#
               T1ia(i,a) = Doldai_a(a,i1)*fock_a(i1,i) 
               Tia(i,a) -= T1ia(i,a) 
#
               ENDIF # i1 == i 
#
            ENDDO i1 
#
            PUT Iia_aa(i,a) += Tia(i,a) 
#
      ENDPARDO a, i 
#
      ENDPROC FOCKIABB
#     ----------------
#
      PROC IFOCK
#     ----------
           CALL FOCKIIJA
           CALL FOCKIABA
           CALL FOCKIABB
      ENDPROC IFOCK
#     -------------
#
      PROC IFOCK_PP 
#     -------------
#
      PARDO i, i1 
#
            Tii(i,i1) = 0.0 # Fock_a(i,i1)
#
            DO i2 
#
            IF i2 == i 
#
               GET Dij_a(i1,i2)
#
               T1ii(i,i1)        = Dij_a(i1,i2)*Fock_a(i2,i)
               Tii(i,i1)        += T1ii(i,i1)  
#
            ENDIF # i2 == i 
#
            ENDDO i2 
#
            Tii(i,i1)        *= -1.0 
            PUT Iij_aa(i,i1) += Tii(i,i1)
#
      ENDPARDO i, i1 
#
#
      PARDO a, a1
#
            DO a2
#
               IF a2 == a 
#
                  GET                 Dab_a(a1,a2)
                  Taa(a,a1)         = Fock_a(a,a2)*Dab_a(a1,a2)
                  Taa(a,a1)        *= -1.0
                  PUT Iab_aa(a,a1) += Taa(a,a1)
#
               ENDIF # a2 == a 
#
            ENDDO a2
#
      ENDPARDO a, a1
#
      ENDPROC IFOCK_PP 
#     ----------------
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
 
# 
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
# Contributions depending in Vabcd are computed in this procedure 
# 'directly'. Since these integrals are not stored the terms:
# Iab_aa(2) and Iai_aa(6) must be 
# computed differently than earlier. 
#
     PROC IABAA1 
#    ----------- 
#
#    Form Half back transformed cluster array
#    ----------------------------------------
#
     PARDO a, a1, i, i1
#
           REQUEST T2old_aa(a,i,a1,i1) i1 
#
           DO lambda
#
              Zaa(lambda,i,a1,i1) = T2old_aa(a,i,a1,i1)*ca(lambda,a)
#
              DO sigma
#
                 ZZaa(lambda,i,sigma,i1)        = Zaa(lambda,i,a1,i1)*ca(sigma,a1)
                 PREPARE TAO_aa(lambda,i,sigma,i1) += ZZaa(lambda,i,sigma,i1)
#
              ENDDO sigma
#
           ENDDO lambda
#
     ENDPARDO a, a1, i, i1
     execute server_barrier 
#
#    Contract Half back transformed arrays with AO integrals 
#    --> Txixi and T1xixi 
#    ------------------------------------------------------- 
#
     PARDO lambda, sigma, mu, nu  
#
           compute_integrals aoint(mu,lambda,nu,sigma) 
#
           DO i 
           DO i1 
#
              REQUEST Tao_aa(mu,i,nu,i1) i1  
#
              Txixi(lambda,i,sigma,i1)      = Tao_aa(mu,i,nu,i1)*aoint(mu,lambda,nu,sigma) 
              PREPARE Ixixi(lambda,i,sigma,i1) += Txixi(lambda,i,sigma,i1) 
#
           ENDDO i1 
           ENDDO i 
#
     ENDPARDO lambda, sigma, mu, nu  
     execute server_barrier 
#
#    Transform I 
#    ------------------ 
#
     PARDO lambda, sigma, i, i1 
#
           REQUEST Ixixi(lambda,i,sigma,i1)  i1  
#
           DO a1 
#
              Txiai(lambda,i,a1,i1)  =  Ixixi(lambda,i,sigma,i1)*ca(sigma,a1) 
#
              DO a 
#
                 Taiai(a,i,a1,i1)       =  Txiai(lambda,i,a1,i1)*ca(lambda,a)  
#
                 PREPARE Iaiai(a,i,a1,i1)  += Taiai(a,i,a1,i1) 
#
                 T2aiai(a1,i,a,i1)      =  Taiai(a,i,a1,i1) 
#
                 T2aiai(a1,i,a,i1)     *= -1.0  
#
                 PREPARE Iaiai(a1,i,a,i1)  += T2aiai(a1,i,a,i1) 
#
              ENDDO a 
#
           ENDDO a1 
#
     ENDPARDO lambda, sigma, i, i1 
     execute server_barrier 
#
#    Perform final contraction 
#    ------------------------- 
#
     PARDO a, a1, a2 
#
           DO i 
           DO i1 
#
              REQUEST  Iaiai(a,i,a2,i1)    a2  
              REQUEST T2old_aa(a1,i,a2,i1)   a2  
#
              Taa(a,a1)        = Iaiai(a,i,a2,i1)*T2old_aa(a1,i,a2,i1) 
              Taa(a,a1)        *= -0.25 
              PUT Iab_aa(a,a1) += Taa(a,a1) 
#
           ENDDO i1 
           ENDDO i 
#
     ENDPARDO a, a1, a2 
     execute sip_barrier 
     execute server_barrier 
#
     ENDPROC IABAA1 
#    -------------- 
#
     PROC IABAA2 
#    ----------- 
#
#    Form Half back transformed cluster array
#    ----------------------------------------
#
     PARDO a, b, i, j
#
           REQUEST T2old_ab(a,i,b,j) j 
#
           DO lambda
#
              Zab(lambda,i,b,j) = T2old_ab(a,i,b,j)*ca(lambda,a)
#
              DO sigma
#
                 ZZab(lambda,i,sigma,j)        = Zab(lambda,i,b,j)*ca(sigma,b)
                 PREPARE TAO_ab(lambda,i,sigma,j) += ZZab(lambda,i,sigma,j)
#
              ENDDO sigma
#
           ENDDO lambda
#
     ENDPARDO a, b, i, j

     execute server_barrier 
#
#    Contract Half back transformed arrays with AO integrals 
#    --> Txixj 
#    ------------------------------------------------------- 
#
     PARDO lambda, sigma, mu, nu  
#
           compute_integrals aoint(mu,lambda,nu,sigma) 
#
           DO i 
           DO j 
#
              REQUEST                            Tao_ab(mu,i,nu,j) j  
              Txixj(lambda,i,sigma,j)          = Tao_ab(mu,i,nu,j)*aoint(mu,lambda,nu,sigma) 
              PREPARE Ixixj(lambda,i,sigma,j) += Txixj(lambda,i,sigma,j) 
#
           ENDDO j 
           ENDDO i 
#
     ENDPARDO lambda, sigma, mu, nu  
     execute server_barrier 
#
#    Transform I and I1 
#    ------------------ 
#
     PARDO lambda, sigma, i, j 
#
           REQUEST Ixixj(lambda,i,sigma,j)  j  
#
           DO b 
#
              Txibj(lambda,i,b,j)     =  Ixixj(lambda,i,sigma,j)*ca(sigma,b) 
#
              DO a 
#
                 Taibj(a,i,b,j)          =  Txibj(lambda,i,b,j)*ca(lambda,a)  
                 PREPARE Iaibj(a,i,b,j) += Taibj(a,i,b,j) 
#
              ENDDO a 
#
           ENDDO b 
#
     ENDPARDO lambda, sigma, i, j 
     execute server_barrier 
#
#    Perform final contraction to Iab_aa  
#    -----------------------------------  
#
     PARDO a, a1, b 
#
           DO i 
           DO j 
#
              REQUEST  Iaibj(a,i,b,j)    b  
              REQUEST T2old_ab(a1,i,b,j)   b  
# 
              Taa(a,a1)        = Iaibj(a,i,b,j)*T2old_ab(a1,i,b,j) 
              Taa(a,a1)        *= -1.0 
              PUT Iab_aa(a,a1) += Taa(a,a1) 
#
           ENDDO j 
           ENDDO i 
#
     ENDPARDO a, a1, b 
#
     PARDO a, a1, b 
#
           DO i 
           DO j 
#
              REQUEST  Iaibj(a,i,b,j)    b  
              REQUEST  Iaibj(a,j,b,i)    b  
              REQUEST T2old_aa(a1,i,b,j)   b  
# 
              tpppp(a,i,b,j)   = Iaibj(a,j,b,i) 
              tpppp(a,i,b,j)  -= Iaibj(a,i,b,j) 
              Taa(a,a1)        = tpppp(a,i,b,j)*T2old_aa(a1,i,b,j) 
              Taa(a,a1)        *= 0.5 
              PUT Iab_aa(a,a1) += Taa(a,a1) 
#
           ENDDO j 
           ENDDO i 
#
     ENDPARDO a, a1, b 
#
     execute sip_barrier 
#
     ENDPROC IABAA2 
#    -------------- 
#
#
     PROC IABDIRECT 
#    -------------- 
         #CALL IABAA1 
          CALL IABAA2 
     ENDPROC IABDIRECT 
#    ----------------- 
#
# ----------------------------------------------------------------------------------------
#
         PROC UPDATE_DAI 
#        --------------- 
#
         PARDO a, i 
#
               GET        Dnewai_a(a,i) 
               GET        Doldai_a(a,i) 
               Tai(a,i) = Dnewai_a(a,i) 
               execute energy_denominator Tai(a,i) 
               Tai(a,i) -= Doldai_a(a,i) 
#
               if kiter == 1 
                  PUT e1ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 2 
                  PUT e2ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 3 
                  PUT e3ai(a,i) = tai(a,i) 
               endif 
#
               if kiter == 4 
                  PUT e4ai(a,i) = tai(a,i) 
               endif 
#
               if kiter >= 5 
                  PUT e5ai(a,i) = tai(a,i) 
               endif 
#
         ENDPARDO a, i 
#
         ENDPROC UPDATE_DAI 
#        ------------------ 
#
# ----------------------------------------------------------------------------------------
# 
# ----------------------------------------------------------------------------------------
#
      PROC MOVE_DAI 
#     ------------- 
#
      PARDO a, i
#
            GET        Doldai_a(a,i)
            tai(a,i) = Doldai_a(a,i)
#
            if kiter == 1
               PUT d1ai(a,i) = tai(a,i)
            endif
#
            if kiter == 2
               PUT d2ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 3
               PUT d3ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 4
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
            if kiter >= 5
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
      ENDPARDO a, i
#
      ENDPROC MOVE_DAI 
#     ---------------- 
# 
# ----------------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR
#    -----------------
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS
#    expansion are zero'd out.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR
#    --------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS
#    ---------------
#
#    Put the matrix elements of B into the sip 'B' matrix.
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS
#    ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to Dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-1 amplitudes
           GET e2ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb22 += b22
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------
#
     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     execute print_scalar c1
     execute print_scalar c2
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-2 amplitudes
           GET D1ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-1 amplitudes
           GET e2ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i) + e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i) + e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           PUT Doldai_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS1
#    -------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-2 amplitudes
           GET e2ai(a,i)    # kiter-1 amplitudes
           GET e3ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb33 += b33
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     execute print_scalar c1
     execute print_scalar c2
     execute print_scalar c3
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-3 amplitudes
           GET D1ai(a,i)     # kiter-2 amplitudes
           GET D2ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-2 amplitudes
           GET e2ai(a,i)     # kiter-1 amplitudes
           GET e3ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i) + e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i) + e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i) + e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           PUT Doldai_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS2
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-3 amplitudes
           GET e2ai(a,i)    # kiter-2 amplitudes
           GET e3ai(a,i)    # kiter-1 amplitudes
           GET e4ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb44 += b44
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     execute print_scalar c1
     execute print_scalar c2
     execute print_scalar c3
     execute print_scalar c4
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-4 amplitudes
           GET D1ai(a,i)     # kiter-3 amplitudes
           GET D2ai(a,i)     # kiter-2 amplitudes
           GET D3ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-3 amplitudes
           GET e2ai(a,i)     # kiter-2 amplitudes
           GET e3ai(a,i)     # kiter-1 amplitudes
           GET e4ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i) + e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i) + e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i) + e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i) + e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           PUT Doldai_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS3
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-4 amplitudes
           GET e2ai(a,i)    # kiter-3 amplitudes
           GET e3ai(a,i)    # kiter-2 amplitudes
           GET e4ai(a,i)    # kiter-1 amplitudes
           GET e5ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
              etemp = e1ai(a,i)*e5ai(a,i)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
              etemp = e2ai(a,i)*e5ai(a,i)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
              etemp = e3ai(a,i)*e5ai(a,i)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
              etemp = e4ai(a,i)*e5ai(a,i)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5ai(a,i)*e5ai(a,i)
              b55  += etemp
#
     ENDPARDO a, i
#
#    Compute contributions due to dbj amplitudes.
#    --------------------------------------------
#

     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb15 += b15
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb25 += b25
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb35 += b35
     collective Tb44 += b44
     collective Tb45 += b45
     collective Tb55 += b55
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     c5 = Tb55
     execute print_scalar c1
     execute print_scalar c2
     execute print_scalar c3
     execute print_scalar c4
     execute print_scalar c5
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-5 amplitudes
           GET D1ai(a,i)     # kiter-4 amplitudes
           GET D2ai(a,i)     # kiter-3 amplitudes
           GET D3ai(a,i)     # kiter-2 amplitudes
           GET D4ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-4 amplitudes
           GET e2ai(a,i)     # kiter-3 amplitudes
           GET e3ai(a,i)     # kiter-2 amplitudes
           GET e4ai(a,i)     # kiter-1 amplitudes
           GET e5ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i) + e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i) + e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i) + e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i) + e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d4ai(a,i) + e5ai(a,i)
           t1ai(a,i)    *= c5
           tai(a,i)     += t1ai(a,i)
#
           PUT Doldai_a(a,i) = tai(a,i)
#
     ENDPARDO a, i
#

     execute sip_barrier
#
     ENDPROC DIIS4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
#
#    0 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET d1ai(a,i)
           PUT d0ai(a,i) = d1ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier 
#
#    2 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET e2ai(a,i)
           PUT e1ai(a,i) = e2ai(a,i)
     ENDPARDO a, i
#
#
     PARDO a, i
           GET d2ai(a,i)
           PUT d1ai(a,i) = d2ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     PARDO a, i
           GET e3ai(a,i)
           PUT e2ai(a,i) = e3ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d3ai(a,i)
           PUT d2ai(a,i) = d3ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    4 --> 3
#    ---------------------------------------------------
#
     PARDO a, i
           GET e4ai(a,i)
           PUT e3ai(a,i) = e4ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d4ai(a,i)
           PUT d3ai(a,i) = d4ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     PARDO a, i
           GET e5ai(a,i)
           PUT e4ai(a,i) = e5ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET doldai_a(a,i)
           PUT d4ai(a,i) = doldai_a(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC MOVE4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------------------
#
# This procedure calculates the virtual-occupied block of the density 
# matrix iteratively. The equation for the AA spin programmed is:
#
# D(a,i)*(e_i-e_a) = X(a,i) - D(c,k)*[ V^{ca}_{ki} - V^{ca}_{ik}  
#                                    + V^{ci}_{ka} - V^{ci}_{ak} ] 
#                           - D(C,K)*[ V^{Ca}_{Ki} + V^{Ci}_{Ka} ] 
#
# ----------------------------------------------------------------------------------------
#
      PROC DAI
#     -------- 
#
# First get initial guess 
# ----------------------- 
#
      create Doldai_a 
      create Dnewai_a 
#
      CREATE D0ai
      CREATE D1ai
      CREATE D2ai
      CREATE D3ai
      CREATE D4ai
#
      CREATE e1ai
      CREATE e2ai
      CREATE e3ai
      CREATE e4ai
      CREATE e5ai
#      
      ecrit = cc_conv # Threshold  
 
#
# Initialize Dai 
# --------------------------  
#
      esum = 0.0 
      eold = 0.0 
      execute sip_barrier 
      PARDO a, i 
#
            GET Xai_aa(a,i) 
            Tai(a,i) = Xai_aa(a,i) 
            execute energy_denominator Tai(a,i) 
            PUT Doldai_a(a,i) = Tai(a,i) 
            PUT D0ai(a,i) = Tai(a,i) 
#
      ENDPARDO a, i 
      execute sip_barrier 
#
# Start iterations 
# ---------------- 
#
      DO KITER  
#
#        AA-spin first 
#        ------------- 
#
         PARDO a, i 
#
               GET Xai_aa(a,i) 
               Tai(a,i)           = Xai_aa(a,i) 
               PUT Dnewai_a(a,i) += Tai(a,i) 
#
         ENDPARDO a, i 
#
         PARDO a, i, a1, i1 
#
               REQUEST VSpipi(a1,i1,a,i) a # + 
               REQUEST Viaai(i1,a1,a,i)  a # + 
               REQUEST Vaaii(a,a1,i1,i)  a # - 
               GET Doldai_a(a1,i1) 
#
               Tpppp(a,i,a1,i1)   = VSpipi(a1,i1,a,i) 
               T2pppp(a,i,a1,i1)  = Viaai(i1,a1,a,i)   
               T3pppp(a,i,a1,i1)  = Vaaii(a,a1,i1,i)  
#
               Tpppp(a,i,a1,i1)  += T2pppp(a,i,a1,i1) 
               Tpppp(a,i,a1,i1)  -= T3pppp(a,i,a1,i1) 
#
               Tai(a,i)           = Tpppp(a,i,a1,i1)*Doldai_a(a1,i1) 
               PUT Dnewai_a(a,i) += Tai(a,i) 
#
         ENDPARDO a, i, a1, i1 
#
         PARDO a, i, b, j 
#
               REQUEST Vpiqj(a,i,b,j) a # + 
               REQUEST Viaai(i,a,b,j) a # + 
               GET Doldai_a(b,j) 
#
               Tppqq(a,i,b,j)     = Vpiqj(a,i,b,j)  
               T2ppqq(a,i,b,j)    = Viaai(i,a,b,j)  
               Tppqq(a,i,b,j)    += T2ppqq(a,i,b,j) 
#
               Tai(a,i)           = Tppqq(a,i,b,j)*Doldai_a(b,j) 
               PUT Dnewai_a(a,i) += Tai(a,i) 
#
         ENDPARDO a, i, b, j 
#
#        DONE AA-spin 
#        ------------ 
         execute sip_barrier 
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_DAI 
         execute sip_barrier 
#
#        Compute 'Energy' 
#        ---------------- 
#
         esum = 0.0 
         enew = 0.0
         PARDO a, i 
#
               GET Dnewai_a(a,i) 
               etemp = Dnewai_a(a,i)*Dnewai_a(a,i)  
               esum += etemp 
               Tai(a,i) = Dnewai_a(a,i) 
               execute energy_denominator Tai(a,i) 
               PUT Doldai_a(a,i) = Tai(a,i) 
#
         ENDPARDO a, i 
         execute sip_barrier 
         collective enew += esum 
         execute print_scalar enew 
         execute print_scalar eold 
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew 
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew 
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_DAI 
#
#        Zero out Dai 
#        ------------ 
# 
         PARDO a, i 
#
               Tai(a,i) = 0.0 
               PUT Dnewai_a(a,i) = Tai(a,i) 
#
         ENDPARDO a, i 
         execute sip_barrier 
#
      ENDDO KITER  
      execute sip_barrier 
#
      ENDPROC DAI
#     ----------- 
#
# -----------------------------------------------------------------------------
#
#
# -----------------------------------------------------------------------------
#
      PROC I1TRANS
#     ------------
#
# -----------------------------------------------------------------------------
#
#     Transform Iai_aa and Iia_aa
#     ---------------------------
      PARDO a, i
#
            GET Iia_aa(i,a)
#
            DO mu
#
               Jxi(mu,i)  = ca(mu,a)*Iia_aa(i,a)
#
               DO nu
#
                  Ixx(mu,nu) = Jxi(mu,i)*ca(nu,i)
                  I1xx(nu,mu) = Ixx(mu,nu)
                  PUT Ipq(mu,nu) += Ixx(mu,nu)
                  PUT Ipq(nu,mu) += I1xx(nu,mu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, i
#
#     Transform Iaa_aa
#     ----------------
      PARDO a, a1
#
            GET Iab_aa(a,a1)
#
            DO mu
#
               Ixa(mu,a1)  = ca(mu,a)*Iab_aa(a,a1)
#
               DO nu
#
                  Ixx(mu,nu) = Ixa(mu,a1)*ca(nu,a1)
                  PUT Ipq(mu,nu) += Ixx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, a1
#
#     Transform Iij_aa
#     ----------------
      PARDO i, i1
#
            GET Iij_aa(i,i1)
#
            DO mu
#
               Jxi(mu,i1)  = ca(mu,i)*Iij_aa(i,i1)
#
               DO nu
#
                  Ixx(mu,nu) = Jxi(mu,i1)*ca(nu,i1)
                  PUT Ipq(mu,nu) += Ixx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO i, i1
      execute sip_barrier
#
# Finally contract with the derivative integrals
# ----------------------------------------------
#
      PARDO mu, nu
            GET Ipq(mu,nu)
            Tpq(mu,nu)  = Ipq(mu,nu)
            Tpq(mu,nu) *= 2.0  
            EXECUTE SCONT1 Tpq(mu,nu)
      ENDPARDO mu, nu
#
# -----------------------------------------------------------------------------
#
      ENDPROC I1TRANS
#     ---------------
#
# -----------------------------------------------------------------------------
#
# -----------------------------------------------------------------------------
#
      PROC D1TRANS
#     ------------
#
# -----------------------------------------------------------------------------
#
#     Transform Dai_aa
#     ----------------
      PARDO a, i
#
            GET Doldai_a(a,i)
#
            DO mu
#
               Jxi(mu,i)  = Doldai_a(a,i)*ca(mu,a)
#
               DO nu
#
                  Ixx(mu,nu)      = Jxi(mu,i)*ca(nu,i)
                  I1xx(nu,mu)     = Ixx(mu,nu)
                  PUT Dpq(mu,nu) += Ixx(mu,nu)
                  PUT Dpq(nu,mu) += I1xx(nu,mu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, i
#
#     Transform Dab_a
#     ---------------
      PARDO a, a1
#
            GET Dab_a(a,a1)
            GET Dor_aa(a,a1)
            taa(a,a1) = Dab_a(a,a1) 
            taa(a,a1)+= Dor_aa(a,a1) 
#
            DO mu
#
               Ixa(mu,a1)  = taa(a,a1)*ca(mu,a)
#
               DO nu
#
                  Ixx(mu,nu) = Ixa(mu,a1)*ca(nu,a1)
                  PUT Dpq(mu,nu) += Ixx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO a, a1
#
#     Transform Dij_aa
#     ----------------
      PARDO i, i1
#
            GET Dij_a(i,i1)
            GET Dor_ii(i,i1)
            tii(i,i1) = Dij_a(i,i1) 
            tii(i,i1)+= Dor_ii(i,i1) 
#
            DO mu
#
               Jxi(mu,i1)  = tii(i,i1)*ca(mu,i)
#
               DO nu
#
                  Ixx(mu,nu) = Jxi(mu,i1)*ca(nu,i1)
                  PUT Dpq(mu,nu) += Ixx(mu,nu)
#
               ENDDO nu
#
            ENDDO mu
#
      ENDPARDO i, i1
      execute sip_barrier
#
# Finally contract with the derivative integrals
# ----------------------------------------------
#
      PARDO mu, nu
            GET Dpq(mu,nu)
            GET DHF(mu,nu)
            Tpq(mu,nu)  = Dpq(mu,nu)
            Tpq(mu,nu) += DHF(mu,nu)
            Tpq(mu,nu) *= 2.0  
            EXECUTE HCONT1 Tpq(mu,nu)
      ENDPARDO mu, nu
#
# -----------------------------------------------------------------------------
#
      ENDPROC D1TRANS
#     ---------------
#
# -----------------------------------------------------------------------------
#
# -----------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
      PARDO mu, nu, i
#
            Txi(nu,i)       = ca(nu,i)
            Tpq(mu,nu)      = ca(mu,i)*Txi(nu,i)
            PUT Dhf(mu,nu) += Tpq(mu,nu)
#
      ENDPARDO mu, nu, i
#
      ENDPROC HFDENS
#     --------------
#
      PROC WHFDENS
#     ------------
#
      PARDO mu, nu, i
#
            Txi(nu,i) = 0.0
#
            DO i1
#
               IF i1 == i 
#
               T1xi(nu,i) = ca(nu,i1)*fock_a(i,i1)
               Txi(nu,i) -= T1xi(nu,i)
#
               ENDIF # i1 == i 
#
            ENDDO i1
#
            Tpq(mu,nu)      = ca(mu,i)*Txi(nu,i)
            PUT Dhfa(mu,nu) += Tpq(mu,nu)
#
      ENDPARDO mu, nu, i
      execute sip_barrier
#
      ENDPROC WHFDENS
#     --------------
# -----------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------
# 
      PROC DIJ_OR  
#     ----------- 
#
# Alpha-alpha block 
# ----------------- 
#
      PARDO i, i1 
#
            GET                         Iij_aa(i,i1)    
            GET                         Iij_aa(i1,i)    
#
            tii(i1,i)                 = Iij_aa(i,i1) 
            tii(i1,i)                -= Iij_aa(i1,i) 
           #tii(i1,i)                *= -1.0  
#
           #execute energy_rdenominator tii 
            execute udenominator tii 
            PUT DOR_ii(i1,i)         += tii(i1,i) 
#
      ENDPARDO i, i1 
# 
      ENDPROC DIJ_OR  
#     -------------- 
# 
# ----------------------------------------------------------------------------------------
# 
# ----------------------------------------------------------------------------------------
# 
      PROC DAB_OR  
#     ----------- 
#
# Alpha-alpha block 
# ----------------- 
#
      PARDO a, a1 
#
            GET                         Iab_aa(a,a1)    
            GET                         Iab_aa(a1,a)    
#
            taa(a1,a)                 = Iab_aa(a,a1) 
            taa(a1,a)                -= Iab_aa(a1,a) 
           #taa(a1,a)                *= -1.0  
#
           #execute energy_rdenominator taa 
            execute udenominator taa 
            PUT DOR_aa(a1,a)         += taa(a1,a) 
#
      ENDPARDO a, a1 
# 
      ENDPROC DAB_OR  
#     -------------- 
#
      PROC XAI_FULL   
#     ------------- 
#
# Set Xai'_aa  
# -----------------------  
#
      PARDO a, i  
#
            GET Iai_aa(a,i) 
            GET Iia_aa(i,a) 
#
            Tai(a,i)        = Iia_aa(i,a) 
            Tai(a,i)       += Iai_aa(a,i) 
            PUT Xai_aa(a,i) = Tai(a,i)  
#            execute dump_amp Tai(a,i) 
#
      ENDPARDO a, i  
      execute sip_barrier 
#
# Add contributions from the o-o and v-v orbital response density. 
# ----------------------------------------------------------------   
#
# Alpha-alpha contribution 
# ------------------------ 
#
      PARDO a, i, i1, i2 
#
            REQUEST             VSpipi(a,i,i2,i1) a  
            REQUEST             VSpipi(a,i,i1,i2) a  
            GET                 DOR_ii(i2,i1) 
#
            tpppp(a,i,i2,i1)  = VSpipi(a,i,i1,i2) 
            tpppp(a,i,i2,i1) += VSpipi(a,i,i2,i1) 
#
            tpp(a,i)          = tpppp(a,i,i2,i1)*DOR_ii(i2,i1) 
            tpp(a,i)         *= 0.5 
            PUT Xai_aa(a,i)  += tpp(a,i)  
#
      ENDPARDO a, i, i1, i2 
#
      PARDO a, i, j, j1 
#
            REQUEST            Vpiqj(a,i,j1,j) a  
            REQUEST            Vpiqj(a,i,j,j1) a  
            GET                DOR_ii(j1,j) 
#
            tppqq(a,i,j1,j)  = Vpiqj(a,i,j,j1) 
            tppqq(a,i,j1,j) += Vpiqj(a,i,j1,j) 
#
            tpp(a,i)         = tppqq(a,i,j1,j)*DOR_ii(j1,j) 
            tpp(a,i)        *= 0.5 
            PUT Xai_aa(a,i) += tpp(a,i)  
#
      ENDPARDO a, i, j, j1 
#
      PARDO a, i, a1, a2 
#
            REQUEST             VSaaai(a1,a2,a,i) a 
            REQUEST             VSaaai(a2,a1,a,i) a 
            GET                 DOR_aa(a1,a2) 
#
            tpppp(a1,a2,a,i)  = VSaaai(a2,a1,a,i) 
            tpppp(a1,a2,a,i) += VSaaai(a1,a2,a,i) 
#
            tpp(a,i)          = tpppp(a1,a2,a,i)*DOR_aa(a1,a2) 
            tpp(a,i)         *= 0.5 
            PUT Xai_aa(a,i)  += tpp(a,i)  
#
      ENDPARDO a, i, a1, a2 
#
      PARDO a, i, b, b1 
#
            REQUEST            Vaabj(b,b1,a,i) a 
            REQUEST            Vaabj(b1,b,a,i) a 
            GET                DOR_aa(b,b1) 
#
            tqqpp(b,b1,a,i)  = Vaabj(b1,b,a,i) 
            tqqpp(b,b1,a,i) += Vaabj(b,b1,a,i) 
#
            tpp(a,i)         = tqqpp(b,b1,a,i)*DOR_aa(b,b1) 
            tpp(a,i)        *= 0.5 
            PUT Xai_aa(a,i) += tpp(a,i)  
#            execute dump_amp Xai_aa(a,i) 
#
      ENDPARDO a, i, b, b1 
#
      execute sip_barrier 
#
      ENDPROC XAI_FULL   
#     ---------------- 
# 
# ----------------------------------------------------------------------------------------
#
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 
#
      PROC S2IIJ 
#
           DO i 
           DO i1 
              GET Iij_aa(i,i1) 
              execute dump_block Iij_aa(i,i1)  
           ENDDO i1 
           ENDDO i 
#
      ENDPROC S2IIJ 
#
      PROC S2IAB 
#
           DO a 
           DO a1 
              GET Iab_aa(a,a1) 
              execute dump_block Iab_aa(a,a1)  
           ENDDO a1 
           ENDDO a 
#
      ENDPROC S2IAB 
#
      PROC S2IAI 
#
           DO a 
           DO i 
              GET Iai_aa(a,i) 
              execute dump_block Iai_aa(a,i)  
           ENDDO i 
           ENDDO a 
#
      ENDPROC S2IAI 
#
      PROC S2IIA 
#
           DO a 
           DO i 
              GET Iia_aa(i,a) 
              execute dump_block Iia_aa(i,a)  
           ENDDO i 
           ENDDO a 
#
      ENDPROC S2IIA 
#
      PROC PRINTIIJ
#
           DO i
           DO i1
              GET Iij_aa(i,i1)
              execute dump_block Iij_aa(i,i1)
           ENDDO i1
           ENDDO i
#
      ENDPROC PRINTIIJ
#
      PROC PRINTIAB
#
           DO a
           DO a1
              GET Iab_aa(a,a1)
              execute dump_block Iab_aa
           ENDDO a1
           ENDDO a
#
      ENDPROC PRINTIAB
#
      PROC PRINTIIA
#
           DO i
           DO a
              GET Iia_aa(i,a)
              execute dump_block Iia_aa
           ENDDO a
           ENDDO i
#
      ENDPROC PRINTIIA
#
      PROC PRINTIAI
#
           DO i
           DO a
              GET Iai_aa(a,i)
              execute dump_block Iai_aa
           ENDDO a
           ENDDO i
#
      ENDPROC PRINTIAI
#
# --------------------------------------------------------------------------- 
# 
# ----------------------------------------------------------------------------------------
#
# As a simple test of the correctnes of the code the sum of the sum of the squares 
# of ALL the one-particle intermediates is computed. This can determine whether there
# is an error but obviously not where the error is. Of course the same quantity 
# must have been calculated correctly using another code.  
#
      PROC SQUAREALL 
#     -------------- 
#
# Intermediate arrays
# -------------------
#
      esum = 0.0 
      enew = 0.0
#
      PARDO i, i1 
            GET Iij_aa(i,i1)
            etemp = Iij_aa(i,i1)*Iij_aa(i,i1) 
            esum += etemp 
      ENDPARDO i, i1 
      
      execute sip_barrier 
      collective enew += esum 
      execute print_scalar enew
      enew=0.0
      esum=0.0     
#
      PARDO a, a1 
            GET Iab_aa(a,a1)
            etemp = Iab_aa(a,a1)*Iab_aa(a,a1) 
            esum += etemp 
      ENDPARDO a, a1 
      
            execute sip_barrier 
      collective enew += esum 
      execute print_scalar enew
      enew=0.0
      esum=0.0    
#
      PARDO a, i 
            GET Iai_aa(a,i)
            etemp = Iai_aa(a,i)*Iai_aa(a,i) 
            esum += etemp 
      ENDPARDO a, i 
      
            execute sip_barrier 
      collective enew += esum 
      execute print_scalar enew
      enew=0.0
      esum=0.0    
#
      PARDO a, i 
            GET Iia_aa(i,a)
            etemp = Iia_aa(i,a)*Iia_aa(i,a) 
            esum += etemp 
      ENDPARDO a, i 
      
            execute sip_barrier 
      collective enew += esum 
      execute print_scalar enew
      enew=0.0
      esum=0.0    
#
      PARDO a, i 
            GET Xai_aa(a,i)
            etemp = Xai_aa(a,i)*Xai_aa(a,i) 
            esum += etemp 
      ENDPARDO a, i 
      
            execute sip_barrier 
      collective enew += esum 
      execute print_scalar enew
      enew=0.0
      esum=0.0    
#
      PARDO i, i1 
            GET Dij_a(i,i1)
            etemp = Dij_a(i,i1)*Dij_a(i,i1) 
            esum += etemp 
      ENDPARDO i, i1 
      
      execute sip_barrier 
      collective enew += esum 
      execute print_scalar enew
      enew=0.0
      esum=0.0    
#
      PARDO a, a1 
            GET Dab_a(a,a1)
            etemp = Dab_a(a,a1)*Dab_a(a,a1) 
            esum += etemp 
      ENDPARDO a, a1 
      
            execute sip_barrier 
      collective enew += esum 
      execute print_scalar enew
      enew=0.0
      esum=0.0    
#
#      execute sip_barrier 
##      collective enew += esum 
#      execute print_scalar enew  
#
      ENDPROC SQUAREALL 
#     ----------------- 
# 
# ----------------------------------------------------------------------------- 
#
      PROC DMAIN
#     ----------
#
# Create single particle intermediates GAE and GMI and DAB, DIJ arrays 
# ------------------------------------------------------------------------------ 
         CALL CREATE1ARRAY 
         execute sip_barrier  
#
# Form the single particle density DAB and DIJ   
# --------------------------------------------  
         CALL DAB 
         CALL DIJ 
         execute sip_barrier  
         execute server_barrier  
#
# Compute contributions to one-particle intermediates from DAB and DIJ 
# -------------------------------------------------------------------- 
         CALL I11 
#
# Form DIJKL 
# ---------- 
         CALL DIJKL # gamma3 
#
# Form DABCD 
# ---------- 
         CALL DABCD # gamma2 
#
# Form DIBJA 
# ---------- 
         CALL DIBJA # gamma4 
#
# Form DIJAB  
# ---------- 
         CALL DIJAB # gamma1 
#
# Form DIJKA  
# ---------- 
        #CALL DIJKA # gamma6 
#
# Form DABCI 
# ---------- 
        #CALL DABCI # gamma5 
#
# Compute 'Direct' contributions to Iab coming from Vabcd  
# ------------------------------------------------------- 
         CALL IABDIRECT 
         execute sip_barrier  
         execute server_barrier
         CALL IFOCK_PP
         execute sip_barrier  
         
         CALL DIJ_OR
         CALL DAB_OR
         execute sip_barrier
         
         CALL XAI_FULL
         execute sip_barrier
#
# Finally solve for Dai iteratively 
# --------------------------------- 
         CALL DAI 
         execute sip_barrier  
#
# Compute the contributions to Iai coming from the Fock matrix 
# ------------------------------------------------------------ 
         CALL IFOCK
         execute sip_barrier ca 
#      CALL PRINTIIJ   # --> symmetric  
#      CALL PRINTIAB   # --> symmetric  
#      CALL PRINTIIA   # --> symmetric  
#      CALL PRINTIAI   # --> symmetric  
#      CALL SQUAREALL 
#
# Backtransform one-particle intermediates and contract with integral derivatives
# -------------------------------------------------------------------------------
         create Ipq
         create Dpq
         create DHF
         create DHFa
         create DHFb
         execute sip_barrier
         CALL HFDENS
         CALL WHFDENS
         execute sip_barrier
         CALL I1TRANS
#
# Backtransform one-particle density and contract with integral derivatives
# -------------------------------------------------------------------------
         CALL D1TRANS
#
      ENDPROC DMAIN
#     -------------
#
# Read two-electron transformed integrals 
# --------------------------------------- 
#
      CALL READ_2EL 
#
# Read converged T and Lambda amplitudes 
# -------------------------------------- 
#
      execute list_to_blocks T2old_ab

      execute read_list_to_blocks
      execute sip_barrier
      execute server_barrier
      PARDO a, a1, a2, i 
            REQUEST                     Vaabj(a,a1,a2,i) a 
            REQUEST                     Vaabj(a2,a1,a,i) a 
            tpppp(a,a1,a2,i)          = Vaabj(a,a1,a2,i) 
            t1pppp(a,a1,a2,i)         = Vaabj(a2,a1,a,i) 
            tpppp(a,a1,a2,i)         -= t1pppp(a,a1,a2,i)  
            PREPARE VSaaai(a,a1,a2,i) = tpppp(a,a1,a2,i) 
      ENDPARDO a, a1, a2, i 

      PARDO a, i, a1, i1 
            REQUEST T2old_ab(a,i,a1,i1) a 
            REQUEST T2old_ab(a,i1,a1,i) a 
            tpppp(a,i,a1,i1) = T2old_ab(a,i,a1,i1) 
            t1pppp(a,i,a1,i1) = T2old_ab(a,i1,a1,i)  
            tpppp(a,i,a1,i1) -= t1pppp(a,i,a1,i1) 
            PREPARE T2old_aa(a,i,a1,i1) = tpppp(a,i,a1,i1) 
      ENDPARDO a, i, a1, i1 
      execute server_barrier
#
      CALL DMAIN 
#
# Write amplitudes to file
# ------------------------
#
      execute sip_barrier
      execute blocks_to_list T2old_aa
      execute blocks_to_list T2old_ab
#
      execute blocks_to_list Doldai_a
#
      execute blocks_to_list DOR_ii 
      execute blocks_to_list DOR_aa 
      execute write_blocks_to_list
      execute sip_barrier
      execute server_barrier
#
# Compute squares of each density contribution 
# -------------------------------------------- 
#
#     CALL S2IIJ   # --> symmetric  
#     CALL S2IAB   # --> symmetric  
#
#     CALL S2DIJKL # --> symmetric Matches Aces 
#     CALL S2DABCD # --> symmetric Matches Aces  
#     CALL S2DIBJA # --> symmetric Matches Aces  
#
#     CALL S2DIJKA # --> symmetric Matches Aces  
#     CALL S2ABCI  # --> symmetric Matches Aces  
#     CALL S2DIJAB # --> symmetric Matches Aces  
# 
                    ENDSIAL ONE_HERM_GRAD_CO       
# 
# ----------------------------------------------------------------------------------------
#
#
