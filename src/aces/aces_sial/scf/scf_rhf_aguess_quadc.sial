#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
#
                           SIAL SCF_UHF_DIIS         
#
# ----------------------------------------------------------------------------
#
# The sial program SIAL_UHF performs a UHF based SCF calculation. Davidson 
# damping is performed during the first scf_beg-1 iterations after which the 
# DIIS is turned on with scf_order. At present DIIS is turned on after the 
# third iteration and 6 histories are kept. 
#
# Fock matrix final arrays:
# ------------------------- 
#
# 1. Fpq_a  
# 2. Fpq_b  
#
# Transformation coefficients final arrays:
# ----------------------------------------- 
#
# 1. Ca  
# 2. Cb  
#
# Converged SCF energy:
# --------------------- 
#
# 1. scfeneg 
#
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
#
# Declare indeces 
# --------------- 
#
      index   kiter  = 1, scf_iter  
      index   qiter  = 1, 25 # scf_iter  
      index   kbeg   = 1, scf_beg
      index   korder = 1, scf_hist
      index   kptr1  = 1, 2
      index   kptr2  = 1, 2
      index   kone   = 1, 1
      index   kdiis  = 1, 10 
      index   d1     = 1, 10 
      index   d2     = 1, 10 
      index   d3     = 1, 10 
      index   d4     = 1, 10 
      index   iiter1 = 1, 1
      index   jjter1 = 1, 1
      index   jjter2 = 2, 2
#
      aoindex mu     = 1, norb
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
# 
# Declare one-particle density arrays 
# ----------------------------------- 
#
      distributed Dhfa(mu,nu) 
      distributed Dhfb(mu,nu) 
      distributed IDhfa(mu,nu) 
      distributed IDhfb(mu,nu) 
      distributed Dhfa_old(mu,nu) 
      distributed Dhfb_old(mu,nu) 
#
      distributed Fpq_a(mu,nu) 
      distributed Fpq_b(mu,nu) 
      distributed FTpq_a(mu,nu) 
      distributed FTpq_b(mu,nu) 
      distributed CBT_a(mu,p) 
      distributed CBT_b(mu,q) 

      static dflags11(iiter1,jjter1)
      static dflags12(iiter1,jjter2)
#
# Arrays needed for two-electron transformation 
# --------------------------------------------- 
#
      served Vxxii(mu,nu,i1,i) 
      served Vixxi(i1,nu,lambda,i) 
      served Vxixi(mu,i,nu,i1) 
      served Viaai(i1,a1,a,i) 
      served Vaaii(a,a1,i,i1) 
      served Vaiai(a,i,a1,i1) 
      local Lxxxi(mu,nu,lambda,i) 
      local Lixai(i,nu,a,i1) 
      local Lxaii(mu,a,i,i1) 
      local Lxiai(mu,i,a1,i1) 
      temp Txxxi(mu,nu,lambda,i)  
      temp Txxii(mu,nu,i,i1)  
      temp Txixi(mu,i,nu,i1) 
      temp Tixxi(i,mu,nu,i1)  
      temp Tixai(i,mu,a,i1) 
      temp Txaii(mu,a,i,i1) 
      temp Txiai(mu,i,a,i1) 
      temp Taiai(a,i,a1,i1) 
      temp T1aiai(a,i,a1,i1) 
      temp T2aiai(a,i,a1,i1) 
      temp T3aiai(a,i,a1,i1) 
      temp Tiaai(i,a,a1,i1) 
      temp Taaii(a,a1,i,i1)  
      static DFock_a(p,p1)  
      static DFock_b(q,q1)  
#
# Arrays used in quadratic convergence 
# ------------------------------------ 
#
      distributed Denai(a,i) 
      distributed Denbj(b,j) 
      distributed Cai(a,i) 
      distributed Cbj(b,j) 
      distributed Cnewai(a,i) 
      distributed Cnewbj(b,j) 
      distributed D_ca(mu,i) 
      static S_ca(mu,p) 
      static foed_ovl(mu,nu) 
      static XX(i,i1) 
      static XXX(i,i1) 
      temp taa(a,a1) 
      temp tii(i,i1) 
      temp tpx(p,nu) 
      scalar esuma 
      scalar esumb 
      scalar eTsuma 
      scalar eTsumb 
      scalar D0a 
      scalar D0b 
      scalar exponent 
      scalar dfact_a 
      scalar qdone 
      scalar qdonea 
      scalar qcrit 
#
# Declare temporary arrays 
# ------------------------ 
#
      temp Ixi(mu,i) 
      temp I1xi(mu,i) 
      temp Ixj(mu,j) 
      temp I1xj(mu,j) 
      temp Tpq(mu,nu) 
      temp T1pq(mu,nu) 
      temp Txi(mu,i) 
      temp T1xi(mu,i) 
      temp Txj(mu,j) 
      temp T1xj(mu,j) 
      temp Txx(mu,nu) 
      temp TAxx(mu,nu) 
      temp TBxx(mu,nu) 
      temp T1xx(mu,nu) 
      temp T2xx(mu,nu) 
      temp T3xx(mu,nu) 
      temp T4xx(mu,nu) 
      temp T5xx(mu,nu) 
      temp T6xx(mu,nu) 
      temp T7xx(mu,nu) 
      temp T8xx(mu,nu) 
      temp T9xx(mu,nu) 
      temp T10xx(mu,nu) 
      temp T11xx(mu,nu) 
      temp T12xx(mu,nu) 
      temp T13xx(mu,nu) 
      temp T14xx(mu,nu) 
      temp T15xx(mu,nu) 
      temp T16xx(mu,nu) 
      temp T17xx(mu,nu) 
      temp T18xx(mu,nu) 
      temp T19xx(mu,nu) 
      temp T20xx(mu,nu) 
      temp T21xx(mu,nu) 
      temp T22xx(mu,nu) 
      temp T1ii(i,i1) 
      temp Tjj(j,j1) 
      temp T1jj(j,j1) 
      temp Txp(mu,p) 
      temp T1xp(mu,p) 
      temp Tpp(p,p1) 
      temp T1pp(p,p1) 
      temp Txq(mu,q) 
      temp T1xq(mu,q) 
      temp Tqq(q,q1) 
      temp T1qq(q,q1) 
#
# Declare served arrays 
# --------------------- 
#
      temp aoint(mu,nu,lambda,sigma)
#
# Declare static arrays 
# --------------------- 
#
      static FSpq_a(mu,nu) 
      static FSpq_b(mu,nu) 
      distributed Qxx(mu,nu) 
      distributed FTa(p,p1) 
      distributed FTb(q,q1) 
      static X1(mu,nu) 
      local LDHFa(mu,nu) 
      local LDHFb(mu,nu) 
      local LFpq_b(mu,nu) 
      local LFpq_a(mu,nu) 
      static pinf(kiter,kptr1)
      temp tpinf(kiter,kptr1)
#
# Arrays used in DIIS procedure 
# ----------------------------- 
#  
      distributed FFai(a,i) 
      distributed FFbj(b,j) 
      temp tai(a,i) 
      temp t1ai(a,i) 
      temp t2ai(a,i) 
      temp t3ai(a,i) 
      temp tbj(b,j) 
      temp t1bj(b,j) 
      temp t2bj(b,j) 
      temp t3bj(b,j) 
#
# Scalars used in DIIS procedure 
# ------------------------------ 
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110 
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210 
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310 
#
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410 
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510 
#
       scalar b66 
       scalar b67 
       scalar b68 
       scalar b69 
       scalar b610  
#
       scalar b77 
       scalar b78 
       scalar b79 
       scalar b710  
#
       scalar b88 
       scalar b89 
       scalar b810  
#
       scalar b99 
       scalar b910  
#
       scalar b1010 
#
       scalar c1
       scalar c2
       scalar c3
       scalar c4
       scalar c5
       scalar c6
       scalar c7
       scalar c8
       scalar c9
       scalar c10 
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110 
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210 
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310 
#
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410 
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510 
#
       scalar Tb66 
       scalar Tb67 
       scalar Tb68 
       scalar Tb69 
       scalar Tb610  
#
       scalar Tb77 
       scalar Tb78 
       scalar Tb79 
       scalar Tb710  
#
       scalar Tb88 
       scalar Tb89 
       scalar Tb810  
#
       scalar Tb99 
       scalar Tb910  
#
       scalar Tb1010 
#
# Declare scalars 
# --------------- 
#
      scalar e_a     
      scalar e_b     
      scalar escf_a 
      scalar escf_b 
      scalar etemp 
      scalar etemp1
      scalar esum 
      scalar esum1
      scalar energy 
      scalar energy1 
      scalar energy2 
      scalar ecrit 
      scalar ediff  
#     scalar damp 
      scalar damp1 
      scalar done 
      scalar donea 
      scalar doneb 
   
      scalar zero 
      scalar mone 
      scalar one
      scalar two
      scalar three
      scalar four
      scalar ncount1 
      scalar rank 

      scalar dsqrt2 
#
# Parameters needed for DIIS 

      scalar diis_start  
      scalar diis_end   
      scalar diis_order   
      scalar diis_max_order # same as kdiis   
      scalar diis_count 
      scalar worder  
      scalar n1 
      scalar n2 

      distributed Fa(mu,nu,kdiis) 
      distributed Fb(mu,nu,kdiis) 
      distributed Fbj(b,j,kdiis) 
      distributed Fai(a,i,kdiis) 
      temp tpqx(mu,nu,d2)   
      temp taix(a,i,d2)   
      temp tbjx(b,j,d2)   
      temp tdd(d1,d2) 
      temp t1dd(d1,d2) 
      local BB(kdiis,kdiis) 
#
# ---------------------------------------------------------------------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
#     The HF density is computed. Davidson damping is incorporated thus
#     knowledge of the previous iteration is needed. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component first 
#           --------------------- 
#
            GET           DHFa_old(mu,nu) 
            GET           DHFb_old(mu,nu) 
            Tpq(mu,nu)  = DHFa_old(mu,nu)   
            Tpq(mu,nu) *= damp  
#
            DO i 
#
               Txi(nu,i)   = ca(nu,i)
               T1pq(mu,nu) = Txi(nu,i)*ca(mu,i)
               Tpq(mu,nu) += T1pq(mu,nu) 
#
            ENDDO i 
#
            Tpq(mu,nu)     *= damp1   
            PUT Dhfa(mu,nu) = Tpq(mu,nu)
#
#           beta component next  
#           ------------------- 
#
            Tpq(mu,nu)  = DHFb_old(mu,nu)   
            Tpq(mu,nu) *= damp  
#
            DO j 
#
               Txj(nu,j)   = ca(nu,j)
               T1pq(mu,nu) = ca(mu,j)*Txj(nu,j)
               Tpq(mu,nu) += T1pq(mu,nu) 
#
            ENDDO j 
#
            Tpq(mu,nu)     *= damp1   
            PUT Dhfb(mu,nu) = Tpq(mu,nu)
#
      ENDPARDO mu, nu 
#
      ENDPROC HFDENS
#     --------------
#
# ---------------------------------------------------------------------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFIDENS
#     ------------
#
#     Procedure which computes the HF density without Davidson damping. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component 
#           --------------- 
#
            Tpq(mu,nu) = 0.0 
#
            DO i 
#
               Txi(nu,i)   = ca(nu,i)
               T1pq(mu,nu) = Txi(nu,i)*ca(mu,i)
               Tpq(mu,nu) += T1pq(mu,nu) 
#
            ENDDO i 
# 
            PUT Dhfa(mu,nu) = Tpq(mu,nu)
#
#           beta component 
#           -------------- 
#
            Tpq(mu,nu) = 0.0 
#
            DO j 
#
               Txj(nu,j)   = ca(nu,j)
               T1pq(mu,nu) = ca(mu,j)*Txj(nu,j)
               Tpq(mu,nu) += T1pq(mu,nu) 
#
            ENDDO j 
#
            PUT Dhfb(mu,nu) = Tpq(mu,nu)
#
      ENDPARDO mu, nu 
#
      ENDPROC HFIDENS
#     ---------------
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_MATRIX  
#      ----------------- 
#
#      The complete Fock matrix is constructed. Eight fold symmetry of the
#      two-electron integrals is incorporated. 
#      ------------------------------------------------------------------
#
#      Put the density into local arrays 
#      --------------------------------- 
#
       allocate LDHFa(*,*) 
       allocate LDHFb(*,*) 
       allocate LFpq_b(*,*) 
       allocate LFpq_a(*,*) 
       DO mu 
       DO nu 
          GET            DHFa(mu,nu) 
          GET            DHFb(mu,nu) 
          LDHFa(mu,nu) = DHFa(mu,nu) 
          LDHFb(mu,nu) = DHFb(mu,nu) 
          LFpq_a(mu,nu) = 0.0 
          LFpq_b(mu,nu) = 0.0 
       ENDDO nu 
       ENDDO mu 
#
#      Initialize the Fock matrix to the bare 1-electron hamiltonian.
#      -------------------------------------------------------------- 
#
       execute sip_barrier
#
       execute get_my_rank rank 
       if rank == 0.0 
          DO mu   
          DO nu   
#
             txx(mu,nu) = 0.0 
             execute return_h1 txx  
#
             PUT Fpq_a(mu,nu) += Txx(mu,nu) 
             PUT Fpq_b(mu,nu) += Txx(mu,nu) 
#
          ENDDO nu   
          ENDDO mu    
       endif 

       execute sip_barrier
       execute load_balance_off
       execute sip_barrier
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
############# CLASS 6  ############
##  Do four-center part (mu nu |la si)->(mu nu |si la ),(nu mu|la si),(nu mu|si la)
##                      (la si |mu nu),(si la |mu nu),(la si |nu mu),(si la |nu mu)
##
        PARDO mu, nu, lambda, sigma
##
                 WHERE mu      < nu
                 WHERE lambda  < sigma
                 WHERE mu     < lambda
                 WHERE nu     != sigma
                 WHERE nu     != lambda
                 WHERE mu     != sigma
##
                    compute_integrals       aoint(mu,nu,lambda,sigma)
##
                    T1xx(lambda,sigma)    = LDHFa(lambda,sigma)
                    T1xx(lambda,sigma)   += LDHFb(lambda,sigma)
                    T4xx(mu,nu)           = LDHFa(mu,nu)
                    T4xx(mu,nu)          += LDHFb(mu,nu)
##
                    T2xx(mu,nu)           = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
                    T2xx(mu,nu)          *= 2.0
                    LFpq_a(mu,nu)        += T2xx(mu,nu)
                    LFpq_b(mu,nu)        += T2xx(mu,nu)
                    T3xx(nu,mu)           = T2xx(mu,nu)
                    LFpq_a(nu,mu)        += T3xx(nu,mu)
                    LFpq_b(nu,mu)        += T3xx(nu,mu)
##
                    T5xx(lambda,sigma)    = aoint(mu,nu,lambda,sigma)*T4xx(mu,nu)
                    T5xx(lambda,sigma)   *= 2.0
                    LFpq_a(lambda,sigma) += T5xx(lambda,sigma)
                    LFpq_b(lambda,sigma) += T5xx(lambda,sigma)
                    T6xx(sigma,lambda)    = T5xx(lambda,sigma)
                    LFpq_a(sigma,lambda) += T6xx(sigma,lambda)
                    LFpq_b(sigma,lambda) += T6xx(sigma,lambda)
##
                    T7xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                    LFpq_a(mu,lambda)    -= T7xx(mu,lambda)
                    T8xx(lambda,mu)       = T7xx(mu,lambda)
                    LFpq_a(lambda,mu)    -= T8xx(lambda,mu)
##
                    T9xx(mu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFa(nu,lambda)
                    LFpq_a(mu,sigma)     -= T9xx(mu,sigma)
                    T10xx(sigma,mu)       = T9xx(mu,sigma)
                    LFpq_a(sigma,mu)     -= T10xx(sigma,mu)
##
                    T11xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFa(mu,sigma)
                    LFpq_a(nu,lambda)    -= T11xx(nu,lambda)
                    T12xx(lambda,nu)      = T11xx(nu,lambda)
                    LFpq_a(lambda,nu)    -= T12xx(lambda,nu)
##
                    T13xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFa(mu,lambda)
                    LFpq_a(nu,sigma)     -= T13xx(nu,sigma)
                    T14xx(sigma,nu)       = T13xx(nu,sigma)
                    LFpq_a(sigma,nu)     -= T14xx(sigma,nu)
##
                    T15xx(mu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                    LFpq_b(mu,lambda)    -= T15xx(mu,lambda)
                    T16xx(lambda,mu)      = T15xx(mu,lambda)
                    LFpq_b(lambda,mu)    -= T16xx(lambda,mu)
##
                    T17xx(mu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(nu,lambda)
                    LFpq_b(mu,sigma)     -= T17xx(mu,sigma)
                    T18xx(sigma,mu)       = T17xx(mu,sigma)
                    LFpq_b(sigma,mu)     -= T18xx(sigma,mu)
##
                    T19xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(mu,sigma)
                    LFpq_b(nu,lambda)    -= T19xx(nu,lambda)
                    T20xx(lambda,nu)      = T19xx(nu,lambda)
                    LFpq_b(lambda,nu)    -= T20xx(lambda,nu)

                    T21xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(mu,lambda)
                    LFpq_b(nu,sigma)     -= T21xx(nu,sigma)
                    T22xx(sigma,nu)       = T21xx(nu,sigma)
                    LFpq_b(sigma,nu)     -= T22xx(sigma,nu)
##
        ENDPARDO mu, nu, lambda, sigma
##
#
############ CLASS 3  ############
#  Do two-center part (mu mu |mu nu)->(mu nu |mu mu ),(mu mu|nu mu),(nu mu|mu mu)
#  Do three-center part (mu mu |nu lambda)->(mu mu |lambda nu ),(nu lambda|mu mu),(lambda nu|mu mu)
#
       PARDO mu, nu, sigma 
#
          WHERE mu == nu
#
             T3xx(mu,nu)    = LDHFa(mu,nu)
             T3xx(mu,nu)   += LDHFb(mu,nu)
#
             DO lambda  
#
                      WHERE lambda  < sigma
#
                         compute_integrals       aoint(mu,nu,lambda,sigma)
#
                         T1xx(lambda,sigma)    = LDHFa(lambda,sigma)
                         T1xx(lambda,sigma)   += LDHFb(lambda,sigma)
#
                         T2xx(mu,nu)           = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
                         T2xx(mu,nu)          *= 2.0
#
                         T4xx(lambda,sigma)    = aoint(mu,nu,lambda,sigma)*T3xx(mu,nu)
                         T5xx(sigma,lambda)    = T4xx(lambda,sigma)
#
                         T6xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                        #T6xx(mu,lambda)      *= -1.0
                         T7xx(lambda,mu)       = T6xx(mu,lambda)
#
                         T8xx(mu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFa(nu,lambda)
                        #T8xx(mu,sigma)       *= -1.0
                         T9xx(sigma,mu)        = T8xx(mu,sigma)
#
                         T10xx(mu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                        #T10xx(mu,lambda)     *= -1.0
                         T11xx(lambda,mu)      = T10xx(mu,lambda)
#
                         T12xx(mu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(nu,lambda)
                        #T12xx(mu,sigma)      *= -1.0
                         T13xx(sigma,mu)       = T12xx(mu,sigma)
#
                         LFpq_a(mu,nu)        += T2xx(mu,nu)
                         LFpq_b(mu,nu)        += T2xx(mu,nu)
#
                         LFpq_a(lambda,sigma) += T4xx(lambda,sigma)
                         LFpq_b(lambda,sigma) += T4xx(lambda,sigma)
#
                         LFpq_a(sigma,lambda) += T5xx(sigma,lambda)
                         LFpq_b(sigma,lambda) += T5xx(sigma,lambda)
#
                         LFpq_a(mu,lambda)    -= T6xx(mu,lambda)
                         LFpq_a(lambda,mu)    -= T7xx(lambda,mu)
#
                         LFpq_a(mu,sigma)     -= T8xx(mu,sigma)
                         LFpq_a(sigma,mu)     -= T9xx(sigma,mu)
#
                         LFpq_b(mu,lambda)    -= T10xx(mu,lambda)
                         LFpq_b(lambda,mu)    -= T11xx(lambda,mu)
#
                         LFpq_b(mu,sigma)     -= T12xx(mu,sigma)
                         LFpq_b(sigma,mu)     -= T13xx(sigma,mu)
#
                ENDDO lambda 
#
       ENDPARDO mu, nu, sigma 
#
############ CLASS 5  ############
###################  CLASS A ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, nu, sigma  
                WHERE nu < sigma
                WHERE mu < nu
                   T4xx(mu,nu)  = LDHFa(mu,nu)
                   T4xx(mu,nu) += LDHFb(mu,nu)
             DO lambda 
                WHERE mu==lambda
                WHERE lambda < sigma
#
                   compute_integrals       aoint(mu,nu,lambda,sigma)
#
                   T1xx(lambda,sigma)    = LDHFa(lambda,sigma)
                   T1xx(lambda,sigma)   += LDHFb(lambda,sigma)
#
                   T2xx(mu,nu)           = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
                   T2xx(mu,nu)          *= 2.0
                   T3xx(nu,mu)           = T2xx(mu,nu)
#
                   T5xx(lambda,sigma)    = aoint(mu,nu,lambda,sigma)*T4xx(mu,nu)
                   T5xx(lambda,sigma)   *= 2.0
                   T6xx(sigma,lambda)    = T5xx(lambda,sigma)
#
#
                   T7xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                   T7xx(mu,lambda)      *= -1.0
                   T8xx(lambda,mu)       = T7xx(mu,lambda)
#
                   T9xx(mu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFa(nu,lambda)
                   T9xx(mu,sigma)       *= -1.0
                   T10xx(sigma,mu)       = T9xx(mu,sigma)
#
                   T11xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFa(mu,sigma)
                   T11xx(nu,lambda)     *= -1.0
                   T12xx(lambda,nu)      = T11xx(nu,lambda)
#
                   T13xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFa(mu,lambda)
                   T13xx(nu,sigma)      *= -1.0
                   T14xx(sigma,nu)       = T13xx(nu,sigma)
#
                   T15xx(mu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                   T15xx(mu,lambda)     *= -1.0
                   T16xx(lambda,mu)      = T15xx(mu,lambda)
#
                   T17xx(mu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(nu,lambda)
                   T17xx(mu,sigma)      *= -1.0
                   T18xx(sigma,mu)       = T17xx(mu,sigma)
#
                   T19xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(mu,sigma)
                   T19xx(nu,lambda)     *= -1.0
                   T20xx(lambda,nu)      = T19xx(nu,lambda)
#
                   T21xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(mu,lambda)
                   T21xx(nu,sigma)      *= -1.0
                   T22xx(sigma,nu)       = T21xx(nu,sigma)
#
                   LFpq_a(mu,nu)        += T2xx(mu,nu)
                   LFpq_b(mu,nu)        += T2xx(mu,nu)
                   LFpq_a(nu,mu)        += T3xx(nu,mu)
                   LFpq_b(nu,mu)        += T3xx(nu,mu)
                   LFpq_a(lambda,sigma) += T5xx(lambda,sigma)
                   LFpq_b(lambda,sigma) += T5xx(lambda,sigma)
                   LFpq_a(sigma,lambda) += T6xx(sigma,lambda)
                   LFpq_b(sigma,lambda) += T6xx(sigma,lambda)
                   LFpq_a(mu,lambda)    += T7xx(mu,lambda)
                   LFpq_a(lambda,mu)    += T8xx(lambda,mu)
                   LFpq_a(mu,sigma)     += T9xx(mu,sigma)
                   LFpq_a(sigma,mu)     += T10xx(sigma,mu)
                   LFpq_a(nu,lambda)    += T11xx(nu,lambda)
                   LFpq_a(lambda,nu)    += T12xx(lambda,nu)
                   LFpq_a(nu,sigma)     += T13xx(nu,sigma)
                   LFpq_a(sigma,nu)     += T14xx(sigma,nu)
                   LFpq_b(mu,lambda)    += T15xx(mu,lambda)
                   LFpq_b(lambda,mu)    += T16xx(lambda,mu)
                   LFpq_b(mu,sigma)     += T17xx(mu,sigma)
                   LFpq_b(sigma,mu)     += T18xx(sigma,mu)
                   LFpq_b(nu,lambda)    += T19xx(nu,lambda)
                   LFpq_b(lambda,nu)    += T20xx(lambda,nu)
                   LFpq_b(nu,sigma)     += T21xx(nu,sigma)
                   LFpq_b(sigma,nu)     += T22xx(sigma,nu)
#
             ENDDO lambda  
#
       ENDPARDO mu, nu, sigma  
#
###################  CLASS B ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
# 
      PARDO mu, nu, lambda
                WHERE nu == lambda
                WHERE mu < nu
                   T4xx(mu,nu)  = LDHFa(mu,nu)
                   T4xx(mu,nu) += LDHFb(mu,nu)
            DO sigma 
                WHERE lambda < sigma
                WHERE mu < sigma
#
                   compute_integrals       aoint(mu,nu,lambda,sigma)
#
                   T1xx(lambda,sigma)    = LDHFa(lambda,sigma)
                   T1xx(lambda,sigma)   += LDHFb(lambda,sigma)
#
                   T2xx(mu,nu)           = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
                   T2xx(mu,nu)          *= 2.0
                   T3xx(nu,mu)           = T2xx(mu,nu)
#
                   T5xx(lambda,sigma)    = aoint(mu,nu,lambda,sigma)*T4xx(mu,nu)
                   T5xx(lambda,sigma)   *= 2.0
                   T6xx(sigma,lambda)    = T5xx(lambda,sigma)
#
                   T7xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                   T7xx(mu,lambda)      *= -1.0
                   T8xx(lambda,mu)       = T7xx(mu,lambda)
#
                   T9xx(mu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFa(nu,lambda)
                   T9xx(mu,sigma)       *= -1.0
                   T10xx(sigma,mu)       = T9xx(mu,sigma)
#
                   T11xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFa(mu,sigma)
                   T11xx(nu,lambda)     *= -1.0
                   T12xx(lambda,nu)      = T11xx(nu,lambda)
#
                   T13xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFa(mu,lambda)
                   T13xx(nu,sigma)      *= -1.0
                   T14xx(sigma,nu)       = T13xx(nu,sigma)
#
                   T15xx(mu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                   T15xx(mu,lambda)     *= -1.0
                   T16xx(lambda,mu)      = T15xx(mu,lambda)
#
                   T17xx(mu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(nu,lambda)
                   T17xx(mu,sigma)      *= -1.0
                   T18xx(sigma,mu)       = T17xx(mu,sigma)
#
                   T19xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(mu,sigma)
                   T19xx(nu,lambda)     *= -1.0
                   T20xx(lambda,nu)      = T19xx(nu,lambda)
#
                   T21xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(mu,lambda)
                   T21xx(nu,sigma)      *= -1.0
                   T22xx(sigma,nu)       = T21xx(nu,sigma)

                   LFpq_a(mu,nu)        += T2xx(mu,nu)
                   LFpq_b(mu,nu)        += T2xx(mu,nu)
                   LFpq_a(nu,mu)        += T3xx(nu,mu)
                   LFpq_b(nu,mu)        += T3xx(nu,mu)
                   LFpq_a(lambda,sigma) += T5xx(lambda,sigma)
                   LFpq_b(lambda,sigma) += T5xx(lambda,sigma)
                   LFpq_a(sigma,lambda) += T6xx(sigma,lambda)
                   LFpq_b(sigma,lambda) += T6xx(sigma,lambda)
                   LFpq_a(mu,lambda)    += T7xx(mu,lambda)
                   LFpq_a(lambda,mu)    += T8xx(lambda,mu)
                   LFpq_a(mu,sigma)     += T9xx(mu,sigma)
                   LFpq_a(sigma,mu)     += T10xx(sigma,mu)
                   LFpq_a(nu,lambda)    += T11xx(nu,lambda)
                   LFpq_a(lambda,nu)    += T12xx(lambda,nu)
                   LFpq_a(nu,sigma)     += T13xx(nu,sigma)
                   LFpq_a(sigma,nu)     += T14xx(sigma,nu)
                   LFpq_b(mu,lambda)    += T15xx(mu,lambda)
                   LFpq_b(lambda,mu)    += T16xx(lambda,mu)
                   LFpq_b(mu,sigma)     += T17xx(mu,sigma)
                   LFpq_b(sigma,mu)     += T18xx(sigma,mu)
                   LFpq_b(nu,lambda)    += T19xx(nu,lambda)
                   LFpq_b(lambda,nu)    += T20xx(lambda,nu)
                   LFpq_b(nu,sigma)     += T21xx(nu,sigma)
                   LFpq_b(sigma,nu)     += T22xx(sigma,nu)
#
             ENDDO sigma 
#
       ENDPARDO mu, nu, lambda
# 
###################  CLASS C ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, nu, sigma
                WHERE nu == sigma
                WHERE mu < nu
                   T4xx(mu,nu)    = LDHFa(mu,nu)
                   T4xx(mu,nu)   += LDHFb(mu,nu)
             DO lambda
                WHERE lambda < sigma
                WHERE mu < lambda
#
                   compute_integrals       aoint(mu,nu,lambda,sigma)
#
                   T1xx(lambda,sigma)    = LDHFa(lambda,sigma)
                   T1xx(lambda,sigma)   += LDHFb(lambda,sigma)
#
                   T2xx(mu,nu)           = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
                   T2xx(mu,nu)          *= 2.0
                   T3xx(nu,mu)           = T2xx(mu,nu)
#
                   T5xx(lambda,sigma)    = aoint(mu,nu,lambda,sigma)*T4xx(mu,nu)
                   T5xx(lambda,sigma)   *= 2.0
                   T6xx(sigma,lambda)    = T5xx(lambda,sigma)
#
                   T7xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                   T7xx(mu,lambda)      *= -1.0
                   T8xx(lambda,mu)       = T7xx(mu,lambda)
#
                   T9xx(mu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFa(nu,lambda)
                   T9xx(mu,sigma)       *= -1.0
                   T10xx(sigma,mu)       = T9xx(mu,sigma)
#
                   T11xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFa(mu,sigma)
                   T11xx(nu,lambda)     *= -1.0
                   T12xx(lambda,nu)      = T11xx(nu,lambda)
#
                   T13xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFa(mu,lambda)
                   T13xx(nu,sigma)      *= -1.0
                   T14xx(sigma,nu)       = T13xx(nu,sigma)
#
                   T15xx(mu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                   T15xx(mu,lambda)     *= -1.0
                   T16xx(lambda,mu)      = T15xx(mu,lambda)
#
                   T17xx(mu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(nu,lambda)
                   T17xx(mu,sigma)      *= -1.0
                   T18xx(sigma,mu)       = T17xx(mu,sigma)
#
                   T19xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(mu,sigma)
                   T19xx(nu,lambda)     *= -1.0
                   T20xx(lambda,nu)      = T19xx(nu,lambda)
#
                   T21xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(mu,lambda)
                   T21xx(nu,sigma)      *= -1.0
                   T22xx(sigma,nu)       = T21xx(nu,sigma)

                   LFpq_a(nu,mu)        += T3xx(nu,mu)
                   LFpq_a(mu,nu)        += T2xx(mu,nu)
                   LFpq_b(mu,nu)        += T2xx(mu,nu)
                   LFpq_b(nu,mu)        += T3xx(nu,mu)
                   LFpq_a(lambda,sigma) += T5xx(lambda,sigma)
                   LFpq_b(lambda,sigma) += T5xx(lambda,sigma)
                   LFpq_a(sigma,lambda) += T6xx(sigma,lambda)
                   LFpq_b(sigma,lambda) += T6xx(sigma,lambda)
                   LFpq_a(mu,lambda)    += T7xx(mu,lambda)
                   LFpq_a(lambda,mu)    += T8xx(lambda,mu)
                   LFpq_a(mu,sigma)     += T9xx(mu,sigma)
                   LFpq_a(sigma,mu)     += T10xx(sigma,mu)
                   LFpq_a(nu,lambda)    += T11xx(nu,lambda)
                   LFpq_a(lambda,nu)    += T12xx(lambda,nu)
                   LFpq_a(nu,sigma)     += T13xx(nu,sigma)
                   LFpq_a(sigma,nu)     += T14xx(sigma,nu)
                   LFpq_b(mu,lambda)    += T15xx(mu,lambda)
                   LFpq_b(lambda,mu)    += T16xx(lambda,mu)
                   LFpq_b(mu,sigma)     += T17xx(mu,sigma)
                   LFpq_b(sigma,mu)     += T18xx(sigma,mu)
                   LFpq_b(nu,lambda)    += T19xx(nu,lambda)
                   LFpq_b(lambda,nu)    += T20xx(lambda,nu)
                   LFpq_b(nu,sigma)     += T21xx(nu,sigma)
                   LFpq_b(sigma,nu)     += T22xx(sigma,nu)
#
             ENDDO lambda
#
       ENDPARDO mu, nu, sigma
#
############ CLASS 1  ############
#  Do one-center part (mu mu |mu mu)
#
       PARDO mu, sigma, nu
                WHERE nu == mu
                WHERE sigma == mu
                DO lambda
                   WHERE lambda == mu 
#          
                            compute_integrals     aoint(mu,nu,lambda,sigma)
#
                            T1xx(lambda,sigma)  = LDHFa(lambda,sigma)
                            T1xx(lambda,sigma) += LDHFb(lambda,sigma)
                            T2xx(mu,nu)         = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
#
                            T3xx(mu,lambda)     = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                            T3xx(mu,lambda)    *= -1.0
#
                            T4xx(mu,lambda)     = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                            T4xx(mu,lambda)    *= -1.0
#
                            LFpq_a(mu,nu)      += T2xx(mu,nu)
                            LFpq_b(mu,nu)      += T2xx(mu,nu)
                            LFpq_a(mu,lambda)  += T3xx(mu,lambda)
                            LFpq_b(mu,lambda)  += T4xx(mu,lambda)
#
                ENDDO lambda
       ENDPARDO mu, sigma, nu
#
############ CLASS 2  ############
#  Do two-center part (mu mu |nu nu)->(nu nu |mu mu )
#
       PARDO mu, nu, sigma
#
             WHERE mu == nu
#
                T3xx(mu,nu)  = LDHFa(mu,nu)
                T3xx(mu,nu) += LDHFb(mu,nu)
#
                DO lambda
                   WHERE mu     < lambda
                   WHERE lambda == sigma
#
                      compute_integrals aoint(mu,nu,lambda,sigma)
#
                      T1xx(lambda,sigma)    = LDHFa(lambda,sigma)
                      T1xx(lambda,sigma)   += LDHFb(lambda,sigma)
#
                      T2xx(mu,nu)           = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
#
                      T4xx(lambda,sigma)    = aoint(mu,nu,lambda,sigma)*T3xx(mu,nu)
#
                      T5xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                      T5xx(mu,lambda)      *= -1.0
                      T6xx(lambda,mu)       = T5xx(mu,lambda)
#
                      T7xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                      T7xx(mu,lambda)      *= -1.0
                      T8xx(lambda,mu)       = T7xx(mu,lambda)
#
                      LFpq_a(mu,nu)        += T2xx(mu,nu)
                      LFpq_b(mu,nu)        += T2xx(mu,nu)
                      LFpq_a(lambda,sigma) += T4xx(lambda,sigma)
                      LFpq_b(lambda,sigma) += T4xx(lambda,sigma)
                      LFpq_a(mu,lambda)    += T5xx(mu,lambda)
                      LFpq_a(lambda,mu)    += T6xx(lambda,mu)
                      LFpq_b(mu,lambda)    += T7xx(mu,lambda)
                      LFpq_b(lambda,mu)    += T8xx(lambda,mu)
#
             ENDDO lambda
#
       ENDPARDO mu, nu, sigma 
#
############ END CLASS 2  ############
#
############ CLASS 4  ############
#  Do two-center part (mu nu |mu nu)->(mu nu |nu mu ),(nu mu|mu nu),(nu mu|nu mu)
#
       PARDO mu, nu, sigma
                WHERE mu < nu
                WHERE nu == sigma
             DO lambda
#
                WHERE mu == lambda
                WHERE lambda < sigma 
#
                   compute_integrals       aoint(mu,nu,lambda,sigma)
#
                   T1xx(lambda,sigma)    = LDHFa(lambda,sigma)
                   T1xx(lambda,sigma)   += LDHFb(lambda,sigma)
#
                   T2xx(mu,nu)           = aoint(mu,nu,lambda,sigma)*T1xx(lambda,sigma)
                   T2xx(mu,nu)          *= 2.0
                   T3xx(nu,mu)           = T2xx(mu,nu)
#
                   T4xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(nu,sigma)
                   T4xx(mu,lambda)      *= -1.0
#
                   T5xx(mu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFa(nu,lambda)
                   T5xx(mu,sigma)       *= -1.0
#
                   T6xx(nu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFa(mu,sigma)
                   T6xx(nu,lambda)      *= -1.0
#
                   T7xx(nu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFa(mu,lambda)
                   T7xx(nu,sigma)       *= -1.0
#
                   T8xx(mu,lambda)       = aoint(mu,nu,lambda,sigma)*LDHFb(nu,sigma)
                   T8xx(mu,lambda)      *= -1.0
#
                   T9xx(mu,sigma)        = aoint(mu,nu,lambda,sigma)*LDHFb(nu,lambda)
                   T9xx(mu,sigma)       *= -1.0
#
                   T10xx(nu,lambda)      = aoint(mu,nu,lambda,sigma)*LDHFb(mu,sigma)
                   T10xx(nu,lambda)     *= -1.0
#
                   T11xx(nu,sigma)       = aoint(mu,nu,lambda,sigma)*LDHFb(mu,lambda)
                   T11xx(nu,sigma)      *= -1.0
#
                   LFpq_a(mu,nu)        += T2xx(mu,nu)
                   LFpq_b(mu,nu)        += T2xx(mu,nu)
                   LFpq_a(nu,mu)        += T3xx(nu,mu)
                   LFpq_b(nu,mu)        += T3xx(nu,mu)
                   LFpq_a(mu,lambda)    += T4xx(mu,lambda)
                   LFpq_a(mu,sigma)     += T5xx(mu,sigma)
                   LFpq_a(nu,lambda)    += T6xx(nu,lambda)
                   LFpq_a(nu,sigma)     += T7xx(nu,sigma)
                   LFpq_b(mu,lambda)    += T8xx(mu,lambda)
                   LFpq_b(mu,sigma)     += T9xx(mu,sigma)
                   LFpq_b(nu,lambda)    += T10xx(nu,lambda)
                   LFpq_b(nu,sigma)     += T11xx(nu,sigma)
#
             ENDDO lambda
#
       ENDPARDO mu, nu, sigma 
#
       execute sip_barrier
       execute load_balance_on
#
       DO mu   
       DO nu   
#
          PUT Fpq_a(mu,nu) += LFpq_a(mu,nu) 
          PUT Fpq_b(mu,nu) += LFpq_b(mu,nu) 
#
       ENDDO nu   
       ENDDO mu    
#
       deallocate LDHFa(*,*) 
       deallocate LDHFb(*,*) 
       deallocate LFpq_a(*,*) 
       deallocate LFpq_b(*,*) 
#
       ENDPROC FOCK_MATRIX  
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_MATRIX_FAST   
#      --------------------- 
#
#      The complete Fock matrix is constructed. Eight fold symmetry of the
#      two-electron integrals is incorporated. 
#      ------------------------------------------------------------------
#
#      Put the density into local arrays 
#      --------------------------------- 
#
#      Initialize the Fock matrix to the bare 1-electron hamiltonian.
#      -------------------------------------------------------------- 
#
       execute sip_barrier
       DO mu
       DO nu
#
          Txx(mu,nu)        = 0.0
          Fockrohf_a(mu,nu) = Txx(mu,nu)
          Fockrohf_b(mu,nu) = Txx(mu,nu)
       ENDDO nu
       ENDDO mu 

       execute sip_barrier
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
############# CLASS 6  ############
##  Do four-center part (mu nu |la si)->(mu nu |si la ),(nu mu|la si),(nu mu|si la)
##                      (la si |mu nu),(si la |mu nu),(la si |nu mu),(si la |nu mu)
##
        PARDO mu, nu, lambda, sigma
##
                 WHERE mu      < nu
                 WHERE lambda  < sigma
                 WHERE mu     < lambda
                 WHERE nu     != sigma
                 WHERE nu     != lambda
                 WHERE mu     != sigma
##
                    execute compute_ubatch1 aoint(mu,nu,lambda,sigma)
##
        ENDPARDO mu, nu, lambda, sigma
##
#
############ CLASS 3  ############
#  Do two-center part (mu mu |mu nu)->(mu nu |mu mu ),(mu mu|nu mu),(nu mu|mu mu)
#  Do three-center part (mu mu |nu lambda)->(mu mu |lambda nu ),(nu lambda|mu mu),(lambda nu|mu mu)
#
       PARDO mu, nu, lambda, sigma 
#
          WHERE mu == nu
          WHERE lambda  < sigma
#
                execute compute_ubatch2 aoint(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma 
#
############ CLASS 5  ############
###################  CLASS A ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
#
       PARDO mu, nu, lambda, sigma
                WHERE nu < sigma
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu==lambda
#
                   execute compute_ubatch4 aoint(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma

###################  CLASS B ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
# 
      PARDO mu, nu, lambda, sigma 
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu < sigma
                WHERE nu == lambda
#
                   execute compute_ubatch4 aoint(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma
#
# 
###################  CLASS C ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, nu, lambda, sigma
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu < lambda
                WHERE nu == sigma
#
                   execute compute_ubatch4 aoint(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma
#
############ CLASS 4  ############
#  Do two-center part (mu nu |mu nu)->(mu nu |nu mu ),(nu mu|mu nu),(nu mu|nu mu)
#
       PARDO mu, nu, lambda, sigma
                WHERE mu < nu
                WHERE lambda < sigma 
                WHERE nu == sigma
                WHERE mu == lambda
#
                   execute compute_ubatch8 aoint(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma
#
#          
############ CLASS 2  ############
#  Do two-center part (mu mu |nu nu)->(nu nu |mu mu )
#
       PARDO mu, nu, lambda, sigma
#
             WHERE mu < lambda
             WHERE mu == nu
             WHERE lambda == sigma
#
                   execute compute_ubatch7 aoint(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma 
#
############ END CLASS 2  ############
#
#
############ CLASS 1  ############
#  Do one-center part (mu mu |mu mu)
#
       PARDO mu, nu, lambda, sigma
             WHERE nu == mu
             WHERE sigma == mu
             WHERE lambda == mu 
#
                   execute compute_ubatch6 aoint(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma
#
       execute sip_barrier
#      
       DO mu
       DO nu
#         
          Txx(mu,nu)        = Fockrohf_a(mu,nu)
          PUT Fpq_a(mu,nu) += Txx(mu,nu)
#      
       ENDDO nu
       ENDDO mu 
#      
       DO mu
       DO nu
#         
          Txx(mu,nu)        = Fockrohf_b(mu,nu)
          PUT Fpq_b(mu,nu) += Txx(mu,nu)
#      
       ENDDO nu
       ENDDO mu 
#
#      DO mu   
#      DO nu   
#
#         PUT Fpq_a(mu,nu) += LFpq_a(mu,nu) 
#         PUT Fpq_b(mu,nu) += LFpq_b(mu,nu) 
#
#      ENDDO nu   
#      ENDDO mu    
#
       execute sip_barrier
#
       execute get_my_rank rank  
       if rank == 0.0 
       DO mu    
       DO nu   
#
            #Txx(mu,nu)        = oed_nai(mu,nu)  
            #Txx(mu,nu)       += oed_kin(mu,nu)  
            Txx(mu,nu) = 0.0 
            execute return_h1 txx 
#
             PUT Fpq_a(mu,nu) += Txx(mu,nu) 
             PUT Fpq_b(mu,nu) += Txx(mu,nu) 
#
       ENDDO nu   
       ENDDO mu    
       endif 
#
       ENDPROC FOCK_MATRIX_FAST   
#      ------------------------ 
#
# ---------------------------------------------------------------------------- 
#
#
       PROC HF_ENERGY  
#      -------------- 
#
#      The HF energy is computed from the HF density (DHFa(b)) and the 
#      Fock matrix (Fpq_a(b)). 
#      --------------------------------------------------------------- 
#
       energy = 0.0
       esum = 0.0 

       execute get_my_rank rank 
       if rank == 0.0 

          DO mu  
          DO nu 
#
             GET Fpq_a(mu,nu)
             GET Fpq_b(mu,nu)
             GET DHFa(mu,nu) 
             GET DHFb(mu,nu) 
#
             Txx(mu,nu)   = 0.0 
             execute return_h1 txx  
#
             T1xx(mu,nu)  = Txx(mu,nu) 
             T1xx(mu,nu) += Fpq_a(mu,nu) 
#
             etemp        = T1xx(mu,nu)*DHFa(mu,nu)  
             esum        += etemp 
#
             T1xx(mu,nu)  = Txx(mu,nu) 
             T1xx(mu,nu) += Fpq_b(mu,nu) 
#
             etemp        = T1xx(mu,nu)*DHFb(mu,nu)  
             esum        += etemp 
#
          ENDDO nu 
          ENDDO mu 

       endif 


       execute sip_barrier 

       esum *= 0.5 
       collective energy += esum 
       energy += scfeneg 
#
      #execute print_scalar energy 
#
       ENDPROC HF_ENERGY   
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC OVER_HALF 
#      -------------- 
#
#      Diagonalize the overlap matrix, invert and take the square
#      root of the diagonal elements. 
#      -------------------------------------------------------------- 
#
       execute eig_sr_inv oed_ovl x1   
#
#      Form the Q-matrix --> U s**{-1/2) 
#      --------------------------------- 
#
       PARDO mu, nu  
#
          Txx(mu,nu) = 0.0 
#
          DO lambda 
             T1xx(mu,nu) = x1(mu,lambda)*oed_ovl(lambda,nu) 
             Txx(mu,nu) += T1xx(mu,nu) 
          ENDDO lambda  
#
          PUT Qxx(mu,nu) = Txx(mu,nu)  
#
       ENDPARDO mu, nu  
#
      #execute print_scalar scfeneg
       ENDPROC OVER_HALF 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_TRANSPOSE 
#      ------------------- 
#
#      Form the transposed Fock matrix --> Q+ F Q 
#      ------------------------------------------ 
#
       PARDO mu, sigma   
#
             TAxx(mu,sigma) = 0.0 
             TBxx(mu,sigma) = 0.0 
#
             DO lambda 
#
                GET Fpq_a(lambda,sigma) 
                GET Fpq_b(lambda,sigma) 
                GET Qxx(lambda,mu) 
#
                T1xx(mu,sigma)  = Qxx(lambda,mu)*Fpq_a(lambda,sigma)  
                TAxx(mu,sigma) += T1xx(mu,sigma) 
#
                T1xx(mu,sigma)  = Qxx(lambda,mu)*Fpq_b(lambda,sigma)  
                TBxx(mu,sigma) += T1xx(mu,sigma) 
#
             ENDDO lambda 
#
             DO nu 
#
                GET Qxx(sigma,nu) 
#
                T1xx(mu,nu) =        TAxx(mu,sigma)*Qxx(sigma,nu) 
                PUT FTpq_a(mu,nu) += T1xx(mu,nu) 
#
                T2xx(mu,nu)        = TBxx(mu,sigma)*Qxx(sigma,nu) 
                PUT FTpq_b(mu,nu) += T2xx(mu,nu) 
#
             ENDDO nu 
#
       ENDPARDO mu, sigma   
#
       ENDPROC FOCK_TRANSPOSE 
#      ---------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_DIAG  
#      -------------- 
#
#      First put the transposed Fock arrays into static arrays 
#      ------------------------------------------------------- 
#
       DO mu   
       DO nu  
#
          GET             FTpq_a(mu,nu) 
          GET             FTpq_b(mu,nu)
#
          FSpq_a(mu,nu) = FTpq_a(mu,nu)
          FSpq_b(mu,nu) = FTpq_b(mu,nu)
#
       ENDDO nu  
       ENDDO mu   
#
       execute eig FSpq_a ca
      #execute eig FSpq_b Cb  
#
       ENDPROC FOCK_DIAG 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC C_BTRAN 
#      ------------ 
#
#      Transform the coefficient array back to the original basis 
#      ---------------------------------------------------------- 
#
       PARDO mu, p  
#
          Txp(mu,p) = 0.0 
#
          DO nu 
#
             GET          Qxx(mu,nu) 
#
             T1xp(mu,p) = Qxx(mu,nu)*ca(nu,p)   
             Txp(mu,p) += T1xp(mu,p) 
#
          ENDDO nu 
#
          PUT CBT_a(mu,p) = Txp(mu,p) 
#
       ENDPARDO mu, p  
#
       PARDO mu, q
# 
          Txq(mu,q) = 0.0 
#
          DO nu 
#
             GET          Qxx(mu,nu) 
#
             T1xq(mu,q) = Qxx(mu,nu)*ca(nu,q)   
             Txq(mu,q) += T1xq(mu,q) 
#
          ENDDO nu 
#
          PUT CBT_b(mu,q) = Txq(mu,q) 
#
       ENDPARDO mu, q
       execute sip_barrier 
#
#      Put the transformed coefficients into static arrays 
#      --------------------------------------------------- 
#
       DO mu 
       DO p 
          GET        CBT_a(mu,p) 
          ca(mu,p) = CBT_a(mu,p) 
       ENDDO p 
       ENDDO mu  
#
       ENDPROC C_BTRAN 
#      --------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_ZERO   
#      ----------------  
#  
#      Zero out the n-1'th density array. 
#      ---------------------------------- 
#
       PARDO mu, nu 
#
             Txx(mu,nu)   = 0.0   
             PUT DHFa_old(mu,nu) = Txx(mu,nu)  
             PUT DHFb_old(mu,nu) = Txx(mu,nu)  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_ZERO   
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_REPLACE    
#      -------------------   
#
#      Replace the 'old' HF density by the 'new' HF density. 
#      ----------------------------------------------------- 
#
       PARDO mu, nu 
#
             GET DHFa(mu,nu) 
             GET DHFb(mu,nu) 
             PUT DHFa_old(mu,nu) = DHFa(mu,nu)  
             PUT DHFb_old(mu,nu) = DHFb(mu,nu)  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_REPLACE    
#      ----------------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
#
       PROC TRAN 
       CREATE FTa 
       CREATE FTb 
       CREATE Denai 
       CREATE Denbj 
#
# Zero out some arrays 
#
       execute server_barrier 
       PARDO mu, nu, i, i1 
             txixi(mu,i,nu,i1) = 0.0 
             txxii(mu,nu,i,i1) = 0.0 
             tixxi(i,mu,nu,i1) = 0.0 

             PREPARE Vxixi(mu,i,nu,i1) = txixi(mu,i,nu,i1) 
             PREPARE Vxxii(mu,nu,i,i1) = txxii(mu,nu,i,i1) 
             PREPARE Vixxi(i,mu,nu,i1) = tixxi(i,mu,nu,i1) 
       ENDPARDO mu, nu, i, i1 
#
       PARDO a, a1, i, i1 
             taiai(a,i,a1,i1) = 0.0 
             taaii(a,a1,i,i1) = 0.0 
             tiaai(i,a,a1,i1) = 0.0 

             PREPARE Vaiai(a,i,a1,i1) = taiai(a,i,a1,i1) 
             PREPARE Vaaii(a,a1,i,i1) = taaii(a,a1,i,i1) 
             PREPARE Viaai(i,a,a1,i1) = tiaai(i,a,a1,i1) 
       ENDPARDO a, a1, i, i1 
       execute server_barrier 
 
#
       PARDO mu, nu, lambda 
             allocate Lxxxi(mu,nu,lambda,*) 
             DO sigma 
                compute_integrals aoint(mu,nu,lambda,sigma) 
                DO i 
                   Txxxi(mu,nu,lambda,i)  = aoint(mu,nu,lambda,sigma)*ca(sigma,i) 
                   Lxxxi(mu,nu,lambda,i) += Txxxi(mu,nu,lambda,i) 
                ENDDO i 
             ENDDO sigma 

             DO i 
                DO i1 
                   Txxii(mu,nu,i1,i)          = Lxxxi(mu,nu,lambda,i)*ca(lambda,i1) 
                   PREPARE Vxxii(mu,nu,i1,i) += Txxii(mu,nu,i1,i) 

                   Tixxi(i1,nu,lambda,i)          = Lxxxi(mu,nu,lambda,i)*ca(mu,i1) 
                   PREPARE Vixxi(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i) 

                   Txixi(mu,i1,lambda,i)      = Lxxxi(mu,nu,lambda,i)*ca(nu,i1) 
                   PREPARE Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)  
                ENDDO i1 
             ENDDO i  
             deallocate Lxxxi(mu,nu,lambda,*) 
   
       ENDPARDO mu, nu, lambda 
       execute server_barrier 

       PARDO nu, i, i1 
     
             allocate Lixai(i1,nu,*,i) 

             DO lambda 
                REQUEST Vixxi(i1,nu,lambda,i) i 
             DO a 
                Tixai(i1,nu,a,i) = Vixxi(i1,nu,lambda,i)*ca(lambda,a) 
                Lixai(i1,nu,a,i) += Tixai(i1,nu,a,i) 
             ENDDO a 
             ENDDO lambda 

             DO a 
             DO a1 
                Tiaai(i1,a1,a,i) = Lixai(i1,nu,a,i)*ca(nu,a1) 
                PREPARE Viaai(i1,a1,a,i) += Tiaai(i1,a1,a,i) 
             ENDDO a1 
             ENDDO a 
     
             deallocate Lixai(i1,nu,*,i) 

       ENDPARDO nu, i, i1 

       PARDO mu, i, i1 

             allocate Lxaii(mu,*,i,i1) 

             DO nu 
                REQUEST Vxxii(mu,nu,i,i1) i  
             DO a1  
                Txaii(mu,a1,i,i1) = Vxxii(mu,nu,i,i1)*ca(nu,a1) 
                Lxaii(mu,a1,i,i1) += Txaii(mu,a1,i,i1) 
             ENDDO a1 
             ENDDO nu 

             DO a 
             DO a1 
                Taaii(a,a1,i,i1) = Lxaii(mu,a1,i,i1)*ca(mu,a) 
                PREPARE Vaaii(a,a1,i,i1) += Taaii(a,a1,i,i1) 
             ENDDO a1 
             ENDDO a 

             deallocate Lxaii(mu,*,i,i1) 

       ENDPARDO mu, i, i1 

       PARDO mu, i, i1 

             allocate Lxiai(mu,i,*,i1) 

             DO nu 
                REQUEST Vxixi(mu,i,nu,i1) i 
             DO a1 
                Txiai(mu,i,a1,i1) = Vxixi(mu,i,nu,i1)*ca(nu,a1) 
                Lxiai(mu,i,a1,i1) += Txiai(mu,i,a1,i1) 
             ENDDO a1 
             ENDDO nu 

             DO a 
             DO a1 
                Taiai(a,i,a1,i1) = Lxiai(mu,i,a1,i1)*ca(mu,a) 
                PREPARE Vaiai(a,i,a1,i1) += Taiai(a,i,a1,i1) 
             ENDDO a1 
             ENDDO a 

             deallocate Lxiai(mu,i,*,i1) 

       ENDPARDO mu, i, i1 

       execute server_barrier 

# Transform the Fock matrix 

       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             DO p 
                Txp(mu,p) = Fpq_a(mu,nu)*ca(nu,p) 
                DO p1 
                   Tpp(p1,p) = Txp(mu,p)*ca(mu,p1) 
                   PUT FTa(p1,p) += Tpp(p1,p) 
                ENDDO p1  
             ENDDO p 
       ENDPARDO mu, nu  
#     
       PARDO mu, nu 
             GET Fpq_b(mu,nu) 
             DO q 
                Txq(mu,q) = Fpq_b(mu,nu)*ca(nu,q) 
                DO q1 
                   Tqq(q1,q) = Txq(mu,q)*ca(mu,q1) 
                   PUT FTb(q1,q) += Tqq(q1,q) 
                ENDDO q1  
             ENDDO q 
       ENDPARDO mu, nu  
       execute sip_barrier 

       DO p 
       DO p1  
          GET FTa(p,p1) 
          Fock_a(p,p1) = FTa(p,p1) 
       ENDDO p1  
       ENDDO p 

       execute return_diagonal Fock_a DFock_a 
       execute sip_barrier 

       PARDO a, i 

             DO a1 
                if a == a1 
             DO i1 
                if i == i1 

                   tpp(a,a1)    = DFock_a(a,a1) 
                   tpp(a,a1)   *= -1.0  

                   t1pp(i,i1)   = DFock_a(i,i1) 

                   t2ai(a1,i)  = 1.0 
                   T1ai(a,i)   = tpp(a,a1)* t2ai(a1,i) 

                   t2ai(a,i1)  = 1.0 
                   T3ai(a,i)   = t2ai(a,i1)*t1pp(i,i1) 

                   Tai(a,i)     = T1ai(a,i)  
                   Tai(a,i)    += T3ai(a,i)  

                   PUT Denai(a,i) = Tai(a,i) 

                endif 
             ENDDO i1  
                endif 
             ENDDO a1  

       ENDPARDO a, i 
#
       ENDPROC TRAN 

       PROC FORM_DAI 

# Get initial guess 
#
          create cai 
          create cbj 
          create cnewai  
          esuma = 0.0 
          esumb = 0.0 
          eTsuma = 0.0 
          eTsumb = 0.0 
          execute sip_barrier 

          PARDO a, i 
                GET            denai(a,i) 
                tai(a,i)     = Fock_a(a,i) 
                execute apply_den2 tai denai 
                etemp        = tai(a,i)*tai(a,i) 
                esuma       += etemp 
                PUT Cai(a,i) = tai(a,i) 
          ENDPARDO a, i 
#
         #PARDO b, j 
         #      GET denbj(b,j) 
         #      tbj(b,j) = Fock_b(b,j) 
         #      execute apply_den2 tbj denbj 
         #      etemp = tbj(b,j)*tbj(b,j) 
         #      esumb += etemp 
         #      PUT Cbj(b,j) = tbj(b,j)  
         #ENDPARDO b, j 
          execute sip_barrier 

          collective eTsuma += esuma 
          collective eTsumb += esumb 

          exponent = 0.5 

          d0a  = 1.0 
          d0a -= eTsuma  
          execute square_root d0a exponent 
         #execute print_scalar eTsuma  
         #execute print_scalar d0a 
  

          d0b = 1.0 
          d0b -= eTsumb  
          execute square_root d0b exponent 

# Start iterations 

          dsqrt2 = 2.0 
          execute square_root dsqrt2 exponent  
    
          DO qiter 

             dfact_a = 0.0 
             esuma   = 0.0 
             execute sip_barrier 

             PARDO a, i 
                   GET      Cai(a,i) 
                   etemp1 = Cai(a,i)*Fock_a(a,i) 
                   etemp  = etemp1/d0a 
                   etemp *= dsqrt2  
                   esuma += etemp 
             ENDPARDO a, i 
             execute sip_barrier 
             collective dfact_a += esuma 
            #execute print_scalar dfact_a 
             execute sip_barrier 

# First and second term 
             PARDO a, i 

                   Get              Cai(a,i) 
                   tai(a,i)       = Fock_a(a,i) 
                   tai(a,i)      *= d0a 
                   tai(a,i)      *= dsqrt2  

                   t1ai(a,i)      = Cai(a,i) 
                   t1ai(a,i)     *= dfact_a  

                   tai(a,i)      -= t1ai(a,i) 
                   PUT Cnewai(a,i) += tai(a,i) 

             ENDPARDO a, i 

# Third term  
             PARDO a, i 
                   tai(a,i) = 0.0 
                   DO a1 
                      GET          Cai(a1,i) 
                      taa(a,a1)  = Fock_a(a,a1)  
                      taa(a,a1) -= DFock_a(a,a1)  
                      t1ai(a,i)  = taa(a,a1)*Cai(a1,i) 
                      tai(a,i)  += t1ai(a,i) 
                   ENDDO a1 
                   tai(a,i)        *= dsqrt2 
                   PUT Cnewai(a,i) += tai(a,i) 
             ENDPARDO a, i 

# Fourth term 
             PARDO a, i 
                   tai(a,i) = 0.0 
                   DO i1 
                      GET          Cai(a,i1) 
                      tii(i,i1)  = Fock_a(i,i1)  
                      tii(i,i1) -= DFock_a(i,i1)  
                      t1ai(a,i)  = tii(i,i1)*Cai(a,i1) 
                      tai(a,i)  -= t1ai(a,i) 
                   ENDDO i1 
                   tai(a,i)        *= dsqrt2  
                   PUT Cnewai(a,i) += tai(a,i) 
             ENDPARDO a, i 

# Terms containing 2-el integrals 

             PARDO a, i, a1, i1 
                   REQUEST             Vaiai(a,i,a1,i1) a 
                   REQUEST             Vaiai(a,i1,a1,i) a 
                   REQUEST             Viaai(i,a,a1,i1)  a 
                   REQUEST             Vaaii(a,a1,i1,i) a 

                   taiai(a,i,a1,i1)  = Vaiai(a,i,a1,i1)  
                   taiai(a,i,a1,i1) *= 2.0  
                   t1aiai(a,i,a1,i1) = Vaiai(a,i1,a1,i)  
                   t2aiai(a,i,a1,i1) = Viaai(i,a,a1,i1) 
                   t2aiai(a,i,a1,i1) *= 2.0  
                   t3aiai(a,i,a1,i1) = Vaaii(a,a1,i1,i)  

                   taiai(a,i,a1,i1) -= t1aiai(a,i,a1,i1) 
                   taiai(a,i,a1,i1) += t2aiai(a,i,a1,i1) 
                   taiai(a,i,a1,i1) -= t3aiai(a,i,a1,i1) 

                   GET                 Cai(a1,i1) 
                   tai(a,i)          = taiai(a,i,a1,i1)*Cai(a1,i1) 
                 # PUT Cnewai(a,i)  += tai(a,i) 
             ENDPARDO a, i, a1, i1 

             etemp           = 1.0/dsqrt2 
             execute sip_barrier 

# Update Cai 

             PARDO a, i 
                   GET               Cnewai(a,i) 
                   GET               denai(a,i) 
                   tai(a,i)        = Cnewai(a,i) 
                   execute apply_den2 tai denai 
                   tai(a,i)       *= etemp  
                   PUT Cai(a,i)    = tai(a,i)  
                   tai(a,i)        = 0.0 
                   PUT Cnewai(a,i) = tai(a,i)  
             ENDPARDO a, i 

# Update C0 
#
             esuma = 0.0 
             esumb = 0.0 
             eTsuma = 0.0 
             eTsumb = 0.0 
             execute sip_barrier 

             PARDO a, i 
                   GET     Cai(a,i) 
                   etemp = Cai(a,i)*Cai(a,i) 
                   esuma += etemp 
             ENDPARDO a, i 
#
            #PARDO b, j 
            #      GET denbj(b,j) 
            #      tbj(b,j) = Fock_b(b,j) 
            #      execute apply_den2 tbj denbj 
            #      etemp = tbj(b,j)*tbj(b,j) 
            #      esumb += etemp 
            #      PUT Cbj(b,j) = tbj(b,j)  
            #ENDPARDO b, j 
             execute sip_barrier 

             collective eTsuma += esuma 
             collective eTsumb += esumb 

             if eTsuma >= 1.0 
                execute print_scalar eTsuma 
                exit 
             endif 

             exponent = 0.5 

             d0a  = 1.0 
             d0a -= eTsuma  
             execute square_root d0a exponent 
            #execute print_scalar eTsuma 
            #execute print_scalar d0a 

             d0b = 1.0 
             d0b -= eTsumb  
             execute square_root d0b exponent 

             execute sip_barrier 
#
#        Check on convergence --> largest Cai difference. 
#        ----------------------------------------------- 
#
            qdone = 0.0 
            DO a 
            DO i 
#
#           Alpha component 
#           --------------- 
#
               GET           cnewai(a,i) 
               GET           cai(a,i) 
               tai(a,i) = cnewai(a,i) 
               tai(a,i) -= cai(a,i) 
#
               execute check_dconf Tai qdonea  
               if qdonea > qdone 
                  qdone = qdonea 
               endif 
#
            ENDDO i 
            ENDDO a 

            IF qdone < qcrit 
               exit 
            ENDIF 

# Zero out Cnewai array 

             PARDO a, i 
                   tai(a,i)        = 0.0 
                   PUT Cnewai(a,i) = tai(a,i)  
             ENDPARDO a, i 
#
          ENDDO qiter 
          create D_ca 
          execute sip_barrier 

# Construct new orbitals 
#
          if eTsuma < 1.0 
          PARDO mu, i 
                txi(mu,i) = ca(mu,i)  
                DO a 
                   GET          Cai(a,i) 
                   t1xi(mu,i) = ca(mu,a)*Cai(a,i) 
                   txi(mu,i) += t1xi(mu,i) 
                ENDDO a 
                etemp = 1.0/d0a 
                txi(mu,i) *= etemp  
                PUT D_ca(mu,i) = txi(mu,i) 
          ENDPARDO mu, i 
          execute sip_barrier 

          DO mu 
          DO i 
             GET          D_ca(mu,i) 
             S_ca(mu,i) = D_ca(mu,i) 
             ca(mu,i)   = D_ca(mu,i) 
          ENDDO i 
          DO a 
             S_ca(mu,a) = ca(mu,a) 
          ENDDO a 
          ENDDO mu 

          DO i  
          DO i1  
             tpp(i,i1) = 0.0 
          DO mu 
          DO nu 
             tpx(i,nu) = S_ca(mu,i)*foed_ovl(mu,nu) 
             t1pp(i,i1) = tpx(i,nu)*S_ca(nu,i1) 
             tpp(i,i1) += t1pp(i,i1) 
          ENDDO nu 
          ENDDO mu 
             XX(i,i1) = tpp(i,i1) 
             XXX(i,i1) = 0.0  
          ENDDO i1  
          ENDDO i 

          execute eig_sr_inv XX XXX 

          DO mu 
          DO i 
             txp(mu,i) = 0.0 
             DO i1  
                t1xp(mu,i) = S_ca(mu,i1)*XXX(i1,i) 
                txp(mu,i) += t1xp(mu,i) 
             ENDDO i1 
             ca(mu,i) = txp(mu,i) 
          ENDDO i 
          ENDDO mu 
             
          endif 
          execute sip_barrier 
          PARDO mu, nu 
                txx(mu,nu) = 0.0 
                DO i 
                   txi(nu,i)   = ca(nu,i) 
                   t1xx(mu,nu) = ca(mu,i)*txi(nu,i) 
                   txx(mu,nu) += t1xx(mu,nu) 
                ENDDO i 
                PUT DHFa(mu,nu) = txx(mu,nu)  
                PUT DHFb(mu,nu) = txx(mu,nu)  
          ENDPARDO mu, nu 
          delete D_ca 

       ENDPROC FORM_DAI 

       execute server_barrier 
#  
# ---------------------------------------------------------------------------- 
#
############################################################################## 
#
#                         START OF MAIN PROGRAM 
#
############################################################################## 
#
#     Define a few constants 
#     ---------------------- 
#
      ecrit  = scf_conv # Energy tolerance  
      qcrit  = scf_conv 
     #damp   = 0.0 
      etemp  = 1.0 
      etemp += damp  
      damp1  = 1.0/etemp         # 1/(1+damp)  
      execute print_scalar damp 
      execute print_scalar damp1

#     Put the overlap matrix into storage 
#     ----------------------------------- 
      DO mu 
      DO nu 
         foed_ovl(mu,nu) = oed_ovl(mu,nu) 
      ENDDO nu 
      ENDDO mu 

#
#     Perform initial (aa|bb) integral computation to set Schwartz paramaters 
#     ----------------------------------------------------------------------- 
#
      DO mu
      DO nu
      DO lambda
      DO sigma
            IF mu == lambda
            IF nu == sigma
               execute compute_aabb_batch aoint(mu,nu,lambda,sigma)
            ENDIF
            ENDIF
      ENDDO sigma
      ENDDO lambda
      ENDDO nu
      ENDDO mu

      zero = 0.0 
      mone = -1.0 
      one = 1.0 
      two = 2.0 
      three = 3.0 
      four = 4.0 
      diis_count = 0.0  
      diis_start = 2.0 
      diis_end = 5000.0 
      diis_order = 8.0 
      diis_max_order = 10.0 

      diis_start = 0.0
      do kbeg
         diis_start += 1.0
      ENDDO kbeg

      diis_order = 0.0
      do korder
         diis_order += 1.0
      ENDDO korder

      execute print_scalar diis_start
      execute print_scalar diis_order

#
#     Create the one-particle arrays needed for the computation. 
#     ---------------------------------------------------------- 
#
#     Fock matrix
#     ----------- 
      CREATE Fpq_a  
      CREATE Fpq_b  
#
#     New HF density 
#     -------------- 
#
      CREATE DHFa   
      CREATE DHFb   
#
#     Old HF density 
#     -------------- 
#
      CREATE DHFa_old    
      CREATE DHFb_old    
#
#     DIIS vectors 
#     ------------ 
#
      allocate BB(*,*) 
      create Fa 
      create Fb 
      create Fai  
      create Fbj  
      CREATE FFai
      CREATE FFbj
#
#     Orthonormalizing transformation coefficient
#     ------------------------------------------- 
#
      CREATE Qxx 
      execute sip_barrier 
#
#     Construct the initial guess of the Fock matrix.
#     -----------------------------------------------
#    
      create IDhfa
      create IDhfb
      esum = 0.0
      esum1= 0.0
      execute sip_barrier
      execute list_to_blocks IDhfa
      execute list_to_blocks IDhfb
      execute read_list_to_blocks
      execute sip_barrier

     #CALL IGUESS 
      PARDO mu, nu
            GET               IDHFa(mu,nu)
            GET               IDHFb(mu,nu)
            txx(mu,nu)      = IDHFa(mu,nu)
            txx(mu,nu)     += IDHFb(mu,nu)
            txx(mu,nu)     *= 0.5
            PUT DHFa(mu,nu) = txx(mu,nu)
            PUT DHFb(mu,nu) = txx(mu,nu)
            etemp = txx(mu,nu)*txx(mu,nu)
            esum += etemp
      ENDPARDO mu, nu

#     Construct the array S**(-1/2) 
#     ----------------------------- 
#
      CALL OVER_HALF 
      execute sip_barrier 

      DO mu
      DO nu
         GET              DHFa(mu,nu)
         GET              DHFb(mu,nu)
         oed_ovl(mu,nu) = DHFa(mu,nu) # 13
         oed_kin(mu,nu) = DHFb(mu,nu) # 12
      ENDDO nu
      ENDDO mu

      DO iiter1
      DO jjter2
          execute set_flags2 dflags12(iiter1,jjter2)
      ENDDO jjter2
      ENDDO iiter1 

      CALL FOCK_MATRIX_FAST 
      delete IDhfa 
      delete IDhfb 

#
#     Construct S^(-1/2) F S^(-1/2) 
#     ----------------------------- 
#
      CREATE FTpq_a  
      CREATE FTpq_b  
      execute sip_barrier 
      CALL FOCK_TRANSPOSE 
      execute sip_barrier 
#

#     -------------------------------------- 
#
      CALL FOCK_DIAG 
#
#     Back transform the coefficient array 
#     ------------------------------------ 
#
      CREATE CBT_a 
      CREATE CBT_b 
      execute sip_barrier
      CALL   C_BTRAN 
      execute sip_barrier
#
#     Zero out the 'old' HF density 
#     ----------------------------- 
#
      CALL HFDENS_ZERO 
      execute sip_barrier
#
#     Compute the HF density 
#     ---------------------- 
#
      CALL HFIDENS

      DO mu 
      DO nu 
         txx(mu,nu) = 0.0 
         Fockrohf_a(mu,nu) = txx(mu,nu)  
         Fockrohf_b(mu,nu) = txx(mu,nu)  
      ENDDO nu 
      ENDDO mu 

      etemp = -1.0 
      execute scf_atom etemp 
      if etemp == 1.0 

         DO mu 
         DO nu 
            txx(mu,nu)      = Fockrohf_a(mu,nu)  
            PUT Dhfa(mu,nu) = txx(mu,nu)
            txx(mu,nu)      = Fockrohf_b(mu,nu)  
            PUT Dhfb(mu,nu) = txx(mu,nu)
         ENDDO nu 
         ENDDO mu 

      endif 
      
      execute sip_barrier
#
#     Damp the HF density 
#     ------------------- 
#
#     CALL HF_DAMP 
#     execute sip_barrier
#
#     Compute the energy 
#     ------------------ 
#
      CALL HF_ENERGY 
      energy1 = energy 
      execute sip_barrier
#
#     Replace 'old' HF density by 'new' HF density 
#     -------------------------------------------- 
#
      CALL HFDENS_REPLACE 
#
#     Create history arrays 
#     --------------------- 
#
      execute sip_barrier
#
      DELETE FTpq_a  
      DELETE FTpq_b  
      DELETE Fpq_a  
      DELETE Fpq_b  
      DELETE CBT_a 
      DELETE CBT_b 
#
# Start iterations 
# ---------------- 
#
      DO kiter 
         diis_count += 1.0 
#
#        Create 1-particle arrays 
#        ------------------------ 
#
         CREATE Fpq_a 
         CREATE Fpq_b 
         CREATE CBT_a 
         CREATE CBT_b 
         CREATE FTpq_a  
         CREATE FTpq_b  
         execute sip_barrier
#
#        Construct the new Fock matrix 
#        -----------------------------

         DO mu
         DO nu
            GET              DHFa(mu,nu)
            GET              DHFb(mu,nu)
            oed_ovl(mu,nu) = DHFa(mu,nu) # 13
            oed_kin(mu,nu) = DHFb(mu,nu) # 12
         ENDDO nu
         ENDDO mu

         DO iiter1
         DO jjter2
             execute set_flags2 dflags12(iiter1,jjter2)
         ENDDO jjter2
         ENDDO iiter1 

#
         CALL FOCK_MATRIX_FAST 
         execute sip_barrier 
#
         CALL HF_ENERGY 
         energy2 = energy 
         execute sip_barrier
#
         execute sip_barrier
#
#        DONE Compute the DIIS  
#        --------------------- 
#
#        Transpose the new Fock matrix 
#        -----------------------------
#
         CALL FOCK_TRANSPOSE 
         execute sip_barrier
#
#        Diagonalize the transposed Fock matrix 
#        -------------------------------------- 
#
         CALL FOCK_DIAG 
         execute sip_barrier
#
#        Back transform the coefficient array 
#        ------------------------------------ 
#
         CALL C_BTRAN 
         execute sip_barrier
#
         done = 0.0 
         execute sip_barrier
#
#        Check on convergence --> largest HF density difference. 
#        ------------------------------------------------------- 
#
         DO mu 
         DO nu 
#
#           Alpha component 
#           --------------- 
#
            GET           DHFa_old(mu,nu) 
            GET           DHFa(mu,nu) 
#
            Txx(mu,nu)  = DHFa(mu,nu) 
            Txx(mu,nu) -= DHFa_old(mu,nu) 
            execute check_dconf Txx donea  
            if donea > done 
               done = donea 
            endif 
#
#           Beta component 
#           -------------- 
#
            GET           DHFb_old(mu,nu) 
            GET           DHFb(mu,nu) 
#
            Txx(mu,nu)  = DHFb(mu,nu) 
            Txx(mu,nu) -= DHFb_old(mu,nu) 
            execute check_dconf Txx doneb  
            if doneb > done 
               done = doneb 
            endif 
#
         ENDDO nu 
         ENDDO mu 
#
         execute sip_barrier
#
       # execute print_scalar done 

            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == one
               tpinf(kiter,kptr1) = energy
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1

            ncount1 = 0.0
         DO kptr1
            ncount1 = ncount1 + 1.0
            if ncount1 == two
               tpinf(kiter,kptr1) = done
               pinf(kiter,kptr1)  = tpinf(kiter,kptr1)
            endif
         ENDDO kptr1
         execute print_rel_info one pinf

#
#        Check on convergence using density difference. 
#        ---------------------------------------------- 
#
         IF kiter > 1 
            IF done < ecrit 
               DELETE FTpq_a  
               DELETE FTpq_b  
               DELETE CBT_a 
               DELETE CBT_b 
               exit 
            ENDIF 
         ENDIF 
#
#        Replace 'old' HF density by 'new' HF density 
#        -------------------------------------------- 
#
         CALL HFDENS_REPLACE 
         execute sip_barrier
#
#        Reset eold --> enew
#        -------------------
#
         energy1 = energy2  
#
#        Compute the updated orbitals  
#        ----------------------------  
#
        if diis_count >= diis_start 

            CALL TRAN 
            CALL FORM_DAI 
            delete Fta 
            delete Ftb 
            delete Denai 
            delete Denbj 
            delete cai 
            delete cbj 
            delete cnewai  

         endif 
#
#        Compute the HF density 
#        ---------------------- 
#
         if diis_count < diis_start 
#
            CALL HFDENS

         endif 
	 execute sip_barrier
#
#        Delete one-particle arrays to be used in the next iteration. 
#        ------------------------------------------------------------ 
#
         if kiter < scf_iter
            DELETE Fpq_a 
            DELETE Fpq_b 
         endif

         DELETE FTpq_a  
         DELETE FTpq_b  
         DELETE CBT_a 
         DELETE CBT_b 
#
         if kiter >= scf_iter
            one = -10.0
            execute print_rel_info one pinf
         endif
#
      ENDDO kiter 
#
#     Release unneeded memory blocks.
#
      execute sip_barrier
      DELETE DHFA
      DELETE DHFB
      DELETE DHFA_OLD
      DELETE DHFB_OLD

      CREATE FTa 
      CREATE FTb 
      execute sip_barrier 
      PARDO mu, nu 
            GET Fpq_a(mu,nu) 
            DO p 
               Txp(mu,p) = Fpq_a(mu,nu)*ca(nu,p) 
               DO p1 
                  Tpp(p1,p) = Txp(mu,p)*ca(mu,p1) 
                  PUT FTa(p1,p) += Tpp(p1,p) 
               ENDDO p1  
            ENDDO p 
      ENDPARDO mu, nu  
#     
      PARDO mu, nu 
            GET Fpq_b(mu,nu) 
            DO q 
               Txq(mu,q) = Fpq_b(mu,nu)*ca(nu,q) 
               DO q1 
                  Tqq(q1,q) = Txq(mu,q)*ca(mu,q1) 
                  PUT FTb(q1,q) += Tqq(q1,q) 
               ENDDO q1  
            ENDDO q 
      ENDPARDO mu, nu  
      execute sip_barrier 
#
#     Put the final Fock arrays into predefined arrays 
#     ------------------------------------------------ 
#
      DO p
      DO p1
         GET FTa(p,p1)
         Fock_a(p,p1) = FTa(p,p1)
      ENDDO p1
      ENDDO p

      execute sip_barrier

      execute print_rel_info two pinf
      execute print_rel_info three Fock_a
     #execute print_rel_info four Fock_b
      execute get_my_rank rank
      if rank == 0.0
         DO mu
         DO p
            txp(mu,p) = ca(mu,p)
         ENDDO p
         ENDDO mu
      execute print_rel_info zero ca
     #execute print_rel_info mone ca
      endif


      scfeneg  = energy2
      totenerg = scfeneg
      execute sip_barrier
#                         
#
                           ENDSIAL SCF_UHF_DIIS         
#
###############################################################################
#
