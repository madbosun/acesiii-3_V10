#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL SCF_RHF_TEST          
#
# ----------------------------------------------------------------------------
#
# The sial program SIAL_UHF performs a UHF based SCF calculation. Davidson 
# damping is performed during the first scf_beg-1 iterations after which the 
# DIIS is turned on with scf_order. At present DIIS is turned on after the 
# third iteration and 6 histories are kept. 
#
# Fock matrix final arrays:
# ------------------------- 
#
# 1. Fpq_a  
# 2. Fpq_b  
#
# Transformation coefficients final arrays:
# ----------------------------------------- 
#
# 1. Ca  
# 2. Cb  
#
# Converged SCF energy:
# --------------------- 
#
# 1. scfeneg 
#
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
#
# Declare indeces 
# --------------- 
#
      index   kiter  = 1, scf_iter  
      index   iiter  = 1, 8  
      index   jjter  = 1, 2  
#
      index   iiter1 = 1, 1  
      index   iiter2 = 2, 2  
      index   iiter3 = 3, 3  
      index   iiter4 = 4, 4  
      index   iiter5 = 5, 5  
      index   iiter6 = 6, 6  
      index   iiter7 = 7, 7  
      index   iiter8 = 8, 8  
#
      index   jjter1 = 1, 1  
      index   jjter2 = 2, 2  
      index   jjter3 = 3, 3  
      index   jjter4 = 4, 4  
      index   jjter5 = 5, 5  
      index   jjter6 = 6, 6  
      index   jjter7 = 7, 7  
      index   jjter8 = 8, 8  
#
      aoindex mu     = 1, norb
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
      aoindex ii     = 1, norb
      aoindex jj     = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
# 
# Declare one-particle density arrays 
# ----------------------------------- 
#
      distributed Dhfa(mu,nu) 
      local LDhfa(mu,nu) 
      distributed Dhfa_old(mu,nu) 
#
      distributed Fpq_a(mu,nu) 
      local LFpq_a(mu,nu) 
      served FTpq_a(mu,nu) 
      distributed CBT_a(mu,p) 
      static dflags2(iiter,jjter) 
#
      static dflags11(iiter1,jjter1) 
      static dflags21(iiter2,jjter1) 
      static dflags31(iiter3,jjter1) 
      static dflags41(iiter4,jjter1) 
      static dflags51(iiter5,jjter1) 
      static dflags61(iiter6,jjter1) 
      static dflags71(iiter7,jjter1) 
      static dflags81(iiter8,jjter1) 
#
      static dflags12(iiter1,jjter2) 
      static dflags22(iiter2,jjter2) 
      static dflags32(iiter3,jjter2) 
      static dflags42(iiter4,jjter2) 
      static dflags52(iiter5,jjter2) 
      static dflags62(iiter6,jjter2) 
      static dflags72(iiter7,jjter2) 
      static dflags82(iiter8,jjter2) 
#
      temp T11(iiter1,jjter1) 
# 
# Declare temporary arrays 
# ------------------------ 
#
      temp Txxxx(mu,nu,lambda,sigma) 
      temp TSxxxx(mu,nu,lambda,sigma) 
      temp T1xxxx(mu,nu,lambda,sigma) 
      temp T2xxxx(mu,nu,lambda,sigma) 
      temp T3xxxx(mu,nu,lambda,sigma) 
      temp T4xxxx(mu,nu,lambda,sigma) 
      temp T5xxxx(mu,nu,lambda,sigma) 
      temp TAxxxx(mu,ii,lambda,sigma) 
      temp TBxxxx(mu,ii,lambda,jj) 
      temp Txxxi(mu,nu,lambda,i) 
      temp T1xxxi(mu,nu,lambda,i) 
      temp T2xxxi(mu,nu,lambda,i) 
      temp T3xxxi(mu,nu,lambda,i) 
      temp T4xxxi(mu,nu,lambda,i) 
      temp TAxxxi(mu,nu,lambda,i) 
      temp TBxxxi(mu,nu,lambda,i) 
      temp Txxxj(mu,nu,lambda,j) 
      temp T1xxxj(mu,nu,lambda,j) 
      temp T2xxxj(mu,nu,lambda,j) 
      temp T3xxxj(mu,nu,lambda,j) 
      temp T4xxxj(mu,nu,lambda,j) 
      temp TAxxxj(mu,nu,lambda,j) 
      temp TBxxxj(mu,nu,lambda,j) 
      temp Txixx(mu,i,nu,lambda) 
      temp Txjxx(mu,j,nu,lambda) 
      temp Tixxx(i,mu,nu,lambda) 
      temp Tjxxx(j,mu,nu,lambda) 
      temp Ixi(mu,i) 
      temp I1xi(mu,i) 
      temp Ixj(mu,j) 
      temp I1xj(mu,j) 
      temp Tpq(mu,nu) 
      temp T1pq(mu,nu) 
      temp Txi(mu,i) 
      temp T1xi(mu,i) 
      temp Txj(mu,j) 
      temp T1xj(mu,j) 
      temp Txx(mu,nu) 
      distributed TAxx(mu,nu) 
      temp T1xx(mu,nu) 
      temp T2xx(mu,nu) 
      temp T3xx(mu,nu) 
      temp T4xx(mu,nu) 
      temp T5xx(mu,nu) 
      temp T6xx(mu,nu) 
      temp T7xx(mu,nu) 
      temp T8xx(mu,nu) 
      temp T9xx(mu,nu) 
      temp T10xx(mu,nu) 
      temp T11xx(mu,nu) 
      temp T12xx(mu,nu) 
      temp T13xx(mu,nu) 
      temp T14xx(mu,nu) 
      temp T15xx(mu,nu) 
      temp T16xx(mu,nu) 
      temp T17xx(mu,nu) 
      temp T18xx(mu,nu) 
      temp T19xx(mu,nu) 
      temp T20xx(mu,nu) 
      temp T21xx(mu,nu) 
      temp T22xx(mu,nu) 
      temp T23xx(mu,nu) 
      temp T24xx(mu,nu) 
      temp T25xx(mu,nu) 
      temp Tii(i,i1) 
      temp T1ii(i,i1) 
      temp Tjj(j,j1) 
      temp T1jj(j,j1) 
      temp Txp(mu,p) 
      temp T1xp(mu,p) 
      temp Tpp(p,p1) 
      temp T1pp(p,p1) 
      temp Txq(mu,q) 
      temp T1xq(mu,q) 
      temp Tqq(q,q1) 
      temp T1qq(q,q1) 
#
# Declare served arrays 
# --------------------- 
#
      temp aoint(mu,nu,lambda,sigma)
      temp aoint1(mu,nu,lambda,sigma)
      temp aoint1a(mu,nu,lambda,sigma)
      temp aoint2(mu,nu,lambda,sigma)
      temp aoint3(mu,nu,lambda,sigma)
      temp aoint4(mu,nu,lambda,sigma)
      temp aoint5(mu,nu,lambda,sigma)
      temp aoint6(mu,nu,lambda,sigma)
      temp aoint7(mu,nu,lambda,sigma)
      temp aoint8(mu,nu,lambda,sigma)
      temp aoint9(mu,nu,lambda,sigma)
     #served saoint(mu,mu,lambda,lambda)
#
# Declare static arrays 
# --------------------- 
#
      static FSpq_a(mu,nu) 
      static FSpq_b(mu,nu) 
      distributed Qxx(mu,nu) 
      distributed FTa(p,p1) 
      distributed FTb(q,q1) 
      static X1(mu,nu) 
      static X2(mu,nu) 
      static X3(mu,nu) 
#
# Arrays used in DIIS procedure 
# ----------------------------- 
#  
      distributed Fai(a,i) 
      distributed F1ai(a,i) 
      distributed F2ai(a,i) 
      distributed F3ai(a,i) 
      distributed F4ai(a,i) 
      distributed F5ai(a,i) 
      distributed F6ai(a,i) 
      distributed F7ai(a,i) 
      distributed F8ai(a,i) 
      distributed F9ai(a,i) 
      distributed F10ai(a,i) 
      temp tai(a,i) 
      temp tbj(b,j) 
      distributed F1a(mu,nu) 
      distributed F2a(mu,nu) 
      distributed F3a(mu,nu) 
      distributed F4a(mu,nu) 
      distributed F5a(mu,nu) 
      distributed F6a(mu,nu) 
      distributed F7a(mu,nu) 
      distributed F8a(mu,nu) 
      distributed F9a(mu,nu) 
      distributed F10a(mu,nu) 
      distributed F4b(mu,nu) 
#
# Scalars used in DIIS procedure 
# ------------------------------ 
#
       scalar b11
       scalar b12
       scalar b13
       scalar b14
       scalar b15
       scalar b16
       scalar b17
       scalar b18
       scalar b19
       scalar b110 
#
       scalar b22
       scalar b23
       scalar b24
       scalar b25
       scalar b26
       scalar b27
       scalar b28
       scalar b29
       scalar b210 
#
       scalar b33
       scalar b34
       scalar b35
       scalar b36
       scalar b37
       scalar b38
       scalar b39
       scalar b310 
#
       scalar b44
       scalar b45
       scalar b46
       scalar b47
       scalar b48
       scalar b49
       scalar b410 
#
       scalar b55
       scalar b56
       scalar b57
       scalar b58
       scalar b59
       scalar b510 
#
       scalar b66 
       scalar b67 
       scalar b68 
       scalar b69 
       scalar b610  
#
       scalar b77 
       scalar b78 
       scalar b79 
       scalar b710  
#
       scalar b88 
       scalar b89 
       scalar b810  
#
       scalar b99 
       scalar b910  
#
       scalar b1010 
#
       scalar c1
       scalar c2
       scalar c3
       scalar c4
       scalar c5
       scalar c6
       scalar c7
       scalar c8
       scalar c9
       scalar c10 
#
       scalar Tb11
       scalar Tb12
       scalar Tb13
       scalar Tb14
       scalar Tb15
       scalar Tb16
       scalar Tb17
       scalar Tb18
       scalar Tb19
       scalar Tb110 
#
       scalar Tb22
       scalar Tb23
       scalar Tb24
       scalar Tb25
       scalar Tb26
       scalar Tb27
       scalar Tb28
       scalar Tb29
       scalar Tb210 
#
       scalar Tb33
       scalar Tb34
       scalar Tb35
       scalar Tb36
       scalar Tb37
       scalar Tb38
       scalar Tb39
       scalar Tb310 
#
       scalar Tb44
       scalar Tb45
       scalar Tb46
       scalar Tb47
       scalar Tb48
       scalar Tb49
       scalar Tb410 
#
       scalar Tb55
       scalar Tb56
       scalar Tb57
       scalar Tb58
       scalar Tb59
       scalar Tb510 
#
       scalar Tb66 
       scalar Tb67 
       scalar Tb68 
       scalar Tb69 
       scalar Tb610  
#
       scalar Tb77 
       scalar Tb78 
       scalar Tb79 
       scalar Tb710  
#
       scalar Tb88 
       scalar Tb89 
       scalar Tb810  
#
       scalar Tb99 
       scalar Tb910  
#
       scalar Tb1010 
#
# Declare scalars 
# --------------- 
#
      scalar e_a     
      scalar e_b     
      scalar escf_a 
      scalar escf_b 
      scalar etemp 
      scalar esum 
      scalar energy 
      scalar energy1 
      scalar energy2 
      scalar ecrit 
      scalar dcrit 
      scalar ediff  
#     scalar damp 
      scalar damp1 
      scalar done 
      scalar donea  
      scalar doneb  
      scalar ix 
      scalar jx 
      scalar iflag 
      scalar rank 
#
# ---------------------------------------------------------------------------- 
#
      PROC IGUESS   
#     ----------- 
#
#     Initialize the Fock matrix to the bare 1-electron hamiltonian.
#     -------------------------------------------------------------- 
#
      PARDO mu, nu 
#
           #Txx(mu,nu)       = oed_nai(mu,nu)  
           #Txx(mu,nu)      += oed_kin(mu,nu)  
            Txx(mu,nu) = 0.0 
            execute return_h1 Txx(mu,nu) 
#
            PUT Fpq_a(mu,nu) = Txx(mu,nu) 
#
      ENDPARDO mu, nu 
#
      ENDPROC IGUESS   
#     -------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
#     The HF density is computed. Davidson damping is incorporated thus
#     knowlede of the previous iteration is needed. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component first 
#           --------------------- 
#
            GET           DHFa_old(mu,nu) 
            Tpq(mu,nu)  = DHFa_old(mu,nu)   
            Tpq(mu,nu) *= damp  
#
            DO i 
#
               Txi(nu,i)   = ca(nu,i)
               T1pq(mu,nu) = Txi(nu,i)*ca(mu,i)
               Tpq(mu,nu) += T1pq(mu,nu) 
#
            ENDDO i 
#
            Tpq(mu,nu)     *= damp1   
            PUT Dhfa(mu,nu) = Tpq(mu,nu)
#
      ENDPARDO mu, nu 
#
      ENDPROC HFDENS
#     --------------
#
# ---------------------------------------------------------------------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFIDENS
#     ------------
#
#     Procedure which computes the HF density without Davidson damping. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component 
#           --------------- 
#
            Tpq(mu,nu) = 0.0 
#
            DO i 
#
               Txi(nu,i)   = ca(nu,i)
               T1pq(mu,nu) = Txi(nu,i)*ca(mu,i)
               Tpq(mu,nu) += T1pq(mu,nu) 
#
            ENDDO i 
# 
            PUT Dhfa(mu,nu) = Tpq(mu,nu)
#
      ENDPARDO mu, nu 
#
      ENDPROC HFIDENS
#     ---------------
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCKI_MATRIX  
#      ----------------- 
#
#      The complete Fock matrix is constructed. Eight fold symmetry of the
#      two-electron integrals is incorporated. 
#      ------------------------------------------------------------------
#
#      Initialize the Fock matrix to the bare 1-electron hamiltonian.
#      -------------------------------------------------------------- 
#
       DO mu
       DO nu
#
          Txx(mu,nu) = 0.0
          Fockrohf_a(mu,nu) = Txx(mu,nu)
#
       ENDDO nu
       ENDDO mu
#
       DO iiter1 
       DO jjter1 
           execute set_flags2 dflags11(iiter1,jjter1) 
       ENDDO jjter1 
       ENDDO iiter1 
       execute sip_barrier 
#
      #IF iiter == 1 
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
################################### CLASS 6  ########################################
##  Do four-center part (mu nu |la si)->(mu nu |si la ),(nu mu|la si),(nu mu|si la) #
##                      (la si |mu nu),(si la |mu nu),(la si |nu mu),(si la |nu mu) #
#####################################################################################
#
        PARDO nu, sigma, mu, lambda
              WHERE nu > sigma
              WHERE mu  < nu
              WHERE mu != sigma
#
                    WHERE lambda  < sigma
                    WHERE mu     < lambda
                    WHERE nu     != lambda
#
                         execute compute_batch1 aoint(mu,nu,lambda,sigma) 
##
                   #ENDIF
                   #ENDIF
                   #ENDIF
#
                #ENDIF
                #ENDIF
                #ENDIF
        ENDPARDO nu, sigma, mu, lambda
#
        PARDO sigma, nu, mu, lambda 
              WHERE nu < sigma
              WHERE mu  < nu
              WHERE mu != sigma
#
                    WHERE lambda  < sigma
                    WHERE mu     < lambda
                    WHERE nu     != lambda
#
                         execute compute_batch1 aoint1(mu,nu,lambda,sigma)
##
                   #ENDIF
                   #ENDIF
                   #ENDIF
#
                #ENDIF
                #ENDIF
                #ENDIF
        ENDPARDO sigma, nu, mu, lambda  
##
      #ENDIF # iiter == 1 
#
      #IF iiter == 2 
#
############ CLASS 3  ############
#  Do two-center part (mu mu |mu nu)->(mu nu |mu mu ),(mu mu|nu mu),(nu mu|mu mu)
#  Do three-center part (mu mu |nu lambda)->(mu mu |lambda nu ),(nu lambda|mu mu),(lambda nu|mu mu)
#
       PARDO mu, sigma, nu, lambda
              WHERE mu == nu
              WHERE lambda < sigma
#
                   execute compute_batch2 aoint2(mu,nu,lambda,sigma)
#
             #ENDIF
             #ENDIF 
       ENDPARDO mu, sigma, nu, lambda
#
      #IF iiter == 3 
#
############ CLASS 5  ############
###################  CLASS A ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, sigma, nu, lambda 
                WHERE mu == lambda
                WHERE lambda < sigma
                WHERE nu < sigma
                WHERE mu < nu
#
                   execute compute_batch3 aoint3(mu,nu,lambda,sigma)
#
               #ENDIF
               #ENDIF
               #ENDIF
               #ENDIF
       ENDPARDO mu, sigma, nu, lambda
#
      #IF iiter == 4 
#
###################  CLASS B ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
# 
       PARDO mu, lambda, nu, sigma  
              WHERE nu == lambda
              WHERE mu < nu
              WHERE lambda < sigma
              WHERE mu     < sigma
#
                   execute compute_batch4 aoint4(mu,nu,lambda,sigma)
#
               #ENDIF
               #ENDIF
               #ENDIF
               #ENDIF
       ENDPARDO mu, lambda, nu, sigma  
#
      #IF iiter == 5 
#
###################  CLASS C ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, nu, lambda, sigma
                WHERE nu == sigma
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu < lambda
#
                   execute compute_batch5 aoint5(mu,nu,lambda,sigma)
#
               #ENDIF
               #ENDIF
               #ENDIF
               #ENDIF
       ENDPARDO mu, nu, lambda, sigma  
#
      #IF iiter == 7 
#
############ CLASS 2  ############
#  Do two-center part (mu mu |nu nu)->(nu nu |mu mu )
#
       PARDO nu, lambda, mu, sigma  
             WHERE mu == nu
             WHERE mu < lambda
             WHERE lambda == sigma
#
                   execute compute_batch7 aoint6(mu,nu,lambda,sigma)
#
               #ENDIF
               #ENDIF
               #ENDIF
       ENDPARDO nu, lambda, mu, sigma  
#
      #IF iiter == 8 
#
############ END CLASS 2  ############
#
############ CLASS 4  ############
#  Do two-center part (mu nu |mu nu)->(mu nu |nu mu ),(nu mu|mu nu),(nu mu|nu mu)
#
       PARDO mu, sigma, nu, lambda
              WHERE mu < nu
              WHERE nu == sigma
              WHERE mu == lambda
              WHERE lambda < sigma
#
                   execute compute_batch8 aoint7(mu,nu,lambda,sigma)  
#
               #ENDIF
               #ENDIF
               #ENDIF
               #ENDIF
       ENDPARDO mu, sigma, nu, lambda  
#
      #IF iiter == 6 
#
############ CLASS 1  ############
#  Do one-center part (mu mu |mu mu)
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
       PARDO mu, nu, lambda, sigma
              WHERE mu == nu 
              WHERE sigma == mu 
              WHERE lambda == mu 
#
                   execute compute_batch6 aoint8(mu,nu,lambda,sigma)
#
             #ENDIF 
             #ENDIF 
             #ENDIF 
       ENDPARDO mu, nu, lambda, sigma
#
      #ENDDO iiter 
#
       execute sip_barrier
#
       DO mu
       DO nu
#
          Txx(mu,nu)        = Fockrohf_a(mu,nu)
          PUT Fpq_a(mu,nu) += Txx(mu,nu)
#
       ENDDO nu
       ENDDO mu
#
       execute sip_barrier
#
       PARDO mu, nu   
#
            #Txx(mu,nu)        = oed_nai(mu,nu)  
            #Txx(mu,nu)       += oed_kin(mu,nu)  
             Txx(mu,nu) = 0.0 
             execute return_h1 Txx(mu,nu) 
#
             PUT Fpq_a(mu,nu) += Txx(mu,nu) 
#
       ENDPARDO mu, nu   
#
       deallocate LDHFa(*,*) 
       deallocate LFpq_a(*,*) 
#
       execute sip_barrier
#
       ENDPROC FOCKI_MATRIX  
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_MATRIX  
#      ----------------- 
#
#      The complete Fock matrix is constructed. Eight fold symmetry of the
#      two-electron integrals is incorporated. 
#      ------------------------------------------------------------------
#
#      Initialize the Fock matrix to the bare 1-electron hamiltonian.
#      -------------------------------------------------------------- 
#
      #execute get_my_rank rank
      #if rank == 0.0 
          DO mu
          DO nu
             GET              DHFa(mu,nu) 
             oed_ovl(mu,nu) = DHFa(mu,nu)  
#
             Txx(mu,nu)        = 0.0
             Fockrohf_a(mu,nu) = Txx(mu,nu)
          ENDDO nu
          ENDDO mu
      #ENDIF 
#
# To be used with a density difference based algorithm 
# ----------------------------------------------------  
      #dcrit = 0.00000001 
      #IF kiter > 1 
      #   IF done < dcrit 
      #     DO mu
      #     DO nu
      #        GET              DHFa_old(mu,nu)
      #        GET              DHFa(mu,nu)
      #        txx(mu,nu)     = DHFa(mu,nu) 
      #        txx(mu,nu)    -= DHFa_old(mu,nu) 
      #        oed_ovl(mu,nu) = txx(mu,nu)  
      #      ENDDO nu
      #      ENDDO mu
      #    ELSE 
      #      DO mu
      #      DO nu
      #         GET              DHFa(mu,nu) 
      #         oed_ovl(mu,nu) = DHFa(mu,nu)  
      #         Txx(mu,nu)        = 0.0
      #         Fockrohf_a(mu,nu) = Txx(mu,nu)
      #      ENDDO nu
      #      ENDDO mu
      #   ENDIF 
      #ENDIF 
#
       DO iiter1 
       DO jjter2 
           execute set_flags2 dflags12(iiter1,jjter2) 
       ENDDO jjter2 
       ENDDO iiter1 
#
       execute sip_barrier 
#
      #IF iiter == 1 
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
################################### CLASS 6  ########################################
##  Do four-center part (mu nu |la si)->(mu nu |si la ),(nu mu|la si),(nu mu|si la) #
##                      (la si |mu nu),(si la |mu nu),(la si |nu mu),(si la |nu mu) #
#####################################################################################
#
        PARDO nu, sigma, mu, lambda
              WHERE nu > sigma
              WHERE mu  < nu
              WHERE lambda  < sigma
              WHERE mu     < lambda
#
                    WHERE nu != lambda
                    WHERE mu != sigma
#
                         execute compute_batch1 aoint(mu,nu,lambda,sigma)
##
        ENDPARDO nu, sigma, mu, lambda
#
        PARDO sigma, nu, mu, lambda  
              WHERE nu < sigma
              WHERE mu  < nu
              WHERE lambda  < sigma
              WHERE mu     < lambda
#
                    WHERE mu != sigma
                    WHERE nu != lambda
#
                         execute compute_batch1 aoint1(mu,nu,lambda,sigma)
##
        ENDPARDO sigma, nu, mu, lambda  
##
      #ENDIF # iiter == 1 
#
      #IF iiter == 2 
#
############ CLASS 3  ############
#  Do two-center part (mu mu |mu nu)->(mu nu |mu mu ),(mu mu|nu mu),(nu mu|mu mu)
#  Do three-center part (mu mu |nu lambda)->(mu mu |lambda nu ),(nu lambda|mu mu),(lambda nu|mu mu)
#
       PARDO mu, sigma, nu, lambda 
                 WHERE mu == nu
                 WHERE lambda < sigma
#
                   execute compute_batch2 aoint2(mu,nu,lambda,sigma)
#
       ENDPARDO mu, sigma, nu, lambda
#
      #IF iiter == 3 
#
############ CLASS 5  ############
###################  CLASS A ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, sigma, nu, lambda
                   WHERE mu == lambda
                   WHERE lambda < sigma
                   WHERE nu < sigma
                   WHERE mu < nu
#
                   execute compute_batch3 aoint3(mu,nu,lambda,sigma)
#
       ENDPARDO mu, sigma, nu, lambda
#
      #IF iiter == 4 
#
###################  CLASS B ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
# 
       PARDO mu, lambda, nu, sigma 
                 WHERE nu == lambda
                 WHERE mu < nu
                 WHERE lambda < sigma
                 WHERE mu     < sigma
#
                   execute compute_batch4 aoint4(mu,nu,lambda,sigma)
#
       ENDPARDO mu, lambda, nu, sigma  
#
      #IF iiter == 5 
#
###################  CLASS C ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO nu, lambda, mu, sigma  
                WHERE mu < nu
                WHERE mu < lambda
                WHERE nu == sigma
                WHERE lambda < sigma
#
                   execute compute_batch5 aoint5(mu,nu,lambda,sigma)
#
       ENDPARDO nu, lambda, mu, sigma    
#
      #IF iiter == 7 
#
############ CLASS 2  ############
#  Do two-center part (mu mu |nu nu)->(nu nu |mu mu )
#
       PARDO nu, lambda, mu, sigma  
                 WHERE mu == nu
                 WHERE mu < lambda
                 WHERE lambda == sigma
#   
                   execute compute_batch7 aoint6(mu,nu,lambda,sigma)
#
       ENDPARDO nu, lambda, mu, sigma  
#
      #IF iiter == 8 
#
############ END CLASS 2  ############
#
############ CLASS 4  ############
#  Do two-center part (mu nu |mu nu)->(mu nu |nu mu ),(nu mu|mu nu),(nu mu|nu mu)
#
       PARDO mu, sigma, nu, lambda
                 WHERE mu < nu
                 WHERE nu == sigma
                 WHERE mu == lambda
                 WHERE lambda < sigma
#
                      execute compute_batch8 aoint7(mu,nu,lambda,sigma)  
#
       ENDPARDO mu, sigma, nu, lambda   
#
      #IF iiter == 6 
#
############ CLASS 1  ############
#  Do one-center part (mu mu |mu mu)
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
       PARDO mu, nu, lambda, sigma
              WHERE mu == nu 
              WHERE sigma == mu 
              WHERE lambda == mu 
#
                   execute compute_batch6 aoint8(mu,nu,lambda,sigma)
#
       ENDPARDO mu, nu, lambda, sigma
#
      #ENDDO iiter 
#
       execute sip_barrier
#
       DO mu
       DO nu
#
          Txx(mu,nu)        = Fockrohf_a(mu,nu)
          PUT Fpq_a(mu,nu) += Txx(mu,nu)
#
       ENDDO nu
       ENDDO mu
#
       execute sip_barrier
#
       PARDO mu, nu   
#
             Txx(mu,nu)        = oed_nai(mu,nu)  
             Txx(mu,nu)       += oed_kin(mu,nu)  
#
             PUT Fpq_a(mu,nu) += Txx(mu,nu) 
#
       ENDPARDO mu, nu   
#
       deallocate LDHFa(*,*) 
       deallocate LFpq_a(*,*) 
#
       execute sip_barrier
#
       ENDPROC FOCK_MATRIX  
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HF_ENERGY  
#      -------------- 
#
#      The HF energy is computed from the HF density (DHFa(b)) and the 
#      Fock matrix (Fpq_a(b)). 
#      --------------------------------------------------------------- 
#
       energy = 0.0 # scfeneg  
       esum = 0.0 
       execute sip_barrier 
       PARDO mu, nu 
#
             GET Fpq_a(mu,nu)
             GET DHFa(mu,nu) 
#
             Txx(mu,nu)   = oed_nai(mu,nu)  
             Txx(mu,nu)  += oed_kin(mu,nu)  
#
             T1xx(mu,nu)  = Txx(mu,nu) 
             T1xx(mu,nu) += Fpq_a(mu,nu) 
#
             etemp        = T1xx(mu,nu)*DHFa(mu,nu)  
             esum        += etemp 
#
       ENDPARDO mu, nu 
       execute sip_barrier 
      #esum *= 0.5 
       collective energy += esum 
       execute sip_barrier 
       execute print_scalar energy  
#
       ENDPROC HF_ENERGY   
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC OVER_HALF 
#      -------------- 
#
#      Diagonalize the overlap matrix, invert and take the square
#      root of the diagonal elements. 
#      -------------------------------------------------------------- 
#
       execute eig_sr_inv oed_ovl x1   
#
#      Form the Q-matrix --> U s**{-1/2) 
#      --------------------------------- 
#
       PARDO mu, nu  
#
          Txx(mu,nu) = 0.0 
#
          DO lambda 
             T1xx(mu,nu) = x1(mu,lambda)*oed_ovl(lambda,nu) 
             Txx(mu,nu) += T1xx(mu,nu) 
          ENDDO lambda  
#
          PUT Qxx(mu,nu) = Txx(mu,nu)  
#
       ENDPARDO mu, nu  
#
      #execute print_scalar scfeneg
       ENDPROC OVER_HALF 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_TRANSPOSE 
#      ------------------- 
#
#      Form the transposed Fock matrix --> Q+ F Q 
#      ------------------------------------------ 
#
       create TAxx 
       execute server_barrier 
       PARDO mu, nu 
             T1xx(mu,nu) = 0.0 
             PREPARE FTpq_a(mu,nu) = T1xx(mu,nu) 
       ENDPARDO mu, nu 
       execute server_barrier 
       execute sip_barrier 
       PARDO sigma, lambda    
#
             GET Fpq_a(lambda,sigma) 
#
             DO mu  
#
                GET Qxx(lambda,mu) 
                T1xx(mu,sigma)  = Qxx(lambda,mu)*Fpq_a(lambda,sigma)  
                PUT TAxx(mu,sigma) += T1xx(mu,sigma) 
#
             ENDDO mu  
#
       ENDPARDO sigma, lambda    
       execute sip_barrier 
#
       PARDO nu, sigma      
#
             GET Qxx(sigma,nu) 
#
             DO mu 
#
                GET TAxx(mu,sigma) 
                T1xx(mu,nu) =        TAxx(mu,sigma)*Qxx(sigma,nu) 
                PREPARE FTpq_a(mu,nu) += T1xx(mu,nu) 
#
             ENDDO mu 
#
       ENDPARDO nu, sigma   
       execute sip_barrier 
       execute server_barrier 
       delete TAxx 
#
       ENDPROC FOCK_TRANSPOSE 
#      ---------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_DIAG  
#      -------------- 
#
#      First put the transposed Fock arrays into static arrays 
#      ------------------------------------------------------- 
#
       execute get_my_rank rank
       if rank == 0.0 
       DO mu   
       DO nu  
#
          REQUEST         FTpq_a(mu,nu) mu 
          FSpq_a(mu,nu) = FTpq_a(mu,nu) 
#
       ENDDO nu  
       ENDDO mu   
#
       execute eig FSpq_a ca   
       endif 
       execute server_barrier 
       execute broadcast_array ca 
#
       ENDPROC FOCK_DIAG 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC C_BTRAN 
#      ------------ 
#
#      Transform the coefficient array back to the original basis 
#      ---------------------------------------------------------- 
#
       PARDO mu, p  
#
          Txp(mu,p) = 0.0 
#
          DO nu 
#
             GET          Qxx(mu,nu) 
#
             T1xp(mu,p) = Qxx(mu,nu)*ca(nu,p)   
             Txp(mu,p) += T1xp(mu,p) 
#
          ENDDO nu 
#
          PUT CBT_a(mu,p) = Txp(mu,p) 
#
       ENDPARDO mu, p  
#
       execute sip_barrier 
#
#      Put the transformed coefficients into static arrays 
#      --------------------------------------------------- 
#
       execute get_my_rank rank
       if rank == 0.0 
       DO mu 
       DO p 
          GET        CBT_a(mu,p) 
          ca(mu,p) = CBT_a(mu,p) 
       ENDDO p 
       ENDDO mu  
       endif 
       execute sip_barrier 
       execute broadcast_array ca 
#
       ENDPROC C_BTRAN 
#      --------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HF_DAMP  
#      ------------ 
#
       PARDO mu, nu 
#
             GET DHFa(mu,nu) 
             GET DHFa_old(mu,nu) 
#
             Txx(mu,nu)   = DHFa(mu,nu) 
             T1xx(mu,nu)  = DHFa_old(mu,nu) 
             T1xx(mu,nu) *= damp  
             Txx(mu,nu)  += T1xx(mu,nu) 
             Txx(mu,nu)  *= damp1 
             PUT DHFa(mu,nu) = Txx(mu,nu)  
#
       ENDPARDO mu, nu 
#
       ENDPROC HF_DAMP  
#      --------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_ZERO   
#      ----------------  
#  
#      Zero out the n-1'th density array. 
#      ---------------------------------- 
#
       PARDO mu, nu 
#
             Txx(mu,nu)   = 0.0   
             PUT DHFa_old(mu,nu) = Txx(mu,nu)  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_ZERO   
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_REPLACE    
#      -------------------   
#
#      Replace the 'old' HF density by the 'new' HF density. 
#      ----------------------------------------------------- 
#
       PARDO mu, nu 
#
             GET DHFa(mu,nu) 
             PUT DHFa_old(mu,nu) = DHFa(mu,nu)  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_REPLACE    
#      ----------------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC SETUP_DIIS 
#      --------------- 
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110 

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210 

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310 

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410 

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510 

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610 

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710 

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810 

       execute diis_setup Tb99
       execute diis_setup Tb910 

       execute diis_setup Tb1010 
#
       ENDPROC SETUP_DIIS 
#      ------------------ 
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC GEN_6HISTORY  
#      ------------------  
#
      #allocate Fai(*,*) 
       create Fai 
#
       execute sip_barrier 
#  
       PARDO mu, nu  
#
             GET Fpq_a(mu,nu)  
#
             DO i 
#
                txi(mu,i) = Fpq_a(mu,nu)*ca(nu,i) 
#
                DO a 
#
                   tai(a,i)  = txi(mu,i)*ca(mu,a) 
                   PUT Fai(a,i) += tai(a,i) 
#
                ENDDO a 
#
             ENDDO i 
#
       ENDPARDO mu, nu  
#
       if kiter == 1 # (scf_beg - scf_order + 1)  
          PARDO mu, nu 
                GET              Fpq_a(mu,nu) 
                txx(mu,nu)     = Fpq_a(mu,nu) 
                PUT F1a(mu,nu) = txx(mu,nu)  
          ENDPARDO mu, nu 
       endif # kiter 
#
       if kiter == 2 # (scf_beg - scf_order + 2)  
          PARDO mu, nu 
                GET              Fpq_a(mu,nu) 
                txx(mu,nu)     = Fpq_a(mu,nu) 
                PUT F2a(mu,nu) = txx(mu,nu)  
          ENDPARDO mu, nu 
       endif # kiter 
#
       if kiter == 3 # (scf_beg - scf_order + 3)  
          PARDO mu, nu 
                GET              Fpq_a(mu,nu) 
                txx(mu,nu)     = Fpq_a(mu,nu) 
                PUT F3a(mu,nu) = txx(mu,nu)  
          ENDPARDO mu, nu 
       endif # kiter 
#
       if kiter == 4 # (scf_beg - scf_order + 4)  
          PARDO mu, nu 
                GET              Fpq_a(mu,nu) 
                txx(mu,nu)     = Fpq_a(mu,nu) 
                PUT F4a(mu,nu) = txx(mu,nu)  
          ENDPARDO mu, nu 
       endif # kiter 
#
       if kiter == 5 # (scf_beg - scf_order + 5) = scf+beg   
          PARDO mu, nu 
                GET              Fpq_a(mu,nu) 
                txx(mu,nu)     = Fpq_a(mu,nu) 
                PUT F5a(mu,nu) = txx(mu,nu)  
          ENDPARDO mu, nu 
       endif # kiter 
#
       if kiter >= 6 # (scf_beg - scf_order + 6) = scf+beg   
          PARDO mu, nu 
                GET              Fpq_a(mu,nu) 
                txx(mu,nu)     = Fpq_a(mu,nu) 
                PUT F6a(mu,nu) = txx(mu,nu)  
          ENDPARDO mu, nu 
       endif # kiter 
#
       execute sip_barrier 
#
       PARDO a, i 
#
             GET Fai(a,i) 
#
             if kiter == 1  # (scf_beg - scf_order + 1) 
                PUT F1ai(a,i) = Fai(a,i) 
             endif # kiter  
#
             if kiter == 2  # (scf_beg - scf_order + 2) 
                PUT F2ai(a,i) = Fai(a,i) 
             endif # kiter  
#
             if kiter == 3  # (scf_beg - scf_order + 3) 
                PUT F3ai(a,i) = Fai(a,i) 
             endif # kiter  
#
             if kiter == 4  # (scf_beg - scf_order + 4) 
                PUT F4ai(a,i) = Fai(a,i) 
             endif # kiter  
#
             if kiter == 5  # (scf_beg - scf_order + 5) 
                PUT F5ai(a,i) = Fai(a,i) 
             endif # kiter  
#
             if kiter >= 6  # (scf_beg - scf_order + 6) 
                PUT F6ai(a,i) = Fai(a,i) 
             endif # kiter  
#
       ENDPARDO a, i 
#
       execute sip_barrier 
#
       delete Fai 
      #deallocate Fai(*,*) 
#
       ENDPROC GEN_6HISTORY  
#      ---------------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC ZERO_SCALAR 
#      ---------------- 
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0 
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0 
       c2 = 0.0 
       c3 = 0.0 
       c4 = 0.0 
       c5 = 0.0 
       c6 = 0.0 
       c7 = 0.0 
       c8 = 0.0 
       c9 = 0.0 
       c10 = 0.0 
#
       ENDPROC ZERO_SCALAR 
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS2   
#      -----------  
#
# The DIIS expansion coefficients are computed using the 2 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       CALL ZERO_SCALAR 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 2 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,2 
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
#          b2x x=2,2
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb22 += b22
       Tb11 *= 2.0 
       Tb12 *= 2.0 
       Tb22 *= 2.0 
#
       execute sip_barrier 
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       CALL SETUP_DIIS 
#
       execute sip_barrier
       execute compute_diis # --> New instruction
       execute sip_barrier
#
       c1 = Tb11
       c2 = Tb22
#
       etemp  = c1 
       etemp += c2 
#
       execute print_scalar c1
       execute print_scalar c2
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           PUT Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
       ENDPROC DIIS2    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC MOVE2    
#      ----------  
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      Current --> 2 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F2a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       execute sip_barrier 
#
       ENDPROC MOVE2    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS3   
#      -----------  
#
# The DIIS expansion coefficients are computed using the 3 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       CALL ZERO_SCALAR 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,3 
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
#          b2x x=2,3
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
#          b3x x=3,3 
#          --------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13

       collective Tb22 += b22
       collective Tb23 += b23

       collective Tb33 += b33
#
       execute sip_barrier 
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       CALL SETUP_DIIS 
#
       execute sip_barrier 
       execute compute_diis # --> New instruction
       execute sip_barrier 
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
#
       etemp  = c1 
       etemp += c2 
       etemp += c3 
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           PUT Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
       ENDPROC DIIS3    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC MOVE3    
#      ----------  
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 3 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F3a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       ENDPROC MOVE3    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS4   
#      -----------  
#
# The DIIS expansion coefficients are computed using the 6 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       CALL ZERO_SCALAR 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
           GET F4ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,4 
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
           etemp = F1ai(a,i)*F4ai(a,i) 
           b14  += etemp 
#
#          b2x x=2,4
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
           etemp = F2ai(a,i)*F4ai(a,i) 
           b24  += etemp 
#
#          b3x x=3,4 
#          --------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
           etemp = F3ai(a,i)*F4ai(a,i) 
           b34  += etemp 
#
#          b4x x=4,4
#          --------- 
#
           etemp = F4ai(a,i)*F4ai(a,i) 
           b44  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13
       collective Tb14 += b14

       collective Tb22 += b22
       collective Tb23 += b23
       collective Tb24 += b24

       collective Tb33 += b33
       collective Tb34 += b34

       collective Tb44 += b44
#
       execute sip_barrier 
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       CALL SETUP_DIIS 
#
       execute compute_diis # --> New instruction
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
       c4 = Tb44
#
       etemp  = c1 
       etemp += c2 
       etemp += c3 
       etemp += c4 
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute print_scalar c4
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
           GET F4a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F4a(mu,nu) 
           t1xx(mu,nu) *= c4  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           PUT Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
       ENDPROC DIIS4    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC MOVE4    
#      ----------  
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      4 --> 3 
#      ------- 
#
       PARDO mu, nu 
             GET F4a(mu,nu) 
             PUT F3a(mu,nu) = F4a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F4ai(a,i) 
             PUT F3ai(a,i) = F4ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 4 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F4a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       ENDPROC MOVE4    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS5   
#      ----------  
#
# The DIIS expansion coefficients are computed using the 5 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       CALL ZERO_SCALAR 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
           GET F4ai(a,i) 
           GET F5ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,5
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
           etemp = F1ai(a,i)*F4ai(a,i) 
           b14  += etemp 
#
           etemp = F1ai(a,i)*F5ai(a,i) 
           b15  += etemp 
#
#          b2x x=2,5
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
           etemp = F2ai(a,i)*F4ai(a,i) 
           b24  += etemp 
#
           etemp = F2ai(a,i)*F5ai(a,i) 
           b25  += etemp 
#
#          b3x x=3,5
#          --------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
           etemp = F3ai(a,i)*F4ai(a,i) 
           b34  += etemp 
#
           etemp = F3ai(a,i)*F5ai(a,i) 
           b35  += etemp 
#
#          b4x x=4,5
#          --------- 
#
           etemp = F4ai(a,i)*F4ai(a,i) 
           b44  += etemp 
#
           etemp = F4ai(a,i)*F5ai(a,i) 
           b45  += etemp 
#
#          b5x x=5,5
#          --------- 
#
           etemp = F5ai(a,i)*F5ai(a,i) 
           b55  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13
       collective Tb14 += b14
       collective Tb15 += b15
       collective Tb22 += b22
       collective Tb23 += b23
       collective Tb24 += b24
       collective Tb25 += b25
       collective Tb33 += b33
       collective Tb34 += b34
       collective Tb35 += b35
       collective Tb44 += b44
       collective Tb45 += b45
       collective Tb55 += b55
#
       execute sip_barrier 
#
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       CALL SETUP_DIIS 
#
       execute compute_diis # --> New instruction
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
       c4 = Tb44
       c5 = Tb55
#
       etemp  = c1 
       etemp += c2 
       etemp += c3 
       etemp += c4 
       etemp += c5 
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute print_scalar c4
       execute print_scalar c5
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
           GET F4a(mu,nu) 
           GET F5a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F4a(mu,nu) 
           t1xx(mu,nu) *= c4  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F5a(mu,nu) 
           t1xx(mu,nu) *= c5  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           PUT Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
       ENDPROC DIIS5   
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC MOVE5   
#      ----------  
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      4 --> 3 
#      ------- 
#
       PARDO mu, nu 
             GET F4a(mu,nu) 
             PUT F3a(mu,nu) = F4a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F4ai(a,i) 
             PUT F3ai(a,i) = F4ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      5 --> 4 
#      ------- 
#
       PARDO mu, nu 
             GET F5a(mu,nu) 
             PUT F4a(mu,nu) = F5a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F5ai(a,i) 
             PUT F4ai(a,i) = F5ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 5 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F5a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       ENDPROC MOVE5   
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS6   
#      -----------  
#
# The DIIS expansion coefficients are computed using the 6 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       CALL ZERO_SCALAR 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
           GET F4ai(a,i) 
           GET F5ai(a,i) 
           GET F6ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,6 
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
           etemp = F1ai(a,i)*F4ai(a,i) 
           b14  += etemp 
#
           etemp = F1ai(a,i)*F5ai(a,i) 
           b15  += etemp 
#
           etemp = F1ai(a,i)*F6ai(a,i) 
           b16  += etemp 
#
#          b2x x=2,6
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
           etemp = F2ai(a,i)*F4ai(a,i) 
           b24  += etemp 
#
           etemp = F2ai(a,i)*F5ai(a,i) 
           b25  += etemp 
#
           etemp = F2ai(a,i)*F6ai(a,i) 
           b26  += etemp 
#
#          b3x x=3,6 
#          --------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
           etemp = F3ai(a,i)*F4ai(a,i) 
           b34  += etemp 
#
           etemp = F3ai(a,i)*F5ai(a,i) 
           b35  += etemp 
#
           etemp = F3ai(a,i)*F6ai(a,i) 
           b36  += etemp 
#
#          b4x x=4,6
#          --------- 
#
           etemp = F4ai(a,i)*F4ai(a,i) 
           b44  += etemp 
#
           etemp = F4ai(a,i)*F5ai(a,i) 
           b45  += etemp 
#
           etemp = F4ai(a,i)*F6ai(a,i) 
           b46  += etemp 
#
#          b5x x=5,6 
#          ---------- 
#
           etemp = F5ai(a,i)*F5ai(a,i) 
           b55  += etemp 
#
           etemp = F5ai(a,i)*F6ai(a,i) 
           b56  += etemp 
#
#          b6x x=6,6 
#          ---------- 
#
           etemp = F6ai(a,i)*F6ai(a,i) 
           b66  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       b11 *= 2.0 
       b12 *= 2.0 
       b13 *= 2.0 
       b14 *= 2.0 
       b15 *= 2.0 
       b16 *= 2.0 
       b22 *= 2.0 
       b23 *= 2.0 
       b24 *= 2.0 
       b25 *= 2.0 
       b26 *= 2.0 
       b33 *= 2.0 
       b34 *= 2.0 
       b35 *= 2.0 
       b36 *= 2.0 
       b44 *= 2.0 
       b45 *= 2.0 
       b46 *= 2.0 
       b55 *= 2.0 
       b56 *= 2.0 
       b66 *= 2.0 
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13
       collective Tb14 += b14
       collective Tb15 += b15
       collective Tb16 += b16
       collective Tb22 += b22
       collective Tb23 += b23
       collective Tb24 += b24
       collective Tb25 += b25
       collective Tb26 += b26
       collective Tb33 += b33
       collective Tb34 += b34
       collective Tb35 += b35
       collective Tb36 += b36
       collective Tb44 += b44
       collective Tb45 += b45
       collective Tb46 += b46
       collective Tb55 += b55
       collective Tb56 += b56
       collective Tb66 += b66
#
       execute sip_barrier 
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       CALL SETUP_DIIS 
#
       execute sip_barrier 
       execute compute_diis # --> New instruction
       execute sip_barrier 
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
       c4 = Tb44
       c5 = Tb55
       c6 = Tb66  
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute print_scalar c4
       execute print_scalar c5
       execute print_scalar c6
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
           GET F4a(mu,nu) 
           GET F5a(mu,nu) 
           GET F6a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F4a(mu,nu) 
           t1xx(mu,nu) *= c4  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F5a(mu,nu) 
           t1xx(mu,nu) *= c5  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F6a(mu,nu) 
           t1xx(mu,nu) *= c6  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           PUT Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
       ENDPROC DIIS6    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC MOVE6    
#      ----------  
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      4 --> 3 
#      ------- 
#
       PARDO mu, nu 
             GET F4a(mu,nu) 
             PUT F3a(mu,nu) = F4a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F4ai(a,i) 
             PUT F3ai(a,i) = F4ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      5 --> 4 
#      ------- 
#
       PARDO mu, nu 
             GET F5a(mu,nu) 
             PUT F4a(mu,nu) = F5a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F5ai(a,i) 
             PUT F4ai(a,i) = F5ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      6 --> 5 
#      ------- 
#
       PARDO mu, nu 
             GET F6a(mu,nu) 
             PUT F5a(mu,nu) = F6a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F6ai(a,i) 
             PUT F5ai(a,i) = F6ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 6 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F6a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
       ENDPROC MOVE6    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS7   
#      -----------  
#
# The DIIS expansion coefficients are computed using the 7 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0 
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0 
       c2 = 0.0 
       c3 = 0.0 
       c4 = 0.0 
       c5 = 0.0 
       c6 = 0.0 
       c7 = 0.0 
       c8 = 0.0 
       c9 = 0.0 
       c10 = 0.0 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
           GET F4ai(a,i) 
           GET F5ai(a,i) 
           GET F6ai(a,i) 
           GET F7ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,7 
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
           etemp = F1ai(a,i)*F4ai(a,i) 
           b14  += etemp 
#
           etemp = F1ai(a,i)*F5ai(a,i) 
           b15  += etemp 
#
           etemp = F1ai(a,i)*F6ai(a,i) 
           b16  += etemp 
#
           etemp = F1ai(a,i)*F7ai(a,i) 
           b17  += etemp 
#
#          b2x x=2,7
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
           etemp = F2ai(a,i)*F4ai(a,i) 
           b24  += etemp 
#
           etemp = F2ai(a,i)*F5ai(a,i) 
           b25  += etemp 
#
           etemp = F2ai(a,i)*F6ai(a,i) 
           b26  += etemp 
#
           etemp = F2ai(a,i)*F7ai(a,i) 
           b27  += etemp 
#
#          b3x x=3,7 
#          --------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
           etemp = F3ai(a,i)*F4ai(a,i) 
           b34  += etemp 
#
           etemp = F3ai(a,i)*F5ai(a,i) 
           b35  += etemp 
#
           etemp = F3ai(a,i)*F6ai(a,i) 
           b36  += etemp 
#
           etemp = F3ai(a,i)*F7ai(a,i) 
           b37  += etemp 
#
#          b4x x=4,7
#          --------- 
#
           etemp = F4ai(a,i)*F4ai(a,i) 
           b44  += etemp 
#
           etemp = F4ai(a,i)*F5ai(a,i) 
#          b45  += etemp 
#
           etemp = F4ai(a,i)*F6ai(a,i) 
           b46  += etemp 
#
           etemp = F4ai(a,i)*F7ai(a,i) 
           b47  += etemp 
#
#          b5x x=5,7 
#          ---------- 
#
           etemp = F5ai(a,i)*F5ai(a,i) 
           b55  += etemp 
#
           etemp = F5ai(a,i)*F6ai(a,i) 
           b56  += etemp 
#
           etemp = F5ai(a,i)*F7ai(a,i) 
           b57  += etemp 
#
#          b6x x=6,7 
#          ---------- 
#
           etemp = F6ai(a,i)*F6ai(a,i) 
           b66  += etemp 
#
           etemp = F6ai(a,i)*F7ai(a,i) 
           b67  += etemp 
#
#          b7x x=7,7 
#          --------- 
#
           etemp = F7ai(a,i)*F7ai(a,i) 
           b77  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13
       collective Tb14 += b14
       collective Tb15 += b15
       collective Tb16 += b16
       collective Tb17 += b17

       collective Tb22 += b22
       collective Tb23 += b23
       collective Tb24 += b24
       collective Tb25 += b25
       collective Tb26 += b26
       collective Tb27 += b27

       collective Tb33 += b33
       collective Tb34 += b34
       collective Tb35 += b35
       collective Tb36 += b36
       collective Tb37 += b37

       collective Tb44 += b44
       collective Tb45 += b45
       collective Tb46 += b46
       collective Tb47 += b47

       collective Tb55 += b55
       collective Tb56 += b56
       collective Tb57 += b57

       collective Tb66 += b66
       collective Tb67 += b67

       collective Tb77 += b77
#
       execute sip_barrier 
#
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110 

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210 

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310 

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410 

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510 

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610 

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710 

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810 

       execute diis_setup Tb99
       execute diis_setup Tb910 

       execute diis_setup Tb1010 
#
       execute compute_diis # --> New instruction
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
       c4 = Tb44
       c5 = Tb55
       c6 = Tb66  
       c7 = Tb77
#
       etemp  = c1 
       etemp += c2 
       etemp += c3 
       etemp += c4 
       etemp += c5 
       etemp += c6
       etemp += c7
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute print_scalar c4
       execute print_scalar c5
       execute print_scalar c6
       execute print_scalar c7
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
           GET F4a(mu,nu) 
           GET F5a(mu,nu) 
           GET F6a(mu,nu) 
           GET F7a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F4a(mu,nu) 
           t1xx(mu,nu) *= c4  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F5a(mu,nu) 
           t1xx(mu,nu) *= c5  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F6a(mu,nu) 
           t1xx(mu,nu) *= c6  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F7a(mu,nu) 
           t1xx(mu,nu) *= c7  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      4 --> 3 
#      ------- 
#
       PARDO mu, nu 
             GET F4a(mu,nu) 
             PUT F3a(mu,nu) = F4a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F4ai(a,i) 
             PUT F3ai(a,i) = F4ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      5 --> 4 
#      ------- 
#
       PARDO mu, nu 
             GET F5a(mu,nu) 
             PUT F4a(mu,nu) = F5a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F5ai(a,i) 
             PUT F4ai(a,i) = F5ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      6 --> 5 
#      ------- 
#
       PARDO mu, nu 
             GET F6a(mu,nu) 
             PUT F5a(mu,nu) = F6a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F6ai(a,i) 
             PUT F5ai(a,i) = F6ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      7 --> 6 
#      ------- 
#
       PARDO mu, nu 
             GET F7a(mu,nu) 
             PUT F6a(mu,nu) = F7a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F7ai(a,i) 
             PUT F6ai(a,i) = F7ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 7 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F7a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       ENDPROC DIIS7    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS8   
#      -----------  
#
# The DIIS expansion coefficients are computed using the 8 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0 
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0 
       c2 = 0.0 
       c3 = 0.0 
       c4 = 0.0 
       c5 = 0.0 
       c6 = 0.0 
       c7 = 0.0 
       c8 = 0.0 
       c9 = 0.0 
       c10 = 0.0 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
           GET F4ai(a,i) 
           GET F5ai(a,i) 
           GET F6ai(a,i) 
           GET F7ai(a,i) 
           GET F8ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,8 
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
           etemp = F1ai(a,i)*F4ai(a,i) 
           b14  += etemp 
#
           etemp = F1ai(a,i)*F5ai(a,i) 
           b15  += etemp 
#
           etemp = F1ai(a,i)*F6ai(a,i) 
           b16  += etemp 
#
           etemp = F1ai(a,i)*F7ai(a,i) 
           b17  += etemp 
#
           etemp = F1ai(a,i)*F8ai(a,i) 
           b18  += etemp 
#
#          b2x x=2,8
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
           etemp = F2ai(a,i)*F4ai(a,i) 
           b24  += etemp 
#
           etemp = F2ai(a,i)*F5ai(a,i) 
           b25  += etemp 
#
           etemp = F2ai(a,i)*F6ai(a,i) 
           b26  += etemp 
#
           etemp = F2ai(a,i)*F7ai(a,i) 
           b27  += etemp 
#
           etemp = F2ai(a,i)*F8ai(a,i) 
           b28  += etemp 
#
#          b3x x=3,8 
#          --------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
           etemp = F3ai(a,i)*F4ai(a,i) 
           b34  += etemp 
#
           etemp = F3ai(a,i)*F5ai(a,i) 
           b35  += etemp 
#
           etemp = F3ai(a,i)*F6ai(a,i) 
           b36  += etemp 
#
           etemp = F3ai(a,i)*F7ai(a,i) 
           b37  += etemp 
#
           etemp = F3ai(a,i)*F8ai(a,i) 
           b38  += etemp 
#
#          b4x x=4,8
#          --------- 
#
           etemp = F4ai(a,i)*F4ai(a,i) 
           b44  += etemp 
#
           etemp = F4ai(a,i)*F5ai(a,i) 
#          b45  += etemp 
#
           etemp = F4ai(a,i)*F6ai(a,i) 
           b46  += etemp 
#
           etemp = F4ai(a,i)*F7ai(a,i) 
           b47  += etemp 
#
           etemp = F4ai(a,i)*F8ai(a,i) 
           b48  += etemp 
#
#          b5x x=5,8 
#          ---------- 
#
           etemp = F5ai(a,i)*F5ai(a,i) 
           b55  += etemp 
#
           etemp = F5ai(a,i)*F6ai(a,i) 
           b56  += etemp 
#
           etemp = F5ai(a,i)*F7ai(a,i) 
           b57  += etemp 
#
           etemp = F5ai(a,i)*F8ai(a,i) 
           b58  += etemp 
#
#          b6x x=6,8 
#          ---------- 
#
           etemp = F6ai(a,i)*F6ai(a,i) 
           b66  += etemp 
#
           etemp = F6ai(a,i)*F7ai(a,i) 
           b67  += etemp 
#
           etemp = F6ai(a,i)*F8ai(a,i) 
           b68  += etemp 
#
#          b7x x=7,8 
#          --------- 
#
           etemp = F7ai(a,i)*F7ai(a,i) 
           b77  += etemp 
#
           etemp = F7ai(a,i)*F8ai(a,i) 
           b78  += etemp 
#
#          b8x x=8,8
#          ---------- 
#
           etemp = F8ai(a,i)*F8ai(a,i) 
           b88  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13
       collective Tb14 += b14
       collective Tb15 += b15
       collective Tb16 += b16
       collective Tb17 += b17
       collective Tb18 += b18

       collective Tb22 += b22
       collective Tb23 += b23
       collective Tb24 += b24
       collective Tb25 += b25
       collective Tb26 += b26
       collective Tb27 += b27
       collective Tb28 += b28

       collective Tb33 += b33
       collective Tb34 += b34
       collective Tb35 += b35
       collective Tb36 += b36
       collective Tb37 += b37
       collective Tb38 += b38

       collective Tb44 += b44
       collective Tb45 += b45
       collective Tb46 += b46
       collective Tb47 += b47
       collective Tb48 += b48

       collective Tb55 += b55
       collective Tb56 += b56
       collective Tb57 += b57
       collective Tb58 += b58

       collective Tb66 += b66
       collective Tb67 += b67
       collective Tb68 += b68

       collective Tb77 += b77
       collective Tb78 += b78

       collective Tb88 += b88
#
       execute sip_barrier 
#
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110 

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210 

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310 

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410 

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510 

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610 

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710 

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810 

       execute diis_setup Tb99
       execute diis_setup Tb910 

       execute diis_setup Tb1010 
#
       execute compute_diis # --> New instruction
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
       c4 = Tb44
       c5 = Tb55
       c6 = Tb66  
       c7 = Tb77
       c8 = Tb88
#
       etemp  = c1 
       etemp += c2 
       etemp += c3 
       etemp += c4 
       etemp += c5 
       etemp += c6
       etemp += c7
       etemp += c8 
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute print_scalar c4
       execute print_scalar c5
       execute print_scalar c6
       execute print_scalar c7
       execute print_scalar c8
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
           GET F4a(mu,nu) 
           GET F5a(mu,nu) 
           GET F6a(mu,nu) 
           GET F7a(mu,nu) 
           GET F8a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F4a(mu,nu) 
           t1xx(mu,nu) *= c4  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F5a(mu,nu) 
           t1xx(mu,nu) *= c5  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F6a(mu,nu) 
           t1xx(mu,nu) *= c6  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F7a(mu,nu) 
           t1xx(mu,nu) *= c7  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F8a(mu,nu) 
           t1xx(mu,nu) *= c8  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      4 --> 3 
#      ------- 
#
       PARDO mu, nu 
             GET F4a(mu,nu) 
             PUT F3a(mu,nu) = F4a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F4ai(a,i) 
             PUT F3ai(a,i) = F4ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      5 --> 4 
#      ------- 
#
       PARDO mu, nu 
             GET F5a(mu,nu) 
             PUT F4a(mu,nu) = F5a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F5ai(a,i) 
             PUT F4ai(a,i) = F5ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      6 --> 5 
#      ------- 
#
       PARDO mu, nu 
             GET F6a(mu,nu) 
             PUT F5a(mu,nu) = F6a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F6ai(a,i) 
             PUT F5ai(a,i) = F6ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      7 --> 6 
#      ------- 
#
       PARDO mu, nu 
             GET F7a(mu,nu) 
             PUT F6a(mu,nu) = F7a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F7ai(a,i) 
             PUT F6ai(a,i) = F7ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      8 --> 7 
#      ------- 
#
       PARDO mu, nu 
             GET F8a(mu,nu) 
             PUT F7a(mu,nu) = F8a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F8ai(a,i) 
             PUT F7ai(a,i) = F8ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 8 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F8a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       ENDPROC DIIS8    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS9   
#      ----------  
#
# The DIIS expansion coefficients are computed using the 9 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0 
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0 
       c2 = 0.0 
       c3 = 0.0 
       c4 = 0.0 
       c5 = 0.0 
       c6 = 0.0 
       c7 = 0.0 
       c8 = 0.0 
       c9 = 0.0 
       c10 = 0.0 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
           GET F4ai(a,i) 
           GET F5ai(a,i) 
           GET F6ai(a,i) 
           GET F7ai(a,i) 
           GET F8ai(a,i) 
           GET F9ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,9 
#          --------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
           etemp = F1ai(a,i)*F4ai(a,i) 
           b14  += etemp 
#
           etemp = F1ai(a,i)*F5ai(a,i) 
           b15  += etemp 
#
           etemp = F1ai(a,i)*F6ai(a,i) 
           b16  += etemp 
#
           etemp = F1ai(a,i)*F7ai(a,i) 
           b17  += etemp 
#
           etemp = F1ai(a,i)*F8ai(a,i) 
           b18  += etemp 
#
           etemp = F1ai(a,i)*F9ai(a,i) 
           b19  += etemp 
#
#          b2x x=2,9
#          --------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
           etemp = F2ai(a,i)*F4ai(a,i) 
           b24  += etemp 
#
           etemp = F2ai(a,i)*F5ai(a,i) 
           b25  += etemp 
#
           etemp = F2ai(a,i)*F6ai(a,i) 
           b26  += etemp 
#
           etemp = F2ai(a,i)*F7ai(a,i) 
           b27  += etemp 
#
           etemp = F2ai(a,i)*F8ai(a,i) 
           b28  += etemp 
#
           etemp = F2ai(a,i)*F9ai(a,i) 
           b29  += etemp 
#
#          b3x x=3,9 
#          --------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
           etemp = F3ai(a,i)*F4ai(a,i) 
           b34  += etemp 
#
           etemp = F3ai(a,i)*F5ai(a,i) 
           b35  += etemp 
#
           etemp = F3ai(a,i)*F6ai(a,i) 
           b36  += etemp 
#
           etemp = F3ai(a,i)*F7ai(a,i) 
           b37  += etemp 
#
           etemp = F3ai(a,i)*F8ai(a,i) 
           b38  += etemp 
#
           etemp = F3ai(a,i)*F9ai(a,i) 
           b39  += etemp 
#
#          b4x x=4,9
#          --------- 
#
           etemp = F4ai(a,i)*F4ai(a,i) 
           b44  += etemp 
#
           etemp = F4ai(a,i)*F5ai(a,i) 
#          b45  += etemp 
#
           etemp = F4ai(a,i)*F6ai(a,i) 
           b46  += etemp 
#
           etemp = F4ai(a,i)*F7ai(a,i) 
           b47  += etemp 
#
           etemp = F4ai(a,i)*F8ai(a,i) 
           b48  += etemp 
#
           etemp = F4ai(a,i)*F9ai(a,i) 
           b49  += etemp 
#
#          b5x x=5,9 
#          --------- 
#
           etemp = F5ai(a,i)*F5ai(a,i) 
           b55  += etemp 
#
           etemp = F5ai(a,i)*F6ai(a,i) 
           b56  += etemp 
#
           etemp = F5ai(a,i)*F7ai(a,i) 
           b57  += etemp 
#
           etemp = F5ai(a,i)*F8ai(a,i) 
           b58  += etemp 
#
           etemp = F5ai(a,i)*F9ai(a,i) 
           b59  += etemp 
#
#          b6x x=6,9 
#          --------- 
#
           etemp = F6ai(a,i)*F6ai(a,i) 
           b66  += etemp 
#
           etemp = F6ai(a,i)*F7ai(a,i) 
           b67  += etemp 
#
           etemp = F6ai(a,i)*F8ai(a,i) 
           b68  += etemp 
#
           etemp = F6ai(a,i)*F9ai(a,i) 
           b69  += etemp 
#
#          b7x x=7,9 
#          --------- 
#
           etemp = F7ai(a,i)*F7ai(a,i) 
           b77  += etemp 
#
           etemp = F7ai(a,i)*F8ai(a,i) 
           b78  += etemp 
#
           etemp = F7ai(a,i)*F9ai(a,i) 
           b79  += etemp 
#
#          b8x x=8,9 
#          --------- 
#
           etemp = F8ai(a,i)*F8ai(a,i) 
           b88  += etemp 
#
           etemp = F8ai(a,i)*F9ai(a,i) 
           b89  += etemp 
#
#          b9x x=9,9 
#          --------- 
#
           etemp = F9ai(a,i)*F9ai(a,i) 
           b99  += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13
       collective Tb14 += b14
       collective Tb15 += b15
       collective Tb16 += b16
       collective Tb17 += b17
       collective Tb18 += b18
       collective Tb19 += b19

       collective Tb22 += b22
       collective Tb23 += b23
       collective Tb24 += b24
       collective Tb25 += b25
       collective Tb26 += b26
       collective Tb27 += b27
       collective Tb28 += b28
       collective Tb29 += b29

       collective Tb33 += b33
       collective Tb34 += b34
       collective Tb35 += b35
       collective Tb36 += b36
       collective Tb37 += b37
       collective Tb38 += b38
       collective Tb39 += b39

       collective Tb44 += b44
       collective Tb45 += b45
       collective Tb46 += b46
       collective Tb47 += b47
       collective Tb48 += b48
       collective Tb49 += b49

       collective Tb55 += b55
       collective Tb56 += b56
       collective Tb57 += b57
       collective Tb58 += b58
       collective Tb59 += b59

       collective Tb66 += b66
       collective Tb67 += b67
       collective Tb68 += b68
       collective Tb69 += b69

       collective Tb77 += b77
       collective Tb78 += b78
       collective Tb79 += b79

       collective Tb88 += b88
       collective Tb89 += b89

       collective Tb99 += b99
#
       execute sip_barrier 
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110 

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210 

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310 

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410 

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510 

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610 

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710 

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810 

       execute diis_setup Tb99
       execute diis_setup Tb910 

       execute diis_setup Tb1010 
#
       execute compute_diis # --> New instruction
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
       c4 = Tb44
       c5 = Tb55
       c6 = Tb66  
       c7 = Tb77
       c8 = Tb88
       c9 = Tb99
#
       etemp  = c1 
       etemp += c2 
       etemp += c3 
       etemp += c4 
       etemp += c5 
       etemp += c6
       etemp += c7
       etemp += c8 
       etemp += c9 
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute print_scalar c4
       execute print_scalar c5
       execute print_scalar c6
       execute print_scalar c7
       execute print_scalar c8
       execute print_scalar c9
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
           GET F4a(mu,nu) 
           GET F5a(mu,nu) 
           GET F6a(mu,nu) 
           GET F7a(mu,nu) 
           GET F8a(mu,nu) 
           GET F9a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F4a(mu,nu) 
           t1xx(mu,nu) *= c4  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F5a(mu,nu) 
           t1xx(mu,nu) *= c5  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F6a(mu,nu) 
           t1xx(mu,nu) *= c6  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F7a(mu,nu) 
           t1xx(mu,nu) *= c7  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F8a(mu,nu) 
           t1xx(mu,nu) *= c8  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F9a(mu,nu) 
           t1xx(mu,nu) *= c9  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      4 --> 3 
#      ------- 
#
       PARDO mu, nu 
             GET F4a(mu,nu) 
             PUT F3a(mu,nu) = F4a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F4ai(a,i) 
             PUT F3ai(a,i) = F4ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      5 --> 4 
#      ------- 
#
       PARDO mu, nu 
             GET F5a(mu,nu) 
             PUT F4a(mu,nu) = F5a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F5ai(a,i) 
             PUT F4ai(a,i) = F5ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      6 --> 5 
#      ------- 
#
       PARDO mu, nu 
             GET F6a(mu,nu) 
             PUT F5a(mu,nu) = F6a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F6ai(a,i) 
             PUT F5ai(a,i) = F6ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      7 --> 6 
#      ------- 
#
       PARDO mu, nu 
             GET F7a(mu,nu) 
             PUT F6a(mu,nu) = F7a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F7ai(a,i) 
             PUT F6ai(a,i) = F7ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      8 --> 7 
#      ------- 
#
       PARDO mu, nu 
             GET F8a(mu,nu) 
             PUT F7a(mu,nu) = F8a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F8ai(a,i) 
             PUT F7ai(a,i) = F8ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      9 --> 8 
#      ------- 
#
       PARDO mu, nu 
             GET F9a(mu,nu) 
             PUT F8a(mu,nu) = F9a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F9ai(a,i) 
             PUT F8ai(a,i) = F9ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 9 
#      ------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F9a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       ENDPROC DIIS9    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC DIIS10   
#      -----------  
#
# The DIIS expansion coefficients are computed using the 10 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0 
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0 
       c2 = 0.0 
       c3 = 0.0 
       c4 = 0.0 
       c5 = 0.0 
       c6 = 0.0 
       c7 = 0.0 
       c8 = 0.0 
       c9 = 0.0 
       c10 = 0.0 
#
       execute sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       PARDO a, i 
#
#          GET Fock-matrix data from all 5 previous iterations. 
#          ---------------------------------------------------- 
#
           GET F1ai(a,i) 
           GET F2ai(a,i) 
           GET F3ai(a,i) 
           GET F4ai(a,i) 
           GET F5ai(a,i) 
           GET F6ai(a,i) 
           GET F7ai(a,i) 
           GET F8ai(a,i) 
           GET F9ai(a,i) 
           GET F10ai(a,i) 
#
#          Compute contributions to the 'B-matrix'. 
#          ---------------------------------------- 
#
#          b1x x=1,10 
#          ---------- 
#
           etemp = F1ai(a,i)*F1ai(a,i) 
           b11  += etemp 
#
           etemp = F1ai(a,i)*F2ai(a,i) 
           b12  += etemp 
#
           etemp = F1ai(a,i)*F3ai(a,i) 
           b13  += etemp 
#
           etemp = F1ai(a,i)*F4ai(a,i) 
           b14  += etemp 
#
           etemp = F1ai(a,i)*F5ai(a,i) 
           b15  += etemp 
#
           etemp = F1ai(a,i)*F6ai(a,i) 
           b16  += etemp 
#
           etemp = F1ai(a,i)*F7ai(a,i) 
           b17  += etemp 
#
           etemp = F1ai(a,i)*F8ai(a,i) 
           b18  += etemp 
#
           etemp = F1ai(a,i)*F9ai(a,i) 
           b19  += etemp 
#
           etemp = F1ai(a,i)*F10ai(a,i) 
           b110 += etemp 
#
#          b2x x=2,10
#          ---------- 
#
           etemp = F2ai(a,i)*F2ai(a,i) 
           b22  += etemp 
#
           etemp = F2ai(a,i)*F3ai(a,i) 
           b23  += etemp 
#
           etemp = F2ai(a,i)*F4ai(a,i) 
           b24  += etemp 
#
           etemp = F2ai(a,i)*F5ai(a,i) 
           b25  += etemp 
#
           etemp = F2ai(a,i)*F6ai(a,i) 
           b26  += etemp 
#
           etemp = F2ai(a,i)*F7ai(a,i) 
           b27  += etemp 
#
           etemp = F2ai(a,i)*F8ai(a,i) 
           b28  += etemp 
#
           etemp = F2ai(a,i)*F9ai(a,i) 
           b29  += etemp 
#
           etemp = F2ai(a,i)*F10ai(a,i) 
           b210 += etemp 
#
#          b3x x=3,10 
#          ---------- 
#
           etemp = F3ai(a,i)*F3ai(a,i) 
           b33  += etemp 
#
           etemp = F3ai(a,i)*F4ai(a,i) 
           b34  += etemp 
#
           etemp = F3ai(a,i)*F5ai(a,i) 
           b35  += etemp 
#
           etemp = F3ai(a,i)*F6ai(a,i) 
           b36  += etemp 
#
           etemp = F3ai(a,i)*F7ai(a,i) 
           b37  += etemp 
#
           etemp = F3ai(a,i)*F8ai(a,i) 
           b38  += etemp 
#
           etemp = F3ai(a,i)*F9ai(a,i) 
           b39  += etemp 
#
           etemp = F3ai(a,i)*F10ai(a,i) 
           b310 += etemp 
#
#          b4x x=4,10
#          ---------- 
#
           etemp = F4ai(a,i)*F4ai(a,i) 
           b44  += etemp 
#
           etemp = F4ai(a,i)*F5ai(a,i) 
#          b45  += etemp 
#
           etemp = F4ai(a,i)*F6ai(a,i) 
           b46  += etemp 
#
           etemp = F4ai(a,i)*F7ai(a,i) 
           b47  += etemp 
#
           etemp = F4ai(a,i)*F8ai(a,i) 
           b48  += etemp 
#
           etemp = F4ai(a,i)*F9ai(a,i) 
           b49  += etemp 
#
           etemp = F4ai(a,i)*F10ai(a,i) 
           b410 += etemp 
#
#          b5x x=5,10 
#          ---------- 
#
           etemp = F5ai(a,i)*F5ai(a,i) 
           b55  += etemp 
#
           etemp = F5ai(a,i)*F6ai(a,i) 
           b56  += etemp 
#
           etemp = F5ai(a,i)*F7ai(a,i) 
           b57  += etemp 
#
           etemp = F5ai(a,i)*F8ai(a,i) 
           b58  += etemp 
#
           etemp = F5ai(a,i)*F9ai(a,i) 
           b59  += etemp 
#
           etemp = F5ai(a,i)*F10ai(a,i) 
           b510 += etemp 
#
#
#          b6x x=6,10 
#          ---------- 
#
           etemp = F6ai(a,i)*F6ai(a,i) 
           b66  += etemp 
#
           etemp = F6ai(a,i)*F7ai(a,i) 
           b67  += etemp 
#
           etemp = F6ai(a,i)*F8ai(a,i) 
           b68  += etemp 
#
           etemp = F6ai(a,i)*F9ai(a,i) 
           b69  += etemp 
#
           etemp = F6ai(a,i)*F10ai(a,i) 
           b610 += etemp 
#
#          b7x x=7,10 
#          ---------- 
#
           etemp = F7ai(a,i)*F7ai(a,i) 
           b77  += etemp 
#
           etemp = F7ai(a,i)*F8ai(a,i) 
           b78  += etemp 
#
           etemp = F7ai(a,i)*F9ai(a,i) 
           b79  += etemp 
#
           etemp = F7ai(a,i)*F10ai(a,i) 
           b710 += etemp 
#
#          b8x x=8,10 
#          ---------- 
#
           etemp = F8ai(a,i)*F8ai(a,i) 
           b88  += etemp 
#
           etemp = F8ai(a,i)*F9ai(a,i) 
           b89  += etemp 
#
           etemp = F8ai(a,i)*F10ai(a,i) 
           b810 += etemp 
#
#          b9x x=9,10 
#          ---------- 
#
           etemp = F9ai(a,i)*F9ai(a,i) 
           b99  += etemp 
#
           etemp = F9ai(a,i)*F10ai(a,i) 
           b910 += etemp 
#
#          b10x x=10,10 
#          ------------ 
#
           etemp = F10ai(a,i)*F10ai(a,i) 
           b1010 += etemp 
#
       ENDPARDO a, i 
#
       execute sip_barrier
#
#      Collectively sum B-matrix elements.
#      -----------------------------------
#
       collective Tb11 += b11
       collective Tb12 += b12
       collective Tb13 += b13
       collective Tb14 += b14
       collective Tb15 += b15
       collective Tb16 += b16
       collective Tb17 += b17
       collective Tb18 += b18
       collective Tb19 += b19
       collective Tb110 += b110 

       collective Tb22 += b22
       collective Tb23 += b23
       collective Tb24 += b24
       collective Tb25 += b25
       collective Tb26 += b26
       collective Tb27 += b27
       collective Tb28 += b28
       collective Tb29 += b29
       collective Tb210 += b210 

       collective Tb33 += b33
       collective Tb34 += b34
       collective Tb35 += b35
       collective Tb36 += b36
       collective Tb37 += b37
       collective Tb38 += b38
       collective Tb39 += b39
       collective Tb310 += b310 

       collective Tb44 += b44
       collective Tb45 += b45
       collective Tb46 += b46
       collective Tb47 += b47
       collective Tb48 += b48
       collective Tb49 += b49
       collective Tb410 += b410 

       collective Tb55 += b55
       collective Tb56 += b56
       collective Tb57 += b57
       collective Tb58 += b58
       collective Tb59 += b59
       collective Tb510 += b510 

       collective Tb66 += b66
       collective Tb67 += b67
       collective Tb68 += b68
       collective Tb69 += b69
       collective Tb610 += b610 

       collective Tb77 += b77
       collective Tb78 += b78
       collective Tb79 += b79
       collective Tb710 += b710 

       collective Tb88 += b88
       collective Tb89 += b89
       collective Tb810 += b810 

       collective Tb99 += b99
       collective Tb910 += b910 

       collective Tb1010 += b1010 
#
       execute sip_barrier 
#
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
#      Put the elements of the 'B-matrix', which have been computed as scalars into the
#      R-matrix.
#      --------------------------------------------------------------------------------
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110 

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210 

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310 

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410 

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510 

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610 

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710 

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810 

       execute diis_setup Tb99
       execute diis_setup Tb910 

       execute diis_setup Tb1010 
#
       execute compute_diis # --> New instruction
#
       c1 = Tb11
       c2 = Tb22
       c3 = Tb33
       c4 = Tb44
       c5 = Tb55
       c6 = Tb66  
       c7 = Tb77
       c8 = Tb88
       c9 = Tb99
       c10 = Tb1010 
#
       etemp  = c1 
       etemp += c2 
       etemp += c3 
       etemp += c4 
       etemp += c5 
       etemp += c6
       etemp += c7
       etemp += c8 
       etemp += c9 
       etemp += c10 
#
       execute print_scalar c1
       execute print_scalar c2
       execute print_scalar c3
       execute print_scalar c4
       execute print_scalar c5
       execute print_scalar c6
       execute print_scalar c7
       execute print_scalar c8
       execute print_scalar c9
       execute print_scalar c10  
       execute sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           GET F1a(mu,nu) 
           GET F2a(mu,nu) 
           GET F3a(mu,nu) 
           GET F4a(mu,nu) 
           GET F5a(mu,nu) 
           GET F6a(mu,nu) 
           GET F7a(mu,nu) 
           GET F8a(mu,nu) 
           GET F9a(mu,nu) 
           GET F10a(mu,nu) 
#
           t1xx(mu,nu)  = F1a(mu,nu) 
           t1xx(mu,nu) *= c1  
           txx(mu,nu)   = t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F2a(mu,nu) 
           t1xx(mu,nu) *= c2  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F3a(mu,nu) 
           t1xx(mu,nu) *= c3  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F4a(mu,nu) 
           t1xx(mu,nu) *= c4  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F5a(mu,nu) 
           t1xx(mu,nu) *= c5  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F6a(mu,nu) 
           t1xx(mu,nu) *= c6  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F7a(mu,nu) 
           t1xx(mu,nu) *= c7  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F8a(mu,nu) 
           t1xx(mu,nu) *= c8  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F9a(mu,nu) 
           t1xx(mu,nu) *= c9  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           t1xx(mu,nu)  = F10a(mu,nu) 
           t1xx(mu,nu) *= c10  
           txx(mu,nu)  += t1xx(mu,nu) 
#
           Fpq_a(mu,nu) = txx(mu,nu) 
#
       ENDPARDO mu, nu 
#
       execute sip_barrier 
#
#      Move histories 
#      -------------- 
#
#      2 --> 1 
#      ------- 
#
       PARDO mu, nu 
             GET F2a(mu,nu) 
             PUT F1a(mu,nu) = F2a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F2ai(a,i) 
             PUT F1ai(a,i) = F2ai(a,i)  
       ENDPARDO a,i  
#
       execute sip_barrier 
#
#      3 --> 2 
#      ------- 
#
       PARDO mu, nu 
             GET F3a(mu,nu) 
             PUT F2a(mu,nu) = F3a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F3ai(a,i) 
             PUT F2ai(a,i) = F3ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      4 --> 3 
#      ------- 
#
       PARDO mu, nu 
             GET F4a(mu,nu) 
             PUT F3a(mu,nu) = F4a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F4ai(a,i) 
             PUT F3ai(a,i) = F4ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      5 --> 4 
#      ------- 
#
       PARDO mu, nu 
             GET F5a(mu,nu) 
             PUT F4a(mu,nu) = F5a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F5ai(a,i) 
             PUT F4ai(a,i) = F5ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      6 --> 5 
#      ------- 
#
       PARDO mu, nu 
             GET F6a(mu,nu) 
             PUT F5a(mu,nu) = F6a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F6ai(a,i) 
             PUT F5ai(a,i) = F6ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      7 --> 6 
#      ------- 
#
       PARDO mu, nu 
             GET F7a(mu,nu) 
             PUT F6a(mu,nu) = F7a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F7ai(a,i) 
             PUT F6ai(a,i) = F7ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      8 --> 7 
#      ------- 
#
       PARDO mu, nu 
             GET F8a(mu,nu) 
             PUT F7a(mu,nu) = F8a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F8ai(a,i) 
             PUT F7ai(a,i) = F8ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      9 --> 8 
#      ------- 
#
       PARDO mu, nu 
             GET F9a(mu,nu) 
             PUT F8a(mu,nu) = F9a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F9ai(a,i) 
             PUT F8ai(a,i) = F9ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      10 --> 9 
#      -------- 
#
       PARDO mu, nu 
             GET F10a(mu,nu) 
             PUT F9a(mu,nu) = F10a(mu,nu)  
       ENDPARDO mu, nu 
#
       PARDO a, i 
             GET F10ai(a,i) 
             PUT F9ai(a,i) = F10ai(a,i)  
       ENDPARDO a, i  
#
       execute sip_barrier 
#
#      Current --> 10 
#      -------------- 
#
       PARDO mu, nu 
             GET Fpq_a(mu,nu) 
             PUT F10a(mu,nu) = Fpq_a(mu,nu)  
       ENDPARDO mu, nu 
       execute sip_barrier 
#
       ENDPROC DIIS10    
#      --------------  
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC COMP_INTEGRALS  
#      -------------------  
#
#      Compute all two-particle integrals EXCLUDING the 4-center ones.  
#      ---------------------------------------------------------------
#
############ CLASS 1  ############
#  Do one-center part (mu mu |mu mu)
#
#      PARDO mu
#         DO nu
#               IF nu     == mu
#         DO lambda 
#               IF lambda == mu
#         DO sigma
#
#               IF sigma  == mu
#          
#                  compute_integrals aoint(mu,nu,lambda,sigma)
#                  PREPARE saoint(mu,nu,lambda,sigma) = aoint(mu,nu,lambda,sigma) 
#
#               ENDIF
#
#         ENDDO sigma
#               ENDIF
#         ENDDO lambda 
#               ENDIF
#         ENDDO nu 
#      ENDPARDO mu
#
############ CLASS 2  ############
#  Do two-center part (mu mu |nu nu)->(nu nu |mu mu )
#
       PARDO mu, nu
#
             IF mu     == nu
#
             DO lambda 
                IF mu     < lambda
             DO sigma
#
                IF lambda == sigma
#
                   compute_integrals aoint(mu,nu,lambda,sigma)
                  #PREPARE saoint(mu,nu,lambda,sigma) = aoint(mu,nu,lambda,sigma) 
#
                ENDIF
#
           ENDDO sigma
                ENDIF
           ENDDO lambda 
                ENDIF
       ENDPARDO mu, nu 
#
############ CLASS 3  ############
#  Do two-center part (mu mu |mu nu)->(mu nu |mu mu ),(mu mu|nu mu),(nu mu|mu mu)
#  Do three-center part (mu mu |nu lambda)->(mu mu |lambda nu ),(nu lambda|mu mu),(lambda nu|mu mu)
#
#      PARDO mu, nu
#
#            IF mu     == nu
#
#            DO lambda 
#            DO sigma
#
#               IF lambda  < sigma
#
#                  compute_integrals aoint(mu,nu,lambda,sigma)
#                  PREPARE saoint(mu,nu,lambda,sigma) = aoint(mu,nu,lambda,sigma) 
#
#               ENDIF   
#
#            ENDDO sigma 
#            ENDDO lambda 
#               ENDIF
#      ENDPARDO mu, nu  
#
############ CLASS 4  ############
#  Do two-center part (mu nu |mu nu)->(mu nu |nu mu ),(nu mu|mu nu),(nu mu|nu mu)
#      PARDO mu, lambda
#               If mu==lambda
#            DO nu 
#               IF mu     < nu
#            DO sigma 
#
#               If nu==sigma
#               IF lambda < sigma
#
#                  compute_integrals aoint(mu,nu,lambda,sigma)
#                  PREPARE saoint(mu,nu,lambda,sigma) = aoint(mu,nu,lambda,sigma) 
#
#               ENDIF
#               ENDIF
#
#             ENDDO sigma 
#               ENDIF
#             ENDDO nu 
#               ENDIF
#      ENDPARDO mu, lambda
#
############ CLASS 5  ############
###################  CLASS A ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
#      PARDO mu, lambda 
#               If mu==lambda
#            DO nu 
#               IF mu     < nu
#            DO sigma 
#               IF lambda < sigma
#               If nu<sigma
#
#                  compute_integrals aoint(mu,nu,lambda,sigma)
#                  PREPARE saoint(mu,nu,lambda,sigma) = aoint(mu,nu,lambda,sigma) 
#
#               ENDIF
#               ENDIF
#            ENDDO sigma 
#               ENDIF
#            ENDDO nu 
#               ENDIF
#
#      ENDPARDO mu, lambda 
#
###################  CLASS B ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
# 
#     PARDO nu, lambda
#               If nu==lambda
#           DO mu 
#               IF mu     < nu
#           DO sigma 
#               IF lambda < sigma
#               If mu<sigma
#
#                  compute_integrals aoint(mu,nu,lambda,sigma)
#                  PREPARE saoint(mu,nu,lambda,sigma) = aoint(mu,nu,lambda,sigma) 
#
#               ENDIF
#               ENDIF
#            ENDDO sigma 
#               ENDIF
#            ENDDO mu 
#               ENDIF
#
#      ENDPARDO nu, lambda
#
###################  CLASS C ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
#      PARDO nu
#            DO sigma
#               If nu==sigma
#            DO mu 
#               IF mu     < nu
#            DO lambda 
#               IF lambda < sigma
#               If mu<lambda
#
#                  compute_integrals aoint(mu,nu,lambda,sigma)
#                  PREPARE saoint(mu,nu,lambda,sigma) = aoint(mu,nu,lambda,sigma) 
#
#               ENDIF
#               ENDIF
#            ENDDO lambda 
#               ENDIF
#            ENDDO mu 
#               ENDIF
#
#            ENDDO sigma 
#      ENDPARDO nu 
#
       ENDPROC COMP_INTEGRALS  
#      ---------------------- 
#
# ---------------------------------------------------------------------------- 
#
#  
# ---------------------------------------------------------------------------- 
#
############################################################################## 
#
#                         START OF MAIN PROGRAM 
#
############################################################################## 
#
#     Define a few constants 
#     ---------------------- 
#

      ecrit  = scf_conv # Energy tolerance  
#     damp = 0.0 
      etemp  = 1.0
      etemp += damp
      damp1  = 1.0/etemp
      execute print_scalar damp 
      execute print_scalar damp1

      execute sip_barrier 
     #DO mu
     #DO nu
     #   x2(mu,nu) = oed_ovl(mu,nu)
     #ENDDO nu
     #ENDDO mu
     #execute sip_barrier 

     #execute eig_ovl x2 x3 
      execute sip_barrier 
#
#     Compute the two-electron integrals needed for the computation.
#     -------------------------------------------------------------- 
     #CALL COMP_INTEGRALS 
#
#     Perform initial (aa|bb) integral computation to set Schwartz paramaters 
#     ----------------------------------------------------------------------- 
#
      DO mu 
      DO nu  
      DO lambda  
      DO sigma 
            IF mu == lambda  
            IF nu == sigma 
               execute compute_aabb_batch aoint(mu,nu,lambda,sigma) 
            ENDIF 
            ENDIF 
      ENDDO sigma 
      ENDDO lambda  
      ENDDO nu  
      ENDDO mu 
      execute sip_barrier 
#
#     Create the one-particle arrays needed for the computation. 
#     ---------------------------------------------------------- 
#
#     Fock matrix
#     ----------- 
      CREATE Fpq_a  
#
#     New HF density 
#     -------------- 
#
      CREATE DHFa   
#
#     Old HF density 
#     -------------- 
#
      CREATE DHFa_old    
#
#     Orthonormalizing transformation coefficient
#     ------------------------------------------- 
#
      CREATE Qxx 
      execute sip_barrier 
#
#     execute sip_barrier 
#     execute list_to_blocks Fpq_a 
#     execute sip_barrier 
#     execute list_to_blocks Fpq_b 
#     execute sip_barrier 
#
      #execute sip_barrier
#
#     Construct the array S**(-1/2) 
#     ----------------------------- 
#
      CALL OVER_HALF 
      execute sip_barrier
#
#     Construct the initial guess of the Fock matrix. 
#     ----------------------------------------------- 
#
     #CALL IGUESS  
      DO mu
      DO nu  
         oed_ovl(mu,nu) = x1(mu,nu) # 0.125   
      ENDDO nu 
      ENDDO mu 
      CALL FOCKI_MATRIX 
#
#     Construct S^(-1/2) F S^(-1/2) 
#     ----------------------------- 
#
      execute sip_barrier 
      CALL FOCK_TRANSPOSE 
      execute sip_barrier 
#
#     Diagonalize the transposed Fock matrix 
#     -------------------------------------- 
#
      CALL FOCK_DIAG 
#
#     Back transform the coefficient array 
#     ------------------------------------ 
#
      CREATE CBT_a 
      execute sip_barrier
      CALL   C_BTRAN 
      execute sip_barrier
#
#     Zero out the 'old' HF density 
#     ----------------------------- 
#
      CALL HFDENS_ZERO 
      execute sip_barrier
#
#     Compute the HF density 
#     ---------------------- 
#
      CALL HFDENS
      execute sip_barrier
#
#     Damp the HF density 
#     ------------------- 
#
#     CALL HF_DAMP 
#     execute sip_barrier
#
#     Compute the energy 
#     ------------------ 
#
     #CALL HF_ENERGY 
      energy1 = energy 
     #execute sip_barrier
#
     #DO mu
     #DO nu
           #GET           DHFa_old(mu,nu)
           #GET           DHFa(mu,nu)
           #Txx(mu,nu)  = DHFa(mu,nu)
           #Txx(mu,nu) -= DHFa_old(mu,nu)
           #execute check_dconf Txx donea
     #ENDDO nu
     #ENDDO mu
#
#     Replace 'old' HF density by 'new' HF density 
#     -------------------------------------------- 
#
      CALL HFDENS_REPLACE 
#
#     Create history arrays 
#     --------------------- 
#
      CREATE F1ai 
      CREATE F2ai 
      CREATE F3ai 
      CREATE F4ai 
      CREATE F5ai 
      CREATE F6ai 
#
      CREATE F1a 
      CREATE F2a 
      CREATE F3a 
      CREATE F4a 
      CREATE F5a 
      CREATE F6a 
      execute sip_barrier
#
      DELETE Fpq_a  
      DELETE CBT_a 
#
# Start iterations 
# ---------------- 
#
      DO kiter 
#
#        Create 1-particle arrays 
#        ------------------------ 
#
         CREATE Fpq_a 
         CREATE CBT_a 
         execute sip_barrier
#
#        Construct the new Fock matrix 
#        -----------------------------
#
         CALL FOCK_MATRIX  
#
         CALL HF_ENERGY 
         energy2 = energy 
         execute sip_barrier
#
#        Compute the energy 
#        ------------------ 
#
         CALL GEN_6HISTORY 
         execute sip_barrier 
#
         if kiter == 2 # scf_beg  
            damp   = 0.0    
            damp1  = 1.0    
#
#           Perform DIIS if kiter == 4 
#           -------------------------- 
#
            CALL DIIS2 
         endif 
#
         if kiter == 3 # scf_beg  
#
#           Perform DIIS if kiter == 5 
#           -------------------------- 
#
            CALL DIIS3 
         endif 
#
         if kiter == 4 # scf_beg  
#
#           Perform DIIS if kiter == 6 
#           -------------------------- 
#
            CALL DIIS4 
         endif 
#
         if kiter == 5 # scf_beg  
#
#           Perform DIIS if kiter >= 7 
#           -------------------------- 
#
            CALL DIIS5 
         endif 
#
         if kiter >= 6 # scf_beg  
#
#           Perform DIIS if kiter >= 7 
#           -------------------------- 
#
            CALL DIIS6 
            CALL MOVE6 
         endif 
#
         execute sip_barrier
#
#        Transpose the new Fock matrix 
#        -----------------------------
#
         CALL FOCK_TRANSPOSE 
         execute sip_barrier
#
#        Diagonalize the transposed Fock matrix 
#        -------------------------------------- 
#
         CALL FOCK_DIAG 
         execute sip_barrier
#
#        Back transform the coefficient array 
#        ------------------------------------ 
#
         CALL C_BTRAN 
#
         done = 0.0
         execute sip_barrier
#
#        Check on convergence --> largest HF density difference.
#        -------------------------------------------------------
#
         IF kiter > 1 
#
         DO mu
         DO nu
#
#           Alpha component
#           ---------------
#
            GET           DHFa_old(mu,nu)
            GET           DHFa(mu,nu)
#
            Txx(mu,nu)  = DHFa(mu,nu)
            Txx(mu,nu) -= DHFa_old(mu,nu)
            execute check_dconf Txx donea
            if donea > done
               done = donea
            endif
#
         ENDDO nu
         ENDDO mu
#
         execute print_scalar done
#
#        Set the itol 
#        ------------ 
#
        #DO iiter1 
        #DO jjter1 
        #   T11(iiter1,jjter1) = 0.0 
        #   execute set_itol T11 done  
        #ENDDO jjter1  
        #ENDDO iiter1  
#
        #execute print_scalar done
#
         ENDIF # kiter > 1 
#
         execute sip_barrier
#
#        Check on convergence using density difference.
#        ----------------------------------------------
#
         IF kiter > 1
            IF done < scf_conv
               DELETE CBT_a
               exit
            ENDIF
         ENDIF
#
#        Replace 'old' HF density by 'new' HF density 
#        -------------------------------------------- 
#
         CALL HFDENS_REPLACE 
         execute sip_barrier
#
#        Compute the HF density 
#        ---------------------- 
#
         CALL HFDENS
         execute sip_barrier
#
#        Delete one-particle arrays to be used in the next iteration. 
#        ------------------------------------------------------------ 
#
         if kiter < scf_iter
            DELETE Fpq_a
         endif

         DELETE CBT_a
#
      ENDDO kiter 
#
#     Release unneeded memory blocks.
#
      execute sip_barrier
      DELETE DHFA
      DELETE DHFA_OLD
     #DELETE FTPQ_A
     #DELETE FTPQ_B
     #DELETE CBT_A
     #DELETE CBT_B
      DELETE F1Ai
      DELETE F2Ai
      DELETE F3Ai
      DELETE F4Ai
      DELETE F5Ai
      DELETE F6Ai
      DELETE F2A
      DELETE F3A
      DELETE F4A
      DELETE F5A
      DELETE F6A

      CREATE FTa 
      execute sip_barrier 
      PARDO mu, nu 
            GET Fpq_a(mu,nu) 
            DO p 
               Txp(mu,p) = Fpq_a(mu,nu)*ca(nu,p) 
               DO p1 
                  Tpp(p1,p) = Txp(mu,p)*ca(mu,p1) 
                  PUT FTa(p1,p) += Tpp(p1,p) 
                 #Fock_a(p1,p) += Tpp(p1,p) 
               ENDDO p1  
            ENDDO p 
      ENDPARDO mu, nu 
#     
      execute sip_barrier 
#
#     Put the final Fock arrays into predefined arrays 
#     ------------------------------------------------ 
#
      execute get_my_rank rank
      if rank == 0.0 
         DO p 
         DO p1  
            GET FTa(p,p1) 
            tpp(p,p1) = FTa(p,p1) 
            Fock_a(p,p1) = tpp(p,p1) 
         ENDDO p1  
         ENDDO p 
#
#        Copy CA  --> CB, Focka --> Fockb.  This avoids possible errors
#        in setting the ACES2 REF parameter.
#
         execute scf_rhf Fock_b cb 
      endif 
#
      execute sip_barrier 
#
      scfeneg += energy2 
      totenerg = scfeneg
      execute sip_barrier
#
                           ENDSIAL SCF_RHF_TEST    
#
###############################################################################
#
