#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL MBPT2_GRAD_AO2      
#
# This SIAL program computes the second-order correction to the density
# and the second-order correction to the energy-weighted density matrix. 
# They are written to file to be used in the final gradient construction. 
#
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
#
# Declare indeces 
# --------------- 
#
      index kiter    = 1, 100   
#
      aoindex mu     = 1, norb
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      aoindex m      = 1, norb
      aoindex n      = 1, norb
      aoindex l      = 1, norb
      aoindex s      = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
# 
# Arrays used in transformation for AO2 algorithm
# -----------------------------------------------
#
      temp Txixi(mu,i1,lambda,i)
      temp T1xixi(mu,i1,lambda,i)
      temp Txxii(mu,nu,i1,i)
      temp T1xxii(mu,nu,i1,i)
      temp T2xxii(mu,nu,i1,i)
      temp T3xxii(mu,nu,i1,i)
      temp Tixxi(i1,nu,lambda,i)
      temp T1ixxi(i1,nu,lambda,i)
      temp Txipi(mu,i,p,i1)
      temp Tpipi(p1,i,p,i1)
      temp T1pipi(p1,i,p,i1)
      temp T2pipi(p1,i,p,i1)
      temp Tixai(i,mu,a,i1)
      temp Txaii(mu,a,i,i1)
      temp Tiaai(i,a1,a,i1)
      temp Taaii(a,a1,i,i1)
      temp Txaai(mu,a1,a,i)
      temp Taaai(a2,a,a1,i)
      temp T1aaai(a2,a,a1,i)
      temp Txxai(mu,nu,a,i)
      temp txxix(nu,mu,i,lambda) 
#
      served Vxixi(mu,i1,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
#
#     Permanent 
#     --------- 
      served VSpipi(p1,i,p,i1)
      served ASpipi(a,i,a1,i1) 
      served Apiqj(a,i,a1,i1) 
#
      temp Txjxj(mu,j1,lambda,j)
      temp T1xjxj(mu,j1,lambda,j)
      temp Txxjj(mu,nu,j1,j)
      temp Tjjxx(j1,nu,lambda,j)
      temp Tjxxj(j1,nu,lambda,j)
      temp Txjqj(mu,j,q,j1)
      temp Tqjqj(q1,j,q,j1)
      temp T1qjqj(q1,j,q,j1)
      temp T2qjqj(q1,j,q,j1)
      temp Tjxbj(j,mu,b,j1)
      temp Txbjj(mu,b,j,j1)
      temp Tjbbj(j,b1,b,j1)
      temp Tbbjj(b,b1,j,j1)
      temp Txbbj(mu,b1,b,j)
      temp Tbbbj(b2,b,b1,j)
      temp T1bbbj(b2,b,b1,j)
      temp Txxbj(mu,nu,b,j)
#
      served Vxxjj(mu,nu,j1,j)
#
#     Permanent 
#     --------- 
#
      temp Txixj(mu,i,nu,j)
      temp T1xixj(mu,i,nu,j)
      temp Txiqj(mu,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp T1piqj(p,i,q,j)
      temp T2piqj(p,i,q,j)
      temp Tiixx(i,i1,mu,nu)
      temp Tiixb(i,i1,mu,b)
      temp Tiibb(i,i1,b1,b)
      temp Txajj(mu,a,j,j1)
      temp Taajj(a,a1,j,j1)
      temp Txabj(mu,a,b,j)
      temp Tixxj(i,mu,nu,j)
      temp Tixbj(i,mu,b,j)
      temp Tiabj(i,a,b,j)
      temp Taabj(a,a1,b,j)
      temp Taiai(a,i,a1,i1) 
      temp T1aiai(a,i,a1,i1) 
#
      served Vxixj(mu,i,nu,j)
      served Vxiqj(mu,i,q,j)
      served Vpiqj(p,i,q,j)
      served Vxajj(mu,a,j,j1)
      served Vixxj(i,mu,nu,j)
      served Vixbj(i,mu,b,j)
#
#     Permanent 
#     --------- 
      served Viabj(i,a,b,j)
      served Vaajj(a,a1,j,j1)
#
      temp Txbii(mu,b,i,i1)
      temp Tbbii(b,b1,i,i1)
      temp Tjbii(j,b,i,i1)
      temp Txbai(mu,b,a,i)
      temp Tbbai(b,b1,a,i)
#
# End Arrays used in transformation for AO2 algorithm
# --------------------------------------------------- 
#
# Declare one-particle density arrays 
# ----------------------------------- 
#
      distributed Pij_aa(i,i1) 
      distributed Pab_aa(a,a1) 
      distributed Lai_aa(a,i) 
      local LLai_aa(a,i) 
      distributed Painew_aa(a,i)
      distributed Paiold_aa(a,i) 
      distributed Wab_aa(a,a1) 
      distributed Wij_aa(i,i1) 
      local LWij_aa(i,i1) 
      distributed Wai_aa(a,i) 
      distributed P2_ao(mu,nu) 
      distributed P2A_ao(mu,nu) 
      distributed W2_ao(mu,nu) 
      distributed Paa_ao(mu,nu) 
      distributed Whfa(mu,nu) 
      distributed Dhfa(mu,nu) 
      distributed Dhf(mu,nu) 
      distributed Lxi(mu,i) 
      distributed Yxi(mu,i) 
      local LLxi(mu,i) 
      local LYxi(mu,i) 
      local LDhfa(mu,nu)   
      local LP2A_ao(mu,nu) 
      local La(p,mu) 
      local LPaa_ao(sigma,mu) 
#
# Local arrays used in the density contraction 
# -------------------------------------------- 
#
      local LTAxxxi(mu,lambda,nu,i1) 
      local LTAxxxj(mu,lambda,nu,j)  
      local LTBxxxj(mu,lambda,sigma,j) 
      local LVxixj(lambda,i,mu,i1) 
      local LVxxjj(nu,mu,i,i1) 
      local LVixxj(i1,nu,lambda,i) 
#
      scalar ml
      scalar ns
      scalar mm
      scalar nn
      scalar ll
      scalar ss
      scalar n_seg
      scalar efact
#
# Declare temporary arrays 
# ------------------------ 
#
      temp Txxxx(mu,nu,lambda,sigma) 
      temp TSxxxx(mu,nu,lambda,sigma) 
      temp T1xxxx(mu,nu,lambda,sigma) 
      temp T2xxxx(mu,nu,lambda,sigma) 
      temp T3xxxx(mu,nu,lambda,sigma) 
      temp T4xxxx(mu,nu,lambda,sigma) 
      temp T5xxxx(mu,nu,lambda,sigma) 
      temp T6xxxx(mu,nu,lambda,sigma) 

      temp Txxxi(mu,nu,lambda,i) 
      temp Tixxx(i,mu,nu,lambda) 
      temp T1xxxi(mu,nu,lambda,i) 
      temp T2xxxi(mu,nu,lambda,i) 
      temp T3xxxi(mu,nu,lambda,i) 
      temp T4xxxi(mu,nu,lambda,i) 
      temp Txxxj(mu,nu,lambda,j) 
      temp T1xxxj(mu,nu,lambda,j) 
      temp T2xxxj(mu,nu,lambda,j) 
      temp T3xxxj(mu,nu,lambda,j) 
      temp T4xxxj(mu,nu,lambda,j) 
      temp Txixx(mu,i,nu,lambda) 
      temp Txjxx(mu,j,nu,lambda) 
      temp Txxjx(mu,nu,j,lambda) 
      temp gaa(mu,i,nu,lambda) 
      temp gab(mu,i,nu,lambda) 
      temp gbb(mu,i,nu,lambda) 
      temp TAxxxi(mu,lambda,nu,i1)     
      temp TBxxxi(mu,lambda,sigma,i1)  
      temp TAxxxj(mu,lambda,nu,j1)     
      temp TBxxxj(mu,lambda,sigma,j1)  
      temp V0xxxi(mu,nu,lambda,i)
      temp L0xxxi(mu,nu,lambda,i)
      temp V2xxxi(mu,nu,sigma,i)
      temp V3xxxi(mu,nu,lambda,i)
      temp V4xxxi(mu,nu,sigma,i)
      temp Tii(i,i1) 
      temp T1ii(i,i1) 
      temp Tjj(j,j1) 
      temp T1jj(j,j1) 
      temp Taa(a,a1) 
      temp Tbb(b,b1) 
      temp Tai(a,i) 
      temp T1ai(a,i) 
      temp Tbj(b,j) 
      temp T1bj(b,j) 
      temp Tiiaa(i,i1,a,a1) 
      temp T1iiaa(i,i1,a,a1) 
      temp Tjjbb(j,j1,b,b1) 
      temp T1jjbb(j,j1,b,b1) 
      temp Txi(mu,i) 
      temp Ixi(mu,i) 
      temp I1xi(mu,i) 
      temp Jxi(mu,i) 
      temp Kxi(mu,i) 
      temp Txj(mu,j) 
      temp Ixj(mu,j) 
      temp I1xj(mu,j) 
      temp Jxj(mu,j) 
      temp Kxj(mu,j) 
      temp Ixx(mu,nu) 
      temp I1xx(mu,nu) 
      temp I2xx(mu,nu) 
      temp Jxx(mu,nu) 
      temp J1xx(mu,nu) 
      temp Kxx(mu,nu) 
      temp K1xx(mu,nu) 
      temp Ixa(mu,a) 
      temp Jxa(mu,a) 
      temp Ixb(mu,b) 
      temp Jxb(mu,b) 
      temp Kxa(mu,a) 
      temp Kxb(mu,b) 
      temp Tpq(mu,nu)  
      temp Txx(mu,nu)  
      temp T1xx(mu,nu)  
      temp T2xx(mu,nu)  
      temp T3xx(mu,nu)  
#
# Declare served arrays 
# --------------------- 
#
      temp AOINT(mu,nu,lambda,sigma) 
      temp dx1(mu,nu,lambda,sigma)
      temp dy1(mu,nu,lambda,sigma)
      temp dz1(mu,nu,lambda,sigma)
      temp dx2(mu,nu,lambda,sigma)
      temp dy2(mu,nu,lambda,sigma)
      temp dz2(mu,nu,lambda,sigma)
      temp dx3(mu,nu,lambda,sigma)
      temp dy3(mu,nu,lambda,sigma)
      temp dz3(mu,nu,lambda,sigma)
      temp dx4(mu,nu,lambda,sigma)
      temp dy4(mu,nu,lambda,sigma)
      temp dz4(mu,nu,lambda,sigma)
#
# Declare Local arrays 
# -------------------- 
#
      temp Xa(lambda,i,sigma,mu) 
      local xb(sigma,mu,lambda,i)
      temp  D2(mu,lambda,nu,sigma) 
#
      local Lxixi(mu,i1,lambda,i) 
      local Lxixj(mu,i,lambda,j) 
      local Lxjxj(mu,j1,lambda,j) 
      local Lxxii(mu,nu,i1,i) 
      local Lxxjj(mu,nu,j1,j) 
      local Lixxi(i1,nu,lambda,i) 
      local Lixxj(i,nu,lambda,j) 
      local Ljxxj(j1,nu,lambda,j) 
      local Lxipi(mu,i,p,i1) 
      local Lpipi(p1,i,p,i1)  
      local Lxaii(mu,a,i,i1) 
      local Laaii(a1,a,i,i1) 
      local Lixai(i,mu,a,i1) 
      local Liaai(i,a1,a,i1) 
#
      local Lxjqj(mu,j,q,j1) 
      local Lqjqj(q1,j,q,j1)  
      local Lxbjj(mu,b,j,j1) 
      local Lbbjj(b1,b,j,j1) 
      local Ljxbj(j,mu,b,j1) 
      local Ljbbj(j,b1,b,j1) 
      local Lxbii(mu,b,i,i1) 
      local Lbbii(b1,b,i,i1) 
      local Lxajj(mu,a,j,j1) 
      local Laajj(a1,a,j,j1) 
      local Lixbj(i,mu,b,j) 
      local Liabj(i,a,b,j) 
      local Liixb(i,i1,mu,b) 
      local Liibb(i,i1,b1,b) 
      local Lxiqj(mu,i,q,j) 
      local Lpiqj(q,j,p,i) 
#
      local Lxiai(mu,i,a1,i1) 
      local Lxjbj(mu,j,b1,j1) 
      local Lxibj(mu,i,b,j) 
      local L1xixi(mu,i,nu,i1) 
      local L1xjxj(mu,j,nu,j1) 
      local L1xixj(mu,i,nu,j) 
#
# Arrays and scalars  used in iterative computation of Dai
# --------------------------------------------------------
#
      distributed D0ai(a,i)
      distributed D1ai(a,i)
      distributed D2ai(a,i)
      distributed D3ai(a,i)
      distributed D4ai(a,i)
#
      distributed D0bj(b,j)
      distributed D1bj(b,j)
      distributed D2bj(b,j)
      distributed D3bj(b,j)
      distributed D4bj(b,j)
#
      distributed e1ai(a,i)
      distributed e2ai(a,i)
      distributed e3ai(a,i)
      distributed e4ai(a,i)
      distributed e5ai(a,i)
#
      distributed e1bj(b,j)
      distributed e2bj(b,j)
      distributed e3bj(b,j)
      distributed e4bj(b,j)
      distributed e5bj(b,j)
#
      scalar b11
      scalar b12
      scalar b13
      scalar b14
      scalar b15
      scalar b16
      scalar b17
      scalar b18
      scalar b19
      scalar b110
#
      scalar b22
      scalar b23
      scalar b24
      scalar b25
      scalar b26
      scalar b27
      scalar b28
      scalar b29
      scalar b210
#
      scalar b33
      scalar b34
      scalar b35
      scalar b36
      scalar b37
      scalar b38
      scalar b39
      scalar b310
      scalar b44
      scalar b45
      scalar b46
      scalar b47
      scalar b48
      scalar b49
      scalar b410
#
      scalar b55
      scalar b56
      scalar b57
      scalar b58
      scalar b59
      scalar b510
#
      scalar b66
      scalar b67
      scalar b68
      scalar b69
      scalar b610
#
      scalar b77
      scalar b78
      scalar b79
      scalar b710
#
      scalar b88
      scalar b89
      scalar b810
#
      scalar b99
      scalar b910
#
      scalar b1010
#
      scalar Tb11
      scalar Tb12
      scalar Tb13
      scalar Tb14
      scalar Tb15
      scalar Tb16
      scalar Tb17
      scalar Tb18
      scalar Tb19
      scalar Tb110
#
      scalar Tb22
      scalar Tb23
      scalar Tb24
      scalar Tb25
      scalar Tb26
      scalar Tb27
      scalar Tb28
      scalar Tb29
      scalar Tb210
#
      scalar Tb33
      scalar Tb34
      scalar Tb35
      scalar Tb36
      scalar Tb37
      scalar Tb38
      scalar Tb39
      scalar Tb310
      scalar Tb44
      scalar Tb45
      scalar Tb46
      scalar Tb47
      scalar Tb48
      scalar Tb49
      scalar Tb410
#
      scalar Tb55
      scalar Tb56
      scalar Tb57
      scalar Tb58
      scalar Tb59
      scalar Tb510
#
      scalar Tb66
      scalar Tb67
      scalar Tb68
      scalar Tb69
      scalar Tb610
#
      scalar Tb77
      scalar Tb78
      scalar Tb79
      scalar Tb710
#
      scalar Tb88
      scalar Tb89
      scalar Tb810
#
      scalar Tb99
      scalar Tb910
#
      scalar Tb1010
#
      scalar c1
      scalar c2
      scalar c3
      scalar c4
      scalar c5
      scalar c6
      scalar c7
      scalar c8
      scalar c9
      scalar c10
#
# Declare scalars 
# --------------- 
#
      scalar etemp
      scalar esum
      scalar esum1 
      scalar esumaa 
      scalar ecorraa
      scalar ecorrbb
      scalar ecorrab
      scalar ecorrT
      scalar enew 
      scalar eold 
      scalar ecrit 
      scalar ediff 
      scalar mp2_energy
      served Vxxxi(mu,nu,lambda,i) 
      distributed DVxixj(mu,i1,lambda,i) 
      distributed DVxxjj(mu,nu,i1,i) 
      distributed DVixxj(i1,mu,nu,i) 
      distributed DVxajj(mu,a,j,i) 
      distributed DVixbj(i1,mu,a,i) 
      distributed DVxiqj(mu,i1,q,i) 
      local LVxixi(mu,i1,lambda,i) 
      local LVxxii(mu,nu,i1,i) 
      local LVixxi(i1,nu,lambda,i) 
      local Laoint(mu,nu,lambda,sigma) 
#
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_XXXI
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
        WHERE mu < nu 
#
        allocate Laoint(mu,nu,lambda,*) 
        DO sigma 
              compute_integrals            AOINT(mu,nu,lambda,sigma)
              Laoint(mu,nu,lambda,sigma) = AOINT(mu,nu,lambda,sigma) 
        ENDDO sigma 
#
        DO i 
#
           L0xxxi(mu,nu,lambda,i) = 0.0 
#
           DO sigma 
                 V0xxxi(mu,nu,lambda,i)  = LAOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                 L0xxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i)
           ENDDO sigma 
#
           txxxi(nu,mu,lambda,i)         = L0xxxi(mu,nu,lambda,i) 
           PREPARE Vxxxi(mu,nu,lambda,i) = L0xxxi(mu,nu,lambda,i) 
           PREPARE Vxxxi(nu,mu,lambda,i) = txxxi(nu,mu,lambda,i) 
#
        ENDDO i 
        deallocate Laoint(mu,nu,lambda,*) 
#
     ENDPARDO mu, nu, lambda
#
     PARDO mu, nu, lambda
        WHERE mu == nu 
#
        allocate Laoint(mu,nu,lambda,*) 
        DO sigma 
              compute_integrals            AOINT(mu,nu,lambda,sigma)
              Laoint(mu,nu,lambda,sigma) = AOINT(mu,nu,lambda,sigma) 
        ENDDO sigma 
#
        DO i 
#
           L0xxxi(mu,nu,lambda,i) = 0.0 
#
           DO sigma 
                 V0xxxi(mu,nu,lambda,i)  = LAOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                 L0xxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i)
           ENDDO sigma 
#
           PREPARE Vxxxi(mu,nu,lambda,i) = L0xxxi(mu,nu,lambda,i) 
#
        ENDDO i 
        deallocate Laoint(mu,nu,lambda,*) 
#
     ENDPARDO mu, nu, lambda
#
     execute server_barrier 
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_XXXI
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_XXII
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
        WHERE mu < nu
#
           L0xxxi(mu,nu,lambda,i) = 0.0
#
           DO sigma
                 compute_integrals         AOINT(mu,nu,lambda,sigma)
                 V0xxxi(mu,nu,lambda,i)  = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                 L0xxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i)
           ENDDO sigma
#
           txxxi(nu,mu,lambda,i)         = L0xxxi(mu,nu,lambda,i)
           PREPARE Vxxxi(mu,nu,lambda,i) = L0xxxi(mu,nu,lambda,i)
           PREPARE Vxxxi(nu,mu,lambda,i) = txxxi(nu,mu,lambda,i)
#
     ENDPARDO mu, nu, lambda
#
     PARDO mu, nu, lambda
        WHERE mu == nu
#
           L0xxxi(mu,nu,lambda,i) = 0.0
#
           DO sigma
                 compute_integrals         AOINT(mu,nu,lambda,sigma)
                 V0xxxi(mu,nu,lambda,i)  = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                 L0xxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i)
           ENDDO sigma
#
           PREPARE Vxxxi(mu,nu,lambda,i) = L0xxxi(mu,nu,lambda,i)
#
     ENDPARDO mu, nu, lambda
#
     execute server_barrier
#
     PARDO mu, lambda
#
           allocate LVxixi(mu,*,lambda,i)
#
           DO nu
#
              REQUEST Vxxxi(mu,nu,lambda,i) i
#
              DO i1
                 Txixi(mu,i1,lambda,i)   = Vxxxi(mu,nu,lambda,i)*ca(nu,i1)
                 LVxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
              ENDDO i1
#
           ENDDO nu
#
           DO i1
              PUT DVxixj(mu,i1,lambda,i) = LVxixi(mu,i1,lambda,i)
           ENDDO i1
#
           deallocate LVxixi(mu,*,lambda,i)
#
     ENDPARDO mu, lambda
#
     PARDO mu, nu
#
           allocate LVxxii(mu,nu,*,i)
#
           DO lambda
#
              REQUEST Vxxxi(mu,nu,lambda,i) i
#
              DO i1
                 Txxii(mu,nu,i1,i)   = Vxxxi(mu,nu,lambda,i)*ca(lambda,i1)
                 LVxxii(mu,nu,i1,i) += Txxii(mu,nu,i1,i)
              ENDDO i1
#
           ENDDO lambda
#
           DO i1
              PUT DVxxjj(mu,nu,i1,i) = LVxxii(mu,nu,i1,i)
           ENDDO i1
#
           deallocate LVxxii(mu,nu,*,i)
#
     ENDPARDO mu, nu
#
     PARDO nu, lambda
#
           allocate LVixxi(*,nu,lambda,i)
#
           DO mu
#
              REQUEST Vxxxi(mu,nu,lambda,i) i
#
              DO i1
                 Tixxi(i1,nu,lambda,i)   = Vxxxi(mu,nu,lambda,i)*ca(mu,i1)
                 LVixxi(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i)
              ENDDO i1
#
           ENDDO mu
#
           DO i1
              PUT DVixxj(i1,nu,lambda,i) = LVixxi(i1,nu,lambda,i)
           ENDDO i1
#
           deallocate LVixxi(*,nu,lambda,i)
#
     ENDPARDO nu, lambda
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_XXII
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, j 
           allocate Lxajj(mu,*,j,i) 
           DO nu 
              GET DVxxjj(mu,nu,j,i)  
              DO a
                 Txajj(mu,a,j,i)  = DVxxjj(mu,nu,j,i)*ca(nu,a)
                 Lxajj(mu,a,j,i) += Txajj(mu,a,j,i)
              ENDDO a
           ENDDO nu 
#
           DO a
              Txajj(mu,a,j,i)      = Lxajj(mu,a,j,i) 
              PUT DVxajj(mu,a,j,i) = Txajj(mu,a,j,i)
           ENDDO a
           deallocate Lxajj(mu,*,j,i) 
     ENDPARDO mu, j 
#
     PARDO mu, j 
           allocate Lixbj(j,mu,*,i) 
           DO nu 
              GET DVixxj(j,mu,nu,i) 
              DO b
                 Tixbj(j,mu,b,i)  = DVixxj(j,mu,nu,i)*ca(nu,b)
                 Lixbj(j,mu,b,i) += Tixbj(j,mu,b,i)
              ENDDO b
           ENDDO nu 
#
           DO b
              Tixbj(j,mu,b,i)      = Lixbj(j,mu,b,i) 
              PUT DVixbj(j,mu,b,i) = Tixbj(j,mu,b,i)
           ENDDO b
#
           deallocate Lixbj(j,mu,*,i) 
#
     ENDPARDO mu, j 
#
     PARDO mu, j
           allocate Lxiqj(mu,j,*,i) 
           DO nu 
              GET DVxixj(mu,j,nu,i) 
              DO q
                 Txiqj(mu,j,q,i)  = DVxixj(mu,j,nu,i)*ca(nu,q)
                 Lxiqj(mu,j,q,i) += Txiqj(mu,j,q,i)
              ENDDO q
           ENDDO nu 
#
           DO q
              Txiqj(mu,j,q,i)      = Lxiqj(mu,j,q,i) 
              PUT DVxiqj(mu,j,q,i) = Txiqj(mu,j,q,i)
           ENDDO q
#
           deallocate Lxiqj(mu,j,*,i) 
#
     ENDPARDO mu, j 
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_4
#
#    ------------------------------------------------------------------------
#
     PARDO a, j 
#
           allocate Laajj(*,a,j,i) 
#
           DO mu 
              GET DVxajj(mu,a,j,i) 
#
              DO a1
                 Taajj(a1,a,j,i)  = DVxajj(mu,a,j,i)*ca(mu,a1)
                 Laajj(a1,a,j,i) += Taajj(a1,a,j,i)
              ENDDO a1
#
           ENDDO mu 
#
           DO a1
              Taajj(a1,a,j,i)         = Laajj(a1,a,j,i) 
              PREPARE Vaajj(a1,a,j,i) = Taajj(a1,a,j,i)
           ENDDO a1
#
           deallocate Laajj(*,a,j,i) 
#
     ENDPARDO  a, j 
#
     PARDO b, j
#
           allocate Liabj(j,*,b,i) 
#
           DO mu 
              GET DVixbj(j,mu,b,i) 
              DO a
                 Tiabj(j,a,b,i)  = DVixbj(j,mu,b,i)*ca(mu,a)
                 Liabj(j,a,b,i) += Tiabj(j,a,b,i)
              ENDDO a
#
           ENDDO mu 
#
           DO a
              Tiabj(j,a,b,i)         = Liabj(j,a,b,i) 
              PREPARE Viabj(j,a,b,i) = Tiabj(j,a,b,i)
           ENDDO a
#
           deallocate Liabj(j,*,b,i) 
#
     ENDPARDO b, j
#
     PARDO p, j 
#
           allocate Lpiqj(*,j,p,i) 
#
           DO mu 
#
              GET DVxiqj(mu,j,p,i)  
#
              DO q
                 Tpiqj(q,j,p,i)  = DVxiqj(mu,j,p,i)*ca(mu,q)
                 Lpiqj(q,j,p,i) += Tpiqj(q,j,p,i)
              ENDDO q
#
           ENDDO mu 
#
           DO q
              Tpiqj(q,j,p,i)         = Lpiqj(q,j,p,i) 
              PREPARE Vpiqj(q,j,p,i) = Tpiqj(q,j,p,i)
           ENDDO q
#
           deallocate Lpiqj(*,j,p,i) 
#
     ENDPARDO p, j
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_4
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_PPPP
#
#    ------------------------------------------------------------------------
#
     DO I
        create DVxixj(*,*,*,i)
        create DVxxjj(*,*,*,i)
        create DVixxj(*,*,*,i)
        execute sip_barrier
        CALL TRAN_XXII
        execute server_barrier
        destroy Vxxxi
        create DVxajj(*,*,*,i)
        create DVixbj(*,*,*,i)
        create DVxiqj(*,*,*,i)
        execute server_barrier
        CALL TRAN_3
        execute sip_barrier
        delete DVxxjj
        delete DVxixj
        delete DVixxj
        CALL TRAN_4
        execute sip_barrier
        delete DVxiqj(*,*,*,i)
        delete DVxajj(*,*,*,i)
        delete DVixbj(*,*,*,i)
     ENDDO I
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_PPPP
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF 
# 
        CALL TRAN_PPPP  
        execute server_barrier 
#
        PARDO p, i, q, j 
              REQUEST                   Vpiqj(p,i,q,j) p 
              REQUEST                   Vpiqj(p,j,q,i) p 
              Tpiqj(p,i,q,j)          = Vpiqj(p,i,q,j)  
              T1piqj(p,i,q,j)         = Vpiqj(p,j,q,i)  
              Tpiqj(p,i,q,j)         -= T1piqj(p,i,q,j) 
              PREPARE VSpipi(p,i,q,j) = Tpiqj(p,i,q,j) 
        ENDPARDO p, i, q, j 
#
     ENDPROC TRAN_UHF 
# 
#    ------------------------------------------------------------------------ 
#
# -----------------------------------------------------------------------------
#
      PROC WHFDENS
#     ------------
#
      PARDO mu, nu, i 
#
            Ixi(nu,i) = 0.0  
#
            DO i1 
#
               I1xi(nu,i) = ca(nu,i1)*fock_a(i,i1) 
               Ixi(nu,i) -= I1xi(nu,i) 
#
            ENDDO i1  
#
            Tpq(mu,nu)       = ca(mu,i)*Ixi(nu,i)
            PUT Whfa(mu,nu) += Tpq(mu,nu)
#
      ENDPARDO mu, nu, i  
#
      execute sip_barrier 
#
      ENDPROC WHFDENS
#     --------------
# -----------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
      PARDO mu, nu, i
#
            Txi(nu,i)        = ca(nu,i)
            Tpq(mu,nu)       = ca(mu,i)*Txi(nu,i)
            PUT Dhfa(mu,nu) += Tpq(mu,nu)
#
      ENDPARDO mu, nu, i
#
      ENDPROC HFDENS
#     --------------
#
      PROC D1TRANS
#     ------------
#
# Contract with the derivative integrals
# --------------------------------------
#
      PARDO mu, nu
#
            GET            P2A_ao(mu,nu)
            GET            DHFA(mu,nu)
#
            Tpq(mu,nu)   = DHFA(mu,nu)
            Tpq(mu,nu)  += P2A_ao(mu,nu)
            Tpq(mu,nu)  *= 2.0  
#
            EXECUTE HCONT1 Tpq(mu,nu)
#
      ENDPARDO mu, nu
#
# -----------------------------------------------------------------------------
#
      ENDPROC D1TRANS
#     ---------------
#
# -----------------------------------------------------------------------------
#
      PROC S1TRANS
#     ------------
#
# Contract with the derivative integrals
# --------------------------------------
#
      PARDO mu, nu
#
            GET            W2_ao(mu,nu)
            GET            WHFa(mu,nu)
#
            Tpq(mu,nu)   = W2_ao(mu,nu)
            Tpq(mu,nu)  += WHFa(mu,nu)
            Tpq(mu,nu)  *= 2.0  
#
            EXECUTE SCONT1 Tpq(mu,nu)
#
      ENDPARDO mu, nu
#
# -----------------------------------------------------------------------------
#
      ENDPROC S1TRANS
#     ---------------
#
# --------------------------------------------------------------------------- 
#
# The following procedure computes the contribution to Lai which 
# depends on the VVVO integrals directly. 
#
      PROC LAIAO1
#     -----------
#
#     Zero-out half backtransform vvoo integral arrays. 
#     ------------------------------------------------- 
#
      execute server_barrier 
#
#     First half backtransform vvoo integrals
#     ---------------------------------------
#
#     AABB spin case
#     --------------
#
      PARDO b, i, j 
#
            allocate Lxibj(*,i,b,j) 
#
            DO a 
#
               REQUEST Apiqj(a,i,b,j) i 
#
               DO mu
#
                  Txiqj(mu,i,b,j)  = Apiqj(a,i,b,j)*ca(mu,a)
                  Lxibj(mu,i,b,j) += Txiqj(mu,i,b,j) 
#
               ENDDO mu
#
            ENDDO a 
#
            DO mu
#
               Txiqj(mu,i,b,j)         = Lxibj(mu,i,b,j) 
               PREPARE Vxiqj(mu,i,b,j) = Txiqj(mu,i,b,j) 
#
            ENDDO mu
#
            deallocate Lxibj(*,i,b,j) 
#
      ENDPARDO b, i, j
#
      execute server_barrier 
#
      PARDO mu, i, j 
#
            allocate L1xixj(mu,i,*,j) 
#
            DO b 
#
               REQUEST Vxiqj(mu,i,b,j) i  
#
               DO nu
#
                  Txixj(mu,i,nu,j)   = Vxiqj(mu,i,b,j)*La(b,nu) # ca(nu,b)
                  L1xixj(mu,i,nu,j) += Txixj(mu,i,nu,j)
#
               ENDDO nu
#
            ENDDO b  
#
            DO nu
#
               Txixj(mu,i,nu,j)         = L1xixj(mu,i,nu,j) 
               PREPARE Vxixj(mu,i,nu,j) = Txixj(mu,i,nu,j)
#
            ENDDO nu
#
            deallocate L1xixj(mu,i,*,j) 
#
      ENDPARDO mu, i, j
#
      execute server_barrier 
#
      create Lxi 
      create Yxi    
      allocate LPaa_ao(*,*) 
      PARDO lambda, i, sigma, i1  
            REQUEST                            Vxixj(lambda,i,sigma,i1) i 
            REQUEST                            Vxixj(sigma,i,lambda,i1) i 
#
            Txixi(lambda,i,sigma,i1)         = Vxixj(lambda,i,sigma,i1) 
            T1xixi(lambda,i,sigma,i1)        = Vxixj(sigma,i,lambda,i1) 
            T1xixi(lambda,i,sigma,i1)       *= 2.0  
            Txixi(lambda,i,sigma,i1)        -= T1xixi(lambda,i,sigma,i1)  
            PREPARE Vxixi(lambda,i,sigma,i1) = Txixi(lambda,i,sigma,i1) 
      ENDPARDO lambda, i, sigma, i1  
#
      DO mu 
      DO sigma  
         GET                 Paa_ao(sigma,mu) 
         LPaa_ao(sigma,mu) = Paa_ao(sigma,mu) 
      ENDDO sigma  
      ENDDO mu 

#     PARDO mu, i 
#           txi(mu,i)     = 0.0 
#           PUT Lxi(mu,i) = txi(mu,i) 
#           PUT Yxi(mu,i) = txi(mu,i) 
#     ENDPARDO mu, i 

      allocate LLxi(*,*) 
      allocate LYxi(*,*) 

      execute server_barrier
#
#     Perform intermediate contraction to get contribution to Lxi and Lxj 
#     -------------------------------------------------------------------
#
      PARDO mu, lambda, sigma
#
            allocate xb(sigma,mu,lambda,*)
#
#           Form Xa 
#           ------- 
#
            DO i
               xa(lambda,i,sigma,mu) = 0.0 
#
               DO i1
#
                  REQUEST                     Vxixi(lambda,i,sigma,i1) i
                  Txixx(lambda,i,sigma,mu)  = Vxixi(lambda,i,sigma,i1)*La(i1,mu) # ca(mu,i1)
                  xa(lambda,i,sigma,mu)    += Txixx(lambda,i,sigma,mu)
#
               ENDDO i1
#
               xb(sigma,mu,lambda,i) = xa(lambda,i,sigma,mu) 
#
            ENDDO i
#
            DO nu
#
               compute_integrals aoint(nu,sigma,mu,lambda)
#
#              Finish Lxi 
#              ---------- 
#
               DO i
                  Ixi(nu,i)             = aoint(nu,sigma,mu,lambda)*xb(sigma,mu,lambda,i)  
                  LLxi(nu,i)           += Ixi(nu,i)  
               ENDDO i
#
#              Start third-term 
#              ---------------- 
#
               I1xx(sigma,nu)  = LPaa_ao(sigma,nu) 
               I1xx(sigma,nu) *= 2.0  
               Ixx(mu,lambda)  = aoint(nu,sigma,mu,lambda)*I1xx(sigma,nu)   
               I2xx(nu,lambda) = aoint(nu,sigma,mu,lambda)*LPaa_ao(sigma,mu) 
#
               DO i 
#
                  Ixi(lambda,i)      = Ixx(mu,lambda)*ca(mu,i) 
                  I1xi(lambda,i)     = I2xx(nu,lambda)*ca(nu,i) 
                  Ixi(lambda,i)     -= I1xi(lambda,i) 
#
                  LYxi(lambda,i) += Ixi(lambda,i)   
#
               ENDDO i 
#
            ENDDO nu
#
            deallocate xb(sigma,mu,lambda,*)
#
      ENDPARDO mu, lambda, sigma
      execute server_barrier

      DO mu 
      DO i 
         txi(mu,i)      = LLXi(mu,i) 
         PUT Lxi(mu,i) += txi(mu,i) 
      ENDDO i 
      ENDDO mu 

      DO mu 
      DO i 
         txi(mu,i)      = LYXi(mu,i) 
         PUT Yxi(mu,i) += txi(mu,i) 
      ENDDO i 
      ENDDO mu 
      execute sip_barrier  
#
      PARDO mu, nu, i, j
            REQUEST                    Vxixj(mu,i,nu,j) i
            REQUEST                    Vxixj(mu,j,nu,i) i
            Txixj(mu,i,nu,j)         = Vxixj(mu,i,nu,j)
            Txixj(mu,i,nu,j)        *= 2.0
            T1xixj(mu,i,nu,j)        = Vxixj(mu,j,nu,i)
            Txixj(mu,i,nu,j)        -= T1xixj(mu,i,nu,j)
            PREPARE Vxixi(mu,i,nu,j) = Txixj(mu,i,nu,j)
      ENDPARDO mu, nu, i, j
#
      PARDO a, lambda, i 
#
            GET                Yxi(lambda,i) 
            Tai(a,i)         = ca(lambda,a)*Yxi(lambda,i)  
            Tai(a,i)        *= -1.0  
            LLai_aa(a,i) += tai(a,i)
#
      ENDPARDO a, lambda, i 
#
#     Perform final transformation to get contribution to Lai
#     -------------------------------------------------------
#
      PARDO a, i, nu
#
           GET                Lxi(nu,i)
           tai(a,i)         = Lxi(nu,i)*ca(nu,a)
           LLai_aa(a,i) += tai(a,i)
#
      ENDPARDO a, i, nu
      execute sip_barrier 
      deallocate LPaa_ao(*,*) 
      deallocate LLxi(*,*) 
      deallocate LYxi(*,*) 
      delete Lxi 
      delete Yxi    
#
#     Done direct contribution of Lai and Lbj 
#     ---------------------------------------
#
      ENDPROC LAIAO1
#     --------------
#
# --------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------
#
# Procedure DPQRSSEP computes the seperable part of the two-particle
# 'density' matrix.
#
      PROC DPQRSSEP
#     -------------
#
#          Get 1-particle pieces
#          ---------------------
#
           GET DHFa(mu,lambda)
           GET DHFa(mu,sigma)
           GET DHFa(mu,nu)
           GET DHFa(nu,sigma)
           GET DHFa(nu,lambda)
           GET DHFa(sigma,lambda)
#
           GET DHFa(mu,lambda)
           GET DHFa(mu,sigma)
           GET DHFa(mu,nu)
           GET DHFa(nu,sigma)
           GET DHFa(nu,lambda)
           GET DHFa(sigma,lambda)
#
           GET P2A_ao(mu,lambda)
           GET P2A_ao(mu,sigma)
           GET P2A_ao(mu,nu) 
           GET P2A_ao(nu,lambda)
           GET P2A_ao(nu,sigma)
           GET P2A_ao(sigma,lambda) 
#
           GET P2A_ao(mu,lambda)
           GET P2A_ao(mu,nu) 
           GET P2A_ao(mu,sigma)
           GET P2A_ao(nu,lambda)
           GET P2A_ao(nu,sigma)
           GET P2A_ao(sigma,lambda) 
#
#          HF only
#          -------
           Txx(nu,sigma)              = DHFa(nu,sigma) 
           Txx(nu,sigma)             += DHFa(nu,sigma) 
           Txx(nu,sigma)             += P2A_ao(nu,sigma) 
           Txx(nu,sigma)             += P2A_ao(nu,sigma) 
           T1xx(mu,lambda)            = DHFa(mu,lambda) 
           T1xx(mu,lambda)           += DHFa(mu,lambda) 

           Txxxx(mu,lambda,nu,sigma)  = T1xx(mu,lambda)^Txx(nu,sigma)
#
           Txx(nu,lambda)             = DHFa(nu,lambda) 
           Txx(nu,lambda)            += P2A_ao(nu,lambda) 
           T1xxxx(mu,lambda,nu,sigma) = DHFa(mu,sigma)^Txx(nu,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
           Txx(nu,lambda)             = DHFa(nu,lambda) 
           Txx(nu,lambda)            += P2A_ao(nu,lambda) 
           T1xxxx(mu,lambda,nu,sigma) = DHFa(mu,sigma)^Txx(nu,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
           Txx(sigma,lambda)          = DHFa(sigma,lambda) 
           Txx(sigma,lambda)         += P2A_ao(sigma,lambda) 
           T1xxxx(mu,lambda,nu,sigma) = DHFa(mu,nu)^Txx(sigma,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
           Txx(sigma,lambda)          = DHFa(sigma,lambda) 
           Txx(sigma,lambda)         += P2A_ao(sigma,lambda) 
           T1xxxx(mu,lambda,nu,sigma) = DHFa(mu,nu)^Txx(sigma,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
#          Correlation Only 
#          ----------------
#
           Txx(nu,sigma)              = DHFA(nu,sigma) 
           Txx(nu,sigma)             += DHFa(nu,sigma) 
           T1xxxx(mu,lambda,nu,sigma) = P2A_ao(mu,lambda)^Txx(nu,sigma)
           Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
           T1xxxx(mu,lambda,nu,sigma) = P2A_ao(mu,lambda)^Txx(nu,sigma)
           Txxxx(mu,lambda,nu,sigma) += T1xxxx(mu,lambda,nu,sigma)
#
           T1xxxx(mu,lambda,nu,sigma) = P2A_ao(mu,sigma)^DHFA(nu,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
           T1xxxx(mu,lambda,nu,sigma) = P2A_ao(mu,nu)^DHFA(sigma,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
           T1xxxx(mu,lambda,nu,sigma) = P2A_ao(mu,sigma)^DHFa(nu,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
           T1xxxx(mu,lambda,nu,sigma) = P2A_ao(mu,nu)^DHFa(sigma,lambda)
           T1xxxx(mu,lambda,nu,sigma)*= 0.5
           Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
#
           Txxxx(mu,lambda,nu,sigma) *= 0.5
#
      ENDPROC DPQRSSEP
#     ----------------
#
# -----------------------------------------------------------------------------
#
# -----------------------------------------------------------------------------
#
      PROC D2TRANS
#     ------------
#
      allocate LDhfa(*,*) 
      allocate LP2A_ao(*,*) 
      execute sip_barrier 
      DO mu 
      DO nu 
         GET              DHFa(mu,nu) 
         GET              P2A_ao(mu,nu) 
         LDhfa(mu,nu)   = DHFa(mu,nu) 
         LP2A_ao(mu,nu) = P2A_ao(mu,nu) 
      ENDDO nu 
      ENDDO mu 

      n_seg = 0.0 
      DO mu 
         n_seg += 1.0 
      ENDDO mu 
     #execute print_scalar n_seg 

      execute sip_barrier 
#
      PARDO mu, nu, lambda    
#
              WHERE mu < lambda  
                    allocate LTAxxxj(mu,lambda,nu,*)     
#
                 DO j
                    DO i
#
                       REQUEST Vxixi(mu,i,nu,j) i 
                       REQUEST Vxixi(lambda,i,nu,j) i 
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixi(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       T2xxxj(mu,lambda,nu,j)    = Vxixi(lambda,i,nu,j)*ca(mu,i)
#
                       LTAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       LTAxxxj(mu,lambda,nu,j)   += T2xxxj(mu,lambda,nu,j) # - 
#
                    ENDDO i
                 ENDDO j

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
            DO sigma 
              IF nu < sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
                    allocate LTBxxxj(mu,lambda,sigma,*)  
#
                 DO j
                    DO i
#
                       REQUEST Vxixi(mu,i,sigma,j) i 
                       REQUEST Vxixi(lambda,i,sigma,j) i 
#
                       T3xxxj(mu,lambda,sigma,j) = Vxixi(mu,i,sigma,j)*La(i,lambda) # ca(lambda,i)
                       T4xxxj(mu,lambda,sigma,j) = Vxixi(lambda,i,sigma,j)*ca(mu,i)
# 
                       LTBxxxj(mu,lambda,sigma,j)+= T4xxxj(mu,lambda,sigma,j)
                       LTBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # - 
#
                    ENDDO i
                 ENDDO j
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO j
#
                    Txxjx(mu,lambda,j,sigma)   = LTBxxxj(mu,lambda,sigma,j)  
                    Txxxx(mu,lambda,nu,sigma)  = Txxjx(mu,lambda,j,sigma)*La(j,nu) # ca(nu,j)
                   #Txxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    T1xxxx(mu,lambda,nu,sigma)  = LTAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                   #T1xxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += T1xxxx(mu,lambda,nu,sigma)
#
                 ENDDO j
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T1xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T3xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^LDHFA(nu,sigma)
                 T3xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T3xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)
#
                    deallocate LTBxxxj(mu,lambda,sigma,*)  

                endif # ml <= ns 
#
              ENDIF # nu < sigma   
            ENDDO sigma 
#
                    deallocate LTAxxxj(mu,lambda,nu,*)     
#
      ENDPARDO mu, nu, lambda    
#
      PARDO lambda, sigma, mu     
            WHERE mu == lambda  
#
                 allocate LTBxxxj(mu,lambda,sigma,*)  
#
                 DO j
                    DO i

                       REQUEST                     Vxixi(mu,i,sigma,j) i  

                       T3xxxj(mu,lambda,sigma,j) = Vxixi(mu,i,sigma,j)*La(i,lambda) # ca(lambda,i)
                       LTBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # - 
#
                    ENDDO i
                 ENDDO j

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
         DO nu 
            IF nu < sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
                 allocate LTAxxxj(mu,lambda,nu,*)     
#
                 DO j
                    DO i

                       REQUEST                     Vxixi(mu,i,nu,j)    i  

                       T1xxxj(mu,lambda,nu,j)    = Vxixi(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       LTAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
#
                    ENDDO i
                 ENDDO j
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO j
                    Txxjx(mu,lambda,j,sigma)   = LTBxxxj(mu,lambda,sigma,j)  
                    Txxxx(mu,lambda,nu,sigma)  = Txxjx(mu,lambda,j,sigma)*La(j,nu) # ca(nu,j)
                   #Txxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    T1xxxx(mu,lambda,nu,sigma)  = LTAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                   #T1xxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += T1xxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T1xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T3xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^LDHFa(nu,sigma)
                 T3xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T3xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)
#
                 deallocate LTAxxxj(mu,lambda,nu,*)     

                endif # ml <= ns 
#
            ENDIF # nu < sigma   
         ENDDO nu 
#
                    deallocate LTBxxxj(mu,lambda,sigma,*)  
#
      ENDPARDO lambda, sigma, mu     
#
      PARDO mu, lambda, nu     
            WHERE mu < lambda  
#
                    allocate LTAxxxj(mu,lambda,nu,*)     
#
                 DO j
                    DO i

                       REQUEST                     Vxixi(lambda,i,nu,j) j 
                       REQUEST                     Vxixi(mu,i,nu,j) j 

                       T1xxxj(mu,lambda,nu,j)    = Vxixi(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       T2xxxj(mu,lambda,nu,j)    = Vxixi(lambda,i,nu,j)*ca(mu,i)
#
                       LTAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       LTAxxxj(mu,lambda,nu,j)   += T2xxxj(mu,lambda,nu,j) # - 
#
                    ENDDO i
                 ENDDO j

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
             DO sigma 
                IF nu == sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO j
                    Txxxx(mu,lambda,nu,sigma)  = LTAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                   #Txxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T1xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T3xx(nu,sigma)             = LDHFA(nu,sigma) 
                 T3xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^T3xx(nu,sigma)
                 T3xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T3xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)

                endif # ml <= ns 
#
                ENDIF # nu == sigma   
             ENDDO sigma 
#
                    deallocate LTAxxxj(mu,lambda,nu,*)     
#
      ENDPARDO mu, lambda, nu     
#
      PARDO lambda, mu, nu 
            WHERE mu == lambda  
#
                 allocate LTAxxxi(mu,lambda,nu,*) 
#
                 DO i1  
                    DO i 
                       REQUEST                     Vxixi(mu,i,nu,i1) i 
                       T1xxxi(mu,lambda,nu,i1)   = Vxixi(mu,i,nu,i1)*La(i,lambda) # ca(lambda,i)  
                       LTAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                    ENDDO i 
                 ENDDO i1

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
         DO sigma    
#
            IF nu == sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO i1  
                    Txxxx(mu,lambda,nu,sigma) = LTAxxxi(mu,lambda,nu,i1)*La(i1,sigma) # ca(sigma,i1) 
                   #Txxxx(mu,lambda,nu,sigma)*= 2.0  
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T3xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T3xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^LDHFa(nu,sigma)
                 T4xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T6xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)

                endif # ml <= ns 
#
            ENDIF # nu == sigma   
#
         ENDDO sigma    
#
                 deallocate LTAxxxi(mu,lambda,nu,*) 
#
      ENDPARDO lambda, mu, nu 
      execute sip_barrier 
#
      ENDPROC D2TRANS
#     ---------------
#
# -----------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------------------
#
         PROC UPDATE_PAI
#        ---------------
#
         PARDO a, i
#
               GET                        Painew_aa(a,i)
               GET                        Paiold_aa(a,i)
               Tai(a,i)                 = Painew_aa(a,i)
               execute energy_denominator Tai(a,i)
               Tai(a,i)                -= Paiold_aa(a,i)
#
               if kiter == 1
                  PUT e1ai(a,i) = tai(a,i)
               endif
#
               if kiter == 2
                  PUT e2ai(a,i) = tai(a,i)
               endif
#
               if kiter == 3
                  PUT e3ai(a,i) = tai(a,i)
               endif
#
               if kiter == 4
                  PUT e4ai(a,i) = tai(a,i)
               endif
#
               if kiter >= 5
                  PUT e5ai(a,i) = tai(a,i)
               endif
#
         ENDPARDO a, i
#
         ENDPROC UPDATE_PAI
#        ------------------
#
# ----------------------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------------------
#
      PROC MOVE_PAI
#     -------------
#
      PARDO a, i
#
            GET        Paiold_aa(a,i)
            tai(a,i) = Paiold_aa(a,i)
#
            if kiter == 1
               PUT d1ai(a,i) = tai(a,i)
            endif
#
            if kiter == 2
               PUT d2ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 3
               PUT d3ai(a,i) = Tai(a,i)
            endif
#
            if kiter == 4
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
            if kiter >= 5
               PUT d4ai(a,i) = Tai(a,i)
            endif
#
      ENDPARDO a, i
#
      ENDPROC MOVE_PAI
#     ----------------
#
# ----------------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC ZERO_DSCALAR
#    -----------------
#
#    The scalars used (overlap of error arrays and coeffients) in the DIIS
#    expansion are zero'd out.
#
#      Zero out scalars.
#      -----------------
#
       b11 = 0.0
       b12 = 0.0
       b13 = 0.0
       b14 = 0.0
       b15 = 0.0
       b16 = 0.0
       b17 = 0.0
       b18 = 0.0
       b19 = 0.0
       b110 = 0.0
#
       b22 = 0.0
       b23 = 0.0
       b24 = 0.0
       b25 = 0.0
       b26 = 0.0
       b27 = 0.0
       b28 = 0.0
       b29 = 0.0
       b210 = 0.0
#
       b33 = 0.0
       b34 = 0.0
       b35 = 0.0
       b36 = 0.0
       b37 = 0.0
       b38 = 0.0
       b39 = 0.0
       b310 = 0.0
#
       b44 = 0.0
       b45 = 0.0
       b46 = 0.0
       b47 = 0.0
       b48 = 0.0
       b49 = 0.0
       b410 = 0.0
#
       b55 = 0.0
       b56 = 0.0
       b57 = 0.0
       b58 = 0.0
       b59 = 0.0
       b510 = 0.0
#
       b66 = 0.0
       b67 = 0.0
       b68 = 0.0
       b69 = 0.0
       b610 = 0.0
#
       b77 = 0.0
       b78 = 0.0
       b79 = 0.0
       b710 = 0.0
#
       b88 = 0.0
       b89 = 0.0
       b810 = 0.0
#
       b99 = 0.0
       b910 = 0.0
#
       b1010 = 0.0
#
       Tb11 = 0.0
       Tb12 = 0.0
       Tb13 = 0.0
       Tb14 = 0.0
       Tb15 = 0.0
       Tb16 = 0.0
       Tb17 = 0.0
       Tb18 = 0.0
       Tb19 = 0.0
       Tb110 = 0.0
#
       Tb22 = 0.0
       Tb23 = 0.0
       Tb24 = 0.0
       Tb25 = 0.0
       Tb26 = 0.0
       Tb27 = 0.0
       Tb28 = 0.0
       Tb29 = 0.0
       Tb210 = 0.0
#
       Tb33 = 0.0
       Tb34 = 0.0
       Tb35 = 0.0
       Tb36 = 0.0
       Tb37 = 0.0
       Tb38 = 0.0
       Tb39 = 0.0
       Tb310 = 0.0
#
       Tb44 = 0.0
       Tb45 = 0.0
       Tb46 = 0.0
       Tb47 = 0.0
       Tb48 = 0.0
       Tb49 = 0.0
       Tb410 = 0.0
#
       Tb55 = 0.0
       Tb56 = 0.0
       Tb57 = 0.0
       Tb58 = 0.0
       Tb59 = 0.0
       Tb510 = 0.0
#
       Tb66 = 0.0
       Tb67 = 0.0
       Tb68 = 0.0
       Tb69 = 0.0
       Tb610 = 0.0
#
       Tb77 = 0.0
       Tb78 = 0.0
       Tb79 = 0.0
       Tb710 = 0.0
#
       Tb88 = 0.0
       Tb89 = 0.0
       Tb810 = 0.0
#
       Tb99 = 0.0
       Tb910 = 0.0
#
       Tb1010 = 0.0
#
       c1 = 0.0
       c2 = 0.0
       c3 = 0.0
       c4 = 0.0
       c5 = 0.0
       c6 = 0.0
       c7 = 0.0
       c8 = 0.0
       c9 = 0.0
       c10 = 0.0
#
       execute sip_barrier
#
     ENDPROC ZERO_DSCALAR
#    --------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC SETUP_DIIS
#    ---------------
#
#    Put the matrix elements of B into the sip 'B' matrix.
#
       execute diis_setup Tb11
       execute diis_setup Tb12
       execute diis_setup Tb13
       execute diis_setup Tb14
       execute diis_setup Tb15
       execute diis_setup Tb16
       execute diis_setup Tb17
       execute diis_setup Tb18
       execute diis_setup Tb19
       execute diis_setup Tb110

       execute diis_setup Tb22
       execute diis_setup Tb23
       execute diis_setup Tb24
       execute diis_setup Tb25
       execute diis_setup Tb26
       execute diis_setup Tb27
       execute diis_setup Tb28
       execute diis_setup Tb29
       execute diis_setup Tb210

       execute diis_setup Tb33
       execute diis_setup Tb34
       execute diis_setup Tb35
       execute diis_setup Tb36
       execute diis_setup Tb37
       execute diis_setup Tb38
       execute diis_setup Tb39
       execute diis_setup Tb310

       execute diis_setup Tb44
       execute diis_setup Tb45
       execute diis_setup Tb46
       execute diis_setup Tb47
       execute diis_setup Tb48
       execute diis_setup Tb49
       execute diis_setup Tb410

       execute diis_setup Tb55
       execute diis_setup Tb56
       execute diis_setup Tb57
       execute diis_setup Tb58
       execute diis_setup Tb59
       execute diis_setup Tb510

       execute diis_setup Tb66
       execute diis_setup Tb67
       execute diis_setup Tb68
       execute diis_setup Tb69
       execute diis_setup Tb610

       execute diis_setup Tb77
       execute diis_setup Tb78
       execute diis_setup Tb79
       execute diis_setup Tb710

       execute diis_setup Tb88
       execute diis_setup Tb89
       execute diis_setup Tb810

       execute diis_setup Tb99
       execute diis_setup Tb910

       execute diis_setup Tb1010
#
       execute sip_barrier
#
     ENDPROC SETUP_DIIS
#    ------------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS1
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to Dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-1 amplitudes
           GET e2ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,2
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
#             b1x x=2,2
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb22 += b22
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed, the array is filled out
#    in the setup_diis.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------
#
     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     execute print_scalar c1
     execute print_scalar c2
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form Pai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 2 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-2 amplitudes
           GET D1ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-1 amplitudes
           GET e2ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           PUT Paiold_aa(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS1
#    -------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS2
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute server_barrier
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-2 amplitudes
           GET e2ai(a,i)    # kiter-1 amplitudes
           GET e3ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,3
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
#             b1x x=2,3
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
#             b1x x=3,3
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb33 += b33
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
    #execute print_scalar c1
    #execute print_scalar c2
    #execute print_scalar c3
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-3 amplitudes
           GET D1ai(a,i)     # kiter-2 amplitudes
           GET D2ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-2 amplitudes
           GET e2ai(a,i)     # kiter-1 amplitudes
           GET e3ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           PUT Paiold_aa(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS2
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS3
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-3 amplitudes
           GET e2ai(a,i)    # kiter-2 amplitudes
           GET e3ai(a,i)    # kiter-1 amplitudes
           GET e4ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,4
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
#             b1x x=2,4
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
#             b1x x=3,4
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
#             b1x x=4,4
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb44 += b44
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
    #execute print_scalar c1
    #execute print_scalar c2
    #execute print_scalar c3
    #execute print_scalar c4
     execute server_barrier
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-4 amplitudes
           GET D1ai(a,i)     # kiter-3 amplitudes
           GET D2ai(a,i)     # kiter-2 amplitudes
           GET D3ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-3 amplitudes
           GET e2ai(a,i)     # kiter-2 amplitudes
           GET e3ai(a,i)     # kiter-1 amplitudes
           GET e4ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           PUT Paiold_aa(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS3
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC DIIS4
#    ----------
#
#    Zero out scalars.
#    -----------------
#
     CALL ZERO_DSCALAR
#
     execute sip_barrier
#
#    Determine the 'B-matrix'.
#    -------------------------
#
#    Compute contributions due to dai amplitudes.
#    --------------------------------------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 4 previous iterations.
#          ----------------------------------------------------------
#
           GET e1ai(a,i)    # kiter-4 amplitudes
           GET e2ai(a,i)    # kiter-3 amplitudes
           GET e3ai(a,i)    # kiter-2 amplitudes
           GET e4ai(a,i)    # kiter-1 amplitudes
           GET e5ai(a,i)    # kiter-0 amplitudes
#
#          Compute contributions to the 'B-matrix'.
#          ----------------------------------------
#
#             b1x x=1,5
#             ---------
#
              etemp = e1ai(a,i)*e1ai(a,i)
              b11  += etemp
#
              etemp = e1ai(a,i)*e2ai(a,i)
              b12  += etemp
#
              etemp = e1ai(a,i)*e3ai(a,i)
              b13  += etemp
#
              etemp = e1ai(a,i)*e4ai(a,i)
              b14  += etemp
#
              etemp = e1ai(a,i)*e5ai(a,i)
              b15  += etemp
#
#             b1x x=2,5
#             ---------
#
              etemp = e2ai(a,i)*e2ai(a,i)
              b22  += etemp
#
              etemp = e2ai(a,i)*e3ai(a,i)
              b23  += etemp
#
              etemp = e2ai(a,i)*e4ai(a,i)
              b24  += etemp
#
              etemp = e2ai(a,i)*e5ai(a,i)
              b25  += etemp
#
#             b1x x=3,5
#             ---------
#
              etemp = e3ai(a,i)*e3ai(a,i)
              b33  += etemp
#
              etemp = e3ai(a,i)*e4ai(a,i)
              b34  += etemp
#
              etemp = e3ai(a,i)*e5ai(a,i)
              b35  += etemp
#
#             b1x x=4,5
#             ---------
#
              etemp = e4ai(a,i)*e4ai(a,i)
              b44  += etemp
#
              etemp = e4ai(a,i)*e5ai(a,i)
              b45  += etemp
#
#             b1x x=5,5
#             ---------
#
              etemp = e5ai(a,i)*e5ai(a,i)
              b55  += etemp
#
     ENDPARDO a, i
#
     execute sip_barrier
#
#    Collectively sum B-matrix elements.
#    -----------------------------------
#
     collective Tb11 += b11
     collective Tb12 += b12
     collective Tb13 += b13
     collective Tb14 += b14
     collective Tb15 += b15
     collective Tb22 += b22
     collective Tb23 += b23
     collective Tb24 += b24
     collective Tb25 += b25
     collective Tb33 += b33
     collective Tb34 += b34
     collective Tb35 += b35
     collective Tb44 += b44
     collective Tb45 += b45
     collective Tb55 += b55
     execute server_barrier
#
#    Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#    --------------------------------------------------------------------------------------
#
#    Put the elements of the 'B-matrix', which have been computed as scalars into the
#    R-matrix.
#    --------------------------------------------------------------------------------

     CALL SETUP_DIIS
#
     execute compute_diis # --> New instruction
#
     c1 = Tb11
     c2 = Tb22
     c3 = Tb33
     c4 = Tb44
     c5 = Tb55
    #execute print_scalar c1
    #execute print_scalar c2
    #execute print_scalar c3
    #execute print_scalar c4
    #execute print_scalar c5
     execute sip_barrier
#
#    Done computing the c-vector.
#    ----------------------------
#
#    Form the updated amplitudes using the c-vector.
#    -----------------------#
#    Form Dai_old.
#    -------------
#
     PARDO a, i
#
#          REQUEST/GET amplitude data from all 3 previous iterations.
#          ----------------------------------------------------------
#
           GET D0ai(a,i)     # kiter-5 amplitudes
           GET D1ai(a,i)     # kiter-4 amplitudes
           GET D2ai(a,i)     # kiter-3 amplitudes
           GET D3ai(a,i)     # kiter-2 amplitudes
           GET D4ai(a,i)     # kiter-1 amplitudes
#
           GET e1ai(a,i)     # kiter-4 amplitudes
           GET e2ai(a,i)     # kiter-3 amplitudes
           GET e3ai(a,i)     # kiter-2 amplitudes
           GET e4ai(a,i)     # kiter-1 amplitudes
           GET e5ai(a,i)     # kiter-0 amplitudes
#
#          Compute contributions to updated amplitudes --> tai_old.
#          --------------------------------------------------------
#
           t1ai(a,i)     = d0ai(a,i)
           t1ai(a,i)    += e1ai(a,i)
           t1ai(a,i)    *= c1
           tai(a,i)      = t1ai(a,i)
#
           t1ai(a,i)     = d1ai(a,i)
           t1ai(a,i)    += e2ai(a,i)
           t1ai(a,i)    *= c2
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d2ai(a,i)
           t1ai(a,i)    += e3ai(a,i)
           t1ai(a,i)    *= c3
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d3ai(a,i)
           t1ai(a,i)    += e4ai(a,i)
           t1ai(a,i)    *= c4
           tai(a,i)     += t1ai(a,i)
#
           t1ai(a,i)     = d4ai(a,i)
           t1ai(a,i)    += e5ai(a,i)
           t1ai(a,i)    *= c5
           tai(a,i)     += t1ai(a,i)
#
           PUT Paiold_aa(a,i) = tai(a,i)
#
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC DIIS4
#    -------------
#
# ---------------------------------------------------------------------------------
#
# ---------------------------------------------------------------------------------
#
     PROC MOVE4
#    ----------
#
#    0 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET d1ai(a,i)
           PUT d0ai(a,i) = d1ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier 
#
#    2 --> 1
#    ---------------------------------------------------
#
     PARDO a, i
           GET e2ai(a,i)
           PUT e1ai(a,i) = e2ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d2ai(a,i)
           PUT d1ai(a,i) = d2ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    3 --> 2
#    ---------------------------------------------------
#
     PARDO a, i
           GET e3ai(a,i)
           PUT e2ai(a,i) = e3ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d3ai(a,i)
           PUT d2ai(a,i) = d3ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    4 --> 3
#    ---------------------------------------------------
#
     PARDO a, i
           GET e4ai(a,i)
           PUT e3ai(a,i) = e4ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET d4ai(a,i)
           PUT d3ai(a,i) = d4ai(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
#    5 --> 4
#    ---------------------------------------------------
#
     PARDO a, i
           GET e5ai(a,i)
           PUT e4ai(a,i) = e5ai(a,i)
     ENDPARDO a, i
#
     PARDO a, i
           GET Paiold_aa(a,i)
           PUT d4ai(a,i) = Paiold_aa(a,i)
     ENDPARDO a, i
#
     execute sip_barrier
#
     ENDPROC MOVE4
#    -------------
#
# ---------------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC ENERGY  
#
#    ------------------------------------------------------------------------
#
     esumaa = 0.0 
     ecorraa = 0.0 
     execute sip_barrier 
#
     PARDO a, a1, i, i1
 
           request                    Vpiqj(a,i1,a1,i) i
           request                    Vpiqj(a1,i1,a,i) i
           Taiai(a,i1,a1,i)         = Vpiqj(a,i1,a1,i)
           T1aiai(a,i1,a1,i)        = Vpiqj(a1,i1,a,i)
           Taiai(a,i1,a1,i)        *= 2.0
           Taiai(a,i1,a1,i)        -= T1aiai(a,i1,a1,i)
           execute energy_denominator Taiai
           etemp                    = Taiai(a,i1,a1,i)*Vpiqj(a,i1,a1,i)
           esumaa                  += etemp
 
     ENDPARDO a, a1, i, i1
#
     execute server_barrier
     execute sip_barrier
     collective ecorraa += esumaa
     execute sip_barrier
#
      totenerg  = ecorraa  
      totenerg += scfeneg
      execute print_scalar totenerg
#
#    ------------------------------------------------------------------------
#
     ENDPROC ENERGY  
#
#    ------------------------------------------------------------------------
#
#
############################################################################## 
#
#                         START OF MAIN PROGRAM 
#
############################################################################## 
#
# Transform integrals
# ------------------- 
#
      execute sip_barrier 
      allocate La(*,*) 
      CALL TRAN_UHF 
      DO p 
      DO mu 
         La(p,mu) = ca(mu,p) 
      ENDDO mu 
      ENDDO p 
#
# Create one-particle arrays 
# -------------------------- 
#
      CREATE Pij_aa 
      CREATE Pab_aa 
      CREATE Lai_aa 
      CREATE Painew_aa  
      CREATE Paiold_aa 
      CREATE Wab_aa  
      CREATE Wij_aa  
      CREATE Wai_aa  
      CREATE P2_ao   
      CREATE P2A_ao   
      CREATE W2_ao   
      CREATE Paa_ao   
      CREATE WHFa     
      CREATE DHFa     
      CREATE DHF     
      execute sip_barrier 
      execute server_barrier 
      CALL ENERGY 
#
#     Compute the HF contribution to the weighted density matrix 
#     ---------------------------------------------------------- 
#
      call WHFDENS
#
#     Create the second-order 'amplitudes' 
#     ------------------------------------ 
#
      PARDO a, i, a1, i1 
            REQUEST                     VSpipi(a,i,a1,i1) i
            Tpipi(a,i,a1,i1)          = VSpipi(a,i,a1,i1)
            execute energy_denominator  Tpipi(a,i,a1,i1)
            PREPARE ASpipi(a,i,a1,i1) = Tpipi(a,i,a1,i1) 
      ENDPARDO a, i, a1, i1 
#
      PARDO a, i, a1, i1 
            REQUEST                    Vpiqj(a,i,a1,i1) i
            Tpipi(a,i,a1,i1)         = Vpiqj(a,i,a1,i1)
            execute energy_denominator Tpipi(a,i,a1,i1)
            PREPARE Apiqj(a,i,a1,i1) = Tpipi(a,i,a1,i1) 
      ENDPARDO a, i, a1, i1 
#
      execute server_barrier 
#
# First compute the occupied-occupied block of the density correction
# ------------------------------------------------------------------- 
#
#     AAAA/AAAA piece 
#     --------------- 
      PARDO i, a, a1, i2 
#
            REQUEST            ASpipi(a,i,a1,i2) i  
            Tpipi(a,i,a1,i2) = ASpipi(a,i,a1,i2) 
#
            DO i1 
#
               REQUEST             ASpipi(a,i1,a1,i2) i1  
               Tii(i,i1)         = Tpipi(a,i,a1,i2)*ASpipi(a,i1,a1,i2) 
               Tii(i,i1)        *= -0.5 
               PUT Pij_aa(i,i1) += Tii(i,i1) 
#
            ENDDO i1 
#
      ENDPARDO i, a, a1, i2 
#
#     AABB/AABB piece 
#     --------------- 
      PARDO i, a, b, j 
#
            REQUEST          Apiqj(a,i,b,j) i  
            Tpiqj(a,i,b,j) = Apiqj(a,i,b,j) 
#
            DO i1 
#
               REQUEST             Apiqj(a,i1,b,j) j  
               Tii(i,i1)         = Tpiqj(a,i,b,j)*Apiqj(a,i1,b,j) 
               Tii(i,i1)        *= -1.0 
               PUT Pij_aa(i,i1) += Tii(i,i1) 
#
            ENDDO i1 
#
      ENDPARDO i, a, b, j 
#
# Done compute the occupied-occupied block of the density correction
# ------------------------------------------------------------------- 
#
# Compute the virtual-virtual block of the density correction
# ------------------------------------------------------------------- 
#
#     AAAA/AAAA piece 
#     --------------- 
#
      PARDO a, a2, i, i1  
#
            REQUEST            ASpipi(a,i,a2,i1) i  
            Tpipi(a,i,a2,i1) = ASpipi(a,i,a2,i1) 
#
            DO a1 
#
               REQUEST             ASpipi(a1,i,a2,i1) i  
               Taa(a,a1)         = Tpipi(a,i,a2,i1)*ASpipi(a1,i,a2,i1)
               Taa(a,a1)        *= 0.5 
               PUT Pab_aa(a,a1) += Taa(a,a1) 
#
            ENDDO a1 
#
      ENDPARDO a, a2, i, i1  
#
#     AABB/AABB piece 
#     --------------- 
#
      PARDO a, b, i, j  
#
            REQUEST          Apiqj(a,i,b,j) i  
            Tpiqj(a,i,b,j) = Apiqj(a,i,b,j) 
#
            DO a1  
#
               REQUEST             Apiqj(a1,i,b,j) i  
               Taa(a,a1)         = Tpiqj(a,i,b,j)*Apiqj(a1,i,b,j)
               PUT Pab_aa(a,a1) += Taa(a,a1) 
#
            ENDDO a1  
#
      ENDPARDO a, b, i, j  
#
# End compute the virtual-virtual block of the density correction
# ------------------------------------------------------------------- 
      execute sip_barrier 
      
#
# Backtransform Pab to be used in the 'direct' contribution to Lai 
# ---------------------------------------------------------------- 
#
#     Transform Pab_aa 
#     ---------------- 
      PARDO a, a1  
#
            GET Pab_aa(a,a1)  
#
            DO mu 
#
               Ixa(mu,a1) = Pab_aa(a,a1)*ca(mu,a) 
#
               DO nu 
#
                  Ixx(mu,nu)         = Ixa(mu,a1)*ca(nu,a1) 
                  PUT Paa_ao(mu,nu) += Ixx(mu,nu) 
#
               ENDDO nu 
#
            ENDDO mu 
#
      ENDPARDO a, a1  
#
      execute sip_barrier 
      
#
# Compute the right-hand side of Eq. 10 --> Lai_aa  
# ------------------------------------------------  
#
#     Compte the 'direct' contributions 
#     --------------------------------- 
      allocate LLai_aa(*,*) 
      CALL LAIAO1
#
#     Second-term 
#     ----------- 
#
      PARDO a, a1, i1, i2 
#
            REQUEST ASpipi(a,i1,a1,i2) i1  
#
            DO i 
# 
               REQUEST            VSpipi(a1,i2,i,i1) i  
               Tai(a,i)         = ASpipi(a,i1,a1,i2)*VSpipi(a1,i2,i,i1) 
               Tai(a,i)        *= 0.5 
               LLai_aa(a,i) += Tai(a,i) 
#
            ENDDO i 
#
      ENDPARDO a, a1, i1, i2 
#
      PARDO a, b, i1, j 
#
            REQUEST Apiqj(a,i1,b,j) j  
#
            DO i 
# 
               REQUEST            Vpiqj(i,i1,b,j) i  
               Tai(a,i)         = Apiqj(a,i1,b,j)*Vpiqj(i,i1,b,j) 
               LLai_aa(a,i) += Tai(a,i) 
#
            ENDDO i 
#
      ENDPARDO a, b, i1, j 
#
#     Fourth-term 
#     ----------- 
#
      PARDO i, i1, i2, a 
#
            REQUEST            VSpipi(a,i,i1,i2) i  
            GET                Pij_aa(i1,i2) 
# 
            Tai(a,i)         = VSpipi(a,i,i1,i2)*Pij_aa(i1,i2)  
            Tai(a,i)        *= -1.0  
            LLai_aa(a,i) += Tai(a,i) 
#
      ENDPARDO i, i1, i2, a 
#
      PARDO i, j, j1, a 
#
            REQUEST            Vpiqj(a,i,j,j1) i  
            GET                Pij_aa(j,j1) 
# 
            Tai(a,i)         = Vpiqj(a,i,j,j1)*Pij_aa(j,j1)  
            Tai(a,i)        *= -1.0  
            LLai_aa(a,i) += Tai(a,i) 
#
      ENDPARDO i, j, j1, a 
#
# Done compute the right-hand side of Eq. 10 --> Lai_aa  
# -----------------------------------------------------  
#
      execute sip_barrier 
      DO a 
      DO i 
         tai(a,i)         = LLai_aa(a,i) 
         PUT Lai_aa(a,i) += tai(a,i) 
      ENDDO i 
      ENDDO a 
      execute server_barrier 
      deallocate LLai_aa(*,*) 
#
# Compute the occupied-virtual block of correlated density
# -------------------------------------------------------- 
#
# Create error arrays used in the DIIS procedure. 
# ----------------------------------------------- 
#
      CREATE D0ai
      CREATE D1ai
      CREATE D2ai
      CREATE D3ai
      CREATE D4ai
#
      CREATE e1ai
      CREATE e2ai
      CREATE e3ai
      CREATE e4ai
      CREATE e5ai
      
#
# Get initial guess 
# ----------------- 
#
      eold = 0.0 
      esum = 0.0 
      ecrit = 0.0000000001 
      PARDO a, i 
#
            GET                        Lai_aa(a,i) 
            Tai(a,i)                 = Lai_aa(a,i)
            Tai(a,i)                *= -1.0  
            execute energy_denominator Tai(a,i) 
            etemp                    = Tai(a,i)*Tai(a,i) 
            esum                    += etemp 
            PUT Paiold_aa(a,i)      = Tai(a,i) 
#
      ENDPARDO a, i 
      
#
#     Form a couple of 'intermediate' quantities. 
#     ------------------------------------------- 
#
      PARDO a, a1, i, i1 
#
            REQUEST                  VSpipi(a,i,a1,i1) i  
            REQUEST                  Vaajj(a,a1,i1,i)  i  
            REQUEST                  Viabj(i,a,a1,i1)  i  
            REQUEST                  Vpiqj(a,i,a1,i1) i1 
           #REQUEST                  Viabj(i,a,a1,i1) i1 
#
            Tpipi(a,i,a1,i1)         = VSpipi(a,i,a1,i1) 
            T1pipi(a,i,a1,i1)        = Vaajj(a,a1,i1,i)  
            T2pipi(a,i,a1,i1)        = Viabj(i,a,a1,i1) 
            T2pipi(a,i,a1,i1)       *= 2.0  
#
            Tpipi(a,i,a1,i1)        -= T1pipi(a,i,a1,i1)  
            Tpipi(a,i,a1,i1)        += T2pipi(a,i,a1,i1)  
#
            Tpiqj(a,i,a1,i1)         = Vpiqj(a,i,a1,i1)
           #T2piqj(a,i,a1,i1)        = Viabj(i,a,a1,i1)
            Tpipi(a,i,a1,i1)        += Tpiqj(a,i,a1,i1)
           #Tpipi(a,i,a1,i1)        += T2piqj(a,i,a1,i1)
#
            PREPARE Apiqj(a,i,a1,i1) = Tpipi(a,i,a1,i1) 
#
      ENDPARDO a, a1, i, i1  
      
#
      execute sip_barrier 
      execute server_barrier 
      collective eold += esum  
      execute print_scalar eold 
      
#
# Done initial guess 
# ------------------ 
#
#     Start iterations 
#     ---------------- 
#
      DO kiter 
#
         PARDO a, i 
#
               GET                        Lai_aa(a,i) 
               Tai(a,i)                 = Lai_aa(a,i)
               Tai(a,i)                *= -1.0  
               PUT Painew_aa(a,i)      += Tai(a,i) 
#
         ENDPARDO a, i 
#
         PARDO a, a1, i, i1 
#
              #REQUEST                    ASpipi(a,i,a1,i1) i  
               REQUEST                    Apiqj(a,i,a1,i1) i1 
               GET                        Paiold_aa(a1,i1) 
#
              #taiai(a,i,a1,i1)         = ASpipi(a,i,a1,i1) 
              #taiai(a,i,a1,i1)        += Apiqj(a,i,a1,i1) 
#
               Tai(a,i)                 = Apiqj(a,i,a1,i1)*Paiold_aa(a1,i1)
               PUT Painew_aa(a,i)      += Tai(a,i)
#
         ENDPARDO a, a1, i, i1  
#
         execute sip_barrier 
#
#        Update error vector for diis
#        ----------------------------
#
         CALL UPDATE_PAI 
#
         execute sip_barrier 
#
         esum = 0.0
         enew = 0.0
         PARDO a, i
#
               GET                        Painew_aa(a,i)
               Tai(a,i)                 = Painew_aa(a,i) 
               execute energy_denominator Tai(a,i) 
               PUT                        Paiold_aa(a,i) = Tai(a,i)
               etemp                    = Painew_aa(a,i)*Painew_aa(a,i)
               esum                    += etemp
               Tai(a,i)                 = 0.0
               PUT Painew_aa(a,i)       = Tai(a,i)
#
         ENDPARDO a, i
#
         execute sip_barrier 
         collective enew += esum 
#
#        Check on convergence
#        --------------------
#
         IF enew < eold
            ediff = eold - enew
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
         IF enew > eold
            ediff = enew - eold
            IF ediff < ecrit
               exit # kiter
            ENDIF
         ENDIF
#
#        Reset eold --> enew
#        -------------------
#
         eold = enew 
#
         if kiter == 2
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS1
#
         endif # kiter == 2
#
         if kiter == 3
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS2
#
         endif # kiter == 3
#
         if kiter == 4
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS3
#
         endif # kiter == 4
#
         if kiter >= 5
#
#           Get uptated amplitudes based on DIIS procedure.
#           -----------------------------------------------
#
            CALL DIIS4
            CALL MOVE4
#
         endif # kiter == 5
#
         CALL MOVE_PAI
#
      ENDDO kiter 
#
      execute server_barrier 
      PARDO a, i, a1, i1 
            REQUEST                     VSpipi(a,i,a1,i1) i
            Tpipi(a,i,a1,i1)          = VSpipi(a,i,a1,i1)
            execute energy_denominator  Tpipi(a,i,a1,i1)
            PREPARE ASpipi(a,i,a1,i1) = Tpipi(a,i,a1,i1) 
      ENDPARDO a, i, a1, i1 
#
      PARDO a, i, a1, i1 
            REQUEST                    Vpiqj(a,i,a1,i1) i
            Tpipi(a,i,a1,i1)         = Vpiqj(a,i,a1,i1)
            execute energy_denominator Tpipi(a,i,a1,i1)
            PREPARE Apiqj(a,i,a1,i1) = Tpipi(a,i,a1,i1) 
      ENDPARDO a, i, a1, i1 
      allocate LWij_aa(*,*) 
     #allocate LWai_aa(*,*) 
      execute server_barrier 
#
# Delete error arrays used in the DIIS procedure. 
# ----------------------------------------------- 
#
      DELETE D0ai
      DELETE D1ai
      DELETE D2ai
      DELETE D3ai
      DELETE D4ai
#
      DELETE e1ai
      DELETE e2ai
      DELETE e3ai
      DELETE e4ai
      DELETE e5ai
#
# Done compute the occupied-virtual block of correlated density
# ------------------------------------------------------------- 
#
# Compute the second-order corrections to the energy weighted
# density matrix. 
# ----------------------------------------------------------- 
#
#      Compute Wab_aa 
#      --------------  
#
       PARDO a, a1, a2  
#
             GET Pab_aa(a2,a1) 
             Taa(a,a1)         = Pab_aa(a2,a1)*Fock_a(a2,a)  
             Taa(a,a1)        *= -1.0  
             PUT Wab_aa(a,a1) += Taa(a,a1) 
#
       ENDPARDO a, a1, a2  
#
       PARDO a1, a2, i, i1 
#
             REQUEST                    ASpipi(a1,i,a2,i1) i  
            #Tpipi(a1,i,a2,i1)        = VSpipi(a1,i,a2,i1) 
            #execute energy_denominator Tpipi(a1,i,a2,i1) 
#
             DO a
#
                REQUEST             VSpipi(a,i1,a2,i) i  
                Taa(a,a1)         = VSpipi(a,i1,a2,i)*ASpipi(a1,i,a2,i1)
                Taa(a,a1)        *= 0.5  
                PUT Wab_aa(a,a1) += Taa(a,a1) 
#
             ENDDO a
#
       ENDPARDO a1, a2, i, i1 
#
       PARDO a1, b, i, j 
#
             REQUEST                    Apiqj(a1,i,b,j) i  
            #Tpiqj(a1,i,b,j)          = Vpiqj(a1,i,b,j) 
            #execute energy_denominator Tpiqj(a1,i,b,j) 
#
             DO a
#
                REQUEST             Vpiqj(a,i,b,j) i  
                Taa(a,a1)         = Vpiqj(a,i,b,j)*Apiqj(a1,i,b,j)
                Taa(a,a1)        *= -1.0   
                PUT Wab_aa(a,a1) += Taa(a,a1) 
#
             ENDDO a
#
       ENDPARDO a1, b, i, j 
#
#      Done compute Wab_aa 
#      -------------------  
#
#      Compute Wij_aa 
#      --------------  
#
#      Second-term in Eq. 12 
#      --------------------- 
       PARDO i, i1, i2  
#
             GET Pij_aa(i2,i1) 
#
             T1ii(i,i1)        = Pij_aa(i2,i1)*Fock_a(i2,i)  
             T1ii(i,i1)       *= -1.0  
             LWij_aa(i,i1) += T1ii(i,i1) 
#
       ENDPARDO i, i1, i2  
#
#      Fourth-term in Eq. 12 
#      --------------------- 
       PARDO a, a1, i1, i2 
#
             REQUEST                    ASpipi(a,i1,a1,i2) i1  
            #Tpipi(a,i1,a1,i2)        = VSpipi(a,i1,a1,i2) 
            #execute energy_denominator Tpipi(a,i1,a1,i2) 
#
             DO i 
#
                REQUEST             VSpipi(a,i2,a1,i) i  
                Tii(i,i1)         = VSpipi(a,i2,a1,i)*ASpipi(a,i1,a1,i2)
                Tii(i,i1)        *= 0.5 
                LWij_aa(i,i1) += Tii(i,i1) 
#
             ENDDO i 
#
       ENDPARDO a, a1, i1, i2 
#
       PARDO a, b, i1, j 
#
             REQUEST                    Apiqj(a,i1,b,j) i1  
            #Tpiqj(a,i1,b,j)          = Vpiqj(a,i1,b,j) 
            #execute energy_denominator Tpiqj(a,i1,b,j) 
#
             DO i 
#
                REQUEST             Vpiqj(a,i,b,j) i  
                Tii(i,i1)         = Vpiqj(a,i,b,j)*Apiqj(a,i1,b,j)
                Tii(i,i1)        *= -1.0  
                LWij_aa(i,i1) += Tii(i,i1) 
#
             ENDDO i 
#
       ENDPARDO a, b, i1, j 
#
#      Third-term in Eq. 12 
#      -------------------- 
#
#      occupied-occupied contribution 
#      ------------------------------ 
#
       PARDO i, i1, i2, i3 
#
             REQUEST             VSpipi(i,i1,i2,i3) i  
             GET                 Pij_aa(i2,i3) 
#
             Tii(i,i1)         = VSpipi(i,i1,i2,i3)*Pij_aa(i2,i3) 
             Tii(i,i1)        *= -1.0  
             LWij_aa(i,i1) += Tii(i,i1) 
#
       ENDPARDO i, i1, i2, i3 
#
       PARDO i, i1, j, j1 
#
             REQUEST             Vpiqj(i,i1,j,j1) i  
             GET                 Pij_aa(j,j1) 
#
             Tii(i,i1)         = Vpiqj(i,i1,j,j1)*Pij_aa(j,j1) 
             Tii(i,i1)        *= -1.0  
             LWij_aa(i,i1) += Tii(i,i1) 
#
       ENDPARDO i, i1, j, j1 
#
#      virtual-virtual contribution 
#      ---------------------------- 
       PARDO i, i1, a, a1 
#
             REQUEST Vaajj(a,a1,i,i1) i  
             REQUEST Viabj(i,a1,a,i1) i  
             GET Pab_aa(a,a1) 
#
             Tiiaa(i,i1,a,a1)  = Vaajj(a,a1,i,i1) 
             T1iiaa(i,i1,a,a1) = Viabj(i,a1,a,i1) 
             Tiiaa(i,i1,a,a1) -= T1iiaa(i,i1,a,a1)  
#
             Tii(i,i1)         = Tiiaa(i,i1,a,a1)*Pab_aa(a,a1) 
             Tii(i,i1)        *= -1.0  
             LWij_aa(i,i1) += Tii(i,i1) 
#
       ENDPARDO i, i1, a, a1 
#
       PARDO i, i1, b, b1 
#
             REQUEST Vaajj(b,b1,i,i1) i  
             GET Pab_aa(b,b1) 
#
             Tii(i,i1)         = Vaajj(b,b1,i,i1)*Pab_aa(b,b1) 
             Tii(i,i1)        *= -1.0  
             LWij_aa(i,i1) += Tii(i,i1) 
#
       ENDPARDO i, i1, b, b1 
#
#      virtual-occupied contribution --> Needs checked VFL  
#      ----------------------------- 
       PARDO i, i1, i2, a 
#
             REQUEST             VSpipi(i,i1,a,i2) i  
             GET                 Paiold_aa(a,i2) 
#
             Tii(i,i1)         = VSpipi(i,i1,a,i2)*Paiold_aa(a,i2)  
             Tii(i,i1)        *= -1.0  
             LWij_aa(i,i1) += Tii(i,i1) 
             T1ii(i1,i)        = Tii(i,i1)  
             LWij_aa(i1,i) += T1ii(i1,i) 
#
       ENDPARDO i, i1, i2, a 
#
       PARDO i, i1, j, b 
#
             REQUEST             Vpiqj(i,i1,b,j) i  
             GET                 Paiold_aa(b,j) 
#
             Tii(i,i1)         = Vpiqj(i,i1,b,j)*Paiold_aa(b,j)  
             Tii(i,i1)        *= -1.0  
             LWij_aa(i,i1) += Tii(i,i1) 
             T1ii(i1,i)        = Tii(i,i1)  
             LWij_aa(i1,i) += T1ii(i1,i) 
#
       ENDPARDO i, i1, j, b 
#
#      Compute Wai_aa 
#      --------------  
       PARDO a, i, i1 
#
             GET Paiold_aa(a,i1) 
             Tai(a,i)         = Paiold_aa(a,i1)*Fock_a(i1,i)  
             Tai(a,i)        *= -1.0  
             PUT Wai_aa(a,i) += Tai(a,i) 
#
       ENDPARDO a, i, i1 
#
       PARDO a, a1, i1, i2 
#
             REQUEST                    ASpipi(a,i2,a1,i1) i1  
            #Tpipi(a,i2,a1,i1)        = VSpipi(a,i2,a1,i1) 
            #execute energy_denominator Tpipi(a,i2,a1,i1) 
             tpipi(a,i1,a1,i2) = ASpipi(a,i2,a1,i1) 
#
             DO i 
#
               #REQUEST            VSpipi(a1,i2,i,i1) i 
                REQUEST            VSpipi(i,i1,a1,i2) i 
                Tai(a,i)         = Tpipi(a,i1,a1,i2)*VSpipi(i,i1,a1,i2)  
                Tai(a,i)        *= 0.5 
                PUT Wai_aa(a,i) += Tai(a,i) 
#
             ENDDO i 
#
       ENDPARDO a, a1, i1, i2 
#
       PARDO a, b, j, i2 
#
             REQUEST                    Apiqj(a,i2,b,j) j  
            #Tpiqj(a,i2,b,j)          = Vpiqj(a,i2,b,j) 
            #execute energy_denominator Tpiqj(a,i2,b,j) 
#
             DO i 
#
                REQUEST            Vpiqj(i,i2,b,j) i  
                Tai(a,i)         = Apiqj(a,i2,b,j)*Vpiqj(i,i2,b,j)  
                Tai(a,i)        *= -1.0  
                PUT Wai_aa(a,i) += Tai(a,i) 
#
             ENDDO i 
#
       ENDPARDO a, b, j, i2 
       execute sip_barrier 
       DO i 
       DO i1 
          tii(i,i1)         = LWij_aa(i,i1) 
          PUT Wij_aa(i,i1) += tii(i,i1) 
       ENDDO i1 
       ENDDO i 
#
# Done compute the second-order corrections to the energy 
# weighted density matrix. 
# ----------------------------------------------------------- 
      execute sip_barrier 
      deallocate LWij_aa(*,*) 
#     discard VSpipi 
#     discard Vpiqj 
#     discard Viabj 
#     discard Vaajj 
#
# Backtransform Ppq --> P2_ao Wpq --> W2_ao  
# -----------------------------------------  
#
#     Transform Pij_aa 
#     ---------------- 
      PARDO i, i1  
#
            GET Pij_aa(i,i1)  
            GET Wij_aa(i,i1)  
#
            DO mu 
#
               Ixi(mu,i1) = Pij_aa(i,i1)*ca(mu,i) 
               Jxi(mu,i1) = Wij_aa(i,i1)*ca(mu,i) 
#
               DO nu 
#
                  Ixx(mu,nu)         = Ixi(mu,i1)*ca(nu,i1) 
                  Jxx(mu,nu)         = Jxi(mu,i1)*ca(nu,i1) 
                  PUT P2A_ao(mu,nu) += Ixx(mu,nu) 
                  PUT W2_ao(mu,nu)  += Jxx(mu,nu) 
#
               ENDDO nu 
#
            ENDDO mu 
#
      ENDPARDO i, i1  
#
#     Transform Pab_aa 
#     ---------------- 
      PARDO a, a1  
#
            GET Pab_aa(a,a1)  
            GET Wab_aa(a,a1)  
#
            DO mu 
#
               Ixa(mu,a1) = Pab_aa(a,a1)*ca(mu,a) 
               Jxa(mu,a1) = Wab_aa(a,a1)*ca(mu,a) 
#
               DO nu 
#
                  Ixx(mu,nu)         = Ixa(mu,a1)*ca(nu,a1) 
                  Jxx(mu,nu)         = Jxa(mu,a1)*ca(nu,a1) 
                  PUT P2A_ao(mu,nu) += Ixx(mu,nu) 
                  PUT W2_ao(mu,nu)  += Jxx(mu,nu) 
#
               ENDDO nu 
#
            ENDDO mu 
#
      ENDPARDO a, a1  
#
#     Transform Pai_aa 
#     ---------------- 
      PARDO a, i  
#
            GET Paiold_aa(a,i)  
            GET Wai_aa(a,i)  
#
            DO mu 
#
               Ixi(mu,i) = Paiold_aa(a,i)*ca(mu,a) 
               Jxi(mu,i) = Wai_aa(a,i)*ca(mu,a) 
#
               DO nu 
#
                  Ixx(mu,nu)  = Ixi(mu,i)*ca(nu,i) 
                  Jxx(mu,nu)  = Jxi(mu,i)*ca(nu,i) 
                  I1xx(nu,mu) = Ixx(mu,nu) 
                  J1xx(nu,mu) = Jxx(mu,nu) 
# 
                  PUT P2A_ao(mu,nu) += Ixx(mu,nu) 
                  PUT W2_ao(mu,nu)  += Jxx(mu,nu) 
                  PUT P2A_ao(nu,mu) += I1xx(nu,mu) 
                  PUT W2_ao(nu,mu)  += J1xx(nu,mu) 
#
               ENDDO nu 
#
            ENDDO mu 
#
      ENDPARDO a, i  
#
# Done backtransform Ppq --> P2_ao Wpq --> W2_ao  
# ----------------------------------------------  
      execute sip_barrier 
      delete Paiold_aa  
      delete Wai_aa  
      delete Lai_aa  
      execute sip_barrier 
#
# Form the HF density
# -------------------
#
      CALL HFDENS
      execute sip_barrier
#
# Contract the density with the AO basis core Hamiltonian
# -------------------------------------------------------
#
      CALL D1TRANS
      CALL S1TRANS
#
# Contract the 'two-particle' contributions
# -----------------------------------------
#
      CALL D2TRANS
      execute sip_barrier 
#
                           ENDSIAL MBPT2_GRAD_AO2      
#
###############################################################################
#
#
#
# -----------------------------------------------------------------------------
#
      PROC D2TRANS
#     ------------
#
      allocate LDhfa(*,*) 
      allocate LP2A_ao(*,*) 
      execute sip_barrier 
      DO mu 
      DO nu 
         GET              DHFa(mu,nu) 
         GET              P2A_ao(mu,nu) 
         LDhfa(mu,nu)   = DHFa(mu,nu) 
         LP2A_ao(mu,nu) = P2A_ao(mu,nu) 
      ENDDO nu 
      ENDDO mu 

      n_seg = 0.0 
      DO mu 
         n_seg += 1.0 
      ENDDO mu 
     #execute print_scalar n_seg 

      execute sip_barrier 
#
      PARDO mu, nu, lambda    
#
              WHERE mu < lambda  
                    allocate LTAxxxj(mu,lambda,nu,*)     
#
                 DO j
                    DO i
#
                       REQUEST Vxixi(mu,i,nu,j) i 
                       REQUEST Vxixi(lambda,i,nu,j) i 
#
                       T1xxxj(mu,lambda,nu,j)    = Vxixi(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       T2xxxj(mu,lambda,nu,j)    = Vxixi(lambda,i,nu,j)*ca(mu,i)
#
                       LTAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       LTAxxxj(mu,lambda,nu,j)   += T2xxxj(mu,lambda,nu,j) # - 
#
                    ENDDO i
                 ENDDO j

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
            DO sigma 
              IF nu < sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
                    allocate LTBxxxj(mu,lambda,sigma,*)  
#
                 DO j
                    DO i
#
                       REQUEST Vxixi(mu,i,sigma,j) i 
                       REQUEST Vxixi(lambda,i,sigma,j) i 
#
                       T3xxxj(mu,lambda,sigma,j) = Vxixi(mu,i,sigma,j)*La(i,lambda) # ca(lambda,i)
                       T4xxxj(mu,lambda,sigma,j) = Vxixi(lambda,i,sigma,j)*ca(mu,i)
# 
                       LTBxxxj(mu,lambda,sigma,j)+= T4xxxj(mu,lambda,sigma,j)
                       LTBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # - 
#
                    ENDDO i
                 ENDDO j
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO j
#
                    Txxjx(mu,lambda,j,sigma)   = LTBxxxj(mu,lambda,sigma,j)  
                    Txxxx(mu,lambda,nu,sigma)  = Txxjx(mu,lambda,j,sigma)*La(j,nu) # ca(nu,j)
                   #Txxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    T1xxxx(mu,lambda,nu,sigma)  = LTAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                   #T1xxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += T1xxxx(mu,lambda,nu,sigma)
#
                 ENDDO j
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T1xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T3xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^LDHFA(nu,sigma)
                 T3xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T3xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 2.0
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)
#
                    deallocate LTBxxxj(mu,lambda,sigma,*)  

                endif # ml <= ns 
#
              ENDIF # nu < sigma   
            ENDDO sigma 
#
                    deallocate LTAxxxj(mu,lambda,nu,*)     
#
      ENDPARDO mu, nu, lambda    
#
      PARDO lambda, sigma, mu     
            WHERE mu == lambda  
#
                 allocate LTBxxxj(mu,lambda,sigma,*)  
#
                 DO j
                    DO i

                       REQUEST                     Vxixi(mu,i,sigma,j) i  

                       T3xxxj(mu,lambda,sigma,j) = Vxixi(mu,i,sigma,j)*La(i,lambda) # ca(lambda,i)
                       LTBxxxj(mu,lambda,sigma,j)+= T3xxxj(mu,lambda,sigma,j) # - 
#
                    ENDDO i
                 ENDDO j

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
         DO nu 
            IF nu < sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
                 allocate LTAxxxj(mu,lambda,nu,*)     
#
                 DO j
                    DO i

                       REQUEST                     Vxixi(mu,i,nu,j)    i  

                       T1xxxj(mu,lambda,nu,j)    = Vxixi(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       LTAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
#
                    ENDDO i
                 ENDDO j
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO j
                    Txxjx(mu,lambda,j,sigma)   = LTBxxxj(mu,lambda,sigma,j)  
                    Txxxx(mu,lambda,nu,sigma)  = Txxjx(mu,lambda,j,sigma)*La(j,nu) # ca(nu,j)
                   #Txxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                    T1xxxx(mu,lambda,nu,sigma)  = LTAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                   #T1xxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += T1xxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T1xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T3xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^LDHFa(nu,sigma)
                 T3xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T3xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)
#
                 deallocate LTAxxxj(mu,lambda,nu,*)     

                endif # ml <= ns 
#
            ENDIF # nu < sigma   
         ENDDO nu 
#
                    deallocate LTBxxxj(mu,lambda,sigma,*)  
#
      ENDPARDO lambda, sigma, mu     
#
      PARDO mu, lambda, nu     
            WHERE mu < lambda  
#
                    allocate LTAxxxj(mu,lambda,nu,*)     
#
                 DO j
                    DO i

                       REQUEST                     Vxixi(lambda,i,nu,j) j 
                       REQUEST                     Vxixi(mu,i,nu,j) j 

                       T1xxxj(mu,lambda,nu,j)    = Vxixi(mu,i,nu,j)*La(i,lambda) # ca(lambda,i)
                       T2xxxj(mu,lambda,nu,j)    = Vxixi(lambda,i,nu,j)*ca(mu,i)
#
                       LTAxxxj(mu,lambda,nu,j)   += T1xxxj(mu,lambda,nu,j)
                       LTAxxxj(mu,lambda,nu,j)   += T2xxxj(mu,lambda,nu,j) # - 
#
                    ENDDO i
                 ENDDO j

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
             DO sigma 
                IF nu == sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO j
                    Txxxx(mu,lambda,nu,sigma)  = LTAxxxj(mu,lambda,nu,j)*La(j,sigma) # ca(sigma,j)
                   #Txxxx(mu,lambda,nu,sigma) *= 2.0  
                    D2(mu,lambda,nu,sigma)    += Txxxx(mu,lambda,nu,sigma)
                 ENDDO j
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T1xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T1xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T3xx(nu,sigma)             = LDHFA(nu,sigma) 
                 T3xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^T3xx(nu,sigma)
                 T3xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T3xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)

                endif # ml <= ns 
#
                ENDIF # nu == sigma   
             ENDDO sigma 
#
                    deallocate LTAxxxj(mu,lambda,nu,*)     
#
      ENDPARDO mu, lambda, nu     
#
      PARDO lambda, mu, nu 
            WHERE mu == lambda  
#
                 allocate LTAxxxi(mu,lambda,nu,*) 
#
                 DO i1  
                    DO i 
                       REQUEST                     Vxixi(mu,i,nu,i1) i 
                       T1xxxi(mu,lambda,nu,i1)   = Vxixi(mu,i,nu,i1)*La(i,lambda) # ca(lambda,i)  
                       LTAxxxi(mu,lambda,nu,i1) += T1xxxi(mu,lambda,nu,i1)
                    ENDDO i 
                 ENDDO i1

                 ml = 0.0 
                 mm = 0.0 
                 ll = 0.0 

                 DO m 
                    if m <= mu     
                       mm += 1.0  
                    endif 
                 ENDDO m 

                 DO l 
                    if l <= lambda     
                       ll += 1.0  
                    endif 
                 ENDDO l 

                 etemp = ll - 1.0  
                 etemp *= n_seg 
                 ml += etemp 
#
         DO sigma    
#
            IF nu == sigma   

                 ns = 0.0 
                 nn = 0.0 

                 DO n 
                    if n <= nu     
                       nn += 1.0  
                    endif 
                 ENDDO n 

                 ss = 0.0 
                 DO s 
                    if s <= sigma     
                       ss += 1.0  
                    endif 
                 ENDDO s 

                 etemp = ss - 1.0  
                 etemp *= n_seg 
                 ns += etemp 

                 efact = 1.0 
                 if ml < ns 
                    efact = 2.0 
                 endif 

                if ml <= ns 
#
#                Get 1-particle pieces
#                ---------------------
#
                 D2(mu,lambda,nu,sigma) = 0.0 
#
                 DO i1  
                    Txxxx(mu,lambda,nu,sigma) = LTAxxxi(mu,lambda,nu,i1)*La(i1,sigma) # ca(sigma,i1) 
                   #Txxxx(mu,lambda,nu,sigma)*= 2.0  
                    D2(mu,lambda,nu,sigma)   += Txxxx(mu,lambda,nu,sigma)
                 ENDDO i1
#
                 D2(mu,lambda,nu,sigma) *= 2.0 
#
#                Get the separable part  
#                ----------------------
#
#                HF only
#                -------
                 Txx(nu,sigma)              = LDHFa(nu,sigma) 
                 Txx(nu,sigma)             += LP2A_ao(nu,sigma) 
                 T1xx(nu,lambda)             = LDHFa(nu,lambda) 
                 T1xx(nu,lambda)            += LP2A_ao(nu,lambda) 
                 T2xx(sigma,lambda)          = LDHFa(sigma,lambda) 
                 T2xx(sigma,lambda)         += LP2A_ao(sigma,lambda) 

                 Txxxx(mu,lambda,nu,sigma)  = LDHFa(mu,lambda)^Txx(nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) *= 4.0  
                 T2xxxx(mu,lambda,nu,sigma) = LDHFa(mu,sigma)^T1xx(nu,lambda)
                 T3xxxx(mu,lambda,nu,sigma) = LDHFa(mu,nu)^T2xx(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) -= T2xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T3xxxx(mu,lambda,nu,sigma)
#
#                Correlation Only 
#                ----------------
#
                 T4xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,lambda)^LDHFa(nu,sigma)
                 T4xxxx(mu,lambda,nu,sigma)*= 4.0  
                 T5xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,sigma)^LDHFA(nu,lambda)
                 T6xxxx(mu,lambda,nu,sigma) = LP2A_ao(mu,nu)^LDHFA(sigma,lambda)
#
                 Txxxx(mu,lambda,nu,sigma) += T4xxxx(mu,lambda,nu,sigma)
                 Txxxx(mu,lambda,nu,sigma) -= T5xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) -= T6xxxx(mu,lambda,nu,sigma)
#
                 Txxxx(mu,lambda,nu,sigma) *= 0.5
#
#                Add the the nonseparable part
#                -----------------------------
                 Txxxx(mu,lambda,nu,sigma) += D2(mu,lambda,nu,sigma)  
#
                 Txxxx(mu,lambda,nu,sigma) *= efact  
#
#                Set up integrals
#                ----------------
                 execute der_int_setup dx1(mu,lambda,nu,sigma)
                 execute der_int_setup dy1(mu,lambda,nu,sigma)
                 execute der_int_setup dz1(mu,lambda,nu,sigma)
                 execute der_int_setup dx2(mu,lambda,nu,sigma)
                 execute der_int_setup dy2(mu,lambda,nu,sigma)
                 execute der_int_setup dz2(mu,lambda,nu,sigma)
                 execute der_int_setup dx3(mu,lambda,nu,sigma)
                 execute der_int_setup dy3(mu,lambda,nu,sigma)
                 execute der_int_setup dz3(mu,lambda,nu,sigma)
                 execute der_int_setup dx4(mu,lambda,nu,sigma)
                 execute der_int_setup dy4(mu,lambda,nu,sigma)
                 execute der_int_setup dz4(mu,lambda,nu,sigma)
#
#                Compute integral block
#                ----------------------
                 execute compute_derivative_integrals
#
#                Contract density with integral derivatives
#                ------------------------------------------
                 execute DCONT2 Txxxx(mu,lambda,nu,sigma)

                endif # ml <= ns 
#
            ENDIF # nu == sigma   
#
         ENDDO sigma    
#
                 deallocate LTAxxxi(mu,lambda,nu,*) 
#
      ENDPARDO lambda, mu, nu 
      execute sip_barrier 
#
      ENDPROC D2TRANS
#     ---------------
#
# -----------------------------------------------------------------------------
#
