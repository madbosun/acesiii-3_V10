#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
#
#
      SIAL LCCSDPR_RHF_AAA    
#
#
# Make index definitions 
#
#
      Index   i      = 1, naocc   
      Index   j      = 1, naocc   
      Index   k      = 1, naocc   
      Index   ib     = 1, naocc 
      Index   jb     = 1, naocc 
      Index   kb     = 1, naocc 
      index pp   = subb, sube   
#
      aoindex mu     = 1, norb 
      aoindex nu     = 1, norb 
      aoindex lambda = 1, norb 
      aoindex sigma  = 1, norb 
#
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
      moaindex k1= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt 
#
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt 
#
      moaindex p = baocc, eavirt  
      moaindex p1= baocc, eavirt  
      moaindex p2= baocc, eavirt  
      moaindex p3= baocc, eavirt  
#
      moaindex q = baocc, eavirt  
      moaindex q1= baocc, eavirt  
      moaindex q2= baocc, eavirt  
      moaindex q3= baocc, eavirt  
#
#
#   Watson
#
#
      INDEX  indstate = 1, 12
      INDEX  kroot    = 1, 12
      INDEX  kindex12 = 1, 12
      INDEX  indone   = 1, 1
#
#
# VFL TESTS 
      temp  tpps(p,p1,k) 
      temp t1pps(p,p1,k) 
      temp t2pps(p,p1,k) 
      temp t3ppqs(a,a1,b,k)  
      temp  tpqs(p,q,kb) 
      temp t1pqs(p,q,kb) 
      temp t2pqs(p,q,kb) 
      temp t3pqs(p,q,kb) 
#
# Declare served arrays which are read from disk  
# 
      served Vaaai(a1,a2,a3,i1)
      served VSaaai(a1,a2,a3,i1)
      distributed Xaaai(a1,a2,a3,pp)
      distributed XSaaai(a1,a2,a3,pp)
      served YSaaai(a1,a2,a3,i)
      served Yaaai(a1,a2,a3,i)
      served VSpipi(p,i1,p1,i2)
      served Vaaii(a,a1,i1,i2)
      served Viaai(i1,a,a1,i2)
      served Vpiqj(p,i1,q,j2)
      served Vaiai(a,i1,a1,i2) 
#
#
#   Watson
#
#
      SCALAR  iroot
      SCALAR  rootcount
      SCALAR  ncount
      SCALAR  ZERO
      SCALAR  OMEGA
      SCALAR  L_OMEGA
      SCALAR  root_thresh

      STATIC  ST_ROOTS (kroot,indone)
      STATIC  ST_ECORR (kroot,indone)
      TEMP         TEE (kroot,indone)
      TEMP         T1EE (kroot,indone)
      DISTRIBUTED  REE (kroot,indone)
      DISTRIBUTED  LEE (kroot,indone)

      DISTRIBUTED  R1A_VECS (a1,i1,kroot)
     #DISTRIBUTED  R1B_VECS (b1,j1,kroot)
      DISTRIBUTED  L1A_VECS (i1,a1,kroot)
     #DISTRIBUTED  L1B_VECS (j1,b1,kroot)

      SERVED  R2AA_VECS (a1,i1,a2,i2,kroot)
      SERVED  R2AB_VECS (a1,i1,b1,j1,kroot)
     #SERVED  R2BB_VECS (b1,j1,b2,j2,kroot)
      SERVED  L2AA_VECS (i1,a1,i2,a2,kroot)
      SERVED  L2AB_VECS (i1,a1,j1,b1,kroot)
     #SERVED  L2BB_VECS (j1,b1,j2,b2,kroot)

      TEMP  tt1ia   (i1,a1)
      TEMP  tt1ai   (a1,i1)
      TEMP  tt2ai   (a1,i1)
      TEMP  ttiajb  (i1,a1,j1,b1)
      TEMP  tt1iaia (i1,a1,i2,a1)
      TEMP  tt1aiai (a1,i1,a2,i2)
      TEMP  tt2aiai (a1,i1,a2,i2)
      TEMP  ttaibj  (a1,i1,b1,j1)
      TEMP  tt1aibj (a1,i1,b1,j1)

     #TEMP  ttbj    (b1,j1)
     #TEMP  ttjb    (j1,b1)
     #TEMP  ttjbjb  (j1,b1,j2,b2)
     #TEMP  ttbjbj  (b1,j1,b2,j2)

      served T2aiai(a,i1,a1,i2)
      served T2aibj(a,i1,b,j1) 
      served T2bjbj(b,j1,b1,j2)
#
      distributed XSaiii(a,i,i1,j)  
      distributed XSbjjj(b,ib,j1,jb)  
      distributed XaIjJ(a,i,j1,jb)  
      distributed XiIbJ(i1,i,b,jb)  
#
# Declare distributed arrays 
# 
      distributed Paaai(a,a1,a2) 
      distributed Paaaj(a,a1,a2) 
      distributed Paaak(a,a1,a2,k) 
      distributed Pbbbi(b,b1,b2)  
      distributed Pbbbj(b,b1,b2)  
      distributed Pbbbk(b,b1,b2)  
      distributed Pbbai(b,b1,a) 
      distributed Pbbaj(b,b1,a) 
      distributed Paabk(a,a1,b) 
      distributed Paabi(a,a1,b) 
      distributed Paabj(a,a1,b) 
      distributed Pbbak(b,b1,a) 
#
      temp Paiii(a,i,i1,j)   
      temp P1aiii(a,i,i1,j)   
      temp P2aiii(a,i,i1,j)   
      temp P3aiii(a,i,i1,j)   
      temp P4aiii(a,i,i1,j)   
      temp Pbjjj(b,ib,j1,jb)   
      temp PaIjJ(a,i,j1,jb) 
      temp P1aIjJ(a,i,j1,jb) 
      temp PiIbJ(i1,i,b,jb) 
      temp P1iIbJ(i1,i,b,jb) 
#
      distributed XSaI_ij(i1,a) 
      distributed XSaI_ji(i1,a) 
      distributed XSaI_ik(i1,a,k1) 
      distributed XSaI_ki(i1,a,k1) 
      distributed XSaI_kj(i1,a,k1) 
      distributed XaI_ik(j1,a,k1)  
      distributed XaI_jk(j1,a,k1)  
      distributed XiI_ik(i1,b,k1)   
      distributed XiI_jk(i1,b,k1)   
     #static SaI_ik(j1,a)  
     #static SaI_jk(j1,a)  
     #static SiI_ik(i1,b)   
     #static SiI_jk(i1,b)   
      static SSaI_ji(i1,a) 
      distributed S1(a,a1,k1,i) 
      distributed S2(a,a1,k1,j) 
      distributed S3(a,a1) 
#
      temp taaai(a,a1,a2,i1) 
#
      temp XaJbK(a,j,b,kb) 
      temp X1aJbK(a,j,b,kb) 
      temp X2aJbK(a,j,b,kb) 
      temp XaIbK(a,i,b,kb) 
      temp X1aIbK(a,i,b,kb) 
      temp X2aIbK(a,i,b,kb) 
      temp XaJaI(a,j,a1,i) 
      temp X1aJaI(a,j,a1,i) 
      temp YaibK(a,i1,b,kb) 
      temp Y1aibK(a,i1,b,kb) 
      temp XaIbj(a,i,b,j1) 
      temp X1aIbj(a,i,b,j1) 
      temp XaJbj(a,j,b,j1) 
      temp X1aJbj(a,j,b,j1) 
      temp XaiaI(a,i1,a1,i) 
      temp XaiaJ(a,i1,a1,j) 
#
      distributed DbjbS(b,j1,b1) 
      distributed D1bjbS(b,j1,b1) 
      distributed D2bjbS(b,j1,b1) 
      distributed EaibS(a,i1,b) 
      distributed E1aibS(a,i1,b) 
      distributed EabjS(a,b,j1) 
#
      distributed Y3aab(a,a1,b2) 
      distributed D3aab(a,a1,b2,k1) 
      temp DSaab(a,a1,b2) 
      served S3aab(a,a1,b,k1) 
      local L3aab(a,a1,b,k1)  

      served S3ijk(a,a1,a2,k1) 
      distributed D3ijk(a,a1,a2,k1) 
      distributed DD3ijk(a,a1,a2,k1) 

      served SS3ijk(a,a1,a2,k1) 
      distributed LD3ijk(a,a1,a2,k1) 
#
      local L3aaa(a,a1,a2,k1)  
      local LL3aaa(a,a1,a2,k1)  
#
      distributed sai(a,i) 
      distributed Dai(a,i1) 
      distributed sbj(b,kb) 
      temp txai(a,i) 
      distributed txbj(b,kb) 

      served HBAR_ia (i1,a)
      served HBAR_jb (j1,b)
      served A1A     (i1,a)   # Watson
      served A2AA    (i1,a,i2,a1)
      served A2AB    (i1,a,j1,b)

      served t1a_old(a,i1) 
      served t1b_old(b,j1) 
      distributed t1ai(a,i) 
      distributed t1bj(b,jb) 
#
      distributed l1a_old(i1,a)
      served Sl1a(a,i1) 
      served L2iaia(i1,a,i2,a1)  
      served L2iajb(i1,a,i2,a1)  
      served L2aibj(a,i1,a1,i2)
#
      served L2aiai(a,i1,a1,i2)
#
# Declare temporary arrays 
#
      temp taiai(a,i1,a1,i2) 
      temp t1aiai(a,i1,a1,i2) 
      temp taiia(a,i1,i2,a1) 
#
      temp xa(a) 
      temp xb(b) 
      temp xai(a,i) 
      temp xbj(b,kb) 
      temp Pai(a,i) 
      temp Pbj(b,kb) 
      temp tpp(p,p1) 
      temp t1pp(p,p1) 
      temp tqp(q,p) 
      temp tqq(q,q1) 
#
      temp tppp(p,p1,p2) 
      temp t1ppp(p,p1,p2) 
      temp t2ppp(p,p1,p2) 
      temp t4ppp(p,p1,p2) 
      temp t3ppp(p,p1,p2) 
      temp s3ppp(p,p1,p2) 
      temp t5ppp(p,p1,p2) 
      temp taaaiii(a,a1,a2,i,j,k) 
      temp t1aaaiii(a,a1,a2,i,j,k) 
#
      temp tpppp(p,p1,p2,p3) 
      temp t1pppp(p,p1,p2,p3) 
      temp t2pppp(p,p1,p2,p3) 
      temp t3pppp(p,p1,p2,p3) 
      temp t4pppp(p,p1,p2,p3) 
      temp t5pppp(p,p1,p2,p3) 
      temp s3pppp(a,a1,a2,k1)  

      temp tppps(p,p1,p2,i) 
      temp t1ppps(p,p1,p2,i) 
      temp t2ppps(p,p1,p2,j) 
      temp t3ppps(p,p1,p2,j) 
      temp t4ppps(p,p1,p2,i) 
      temp tpsps(p,j,p2,i) 
      temp t1psps(p,j,p2,i) 
      temp t2psps(p,j,p2,i) 
#
      temp tppqq(p,p1,p2,p3) 
      temp t1ppqq(p,p1,p2,p3) 
      temp t2ppqq(p,p1,p2,p3) 
      temp t3ppqq(p,p1,p2,p3) 
#
      temp tpsqq(a,i,b,j1) 
      temp t1psqq(a,j,b,j1) 
      temp t2psqq(a,i,j1,k1) 
      temp t3psqq(i1,i,b,k1) 
      temp t4psqq(a,j,b,k1)
      temp t5psqq(a,j,j1,k1) 
      temp t6psqq(i1,j,b,k1) 
      temp t7psqq(a1,j,b,k1)
      temp t8psqq(a,i,b,k1) 
#
      temp xpspp(a1,j,a2,k1)
      temp x2pspp(a,i,a2,k1)
      temp zpspp(a,i,a1,k1)
      temp wpspp(a,i,a1,k1)
      temp z1pspp(a,i,i1,k1)
      temp zppps(a,k1,i1,i)
      temp z2ppps(a,k1,i1,j) 
      temp x3pspp(a,j,a1,k1) 
      temp x4pspp(a,j,a1,k1) 
#
      temp tpsqs(a,i,b,kb) 
      temp t1psqs(a,j,b,kb) 
#
      temp tqSqS(b,jb,b1,ib) 
      temp t1qSqS(b,jb,b1,ib) 
#
      temp tqqps(b,b1,a,i) 
      temp t1qqpi(b,b1,a,i) 
      temp tppqs(p,p1,q,kb) 
      temp t1ppqs(p,p1,q,kb) 
      temp t2ppqs(p,p1,q,kb) 
      temp tpqqs(a,b,j1,k)    
#
      temp tpqqj(a,b,b1,ib)
#
      temp tppq(p,p1,q) 
      temp t1ppq(p,p1,q) 
      temp t2ppq(p,p1,q) 
      temp t3ppq(p,p1,q) 
      temp t4ppq(p,p1,q) 
      temp t4qqp(q,q1,p,ib,jb,k) 

      temp tqqp(q,q1,p) 
      temp sqqp(q,q1,p) 
      temp t1qqp(q,q1,p) 
      temp t2qqp(q,q1,p) 
      temp t3qqp(q,q1,p) 
      temp tqpp(q,p,p1) 
      temp t1qpp(q,p,p1) 
      temp t2qpp(q,p,p1) 
      temp tqpq(q,p,q1)      
      temp t1qpq(q,p,q1)      
      temp tpqp(p,q,p1)  
      temp t1pqp(p,q,p1)  
      temp tpqq(p,q,q1)  
      temp t1pqq(p,q,q1)  
      temp t2pqq(p,q,q1)  
#
      temp tpppi(p,p1,p2,i) 
      temp tppii(p,p1,i,j) 
      temp tpipi(p,i,p1,j) 
      temp Y1pipi(p,i,p1,j) 
      temp Y2pipi(p,i,p1,j) 
      temp Y3pipi(p,i,p1,j) 
      temp Y4pipi(p,i,p1,j) 
      temp Y5pipi(p,i,p1,j) 
      temp Y6pipi(p,i,p1,j) 
      temp Y7pipi(p,i,p1,j) 
      temp Y8pipi(p,i,p1,j) 
      temp Y9pipi(p,i,p1,j) 
      temp t2pipi(p,i,p1,j) 
#
      temp t1pipi(p,i1,p1,i) 
      temp X1pipi(p,i1,p1,i) 
      temp X2pipi(p,i1,p1,i) 
      temp X3pipi(p,i1,p1,i) 
      temp X4pipi(p,i1,p1,i) 
      temp X5pipi(p,i1,p1,i) 
      temp X6pipi(p,i1,p1,i) 
      temp X7pipi(p,i1,p1,i) 
      temp X8pipi(p,i1,p1,i) 
      temp X9pipi(p,i1,p1,i) 
      temp t1ppii(p,p1,i1,i) 
      temp t2aiii(a,i1,j,i)   
#
      temp tppqj(p,p1,q,ib) 
      temp tqqpi(q,q1,p,i) 
      temp tqppj(b,a,a1,kb) 
#
      temp tqqjj(q,q1,ib,jb) 
      temp tqjqj(q,ib,q1,jb) 

      temp taab(a,a1,b1)
      temp t1aab(a,a1,b1)
      temp tbba(b,b1,a2)
      temp t1bba(b,b1,a2)
      temp tpi(p,i) 
      temp tpj(p,j) 
      temp tpk(p,k) 
      temp tqi(q,ib) 
      temp tqj(q,jb) 
      temp tqk(q,kb) 
      temp tpqpi(a,b,a1,i)
      temp tqpqj(b,a,b1,ib) 
      temp t1jaij(j1,a,j,kb) 
#
# Arrays used in Tbbbjjj computation
#
      temp Tbbbjjj(b,b1,b2,ib,jb,kb) 
      temp tbjbjbj(b,ib,b1,jb,b2,kb)   
      temp t2bjjj(b,j1,kb,jb)  
      temp t1qjqj(b1,j1,b2,ib) 
      temp X1qjqj(b1,j1,b2,ib) 
      temp X2qjqj(b1,j1,b2,ib) 
      temp X3qjqj(b1,j1,b2,ib) 
      temp X4qjqj(b1,j1,b2,ib) 
      temp X5qjqj(b1,j1,b2,ib) 
      temp X6qjqj(b1,j1,b2,ib) 
      temp X7qjqj(b1,j1,b2,ib) 
      temp X8qjqj(b1,j1,b2,ib) 
      temp X9qjqj(b1,j1,b2,ib) 
      temp t1qqjj(b1,b2,j1,ib)
#
# Arrays used in Taabiij computation
#
      temp Dabij(a,b1,j,kb)  
      temp P2aibj(a,j,b,kb) 
      temp P4aibj(a,j,b,kb) 
      temp P5aibj(a,j,b,kb) 
      temp P6aibj(a,j,b,kb) 
      temp P3aibj(a,i,b,jb) 
      temp Tpq(p,q) 
      temp T1pq(p,q) 
      temp tppqi(a,a1,b,i)
      temp tqppi(b,a,a1,i)   
      temp tpqqi(a,b1,b,k)   
      temp P1bbai(b,b1,a1,i) 
      temp t1aibj(a1,i,b,j1) 
      temp taijj(a,j,j1,kb) 
      temp t1ajij(a,j1,j,kb) 
      temp tabji(a1,b,j1,i) 
      temp t1ppqj(a1,a2,b,kb) 
      temp t2ppqj(a1,a2,b,kb) 
      temp taibj(a1,i,b,kb) 
      temp t4aibj(a1,i,b,kb) 
      temp t3aibj(a1,i1,b,kb) 
      temp tpiqj(i1,j,b,kb) 
      temp tbijj(b,i1,j,kb) 
#
      temp taaaoii(a,a1,a2,k1,i,j) 
#
# Arrays used in the Tbbajji computation. 
# --------------------------------------- 
#
      temp P1aibj(a,i,b1,ib) 
      temp P2iibj(i1,k,b,jb) 
      temp P1aabj(a,a2,b1,ib)
      temp P1bjbj(b,jb,b2,ib)
      temp P2bjbj(b,jb,b2,ib)
      temp P3bjbj(b,jb,b2,ib)
      temp P4bjbj(b,jb,b2,ib)
      temp P5bjbj(b,jb,b2,ib)
      temp P6bjbj(b,jb,b2,ib)
      temp P7bjbj(b,jb,b2,ib)
      temp P8bjbj(b,jb,b2,ib)
      temp P9bjbj(b,jb,b2,ib)
      temp P1bbbj(b,b2,b1,ib) 
      temp P2bjjj(b,jb,j1,ib) 
      temp P2aijj(a,k,j1,jb) 
#
      temp t2pqij(a2,b,k,jb) 
      temp tqqaj(b,b1,a,ib)  
      temp t2bbji(b,b2,jb,ib)
      temp tqqai(b,b1,a,k) 
      temp t2abij(a,b2,k,jb) 
      temp t2ajij(a,j1,k,jb) 
#
      temp t1bbajji(b,b1,a,ib,jb,k) 
      temp t2bbajji(b,b1,a,jb,ib,k) 
      temp t3bbajji(b1,b,a,ib,jb,k) 
      temp t4bbajji(b1,b,a,jb,ib,k) 
      temp tbjbjai(b,ib,b1,jb,a,k)
      temp tbbaijj(b,b1,a,k,ib,jb) 
      temp tbiji(b,i1,jb,k) 
      temp tbjjj(b,j1,jb,ib) 
#
      temp Tbbajji(b,b1,a,ib,jb,k) 
      temp tqqa(b,b1,a) 
#
# Arrays used in the sai computation 
# ----------------------------------- 
#
      temp P1aiai(a1,j,a2,k) 
      temp P2aiai(a1,j,a2,k) 
      temp P3aiai(a1,j,a2,k) 
      temp P4aiai(a1,j,a2,k) 
      temp P5aiai(a1,j,a2,k) 
      temp P6aiai(a1,j,a2,k) 
      temp P7aiai(a1,j,a2,k) 
      temp P8aiai(a1,j,a2,k) 
      temp P9aiai(a1,j,a2,k) 
      temp t1pppi(a,a1,a2,i) 
      temp t2ppii(a1,a2,j,k) 
#
      temp Tabbijj(a,b1,b2,i,jb,kb) 
      temp taibjbj(a,i,b1,jb,b2,kb) 
      temp t1abbijj(a,b1,b2,i,jb,kb) 
      temp t1pqqi(a,b1,b2,i) 
      temp t2qqjj(b1,b2,jb,kb) 
      temp t1ppqi(a,a1,b2,i) 
#
# Arrays used in the sbj computation 
# ----------------------------------- 
#
      temp t1qppj(b,a1,a,ib) 
      temp tqqpj(b,b1,a,ib) 
      temp tpqij(p,q,i,jb) 
      temp tqpij(q,p,k,jb) 
      temp tpqji(i1,b,jb,k) 
#
      temp t1baajii(b,a1,a,ib,j,k) 
#
# Distributed arrays to partially hold amplitudes 
# ------------------------------------------------ 
#
      distributed DaSbj(a,b,j1) 
      distributed D1aSbj(a,b,j1) 
      distributed DaibS(a,i1,b,k1) 
#
      distributed Dab(a,b,k1) 
      static Sab(a,b) 
      distributed D1ab(a,b,k1) 
      static S1ab(a,b) 
      distributed D2ab(b,a,k1) 
      static S2ab(a,b) 
      static Saa(a,a1) 
#
      distributed DaiaS(a,i1,a1) 
      distributed D1aiaS(a,i1,a1) 
      distributed D2aiaS(a,i1,a1,k1) 

      distributed Daa(a,a1) 
      distributed D1aa(a,a1,k1) 
      distributed D2aa(a,a1,k1) 
      distributed D2bb(b,b1) 
#
      distributed LDaiaS(a,i1,a1) 
      distributed LD1aiaS(a,i1,a1) 
      distributed LD2aiaS(a,i1,a1,k1) 

      distributed LDaa(a,a1) 
      distributed LD1aa(a,a1,k1) 
      distributed LD2aa(a,a1,k1) 
#
# Arrays used to form identity
# ----------------------------
#
      temp PIi(i,i1)
      served Sii(i2,i1)
      distributed IIi(i,i1)
      static tii(i1,i2)
      static t1ii(i1,i2)
#
      temp PJj(ib,j1)
      served Sjj(j2,j1)
      distributed IJj(ib,j1)
      static tjj(j1,j2)
      static t1jj(j1,j2)
#
# Declare scalars 
#
      scalar LRNORM
      scalar fact 
      scalar etemp 
      scalar etemp1
      scalar etemp2
      scalar etemp3
      scalar etemp4
      scalar etemp5
      scalar etempa
      scalar esum 
      scalar esum1
      scalar esum2
      scalar esum3
      scalar esum4
      scalar esum5
      scalar esum6
      scalar esuma  
      scalar ecorrT 
      scalar ecorraaa 
      scalar ecorraab 
      scalar ecorrbba 
      scalar ecorrbbb 
      scalar ecorrsa 
      scalar ecorrsb 
      scalar icount 
#
# --------------------------------------------------------------------------
#
     PROC READ_BLOCKDATA  
#    -------------------  
#
#   Read BLOCKDATA file.

     #CREATE l1a_old
      execute sip_barrier
      execute server_barrier

      EXECUTE  LIST_TO_BLOCKS  REE

      EXECUTE  LIST_TO_BLOCKS  R1A_VECS
      EXECUTE  LIST_TO_BLOCKS  R2AA_VECS
      EXECUTE  LIST_TO_BLOCKS  R2AB_VECS

      EXECUTE  LIST_TO_BLOCKS  HBAR_ia
      EXECUTE  LIST_TO_BLOCKS  HBAR_jb

      EXECUTE  LIST_TO_BLOCKS  t1a_old
      EXECUTE  LIST_TO_BLOCKS  t1b_old
      EXECUTE  LIST_TO_BLOCKS  T2aiai
      EXECUTE  LIST_TO_BLOCKS  T2aibj
      EXECUTE  LIST_TO_BLOCKS  T2bjbj

      EXECUTE  LIST_TO_BLOCKS  A1A
      EXECUTE  LIST_TO_BLOCKS  A2AA
      EXECUTE  LIST_TO_BLOCKS  A2AB

      EXECUTE  LIST_TO_BLOCKS  VSpipi(p,i1,p1,i2)
      EXECUTE  LIST_TO_BLOCKS  Vpiqj(p,i1,q,j2)

      EXECUTE  LIST_TO_BLOCKS  Vaaii
      EXECUTE  LIST_TO_BLOCKS  Viaai
      EXECUTE  LIST_TO_BLOCKS  Vaaai

      EXECUTE  LIST_TO_BLOCKS  LEE
      EXECUTE  LIST_TO_BLOCKS  L1A_VECS
      EXECUTE  LIST_TO_BLOCKS  L2AA_VECS
      EXECUTE  LIST_TO_BLOCKS  L2AB_VECS

      execute server_barrier
      execute read_list_to_blocks
      execute server_barrier
      execute sip_barrier
#
#   Antisymmetrize Vaaai
#
#
      PARDO a, a1, a2, i1
            REQUEST                      Vaaai(a,a1,a2,i1) a
            REQUEST                      Vaaai(a2,a1,a,i1) a
            taaai(a,a1,a2,i1)          = Vaaai(a2,a1,a,i1)
            taaai(a,a1,a2,i1)         -= Vaaai(a,a1,a2,i1)
            taaai(a,a1,a2,i1)         *= -1.0
            PREPARE VSaaai(a,a1,a2,i1) = taaai(a,a1,a2,i1)
      ENDPARDO a, a1, a2, i1
#
#      PARDO a, i1, a1, i2 
#            REQUEST                      L2iaia(i1,a,i2,a1) a 
#            taiai(a,i1,a1,i2)          = L2iaia(i1,a,i2,a1) 
#            PREPARE L2aiai(a,i1,a1,i2) = taiai(a,i1,a1,i2) 
#      ENDPARDO a, i1, a1, i2 
#
#      PARDO a, i1 
#            GET                  l1a_old(i1,a) 
#            tpp(a,i1)          = l1a_old(i1,a) 
#            PREPARE Sl1a(a,i1) = tpp(a,i1) 
#      ENDPARDO a, i1 
#
     #PARDO a, i1, a1, i2 
     #      REQUEST                   T2aiai(a,i1,a1,i2) a 
     #      taiai(a,i1,a1,i2)          = T2aiai(a,i1,a1,i2) 
     #      PREPARE L2aiai(a,i1,a1,i2) = taiai(a,i1,a1,i2) 
     #ENDPARDO a, i1, a1, i2 
#
     #PARDO a, i1 
     #      REQUEST t1a_old(a,i1) a  
     #      tpp(a,i1) = t1a_old(a,i1) 
     #      PREPARE Sl1a(a,i1) = tpp(a,i1) 
     #ENDPARDO a, i1 
#
      etemp = 0.0 
      etemp1= 0.0 
      etemp2= 0.0 
      etemp3= 0.0 
      etemp4= 0.0 
      etemp5= 0.0 
      esuma = 0.0
      esum  = 0.0 
      esum1 = 0.0 
      esum2 = 0.0 
      esum3 = 0.0 
      esum4 = 0.0 
      esum5 = 0.0 
      esum6 = 0.0 
      execute server_barrier
#
     ENDPROC READ_BLOCKDATA  
#    ----------------------  
#
# --------------------------------------------------------------------------
#
     PROC PDATA  
#    ---------- 
#
#    Put the vOoO integrals into a distributed array 
#    ----------------------------------------------- 
#
#     create t1ai          #
#     create t1bj          #   Watson, removed these and put in main
#     execute sip_barrier  #   for the leomccsdpr 
#
#    PREPARE Vaaai type arrays into XaaaI ones 
#    ----------------------------------------- 
#
     PARDO k, a, a1, a2 
           tppps(a,a1,a2,k) = 0.0
           DO i1
              REQUEST             VSaaai(a,a1,a2,i1) i1
              GET                 IIi(k,i1)
              t1pppi(a,a1,a2,k) = VSaaai(a,a1,a2,i1)*IIi(k,i1)
              tppps(a,a1,a2,k) += t1pppi(a,a1,a2,k)
           ENDDO i1
           PREPARE YSaaaI(a,a1,a2,k) = tppps(a,a1,a2,k) 
#
     ENDPARDO k, a, a1, a2 
#
     PARDO kb, a, a1, b 
           tppqs(a,a1,b,kb) = 0.0
           DO j1
              REQUEST            Vaaai(a,a1,b,j1) b
              GET                IJj(kb,j1)
              t1ppqj(a,a1,b,kb)= Vaaai(a,a1,b,j1)*IJj(kb,j1)
              tppqs(a,a1,b,kb)+= t1ppqj(a,a1,b,kb)
           ENDDO j1
           PREPARE YaaaI(a,a1,b,kb) = tppqs(a,a1,b,kb) 
#
     ENDPARDO kb, a, a1, b 
#
#    Put the singles amplitudes into a distributed array t1aI/t1bJ 
#    ------------------------------------------------------------- 
#    Watson, put in the main program.
#
#     PARDO a, i 
#           PREQUEST tpi(a,i) = t1a_old(a,i1)  
#           PUT t1ai(a,i)     = tpi(a,i) 
#     ENDPARDO a, i 
#
     execute sip_barrier 
     execute server_barrier 
#
# --------------------------------------------------------------------------
#
     ENDPROC PDATA  
#    ------------- 
#
# --------------------------------------------------------------------------
#
# --------------------------------------------------------------------------
#
     PROC T4AAA 
#    ---------- 
#
     create DaiaS 
     create Daa 
     create D1aiaS 
     create Paaai 
     create Paaaj 
     create D2aiaS 
     create D1aa 
     create D2aa 
#
     create LDaiaS 
     create LDaa 
     create LD1aiaS 
     create LD2aiaS 
     create LD1aa 
     create LD2aa 
#
     create XSai_ij 
     create XSai_ik 
     create XSai_ki 
     create XSai_kj 
#
     create S3 
#
     esum1 = 0.0 
     icount = 0.0 
     execute sip_barrier 
#
     PARDO k1, a, a1, i1 
           REQUEST                  T2aiai(a,i1,a1,k1) a  
           PUT D2aiaS(a,i1,a1,k1) = T2aiai(a,i1,a1,k1)  
     ENDPARDO k1, a, a1, i1 
#
     PARDO k1, a, a1, i1 
           REQUEST                   L2aiai(a,i1,a1,k1) a  
           PUT LD2aiaS(a,i1,a1,k1) = L2aiai(a,i1,a1,k1)  
     ENDPARDO k1, a, a1, i1 
     execute sip_barrier 
#
     DO i # segment size of 1  
#
        IF i >= itrips 
        IF i <= itripe 
#
        icount = icount + 1 
        execute print_scalar icount 
#
        execute sip_barrier 
        execute server_barrier 
#
        PARDO a, a1, a2
              REQUEST              YSaaai(a,a1,a2,i) a  
              tppp(a,a1,a2)      = YSaaai(a,a1,a2,i)
              PUT Paaai(a,a1,a2) = tppp(a,a1,a2)
        ENDPARDO a, a1, a2 
#
        PARDO k1, a, i1  
              z1pspp (a,i,i1,k1) = 0.0 # Watson
              PREQUEST z1pspp(a,i,i1,k1) = VSpipi(a,i2,i1,k1) 
              Tppps(a,i1,k1,i)           = z1pspp(a,i,i1,k1)
              tppp(a,i1,k1)              = Tppps(a,i1,k1,i)
              t1ppp(i1,a,k1)             = tppp(a,i1,k1) 
              PUT XSaI_ik(i1,a,k1)       = t1ppp(i1,a,k1) 
        ENDPARDO k1, a, i1  
#
        PARDO k1, a, i1  
              zppps (a,k1,i1,i) = 0.0 # Watson
              PREQUEST zppps(a,k1,i1,i) = VSpipi(a,k1,i1,i3) 
              Tppps(a,i1,k1,i)          = zppps(a,k1,i1,i)
              tppp(a,i1,k1)              = Tppps(a,i1,k1,i)
              t1ppp(i1,a,k1)             = tppp(a,i1,k1) 
              PUT XSaI_ki(i1,a,k1)       = t1ppp(i1,a,k1) 
        ENDPARDO k1, a, i1  
#
# Define arrays used in T3 equations 
# ----------------------------------  
#
        PARDO a, a1, i1 
              t1ppps (a,i1,a1,i) = 0.0 # Watson
              PREQUEST t1ppps(a,i1,a1,i) = T2aiai(a,i1,a1,i2) 
              t1ppp(a,i1,a1)             = t1ppps(a,i1,a1,i) 
              PUT DaiaS(a,i1,a1)         = t1ppp(a,i1,a1) 
        ENDPARDO a, a1, i1 
#
        PARDO k1, a, a1  
              zpspp (a,i,a1,k1) = 0.0 # Watson
              PREQUEST zpspp(a,i,a1,k1) = T2aiai(a,i1,a1,k1) 
              tppps(a,a1,k1,i)           = zpspp(a,i,a1,k1) 
              tppp(a,a1,k1)              = tppps(a,a1,k1,i) 
              t1ppp(a1,a,k1)             = tppp(a,a1,k1) 
              PUT D1aa(a1,a,k1)          = t1ppp(a1,a,k1) 
        ENDPARDO k1, a, a1  
        execute server_barrier 
#
# Define arrays used in L3 equations 
# ----------------------------------  
#
        PARDO a, a1, i1 
              t4ppps (a,i1,a1,i) = 0.0 # Watson
              PREQUEST t4ppps(a,i1,a1,i) = L2aiai(a,i1,a1,i2) 
              t1ppp(a,i1,a1)             = t4ppps(a,i1,a1,i) 
              PUT LDaiaS(a,i1,a1)        = t1ppp(a,i1,a1) 
        ENDPARDO a, a1, i1 
#
        PARDO k1, a, a1  
              wpspp (a,i,a1,k1) = 0.0 # Watson
              PREQUEST wpspp(a,i,a1,k1) = L2aiai(a,i1,a1,k1) 
              tppps(a,a1,k1,i)          = wpspp(a,i,a1,k1) 
              tppp(a,a1,k1)             = tppps(a,a1,k1,i) 
              t1ppp(a1,a,k1)            = tppp(a,a1,k1) 
              PUT LD1aa(a1,a,k1)        = t1ppp(a1,a,k1) 
        ENDPARDO k1, a, a1  
        execute server_barrier 
#
        DO j # segment size of 1  
#
        IF j >= i 
#
        execute server_barrier  
#
        PARDO a, a1, a2
              REQUEST              YSaaai(a,a1,a2,j) a  
              tppp(a,a1,a2)      = YSaaai(a,a1,a2,j)
              PUT Paaaj(a,a1,a2) = tppp(a,a1,a2)
        ENDPARDO a, a1, a2 
#
# Define arrays used in T3 equations 
# ----------------------------------  
#
        PARDO a, a1  
              tpsps (a,j,a1,i) = 0.0 # Watson
              PREQUEST tpsps(a,j,a1,i) = T2aiai(a,i1,a1,i2) 
              tppii(a,a1,j,i)          = tpsps(a,j,a1,i) 
              tpp(a,a1)                = tppii(a,a1,j,i) 
              t1pp(a1,a)               = tpp(a,a1) 
              PUT Daa(a1,a)            = t1pp(a1,a) 
        ENDPARDO a, a1  
#
        PARDO k1, a, a1  
              x3pspp(a,j,a1,k1) = 0.0 # Watson
              PREQUEST x3pspp(a,j,a1,k1) = T2aiai(a,i1,a1,k1) 
              tppps(a,a1,k1,j)           = x3pspp(a,j,a1,k1) 
              tppp(a,a1,k1)              = tppps(a,a1,k1,j) 
              t1ppp(a1,a,k1)             = tppp(a,a1,k1) 
              PUT D2aa(a1,a,k1)          = t1ppp(a1,a,k1) 
        ENDPARDO k1, a, a1  
#
        PARDO a, a1, i1 
              t2ppps (a,i1,a1,j) = 0.0 # Watson
              PREQUEST t2ppps(a,i1,a1,j) = T2aiai(a,i1,a1,i2) 
              t2ppp(a,i1,a1)             = t2ppps(a,i1,a1,j) 
              PUT D1aiaS(a,i1,a1)        = t2ppp(a,i1,a1) 
        ENDPARDO a, a1, i1 
        execute server_barrier 
#
# Define arrays used in L3 equations 
# ----------------------------------  
#
        PARDO a, a1  
              t1psps (a,j,a1,i) = 0.0 # Watson
              PREQUEST t1psps(a,j,a1,i) = L2aiai(a,i1,a1,i2) 
              tppii(a,a1,j,i)           = t1psps(a,j,a1,i) 
              tpp(a,a1)                 = tppii(a,a1,j,i) 
              t1pp(a1,a)                = tpp(a,a1) 
              PUT LDaa(a1,a)            = t1pp(a1,a) 
        ENDPARDO a, a1  
#
        PARDO k1, a, a1  
              x4pspp (a,j,a1,k1) = 0.0 # Watson
              PREQUEST x4pspp(a,j,a1,k1) = L2aiai(a,i1,a1,k1) 
              tppps(a,a1,k1,j)           = x4pspp(a,j,a1,k1) 
              tppp(a,a1,k1)              = tppps(a,a1,k1,j) 
              t1ppp(a1,a,k1)             = tppp(a,a1,k1) 
              PUT LD2aa(a1,a,k1)         = t1ppp(a1,a,k1) 
        ENDPARDO k1, a, a1  
#
        PARDO a, a1, i1 
              t3ppps (a,i1,a1,j) = 0.0 # Watson
              PREQUEST t3ppps(a,i1,a1,j) = L2aiai(a,i1,a1,i2) 
              t2ppp(a,i1,a1)             = t3ppps(a,i1,a1,j) 
              PUT LD1aiaS(a,i1,a1)       = t2ppp(a,i1,a1) 
        ENDPARDO a, a1, i1 
        execute server_barrier 
#
#       Put 'slices' of VSpipi(a,i2,i1,i3) into 2-d arrays 
#       -------------------------------------------------- 
#
        PARDO a, i1  
              PaIiI (a,i,i1,j) = 0.0 # Watson
              PREQUEST PaIiI(a,i,i1,j) = VSpipi(a,i2,i1,i3) 
              Tppii(a,i1,i,j)          = Paiii(a,i,i1,j)
              tpp(a,i1)                = Tppii(a,i1,i,j)
              t1pp(i1,a)               = tpp(a,i1) 
              PUT XSaI_ij(i1,a)        = t1pp(i1,a) 
        ENDPARDO a, i1  
#
#       Put 'slices' of VSpipi(a,i2,i1,i3) into 2-d arrays 
#       -------------------------------------------------- 
#
        PARDO k1, a, i1  
              z2ppps (a,k1,i1,j) = 0.0 # Watson
              PREQUEST z2ppps(a,k1,i1,j) = VSpipi(a,k1,i1,i3) 
              Tppps(a,i1,k1,j)          = z2ppps(a,k1,i1,j)
              tppp(a,i1,k1)              = Tppps(a,i1,k1,j)
              t1ppp(i1,a,k1)             = tppp(a,i1,k1) 
              PUT XSaI_kj(i1,a,k1)       = t1ppp(i1,a,k1) 
        ENDPARDO k1, a, i1  
#
        execute sip_barrier # VFL  
        execute server_barrier  
#
#       Compute contributions to T3/L3 amplitude array 
#       ---------------------------------------------- 
#
#       Compute 1 aaa permutation 
#       ------------------------- 
#
           PARDO k1, a, a2
#
                 allocate  L3aaa(a,*,a2,k1) 
                 allocate LL3aaa(a,*,a2,k1) 
#
                 DO a3  
#
                    REQUEST VSaaai(a,a3,a2,k1) k1  
#
                    DO a1
#
                       IF a <= a1 
                       IF a1 <= a2 
#
                          GET                  Daa(a3,a1)
                          GET                  LDaa(a3,a1)
#
                          tpppp(a,a1,a2,k1)  = VSaaai(a,a3,a2,k1)*Daa(a3,a1)
                          L3aaa(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
#
                          tpppp(a,a1,a2,k1)  = VSaaai(a,a3,a2,k1)*LDaa(a3,a1)
                          LL3aaa(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
#
                       ENDIF 
                       ENDIF 
#
                    ENDDO a1
#
                 ENDDO a3  
#
                 DO a3  
#
                    GET Paaai(a,a3,a2) 
                    GET Paaaj(a,a3,a2) 
#
                    DO a1
#
                       IF a <= a1 
                       IF a1 <= a2 
#
                          GET                  D1aa(a3,a1,k1)
                          GET                  D2aa(a3,a1,k1) 
#
                          tpppp(a,a1,a2,k1)  = Paaaj(a,a3,a2)*D1aa(a3,a1,k1)
                          t2pppp(a,a1,a2,k1) = Paaai(a,a3,a2)*D2aa(a3,a1,k1)   
                          tpppp(a,a1,a2,k1) -= t2pppp(a,a1,a2,k1)
#
                          L3aaa(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
#
                          GET                  LD1aa(a3,a1,k1)
                          GET                  LD2aa(a3,a1,k1) 
#
                          tpppp(a,a1,a2,k1)  = Paaaj(a,a3,a2)*LD1aa(a3,a1,k1)
                          t2pppp(a,a1,a2,k1) = Paaai(a,a3,a2)*LD2aa(a3,a1,k1)   
                          tpppp(a,a1,a2,k1) -= t2pppp(a,a1,a2,k1)
#
                          LL3aaa(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
#
                       ENDIF 
                       ENDIF 
#
                    ENDDO a1
#
                 ENDDO a3  
#
                 DO a1 
                    IF a <= a1 
                       tpppp(a,a1,a2,k1)          = L3aaa(a,a1,a2,k1) 
                       PREPARE S3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                    ENDIF 
                 ENDDO a1 
#
                 DO a1 
                    IF a <= a1 
                       tpppp(a,a1,a2,k1)          = LL3aaa(a,a1,a2,k1) 
                       PREPARE SS3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                    ENDIF 
                 ENDDO a1 
#
                 deallocate  L3aaa(a,*,a2,k1) 
                 deallocate LL3aaa(a,*,a2,k1) 
#
           ENDPARDO k1, a, a2    
#
#       Compute 1 iii permutation 
#       ------------------------- 
#
           PARDO k1, a, a2  
#
                 allocate  L3aaa(a,*,a2,k1) 
                 allocate LL3aaa(a,*,a2,k1) 
#
                 DO i1 
#
                    GET DaiaS(a,i1,a2) 
                    GET D1aiaS(a,i1,a2) 
                    GET D2aiaS(a,i1,a2,k1) 
#
                    DO a1 
#
                       IF a <= a1 
                       IF a1 <= a2 
#
                          GET                   XSai_kj(i1,a1,k1) 
                          GET                   XSai_ki(i1,a1,k1) 
                          GET                   XSai_ij(i1,a1) 
#
                          tpppp(a,a1,a2,k1)   = DaiaS(a,i1,a2)*XSai_kj(i1,a1,k1)  
                          t1pppp(a,a1,a2,k1)  = D1aiaS(a,i1,a2)*XSai_ki(i1,a1,k1)  
                          t2pppp(a,a1,a2,k1)  = D2aiaS(a,i1,a2,k1)*XSai_ij(i1,a1)  
                          t2pppp(a,a1,a2,k1) += t1pppp(a,a1,a2,k1) 
                          t2pppp(a,a1,a2,k1) -= tpppp(a,a1,a2,k1) 
#
                          L3aaa(a,a1,a2,k1)  += t2pppp(a,a1,a2,k1)  
#
                       ENDIF 
                       ENDIF 
#
                    ENDDO a1  
#
                 ENDDO i1 
#
                 DO i1 
#
                    GET LDaiaS(a,i1,a2) 
                    GET LD1aiaS(a,i1,a2) 
                    GET LD2aiaS(a,i1,a2,k1) 
#
                    DO a1 
#
                       IF a <= a1 
                       IF a1 <= a2 
#
                          GET                   XSai_kj(i1,a1,k1) 
                          GET                   XSai_ki(i1,a1,k1) 
                          GET                   XSai_ij(i1,a1) 
#
                          tpppp(a,a1,a2,k1)   = LDaiaS(a,i1,a2)*XSai_kj(i1,a1,k1)  
                          t1pppp(a,a1,a2,k1)  = LD1aiaS(a,i1,a2)*XSai_ki(i1,a1,k1)  
                          t2pppp(a,a1,a2,k1)  = LD2aiaS(a,i1,a2,k1)*XSai_ij(i1,a1)  
                          t2pppp(a,a1,a2,k1) += t1pppp(a,a1,a2,k1) 
                          t2pppp(a,a1,a2,k1) -= tpppp(a,a1,a2,k1) 
#
                          LL3aaa(a,a1,a2,k1)  += t2pppp(a,a1,a2,k1)  
#
                       ENDIF 
                       ENDIF 
#
                    ENDDO a1  
#
                 ENDDO i1 
#
                 DO a1  
                    IF a <= a1 
                       tpppp(a,a1,a2,k1)          = L3aaa(a,a1,a2,k1) 
                       PREPARE S3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                    ENDIF 
                 ENDDO a1  
#
                 DO a1  
                    IF a <= a1 
                       tpppp(a,a1,a2,k1)          = LL3aaa(a,a1,a2,k1) 
                       PREPARE SS3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                    ENDIF 
                 ENDDO a1  
#
                 deallocate L3aaa(*,a1,a2,k1) 
                 deallocate LL3aaa(*,a1,a2,k1) 
#
           ENDPARDO k1, a, a2   
#
           PARDO k1, a1, a2
#
                 WHERE a1 <= a2 
#
                    allocate L3aaa(*,a1,a2,k1) 
                    allocate LL3aaa(*,a1,a2,k1) 
#
                    DO a3  
#
                       REQUEST               VSaaai(a1,a3,a2,k1) k1  
                       t1ppqq(a3,a1,a2,k1) = VSaaai(a1,a3,a2,k1) 
#
                       DO a 
#
                          IF a <= a1 
#
                             GET                  Daa(a3,a)  
                             GET                  LDaa(a3,a)  
#
                             tpppp(a,a1,a2,k1)  = t1ppqq(a3,a1,a2,k1)*Daa(a3,a)   
                             L3aaa(a,a1,a2,k1) -= tpppp(a,a1,a2,k1) 
#
                             tpppp(a,a1,a2,k1)  = t1ppqq(a3,a1,a2,k1)*LDaa(a3,a)   
                             LL3aaa(a,a1,a2,k1) -= tpppp(a,a1,a2,k1) 
#
                          ENDIF 
#
                       ENDDO a 
#
                    ENDDO a3  
#
                    DO a3  
#
                       GET                   Paaaj(a1,a3,a2) 
                       GET                   Paaai(a1,a3,a2) 
                       tppq(a3,a1,a2)      = Paaaj(a1,a3,a2) 
                       t2ppq(a3,a1,a2)     = Paaai(a1,a3,a2) 
#
                       DO a 
#
                          IF a <= a1 
#
                             GET                   D1aa(a3,a,k1) 
                             GET                   D2aa(a3,a,k1) 
#
                             GET                   LD1aa(a3,a,k1) 
                             GET                   LD2aa(a3,a,k1) 
#
                             tpppp(a,a1,a2,k1)   = t2ppq(a3,a1,a2)*D2aa(a3,a,k1) 
                             t1pppp(a,a1,a2,k1)  = tppq(a3,a1,a2)*D1aa(a3,a,k1)   
                             tpppp(a,a1,a2,k1)  -= t1pppp(a,a1,a2,k1) 
#
                             L3aaa(a,a1,a2,k1)  += tpppp(a,a1,a2,k1) 
#
                             tpppp(a,a1,a2,k1)   = t2ppq(a3,a1,a2)*LD2aa(a3,a,k1) 
                             t1pppp(a,a1,a2,k1)  = tppq(a3,a1,a2)*LD1aa(a3,a,k1)   
                             tpppp(a,a1,a2,k1)  -= t1pppp(a,a1,a2,k1) 
#
                             LL3aaa(a,a1,a2,k1)  += tpppp(a,a1,a2,k1) 
#
                          ENDIF 
#
                       ENDDO a 
#
                    ENDDO a3  
#
                    DO a 
                       IF a <= a1 
                          tpppp(a,a1,a2,k1)          = L3aaa(a,a1,a2,k1) 
                          PREPARE S3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                       ENDIF 
                    ENDDO a 
#
                    DO a 
                       IF a <= a1 
                          tpppp(a,a1,a2,k1)          = LL3aaa(a,a1,a2,k1) 
                          PREPARE SS3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                       ENDIF 
                    ENDDO a 
#
                    deallocate L3aaa(*,a1,a2,k1) 
                    deallocate LL3aaa(*,a1,a2,k1) 
#
           ENDPARDO k1, a1, a2    
#
           PARDO k1, a, a1
#
                 WHERE a <= a1 
#
                    allocate L3aaa(a,a1,*,k1) 
                    allocate LL3aaa(a,a1,*,k1) 
#
                    DO a3  
#
                       REQUEST              VSaaai(a1,a3,a,k1) k1   
                       GET                  Paaaj(a1,a3,a) 
                       GET                  Paaai(a1,a3,a) 
                       t1ppqq(a,a1,a3,k1) = VSaaai(a1,a3,a,k1) 
                       tppq(a,a1,a3)      = Paaaj(a1,a3,a) 
                       t2ppq(a,a1,a3)     = Paaai(a1,a3,a) 
#
                       DO a2 
#
                          IF a1 <= a2 
#
                             GET                   D1aa(a3,a2,k1) 
                             GET                   D2aa(a3,a2,k1) 
                             GET                   Daa(a3,a2) 
#
                             tpppp(a,a1,a2,k1)    = tppq(a,a1,a3)*D1aa(a3,a2,k1)   
                             t1pppp(a,a1,a2,k1)   = t1ppqq(a,a1,a3,k1)*Daa(a3,a2)   
                             tpppp(a,a1,a2,k1)   += t1pppp(a,a1,a2,k1)  
                             t2pppp(a,a1,a2,k1)   = t2ppq(a,a1,a3)*D2aa(a3,a2,k1)   
                             tpppp(a,a1,a2,k1)   -= t2pppp(a,a1,a2,k1)  
#
                             L3aaa(a,a1,a2,k1)   += tpppp(a,a1,a2,k1) 
#
                             GET                   LD1aa(a3,a2,k1) 
                             GET                   LD2aa(a3,a2,k1) 
                             GET                   LDaa(a3,a2) 
#
                             tpppp(a,a1,a2,k1)    = tppq(a,a1,a3)*LD1aa(a3,a2,k1)   
                             t1pppp(a,a1,a2,k1)   = t1ppqq(a,a1,a3,k1)*LDaa(a3,a2)   
                             tpppp(a,a1,a2,k1)   += t1pppp(a,a1,a2,k1)  
                             t2pppp(a,a1,a2,k1)   = t2ppq(a,a1,a3)*LD2aa(a3,a2,k1)   
                             tpppp(a,a1,a2,k1)   -= t2pppp(a,a1,a2,k1)  
#
                             LL3aaa(a,a1,a2,k1)   += tpppp(a,a1,a2,k1) 
#
                          ENDIF 
#
                       ENDDO a2 
#
                    ENDDO a3  
#
                    DO a2 
                       IF a <= a1 
                          tpppp(a,a1,a2,k1)          = L3aaa(a,a1,a2,k1) 
                          PREPARE S3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                       ENDIF 
                    ENDDO a2 
#
                    DO a2 
                       IF a <= a1 
                          tpppp(a,a1,a2,k1)          = LL3aaa(a,a1,a2,k1) 
                          PREPARE SS3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                       ENDIF 
                    ENDDO a2 
#
                    deallocate L3aaa(a,a1,*,k1) 
                    deallocate LL3aaa(a,a1,*,k1) 
#
           ENDPARDO k1, a, a1    
#
# End contributions from terms containing Paaai 
# --------------------------------------------- 
#
           PARDO k1, a1, a2  
#
                 WHERE a1 <= a2 
#
                    allocate L3aaa(*,a1,a2,k1) 
                    allocate LL3aaa(*,a1,a2,k1) 
#
                    DO i1  
#
                       GET                   DaiaS(a1,i1,a2) 
                       GET                   D1aiaS(a1,i1,a2) 
                       GET                   D2aiaS(a1,i1,a2,k1)  
                       tppq(i1,a1,a2)      = DaiaS(a1,i1,a2) 
                       t1ppq(i1,a1,a2)     = D1aiaS(a1,i1,a2) 
                       t2ppqq(i1,a1,a2,k1) = D2aiaS(a1,i1,a2,k1) 
#
                       DO a 
#
                          IF a <= a1 
#
                             GET                  XSai_kj(i1,a,k1) 
                             GET                  XSai_ki(i1,a,k1) 
                             GET                  XSai_ij(i1,a) 
#
                             tpppp(a,a1,a2,k1)  = tppq(i1,a1,a2)*XSai_kj(i1,a,k1)  
                             t1pppp(a,a1,a2,k1) = t1ppq(i1,a1,a2)*XSai_ki(i1,a,k1)  
                             t2pppp(a,a1,a2,k1) = t2ppqq(i1,a1,a2,k1)*XSai_ij(i1,a)  
                             tpppp(a,a1,a2,k1) -= t1pppp(a,a1,a2,k1) 
                             tpppp(a,a1,a2,k1) -= t2pppp(a,a1,a2,k1) 
                             L3aaa(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
#
                          ENDIF 
#
                        ENDDO a  
#
                    ENDDO i1  
#
                    DO i1  
#
                       GET                   LDaiaS(a1,i1,a2) 
                       GET                   LD1aiaS(a1,i1,a2) 
                       GET                   LD2aiaS(a1,i1,a2,k1)  
                       tppq(i1,a1,a2)      = LDaiaS(a1,i1,a2) 
                       t1ppq(i1,a1,a2)     = LD1aiaS(a1,i1,a2) 
                       t2ppqq(i1,a1,a2,k1) = LD2aiaS(a1,i1,a2,k1) 
#
                       DO a 
#
                          IF a <= a1 
#
                             GET                  XSai_kj(i1,a,k1) 
                             GET                  XSai_ki(i1,a,k1) 
                             GET                  XSai_ij(i1,a) 
#
                             tpppp(a,a1,a2,k1)  = tppq(i1,a1,a2)*XSai_kj(i1,a,k1)  
                             t1pppp(a,a1,a2,k1) = t1ppq(i1,a1,a2)*XSai_ki(i1,a,k1)  
                             t2pppp(a,a1,a2,k1) = t2ppqq(i1,a1,a2,k1)*XSai_ij(i1,a)  
                             tpppp(a,a1,a2,k1) -= t1pppp(a,a1,a2,k1) 
                             tpppp(a,a1,a2,k1) -= t2pppp(a,a1,a2,k1) 
                             LL3aaa(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
#
                          ENDIF 
#
                        ENDDO a  
#
                    ENDDO i1  
#
                    DO a 
                       IF a <= a1 
                          tpppp(a,a1,a2,k1)          = L3aaa(a,a1,a2,k1) 
                          PREPARE S3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                       ENDIF 
                    ENDDO a 
#
                    DO a 
                       IF a <= a1 
                          tpppp(a,a1,a2,k1)          = LL3aaa(a,a1,a2,k1) 
                          PREPARE SS3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                       ENDIF 
                    ENDDO a 
#
                    deallocate L3aaa(*,a1,a2,k1) 
                    deallocate LL3aaa(*,a1,a2,k1) 
#
           ENDPARDO k1, a1, a2   
#
           PARDO k1, a, a1  
#
                 WHERE a <= a1 
#
                 allocate L3aaa(a,a1,*,k1) 
                 allocate LL3aaa(a,a1,*,k1) 
#
                 DO i1  
#
                    GET                  DaiaS(a1,i1,a) 
                    GET                  D1aiaS(a1,i1,a) 
                    GET                  D2aiaS(a1,i1,a,k1) 
                    tppq(a,a1,i1)      = DaiaS(a1,i1,a) 
                    t1ppq(a,a1,i1)     = D1aiaS(a1,i1,a) 
                    t2ppqq(a,a1,i1,k1) = D2aiaS(a1,i1,a,k1) 
#
                    DO a2 
#
                       IF a1 <= a2 
#
                          GET                   XSai_kj(i1,a2,k1) 
                          GET                   XSai_ki(i1,a2,k1) 
                          GET                   XSai_ij(i1,a2) 
#
                          tpppp(a,a1,a2,k1)   = tppq(a,a1,i1)*XSai_kj(i1,a2,k1)  
                          t1pppp(a,a1,a2,k1)  = t1ppq(a,a1,i1)*XSai_ki(i1,a2,k1)  
                          t2pppp(a,a1,a2,k1)  = t2ppqq(a,a1,i1,k1)*XSai_ij(i1,a2)  
                          t2pppp(a,a1,a2,k1) += t1pppp(a,a1,a2,k1) 
                          t2pppp(a,a1,a2,k1) -= tpppp(a,a1,a2,k1) 
#
                          L3aaa(a,a1,a2,k1) += t2pppp(a,a1,a2,k1)
#
                       ENDIF 
#
                    ENDDO a2  
#
                 ENDDO i1  
#
                 DO i1  
#
                    GET                  LDaiaS(a1,i1,a) 
                    GET                  LD1aiaS(a1,i1,a) 
                    GET                  LD2aiaS(a1,i1,a,k1) 
                    tppq(a,a1,i1)      = LDaiaS(a1,i1,a) 
                    t1ppq(a,a1,i1)     = LD1aiaS(a1,i1,a) 
                    t2ppqq(a,a1,i1,k1) = LD2aiaS(a1,i1,a,k1) 
#
                    DO a2 
#
                       IF a1 <= a2 
#
                          GET                   XSai_kj(i1,a2,k1) 
                          GET                   XSai_ki(i1,a2,k1) 
                          GET                   XSai_ij(i1,a2) 
#
                          tpppp(a,a1,a2,k1)   = tppq(a,a1,i1)*XSai_kj(i1,a2,k1)  
                          t1pppp(a,a1,a2,k1)  = t1ppq(a,a1,i1)*XSai_ki(i1,a2,k1)  
                          t2pppp(a,a1,a2,k1)  = t2ppqq(a,a1,i1,k1)*XSai_ij(i1,a2)  
                          t2pppp(a,a1,a2,k1) += t1pppp(a,a1,a2,k1) 
                          t2pppp(a,a1,a2,k1) -= tpppp(a,a1,a2,k1) 
#
                          LL3aaa(a,a1,a2,k1) += t2pppp(a,a1,a2,k1)
#
                       ENDIF 
#
                    ENDDO a2  
#
                 ENDDO i1  
#
                 DO a2  
                    IF a <= a1 
                       tpppp(a,a1,a2,k1)          = L3aaa(a,a1,a2,k1) 
                       PREPARE S3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                    ENDIF 
                 ENDDO a2  
#
                 DO a2  
                    IF a <= a1 
                       tpppp(a,a1,a2,k1)          = LL3aaa(a,a1,a2,k1) 
                       PREPARE SS3ijk(a,a1,a2,k1) += tpppp(a,a1,a2,k1) 
                    ENDIF 
                 ENDDO a2  
#
                 deallocate L3aaa(a,a1,*,k1) 
                 deallocate LL3aaa(a,a1,*,k1) 
#
           ENDPARDO k1, a, a1  
#
          #execute sip_barrier 
           execute server_barrier # VFL  
#
# Create the S3 array for the s_1 computetion(perm 3) 
# --------------------------------------------------- 
#
        PARDO a, a1  
#
              P3aiai (a1,j,a,i) = 0.0 # Watson
              PREQUEST P3aiai(a1,j,a,i) = VSpipi(a1,i3,a,i2)
              t2ppii(a1,a,j,i)          = P3aiai(a1,j,a,i)
              tpp(a1,a)                 = t2ppii(a1,a,j,i)
              PUT S3(a1,a)              = tpp(a1,a) 
#
        ENDPARDO a, a1  
        execute sip_barrier
#
# Antisymmetrize the amplitude array 
# ---------------------------------- 
#
        DO k1  
#
           create D3ijk(*,*,*,k1) 
           create DD3ijk(*,*,*,k1) 
#
           create LD3ijk(*,*,*,k1) 
#
           execute sip_barrier 
#
           PARDO a, a1, a2  
#
                 WHERE a <= a1 
                 WHERE a1 <= a2 
#
#                   Complete and symmetrize distributed array 
#                   ----------------------------------------- 
#
                    REQUEST                   S3ijk(a,a1,a2,k1) a  
                    s3pppp(a,a1,a2,k1)      = S3ijk(a,a1,a2,k1)  
#
                    t1pppp(a1,a,a2,k1)      = s3pppp(a,a1,a2,k1) 
                    t2pppp(a2,a1,a,k1)      = s3pppp(a,a1,a2,k1) 
                    t3pppp(a,a2,a1,k1)      = s3pppp(a,a1,a2,k1) 
                    t4pppp(a1,a2,a,k1)      = s3pppp(a,a1,a2,k1) 
                    t5pppp(a2,a,a1,k1)      = s3pppp(a,a1,a2,k1) 
                    t1pppp(a1,a,a2,k1)     *= -1.0 
                    t2pppp(a2,a1,a,k1)     *= -1.0 
                    t3pppp(a,a2,a1,k1)     *= -1.0  

                    PUT D3ijk(a,a1,a2,k1) = s3pppp(a,a1,a2,k1)  
                    PUT D3ijk(a1,a,a2,k1) = t1pppp(a1,a,a2,k1)  
                    PUT D3ijk(a2,a1,a,k1) = t2pppp(a2,a1,a,k1)  
                    PUT D3ijk(a,a2,a1,k1) = t3pppp(a,a2,a1,k1)  
                    PUT D3ijk(a1,a2,a,k1) = t4pppp(a1,a2,a,k1)  
                    PUT D3ijk(a2,a,a1,k1) = t5pppp(a2,a,a1,k1)  
#
           ENDPARDO a, a1, a2   
#
           PARDO a, a1, a2  
#
                 WHERE a <= a1 
                 WHERE a1 <= a2 
#
#                   Complete and symmetrize distributed array 
#                   ----------------------------------------- 
#
                    REQUEST                   SS3ijk(a,a1,a2,k1) a  
                    s3pppp(a,a1,a2,k1)      = SS3ijk(a,a1,a2,k1)  
#
                    t1pppp(a1,a,a2,k1)      = s3pppp(a,a1,a2,k1) 
                    t2pppp(a2,a1,a,k1)      = s3pppp(a,a1,a2,k1) 
                    t3pppp(a,a2,a1,k1)      = s3pppp(a,a1,a2,k1) 
                    t4pppp(a1,a2,a,k1)      = s3pppp(a,a1,a2,k1) 
                    t5pppp(a2,a,a1,k1)      = s3pppp(a,a1,a2,k1) 
                    t1pppp(a1,a,a2,k1)     *= -1.0 
                    t2pppp(a2,a1,a,k1)     *= -1.0 
                    t3pppp(a,a2,a1,k1)     *= -1.0  

                    PUT LD3ijk(a,a1,a2,k1) = s3pppp(a,a1,a2,k1)  
                    PUT LD3ijk(a1,a,a2,k1) = t1pppp(a1,a,a2,k1)  
                    PUT LD3ijk(a2,a1,a,k1) = t2pppp(a2,a1,a,k1)  
                    PUT LD3ijk(a,a2,a1,k1) = t3pppp(a,a2,a1,k1)  
                    PUT LD3ijk(a1,a2,a,k1) = t4pppp(a1,a2,a,k1)  
                    PUT LD3ijk(a2,a,a1,k1) = t5pppp(a2,a,a1,k1)  
#
           ENDPARDO a, a1, a2   
#
           execute sip_barrier # VFL  
           execute server_barrier # VFL  
#
# Compute the contribution to energy and one-particle intermediates
# -----------------------------------------------------------------
#
           PARDO a, a1, a2
#
                 GET                         D3ijk(a,a1,a2,k1)
                 GET                         LD3ijk(a,a1,a2,k1)
                 taaaoii(a,a1,a2,k1,i,j)    = D3ijk(a,a1,a2,k1)
                 #execute energy_ty_denominator taaaoii  omega
#
# Form contribution to the energy
# -------------------------------
#
                 t1pppp(a,a1,a2,k1)    = taaaoii(a,a1,a2,k1,i,j)
                 etemp                 = LD3ijk(a,a1,a2,k1)*t1pppp(a,a1,a2,k1)
                 etemp                 = etemp/18.0
                 esum1                += etemp
#
                 PUT DD3ijk(a,a1,a2,k1) = t1pppp(a,a1,a2,k1) 
#
           ENDPARDO a, a1, a2 
#
           execute sip_barrier # VFL  
#
# Form Contribution to Sai
# ------------------------
#
# Perm 3
# -------
#
           PARDO a2, a1, a   
#
                 GET                  DD3ijk(a,a1,a2,k1)   
                 GET                  S3(a1,a) 
                #t1pppp(a2,k1,a1,a) = DD3ijk(a,a1,a2,k1) # VFL  
                 t1pp(a2,k1)        = DD3ijk(a,a1,a2,k1)*S3(a1,a) # VFL 
                 t1pp(a2,k1)       *= 0.6666666666666666666666667  
                 PUT Dai(a2,k1)    += t1pp(a2,k1)
#
                 t2pppp(a,a1,a2,k1)        = 0.0 
                 PREPARE S3ijk(a,a1,a2,k1) = t2pppp(a,a1,a2,k1) 
                 PREPARE SS3ijk(a,a1,a2,k1) = t2pppp(a,a1,a2,k1) 
#
           ENDPARDO a2, a1, a  
#
# Perm 1
# -------
#
           PARDO a1, a2 
#
                 xpspp (a1,j,a2,k1) = 0.0 # Watson
                 PREQUEST xpspp(a1,j,a2,k1) = VSpipi(a1,i1,a2,k1)
                 t2ppps(a1,a2,k1,j)         = xpspp(a1,j,a2,k1)
                 tppp(a1,a2,k1)             = t2ppps(a1,a2,k1,j)
                 tppps(a1,a2,k1,i)          = tppp(a1,a2,k1) 
#
                 DO a 
#
                    GET                         DD3ijk(a,a1,a2,k1)   
                    xai(a,i)                  = DD3ijk(a,a1,a2,k1)*tppps(a1,a2,k1,i)
                    xai(a,i)                 *= 0.6666666666666666666666667  
                    PUT sai(a,i)             += xai(a,i)
#
                 ENDDO a 
#
           ENDPARDO a1, a2 
#
# Perm 2
# -------
#
           PARDO a, a2 
#
                 x2pspp (a,i,a2,k1) = 0.0 # Watson
                 PREQUEST x2pspp(a,i,a2,k1) = VSpipi(a,i1,a2,k1)
                 t2ppps(a,a2,k1,i)          = x2pspp(a,i,a2,k1)
                 tppp(a,a2,k1)              = t2ppps(a,a2,k1,i)
                 tppps(a,a2,k1,j)           = tppp(a,a2,k1) 
#
                 DO a1 
#
                    GET                         DD3ijk(a,a1,a2,k1)  
                   #t1pppp(a1,a,a2,k1)        = tpppp(a,a1,a2,k1) 
                    xai(a1,j)                 = DD3ijk(a,a1,a2,k1)*tppps(a,a2,k1,j) # VFL 
                    xai(a1,j)                *= 0.6666666666666666666666667  
                    PUT sai(a1,j)            += xai(a1,j)
#
                 ENDDO a1 
#
           ENDPARDO a, a2 
#
           #   execute sip_barrier # VFL 
           execute server_barrier
           delete LD3ijk(*,*,*,k1) 
           delete D3ijk(*,*,*,k1) 
           delete DD3ijk(*,*,*,k1) 
#
        ENDDO k1  
#
        ENDIF # i>=j 
        ENDDO j # segment size of 1  
#
        ENDIF # i <= itripe 
        ENDIF # i >= itrips 
#
     ENDDO i # segment size of 1  
#
#    DONE alpha/alpha/alpha/ block. 
#    ------------------------------ 
#
     execute sip_barrier
     collective ecorraaa += esum1 
     execute print_scalar ecorraaa 
#
     delete Paaai
     delete Paaaj
#
     delete LDaiaS
     delete LDaa
     delete LD1aiaS
     delete LD2aiaS
     delete LD1aa
     delete LD2aa
#
     delete S3

     delete DaiaS 
     delete Daa 
     delete D1aiaS 
     delete D2aiaS 
     delete D1aa 
     delete D2aa 
#
     delete XSai_ij 
     delete XSai_ik 
     delete XSai_ki 
     delete XSai_kj 
     execute sip_barrier 
     execute sip_barrier 
     execute server_barrier 
#
     ENDPROC T4AAA 
#    ------------- 
#
# --------------------------------------------------------------------------
#
# --------------------------------------------------------------------------
#
     PROC ST5 
#    -------- 
#
# Compute contribution to the energy from sai 
# -------------------------------------------  
#
     esum = 0.0 
     execute sip_barrier 
     PARDO a, i 
#
           Pai (a,i) = 0.0 # Watson
	   PREQUEST Pai(a,i) = Sl1a(a,i1) # t1a_old(a,i1) 
	   GET                 sai(a,i) 
	   etemp             = Pai(a,i)*sai(a,i) 
	   etemp            *= 0.25
	   esum             += etemp  
#
     ENDPARDO a, i 
#
     PARDO a, i1  
#
	   REQUEST             Sl1a(a,i1) a # t1a_old(a,i1) a  
	   GET                 Dai(a,i1) 
	  #etemp             = t1a_old(a,i1)*Dai(a,i1) 
	   etemp             = Sl1a(a,i1)*Dai(a,i1) 
	   etemp            *= 0.25
	   esum             += etemp  
#
     ENDPARDO a, i1 

     execute sip_barrier 
     collective ecorrsa += esum 
     execute sip_barrier 
     execute print_scalar ecorrsa  
     execute server_barrier 
#
     ENDPROC ST5 
#    ----------- 
#
# --------------------------------------------------------------------------
#
# --------------------------------------------------------------------------
#
     PROC FORM_IDENTITY
#    ------------------
#
     create IIi
     create IJj
#
# Form identity arrays
# --------------------
#
     DO i1
     DO i2
           tii(i1,i2) = 1.0
           t1ii(i1,i2) = 0.0
           execute return_diagonal tii t1ii
           tpp(i1,i2) = t1ii(i1,i2)
           PREPARE Sii(i1,i2) = tpp(i1,i2)
     ENDDO i2
     ENDDO i1
#
     DO j1
     DO j2
           tjj(j1,j2) = 1.0
           t1jj(j1,j2) = 0.0
           execute return_diagonal tjj t1jj
           tqq(j1,j2) = t1jj(j1,j2)
           PREPARE Sjj(j1,j2) = tqq(j1,j2)
     ENDDO j2
     ENDDO j1
     execute sip_barrier
     execute server_barrier
#
     PARDO i1, i
#
           PIi (i,i1) = 0.0 # Watson
           PREQUEST PIi(i,i1) = Sii(i2,i1)
           PUT IIi(i,i1) = PIi(i,i1)
#
     ENDPARDO i1, i
#
     PARDO j1, jb
#
           PJj (jb,j1) = 0.0 # Watson
           PREQUEST PJj(jb,j1) = Sjj(j2,j1)
           PUT IJj(jb,j1) = PJj(jb,j1)
#
     ENDPARDO j1, jb
     execute sip_barrier
#
     ENDPROC FORM_IDENTITY
#    ---------------------
#
#
#
#
#-------------------------------------------------------------------------
#
#    -------------------
      PROC  GET_RL_AMPS 
#    -------------------
#
#
      rootcount = 0

      DO indone
      DO kroot

         GET  REE (kroot,indone)
         tee (kroot,indone) = REE (kroot,indone)

         rootcount += 1
         IF rootcount == iroot
            EXECUTE  RETURN_SVAL  tee  OMEGA
         ENDIF

      ENDDO kroot
      ENDDO indone

      EXECUTE  SIP_BARRIER

      ncount    = 0
      rootcount = 0
      DO indone
      DO kroot

         GET                  LEE (kroot,indone)
         tee (kroot,indone) = LEE (kroot,indone)
         EXECUTE  RETURN_SVAL  tee  L_OMEGA
         etemp = L_OMEGA - OMEGA
         IF etemp < 0.0
            etemp *= -1.0
         ENDIF

         rootcount += 1
         IF etemp < root_thresh
            ncount = rootcount
            EXIT
         ENDIF

      ENDDO kroot
      ENDDO indone

      EXECUTE  SIP_BARRIER

#
#
#          ...Grab an R  array...
#                      k
#
#
      PARDO  a1, i1
         rootcount = 0
         DO kroot
            GET  R1A_VECS (a1,i1,kroot)
            rootcount += 1
            IF  rootcount == iroot
                tt1ai (a1,i1) = R1A_VECS (a1,i1,kroot)
                PREPARE  t1a_old (a1,i1) = tt1ai (a1,i1)
            ENDIF
         ENDDO kroot
      ENDPARDO  a1, i1

      PARDO  a1, i1, a2, i2
         rootcount = 0
         DO kroot
            REQUEST  R2AA_VECS (a1,i1,a2,i2,kroot) kroot
            rootcount += 1
            IF  rootcount == iroot
                tt1aiai (a1,i1,a2,i2) = R2AA_VECS (a1,i1,a2,i2,kroot)
                PREPARE  T2aiai (a1,i1,a2,i2) = tt1aiai (a1,i1,a2,i2)
            ENDIF
         ENDDO kroot
      ENDPARDO  a1, i1, a2, i2

      PARDO  a1, i1, b1, j1
         rootcount = 0
         DO kroot
            REQUEST  R2AB_VECS (a1,i1,b1,j1,kroot) kroot
            rootcount += 1
            IF  rootcount == iroot
                ttaibj (a1,i1,b1,j1) = R2AB_VECS (a1,i1,b1,j1,kroot)
                PREPARE  T2aibj (a1,i1,b1,j1) = ttaibj (a1,i1,b1,j1)
            ENDIF
         ENDDO kroot
      ENDPARDO  a1, i1, b1, j1
#     
#
#          ...Grab the corresponding L  array...
#                                     k
#
#
#
#
#          We found a matching excitation energy, so grab
#          the corresponding root!
#
# 
      IF ncount > ZERO

         PARDO  a1, i1
            rootcount = 0
            DO kroot
               GET  L1A_VECS (i1,a1,kroot)
               rootcount += 1
               IF  rootcount == ncount
                   tt1ia (i1,a1) = L1A_VECS (i1,a1,kroot)
                   tt1ai (a1,i1) = tt1ia (i1,a1)
                   PREPARE  Sl1a (a1,i1) = tt1ai (a1,i1)
                   EXIT
               ENDIF
            ENDDO kroot
         ENDPARDO  a1, i1

         PARDO  a1, i1, a2, i2
            rootcount = 0
            DO kroot
               REQUEST  L2AA_VECS (i1,a1,i2,a2,kroot) kroot
               rootcount += 1
               IF  rootcount == ncount
                   tt1iaia (i1,a1,i2,a2) = L2AA_VECS (i1,a1,i2,a2,kroot)
                   tt1aiai (a1,i1,a2,i2) = tt1iaia (i1,a1,i2,a2)
                   PREPARE  L2aiai (a1,i1,a2,i2) = tt1aiai (a1,i1,a2,i2)
               ENDIF
            ENDDO kroot
         ENDPARDO  a1, i1, a2, i2
                      
         PARDO  a1, i1, b1, j1
            rootcount = 0
            DO kroot
               REQUEST  L2AB_VECS (i1,a1,j1,b1,kroot) kroot
               rootcount += 1
               IF  rootcount == ncount
                  ttiajb (i1,a1,j1,b1) = L2AB_VECS (i1,a1,j1,b1,kroot)
                  ttaibj (a1,i1,b1,j1) = ttiajb (i1,a1,j1,b1)
                  PREPARE  L2aibj (a1,i1,b1,j1) = ttaibj (a1,i1,b1,j1)
               ENDIF
            ENDDO kroot
         ENDPARDO  a1, i1, b1, j1

      ENDIF # ncount > 0
#
#
#          In the event that none of the L excitation energies
#          match the the current R excitation energy, we need
#          to put in R^t as L.
#
#
      IF ncount == ZERO

         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO 
         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO
         EXECUTE  PRINT_SCALAR  ZERO

         PARDO  a1, i1
            rootcount = 0
            DO kroot
               GET  R1A_VECS (a1,i1,kroot)
               rootcount += 1
               IF  rootcount == iroot
                   tt1ai (a1,i1) = R1A_VECS (a1,i1,kroot)
                   PREPARE  Sl1a (a1,i1) = tt1ai (a1,i1)
               ENDIF
            ENDDO kroot
         ENDPARDO  a1, i1
   
         PARDO  a1, i1, a2, i2
            rootcount = 0
            DO kroot
               REQUEST  R2AA_VECS (a1,i1,a2,i2,kroot) kroot
               rootcount += 1
               IF  rootcount == iroot
                   tt1aiai (a1,i1,a2,i2) = R2AA_VECS (a1,i1,a2,i2,kroot)
                   PREPARE  L2aiai (a1,i1,a2,i2) = tt1aiai (a1,i1,a2,i2)
               ENDIF
            ENDDO kroot
         ENDPARDO  a1, i1, a2, i2

         PARDO  a1, i1, b1, j1 
            rootcount = 0
            DO kroot
               REQUEST  R2AB_VECS (a1,i1,b1,j1,kroot) kroot
               rootcount += 1  
               IF  rootcount == iroot
                  ttaibj (a1,i1,b1,j1) = R2AB_VECS (a1,i1,b1,j1,kroot)
                  PREPARE  L2aibj (a1,i1,b1,j1) = ttaibj (a1,i1,b1,j1)
               ENDIF
            ENDDO kroot
         ENDPARDO  a1, i1, b1, j1

      ENDIF

      EXECUTE  SERVER_BARRIER

      etemp = 0.0 
      etemp1= 0.0 
      etemp2= 0.0
      etemp3= 0.0 
      etemp4= 0.0 
      etemp5= 0.0 
      esuma = 0.0
      esum  = 0.0 
      esum1 = 0.0
      esum2 = 0.0 
      esum3 = 0.0 
      esum4 = 0.0 
      esum5 = 0.0 
      esum6 = 0.0 
#
#
#          ...ready!
#
#
      ENDPROC  GET_RL_AMPS
#-------------------------------------------------------------------------


#-------------------------------------------------------------------------
#
#    --------------------
      PROC  COMP_LR_NORM
#    --------------------
#
#
      LRNORM = 0.0
      esum   = 0.0

      PARDO  a1, i1

         REQUEST         t1a_old (a1,i1) i1
         REQUEST         Sl1a    (a1,i1) i1
         tt1ai (a1,i1) = t1a_old (a1,i1)
         tt2ai (a1,i1) = Sl1a    (a1,i1)
         etemp  = tt1ai (a1,i1) * tt2ai (a1,i1)
         etemp *= 2.0
         esum  += etemp

      ENDPARDO  a1, i1

      PARDO  a1, i1, a2 ,i2

         REQUEST                 T2aiai (a1,i1,a2,i2) i2
         REQUEST                 L2aiai (a1,i1,a2,i2) i2
         tt1aiai (a1,i1,a2,i2) = T2aiai (a1,i1,a2,i2)
         tt2aiai (a1,i1,a2,i2) = L2aiai (a1,i1,a2,i2)
         etemp  = tt1aiai (a1,i1,a2,i2) * tt2aiai (a1,i1,a2,i2)
         etemp  = etemp/2.0
         esum  += etemp

      ENDPARDO  a1, i1, a2, i2

      PARDO  a1, i1, b1, j1

         REQUEST                 T2aibj (a1,i1,b1,j1) j1
         REQUEST                 L2aibj (a1,i1,b1,j1) j1
         ttaibj  (a1,i1,b1,j1) = T2aibj (a1,i1,b1,j1)
         tt1aibj (a1,i1,b1,j1) = L2aibj (a1,i1,b1,j1)
         etemp  = ttaibj (a1,i1,b1,j1) * tt1aibj (a1,i1,b1,j1)
         esum  += etemp

      ENDPARDO  a1, i1, b1, j1

      EXECUTE  SIP_BARRIER
      EXECUTE  SERVER_BARRIER

      COLLECTIVE  LRNORM += esum

      EXECUTE SIP_BARRIER

      LRNORM  = 1.0 / LRNORM
      EXECUTE  PRINT_SCALAR  LRNORM
#
#        
#          ...ready!         
#        
#        
      ENDPROC  COMP_LR_NORM
#-------------------------------------------------------------------------
#
#
#
#
# MAIN PROGRAM 
#
# --------------------------------------------------------------------------
#
# Compute E^{[4]}_T contribution only and form sai and sbj  
# -------------------------------------------------------- 
#
     ZERO = 0.0
     root_thresh  = eom_tol
     root_thresh *= 10.0
     CREATE  REE
     CREATE  LEE
     CREATE  R1A_VECS
     CREATE  L1A_VECS
     execute sip_barrier 
     execute load_balance_off 
#
     CALL READ_BLOCKDATA  

     CALL FORM_IDENTITY 
     EXECUTE PRINT_SCALAR etemp 
     EXECUTE  SIP_BARRIER
     EXECUTE  SERVER_BARRIER
     CALL PDATA 
     EXECUTE PRINT_SCALAR etemp 

     iroot = 0
     DO indstate
        iroot += 1

        CREATE  Dai           #   Watson, taken from T4AAA
        CREATE  Sai
        CREATE  Sbj
        CREATE  T1ai          #
        CREATE  T1bj          #   Watson, taken from PDATA
        ecorraaa = 0.0  
        ecorrsa  = 0.0  
        etemp = 0.0 
        etemp1= 0.0 
        etemp2= 0.0 
        etemp3= 0.0 
        etemp4= 0.0 
        etemp5= 0.0 
        esuma = 0.0
        esum  = 0.0 
        esum1 = 0.0 
        esum2 = 0.0 
        esum3 = 0.0 
        esum4 = 0.0 
        esum5 = 0.0 
        esum6 = 0.0 

        CALL  GET_RL_AMPS
        CALL  COMP_LR_NORM

        IF OMEGA == 100000.0
            EXIT # Because we are all out of excitation energies!
        ENDIF

        EXECUTE  SIP_BARRIER
#
#
#          Put the singles amplitudes into a distributed array t1aI/t1bJ 
#
#
        PARDO a, i
           tpi (a,i) = 0.0 # Watson
           PREQUEST tpi(a,i) = t1a_old(a,i1)
           PUT t1ai(a,i)     = tpi(a,i)
        ENDPARDO a, i

        CALL T4AAA 
        CALL ST5  
#
#
#          Sum the total energy contribution and add to OMEGA.
#
#
        ecorrT  = ecorraaa  
        ecorrT += ecorrsa 
        ecorrT *= 2.0 
        ecorrT *= LRNORM
        EXECUTE  PRINT_SCALAR  ecorrT 

       #totenerg += ecorraaa 
       #totenerg += ecorraab 
       #totenerg += ecorrsa 
       #totenerg += ecorrT 

        rootcount = 0
        DO indone
        DO kroot
           rootcount += 1
           if rootcount == iroot
              tee  (kroot,indone) = OMEGA
              t1ee (kroot,indone) = ecorrT
              ST_ROOTS (kroot,indone) = tee  (kroot,indone)
              ST_ECORR (kroot,indone) = t1ee (kroot,indone)
              exit
           endif
        ENDDO kroot
        ENDDO indone

        EXECUTE  PRINT_SCALAR  OMEGA
        OMEGA += ecorrT
        EXECUTE  PRINT_SCALAR  OMEGA
        EXECUTE  PRINT_SCALAR  ZERO

        EXECUTE  SIP_BARRIER
        DELETE  Dai
        DELETE  Sai
        DELETE  Sbj
        DELETE  T1ai
        DELETE  T1bj

     ENDDO indstate

     EXECUTE  EOMROOT_PRINT_NEW  ST_ROOTS  ST_ECORR

     ENDSIAL LCCSDPR_RHF_AAA   
#
#
#
